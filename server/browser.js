"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all3) => {
  for (var name in all3)
    __defProp(target, name, { get: all3[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// server/node_modules/vscode-jsonrpc/lib/common/is.js
var require_is = __commonJS({
  "server/node_modules/vscode-jsonrpc/lib/common/is.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;
    function boolean(value) {
      return value === true || value === false;
    }
    exports.boolean = boolean;
    function string(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports.string = string;
    function number(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports.number = number;
    function error(value) {
      return value instanceof Error;
    }
    exports.error = error;
    function func(value) {
      return typeof value === "function";
    }
    exports.func = func;
    function array(value) {
      return Array.isArray(value);
    }
    exports.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string(elem));
    }
    exports.stringArray = stringArray;
  }
});

// server/node_modules/vscode-jsonrpc/lib/common/messages.js
var require_messages = __commonJS({
  "server/node_modules/vscode-jsonrpc/lib/common/messages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Message = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType = exports.RequestType0 = exports.AbstractMessageSignature = exports.ParameterStructures = exports.ResponseError = exports.ErrorCodes = void 0;
    var is = require_is();
    var ErrorCodes;
    (function (ErrorCodes2) {
      ErrorCodes2.ParseError = -32700;
      ErrorCodes2.InvalidRequest = -32600;
      ErrorCodes2.MethodNotFound = -32601;
      ErrorCodes2.InvalidParams = -32602;
      ErrorCodes2.InternalError = -32603;
      ErrorCodes2.jsonrpcReservedErrorRangeStart = -32099;
      ErrorCodes2.serverErrorStart = -32099;
      ErrorCodes2.MessageWriteError = -32099;
      ErrorCodes2.MessageReadError = -32098;
      ErrorCodes2.PendingResponseRejected = -32097;
      ErrorCodes2.ConnectionInactive = -32096;
      ErrorCodes2.ServerNotInitialized = -32002;
      ErrorCodes2.UnknownErrorCode = -32001;
      ErrorCodes2.jsonrpcReservedErrorRangeEnd = -32e3;
      ErrorCodes2.serverErrorEnd = -32e3;
    })(ErrorCodes || (exports.ErrorCodes = ErrorCodes = {}));
    var ResponseError = class _ResponseError extends Error {
      constructor(code, message, data) {
        super(message);
        this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
        this.data = data;
        Object.setPrototypeOf(this, _ResponseError.prototype);
      }
      toJson() {
        const result = {
          code: this.code,
          message: this.message
        };
        if (this.data !== void 0) {
          result.data = this.data;
        }
        return result;
      }
    };
    exports.ResponseError = ResponseError;
    var ParameterStructures = class _ParameterStructures {
      constructor(kind) {
        this.kind = kind;
      }
      static is(value) {
        return value === _ParameterStructures.auto || value === _ParameterStructures.byName || value === _ParameterStructures.byPosition;
      }
      toString() {
        return this.kind;
      }
    };
    exports.ParameterStructures = ParameterStructures;
    ParameterStructures.auto = new ParameterStructures("auto");
    ParameterStructures.byPosition = new ParameterStructures("byPosition");
    ParameterStructures.byName = new ParameterStructures("byName");
    var AbstractMessageSignature = class {
      constructor(method, numberOfParams) {
        this.method = method;
        this.numberOfParams = numberOfParams;
      }
      get parameterStructures() {
        return ParameterStructures.auto;
      }
    };
    exports.AbstractMessageSignature = AbstractMessageSignature;
    var RequestType0 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 0);
      }
    };
    exports.RequestType0 = RequestType0;
    var RequestType = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports.RequestType = RequestType;
    var RequestType1 = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports.RequestType1 = RequestType1;
    var RequestType2 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 2);
      }
    };
    exports.RequestType2 = RequestType2;
    var RequestType3 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 3);
      }
    };
    exports.RequestType3 = RequestType3;
    var RequestType4 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 4);
      }
    };
    exports.RequestType4 = RequestType4;
    var RequestType5 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 5);
      }
    };
    exports.RequestType5 = RequestType5;
    var RequestType6 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 6);
      }
    };
    exports.RequestType6 = RequestType6;
    var RequestType7 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 7);
      }
    };
    exports.RequestType7 = RequestType7;
    var RequestType8 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 8);
      }
    };
    exports.RequestType8 = RequestType8;
    var RequestType9 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 9);
      }
    };
    exports.RequestType9 = RequestType9;
    var NotificationType = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports.NotificationType = NotificationType;
    var NotificationType0 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 0);
      }
    };
    exports.NotificationType0 = NotificationType0;
    var NotificationType1 = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports.NotificationType1 = NotificationType1;
    var NotificationType2 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 2);
      }
    };
    exports.NotificationType2 = NotificationType2;
    var NotificationType3 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 3);
      }
    };
    exports.NotificationType3 = NotificationType3;
    var NotificationType4 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 4);
      }
    };
    exports.NotificationType4 = NotificationType4;
    var NotificationType5 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 5);
      }
    };
    exports.NotificationType5 = NotificationType5;
    var NotificationType6 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 6);
      }
    };
    exports.NotificationType6 = NotificationType6;
    var NotificationType7 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 7);
      }
    };
    exports.NotificationType7 = NotificationType7;
    var NotificationType8 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 8);
      }
    };
    exports.NotificationType8 = NotificationType8;
    var NotificationType9 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 9);
      }
    };
    exports.NotificationType9 = NotificationType9;
    var Message;
    (function (Message2) {
      function isRequest(message) {
        const candidate = message;
        return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
      }
      Message2.isRequest = isRequest;
      function isNotification(message) {
        const candidate = message;
        return candidate && is.string(candidate.method) && message.id === void 0;
      }
      Message2.isNotification = isNotification;
      function isResponse(message) {
        const candidate = message;
        return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
      }
      Message2.isResponse = isResponse;
    })(Message || (exports.Message = Message = {}));
  }
});

// server/node_modules/vscode-jsonrpc/lib/common/linkedMap.js
var require_linkedMap = __commonJS({
  "server/node_modules/vscode-jsonrpc/lib/common/linkedMap.js"(exports) {
    "use strict";
    var _a;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LRUCache = exports.LinkedMap = exports.Touch = void 0;
    var Touch;
    (function (Touch2) {
      Touch2.None = 0;
      Touch2.First = 1;
      Touch2.AsOld = Touch2.First;
      Touch2.Last = 2;
      Touch2.AsNew = Touch2.Last;
    })(Touch || (exports.Touch = Touch = {}));
    var LinkedMap = class {
      constructor() {
        this[_a] = "LinkedMap";
        this._map = /* @__PURE__ */ new Map();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
        this._state = 0;
      }
      clear() {
        this._map.clear();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
        this._state++;
      }
      isEmpty() {
        return !this._head && !this._tail;
      }
      get size() {
        return this._size;
      }
      get first() {
        return this._head?.value;
      }
      get last() {
        return this._tail?.value;
      }
      has(key) {
        return this._map.has(key);
      }
      get(key, touch = Touch.None) {
        const item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        if (touch !== Touch.None) {
          this.touch(item, touch);
        }
        return item.value;
      }
      set(key, value, touch = Touch.None) {
        let item = this._map.get(key);
        if (item) {
          item.value = value;
          if (touch !== Touch.None) {
            this.touch(item, touch);
          }
        } else {
          item = { key, value, next: void 0, previous: void 0 };
          switch (touch) {
            case Touch.None:
              this.addItemLast(item);
              break;
            case Touch.First:
              this.addItemFirst(item);
              break;
            case Touch.Last:
              this.addItemLast(item);
              break;
            default:
              this.addItemLast(item);
              break;
          }
          this._map.set(key, item);
          this._size++;
        }
        return this;
      }
      delete(key) {
        return !!this.remove(key);
      }
      remove(key) {
        const item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        this._map.delete(key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
      shift() {
        if (!this._head && !this._tail) {
          return void 0;
        }
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        const item = this._head;
        this._map.delete(item.key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
      forEach(callbackfn, thisArg) {
        const state = this._state;
        let current = this._head;
        while (current) {
          if (thisArg) {
            callbackfn.bind(thisArg)(current.value, current.key, this);
          } else {
            callbackfn(current.value, current.key, this);
          }
          if (this._state !== state) {
            throw new Error(`LinkedMap got modified during iteration.`);
          }
          current = current.next;
        }
      }
      keys() {
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]: () => {
            return iterator;
          },
          next: () => {
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: current.key, done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      values() {
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]: () => {
            return iterator;
          },
          next: () => {
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: current.value, done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      entries() {
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]: () => {
            return iterator;
          },
          next: () => {
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: [current.key, current.value], done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      [(_a = Symbol.toStringTag, Symbol.iterator)]() {
        return this.entries();
      }
      trimOld(newSize) {
        if (newSize >= this.size) {
          return;
        }
        if (newSize === 0) {
          this.clear();
          return;
        }
        let current = this._head;
        let currentSize = this.size;
        while (current && currentSize > newSize) {
          this._map.delete(current.key);
          current = current.next;
          currentSize--;
        }
        this._head = current;
        this._size = currentSize;
        if (current) {
          current.previous = void 0;
        }
        this._state++;
      }
      addItemFirst(item) {
        if (!this._head && !this._tail) {
          this._tail = item;
        } else if (!this._head) {
          throw new Error("Invalid list");
        } else {
          item.next = this._head;
          this._head.previous = item;
        }
        this._head = item;
        this._state++;
      }
      addItemLast(item) {
        if (!this._head && !this._tail) {
          this._head = item;
        } else if (!this._tail) {
          throw new Error("Invalid list");
        } else {
          item.previous = this._tail;
          this._tail.next = item;
        }
        this._tail = item;
        this._state++;
      }
      removeItem(item) {
        if (item === this._head && item === this._tail) {
          this._head = void 0;
          this._tail = void 0;
        } else if (item === this._head) {
          if (!item.next) {
            throw new Error("Invalid list");
          }
          item.next.previous = void 0;
          this._head = item.next;
        } else if (item === this._tail) {
          if (!item.previous) {
            throw new Error("Invalid list");
          }
          item.previous.next = void 0;
          this._tail = item.previous;
        } else {
          const next = item.next;
          const previous = item.previous;
          if (!next || !previous) {
            throw new Error("Invalid list");
          }
          next.previous = previous;
          previous.next = next;
        }
        item.next = void 0;
        item.previous = void 0;
        this._state++;
      }
      touch(item, touch) {
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        if (touch !== Touch.First && touch !== Touch.Last) {
          return;
        }
        if (touch === Touch.First) {
          if (item === this._head) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._tail) {
            previous.next = void 0;
            this._tail = previous;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.previous = void 0;
          item.next = this._head;
          this._head.previous = item;
          this._head = item;
          this._state++;
        } else if (touch === Touch.Last) {
          if (item === this._tail) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._head) {
            next.previous = void 0;
            this._head = next;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.next = void 0;
          item.previous = this._tail;
          this._tail.next = item;
          this._tail = item;
          this._state++;
        }
      }
      toJSON() {
        const data = [];
        this.forEach((value, key) => {
          data.push([key, value]);
        });
        return data;
      }
      fromJSON(data) {
        this.clear();
        for (const [key, value] of data) {
          this.set(key, value);
        }
      }
    };
    exports.LinkedMap = LinkedMap;
    var LRUCache = class extends LinkedMap {
      constructor(limit, ratio = 1) {
        super();
        this._limit = limit;
        this._ratio = Math.min(Math.max(0, ratio), 1);
      }
      get limit() {
        return this._limit;
      }
      set limit(limit) {
        this._limit = limit;
        this.checkTrim();
      }
      get ratio() {
        return this._ratio;
      }
      set ratio(ratio) {
        this._ratio = Math.min(Math.max(0, ratio), 1);
        this.checkTrim();
      }
      get(key, touch = Touch.AsNew) {
        return super.get(key, touch);
      }
      peek(key) {
        return super.get(key, Touch.None);
      }
      set(key, value) {
        super.set(key, value, Touch.Last);
        this.checkTrim();
        return this;
      }
      checkTrim() {
        if (this.size > this._limit) {
          this.trimOld(Math.round(this._limit * this._ratio));
        }
      }
    };
    exports.LRUCache = LRUCache;
  }
});

// server/node_modules/vscode-jsonrpc/lib/common/disposable.js
var require_disposable = __commonJS({
  "server/node_modules/vscode-jsonrpc/lib/common/disposable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Disposable = void 0;
    var Disposable;
    (function (Disposable2) {
      function create(func) {
        return {
          dispose: func
        };
      }
      Disposable2.create = create;
    })(Disposable || (exports.Disposable = Disposable = {}));
  }
});

// server/node_modules/vscode-jsonrpc/lib/common/ral.js
var require_ral = __commonJS({
  "server/node_modules/vscode-jsonrpc/lib/common/ral.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _ral;
    function RAL() {
      if (_ral === void 0) {
        throw new Error(`No runtime abstraction layer installed`);
      }
      return _ral;
    }
    (function (RAL2) {
      function install(ral) {
        if (ral === void 0) {
          throw new Error(`No runtime abstraction layer provided`);
        }
        _ral = ral;
      }
      RAL2.install = install;
    })(RAL || (RAL = {}));
    exports.default = RAL;
  }
});

// server/node_modules/vscode-jsonrpc/lib/common/events.js
var require_events = __commonJS({
  "server/node_modules/vscode-jsonrpc/lib/common/events.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Emitter = exports.Event = void 0;
    var ral_1 = require_ral();
    var Event;
    (function (Event2) {
      const _disposable = {
        dispose() {
        }
      };
      Event2.None = function () {
        return _disposable;
      };
    })(Event || (exports.Event = Event = {}));
    var CallbackList = class {
      add(callback, context = null, bucket) {
        if (!this._callbacks) {
          this._callbacks = [];
          this._contexts = [];
        }
        this._callbacks.push(callback);
        this._contexts.push(context);
        if (Array.isArray(bucket)) {
          bucket.push({ dispose: () => this.remove(callback, context) });
        }
      }
      remove(callback, context = null) {
        if (!this._callbacks) {
          return;
        }
        let foundCallbackWithDifferentContext = false;
        for (let i = 0, len = this._callbacks.length; i < len; i++) {
          if (this._callbacks[i] === callback) {
            if (this._contexts[i] === context) {
              this._callbacks.splice(i, 1);
              this._contexts.splice(i, 1);
              return;
            } else {
              foundCallbackWithDifferentContext = true;
            }
          }
        }
        if (foundCallbackWithDifferentContext) {
          throw new Error("When adding a listener with a context, you should remove it with the same context");
        }
      }
      invoke(...args) {
        if (!this._callbacks) {
          return [];
        }
        const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
        for (let i = 0, len = callbacks.length; i < len; i++) {
          try {
            ret.push(callbacks[i].apply(contexts[i], args));
          } catch (e) {
            (0, ral_1.default)().console.error(e);
          }
        }
        return ret;
      }
      isEmpty() {
        return !this._callbacks || this._callbacks.length === 0;
      }
      dispose() {
        this._callbacks = void 0;
        this._contexts = void 0;
      }
    };
    var Emitter = class _Emitter {
      constructor(_options) {
        this._options = _options;
      }
      /**
       * For the public to allow to subscribe
       * to events from this Emitter
       */
      get event() {
        if (!this._event) {
          this._event = (listener, thisArgs, disposables) => {
            if (!this._callbacks) {
              this._callbacks = new CallbackList();
            }
            if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
              this._options.onFirstListenerAdd(this);
            }
            this._callbacks.add(listener, thisArgs);
            const result = {
              dispose: () => {
                if (!this._callbacks) {
                  return;
                }
                this._callbacks.remove(listener, thisArgs);
                result.dispose = _Emitter._noop;
                if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                  this._options.onLastListenerRemove(this);
                }
              }
            };
            if (Array.isArray(disposables)) {
              disposables.push(result);
            }
            return result;
          };
        }
        return this._event;
      }
      /**
       * To be kept private to fire an event to
       * subscribers
       */
      fire(event) {
        if (this._callbacks) {
          this._callbacks.invoke.call(this._callbacks, event);
        }
      }
      dispose() {
        if (this._callbacks) {
          this._callbacks.dispose();
          this._callbacks = void 0;
        }
      }
    };
    exports.Emitter = Emitter;
    Emitter._noop = function () {
    };
  }
});

// server/node_modules/vscode-jsonrpc/lib/common/cancellation.js
var require_cancellation = __commonJS({
  "server/node_modules/vscode-jsonrpc/lib/common/cancellation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CancellationTokenSource = exports.CancellationToken = void 0;
    var ral_1 = require_ral();
    var Is2 = require_is();
    var events_1 = require_events();
    var CancellationToken;
    (function (CancellationToken2) {
      CancellationToken2.None = Object.freeze({
        isCancellationRequested: false,
        onCancellationRequested: events_1.Event.None
      });
      CancellationToken2.Cancelled = Object.freeze({
        isCancellationRequested: true,
        onCancellationRequested: events_1.Event.None
      });
      function is(value) {
        const candidate = value;
        return candidate && (candidate === CancellationToken2.None || candidate === CancellationToken2.Cancelled || Is2.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested);
      }
      CancellationToken2.is = is;
    })(CancellationToken || (exports.CancellationToken = CancellationToken = {}));
    var shortcutEvent = Object.freeze(function (callback, context) {
      const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);
      return {
        dispose() {
          handle.dispose();
        }
      };
    });
    var MutableToken = class {
      constructor() {
        this._isCancelled = false;
      }
      cancel() {
        if (!this._isCancelled) {
          this._isCancelled = true;
          if (this._emitter) {
            this._emitter.fire(void 0);
            this.dispose();
          }
        }
      }
      get isCancellationRequested() {
        return this._isCancelled;
      }
      get onCancellationRequested() {
        if (this._isCancelled) {
          return shortcutEvent;
        }
        if (!this._emitter) {
          this._emitter = new events_1.Emitter();
        }
        return this._emitter.event;
      }
      dispose() {
        if (this._emitter) {
          this._emitter.dispose();
          this._emitter = void 0;
        }
      }
    };
    var CancellationTokenSource = class {
      get token() {
        if (!this._token) {
          this._token = new MutableToken();
        }
        return this._token;
      }
      cancel() {
        if (!this._token) {
          this._token = CancellationToken.Cancelled;
        } else {
          this._token.cancel();
        }
      }
      dispose() {
        if (!this._token) {
          this._token = CancellationToken.None;
        } else if (this._token instanceof MutableToken) {
          this._token.dispose();
        }
      }
    };
    exports.CancellationTokenSource = CancellationTokenSource;
  }
});

// server/node_modules/vscode-jsonrpc/lib/common/sharedArrayCancellation.js
var require_sharedArrayCancellation = __commonJS({
  "server/node_modules/vscode-jsonrpc/lib/common/sharedArrayCancellation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SharedArrayReceiverStrategy = exports.SharedArraySenderStrategy = void 0;
    var cancellation_1 = require_cancellation();
    var CancellationState;
    (function (CancellationState2) {
      CancellationState2.Continue = 0;
      CancellationState2.Cancelled = 1;
    })(CancellationState || (CancellationState = {}));
    var SharedArraySenderStrategy = class {
      constructor() {
        this.buffers = /* @__PURE__ */ new Map();
      }
      enableCancellation(request) {
        if (request.id === null) {
          return;
        }
        const buffer = new SharedArrayBuffer(4);
        const data = new Int32Array(buffer, 0, 1);
        data[0] = CancellationState.Continue;
        this.buffers.set(request.id, buffer);
        request.$cancellationData = buffer;
      }
      async sendCancellation(_conn, id) {
        const buffer = this.buffers.get(id);
        if (buffer === void 0) {
          return;
        }
        const data = new Int32Array(buffer, 0, 1);
        Atomics.store(data, 0, CancellationState.Cancelled);
      }
      cleanup(id) {
        this.buffers.delete(id);
      }
      dispose() {
        this.buffers.clear();
      }
    };
    exports.SharedArraySenderStrategy = SharedArraySenderStrategy;
    var SharedArrayBufferCancellationToken = class {
      constructor(buffer) {
        this.data = new Int32Array(buffer, 0, 1);
      }
      get isCancellationRequested() {
        return Atomics.load(this.data, 0) === CancellationState.Cancelled;
      }
      get onCancellationRequested() {
        throw new Error(`Cancellation over SharedArrayBuffer doesn't support cancellation events`);
      }
    };
    var SharedArrayBufferCancellationTokenSource = class {
      constructor(buffer) {
        this.token = new SharedArrayBufferCancellationToken(buffer);
      }
      cancel() {
      }
      dispose() {
      }
    };
    var SharedArrayReceiverStrategy = class {
      constructor() {
        this.kind = "request";
      }
      createCancellationTokenSource(request) {
        const buffer = request.$cancellationData;
        if (buffer === void 0) {
          return new cancellation_1.CancellationTokenSource();
        }
        return new SharedArrayBufferCancellationTokenSource(buffer);
      }
    };
    exports.SharedArrayReceiverStrategy = SharedArrayReceiverStrategy;
  }
});

// server/node_modules/vscode-jsonrpc/lib/common/semaphore.js
var require_semaphore = __commonJS({
  "server/node_modules/vscode-jsonrpc/lib/common/semaphore.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Semaphore = void 0;
    var ral_1 = require_ral();
    var Semaphore = class {
      constructor(capacity = 1) {
        if (capacity <= 0) {
          throw new Error("Capacity must be greater than 0");
        }
        this._capacity = capacity;
        this._active = 0;
        this._waiting = [];
      }
      lock(thunk) {
        return new Promise((resolve, reject) => {
          this._waiting.push({ thunk, resolve, reject });
          this.runNext();
        });
      }
      get active() {
        return this._active;
      }
      runNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
          return;
        }
        (0, ral_1.default)().timer.setImmediate(() => this.doRunNext());
      }
      doRunNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
          return;
        }
        const next = this._waiting.shift();
        this._active++;
        if (this._active > this._capacity) {
          throw new Error(`To many thunks active`);
        }
        try {
          const result = next.thunk();
          if (result instanceof Promise) {
            result.then((value) => {
              this._active--;
              next.resolve(value);
              this.runNext();
            }, (err) => {
              this._active--;
              next.reject(err);
              this.runNext();
            });
          } else {
            this._active--;
            next.resolve(result);
            this.runNext();
          }
        } catch (err) {
          this._active--;
          next.reject(err);
          this.runNext();
        }
      }
    };
    exports.Semaphore = Semaphore;
  }
});

// server/node_modules/vscode-jsonrpc/lib/common/messageReader.js
var require_messageReader = __commonJS({
  "server/node_modules/vscode-jsonrpc/lib/common/messageReader.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = void 0;
    var ral_1 = require_ral();
    var Is2 = require_is();
    var events_1 = require_events();
    var semaphore_1 = require_semaphore();
    var MessageReader;
    (function (MessageReader2) {
      function is(value) {
        let candidate = value;
        return candidate && Is2.func(candidate.listen) && Is2.func(candidate.dispose) && Is2.func(candidate.onError) && Is2.func(candidate.onClose) && Is2.func(candidate.onPartialMessage);
      }
      MessageReader2.is = is;
    })(MessageReader || (exports.MessageReader = MessageReader = {}));
    var AbstractMessageReader = class {
      constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
        this.partialMessageEmitter = new events_1.Emitter();
      }
      dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
      }
      get onError() {
        return this.errorEmitter.event;
      }
      fireError(error) {
        this.errorEmitter.fire(this.asError(error));
      }
      get onClose() {
        return this.closeEmitter.event;
      }
      fireClose() {
        this.closeEmitter.fire(void 0);
      }
      get onPartialMessage() {
        return this.partialMessageEmitter.event;
      }
      firePartialMessage(info) {
        this.partialMessageEmitter.fire(info);
      }
      asError(error) {
        if (error instanceof Error) {
          return error;
        } else {
          return new Error(`Reader received error. Reason: ${Is2.string(error.message) ? error.message : "unknown"}`);
        }
      }
    };
    exports.AbstractMessageReader = AbstractMessageReader;
    var ResolvedMessageReaderOptions;
    (function (ResolvedMessageReaderOptions2) {
      function fromOptions(options) {
        let charset;
        let result;
        let contentDecoder;
        const contentDecoders = /* @__PURE__ */ new Map();
        let contentTypeDecoder;
        const contentTypeDecoders = /* @__PURE__ */ new Map();
        if (options === void 0 || typeof options === "string") {
          charset = options ?? "utf-8";
        } else {
          charset = options.charset ?? "utf-8";
          if (options.contentDecoder !== void 0) {
            contentDecoder = options.contentDecoder;
            contentDecoders.set(contentDecoder.name, contentDecoder);
          }
          if (options.contentDecoders !== void 0) {
            for (const decoder of options.contentDecoders) {
              contentDecoders.set(decoder.name, decoder);
            }
          }
          if (options.contentTypeDecoder !== void 0) {
            contentTypeDecoder = options.contentTypeDecoder;
            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
          }
          if (options.contentTypeDecoders !== void 0) {
            for (const decoder of options.contentTypeDecoders) {
              contentTypeDecoders.set(decoder.name, decoder);
            }
          }
        }
        if (contentTypeDecoder === void 0) {
          contentTypeDecoder = (0, ral_1.default)().applicationJson.decoder;
          contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
        }
        return { charset, contentDecoder, contentDecoders, contentTypeDecoder, contentTypeDecoders };
      }
      ResolvedMessageReaderOptions2.fromOptions = fromOptions;
    })(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
    var ReadableStreamMessageReader = class extends AbstractMessageReader {
      constructor(readable, options) {
        super();
        this.readable = readable;
        this.options = ResolvedMessageReaderOptions.fromOptions(options);
        this.buffer = (0, ral_1.default)().messageBuffer.create(this.options.charset);
        this._partialMessageTimeout = 1e4;
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.readSemaphore = new semaphore_1.Semaphore(1);
      }
      set partialMessageTimeout(timeout) {
        this._partialMessageTimeout = timeout;
      }
      get partialMessageTimeout() {
        return this._partialMessageTimeout;
      }
      listen(callback) {
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.partialMessageTimer = void 0;
        this.callback = callback;
        const result = this.readable.onData((data) => {
          this.onData(data);
        });
        this.readable.onError((error) => this.fireError(error));
        this.readable.onClose(() => this.fireClose());
        return result;
      }
      onData(data) {
        try {
          this.buffer.append(data);
          while (true) {
            if (this.nextMessageLength === -1) {
              const headers = this.buffer.tryReadHeaders(true);
              if (!headers) {
                return;
              }
              const contentLength = headers.get("content-length");
              if (!contentLength) {
                this.fireError(new Error(`Header must provide a Content-Length property.
${JSON.stringify(Object.fromEntries(headers))}`));
                return;
              }
              const length = parseInt(contentLength);
              if (isNaN(length)) {
                this.fireError(new Error(`Content-Length value must be a number. Got ${contentLength}`));
                return;
              }
              this.nextMessageLength = length;
            }
            const body = this.buffer.tryReadBody(this.nextMessageLength);
            if (body === void 0) {
              this.setPartialMessageTimer();
              return;
            }
            this.clearPartialMessageTimer();
            this.nextMessageLength = -1;
            this.readSemaphore.lock(async () => {
              const bytes = this.options.contentDecoder !== void 0 ? await this.options.contentDecoder.decode(body) : body;
              const message = await this.options.contentTypeDecoder.decode(bytes, this.options);
              this.callback(message);
            }).catch((error) => {
              this.fireError(error);
            });
          }
        } catch (error) {
          this.fireError(error);
        }
      }
      clearPartialMessageTimer() {
        if (this.partialMessageTimer) {
          this.partialMessageTimer.dispose();
          this.partialMessageTimer = void 0;
        }
      }
      setPartialMessageTimer() {
        this.clearPartialMessageTimer();
        if (this._partialMessageTimeout <= 0) {
          return;
        }
        this.partialMessageTimer = (0, ral_1.default)().timer.setTimeout((token, timeout) => {
          this.partialMessageTimer = void 0;
          if (token === this.messageToken) {
            this.firePartialMessage({ messageToken: token, waitingTime: timeout });
            this.setPartialMessageTimer();
          }
        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
      }
    };
    exports.ReadableStreamMessageReader = ReadableStreamMessageReader;
  }
});

// server/node_modules/vscode-jsonrpc/lib/common/messageWriter.js
var require_messageWriter = __commonJS({
  "server/node_modules/vscode-jsonrpc/lib/common/messageWriter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = void 0;
    var ral_1 = require_ral();
    var Is2 = require_is();
    var semaphore_1 = require_semaphore();
    var events_1 = require_events();
    var ContentLength = "Content-Length: ";
    var CRLF = "\r\n";
    var MessageWriter;
    (function (MessageWriter2) {
      function is(value) {
        let candidate = value;
        return candidate && Is2.func(candidate.dispose) && Is2.func(candidate.onClose) && Is2.func(candidate.onError) && Is2.func(candidate.write);
      }
      MessageWriter2.is = is;
    })(MessageWriter || (exports.MessageWriter = MessageWriter = {}));
    var AbstractMessageWriter = class {
      constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
      }
      dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
      }
      get onError() {
        return this.errorEmitter.event;
      }
      fireError(error, message, count) {
        this.errorEmitter.fire([this.asError(error), message, count]);
      }
      get onClose() {
        return this.closeEmitter.event;
      }
      fireClose() {
        this.closeEmitter.fire(void 0);
      }
      asError(error) {
        if (error instanceof Error) {
          return error;
        } else {
          return new Error(`Writer received error. Reason: ${Is2.string(error.message) ? error.message : "unknown"}`);
        }
      }
    };
    exports.AbstractMessageWriter = AbstractMessageWriter;
    var ResolvedMessageWriterOptions;
    (function (ResolvedMessageWriterOptions2) {
      function fromOptions(options) {
        if (options === void 0 || typeof options === "string") {
          return { charset: options ?? "utf-8", contentTypeEncoder: (0, ral_1.default)().applicationJson.encoder };
        } else {
          return { charset: options.charset ?? "utf-8", contentEncoder: options.contentEncoder, contentTypeEncoder: options.contentTypeEncoder ?? (0, ral_1.default)().applicationJson.encoder };
        }
      }
      ResolvedMessageWriterOptions2.fromOptions = fromOptions;
    })(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
    var WriteableStreamMessageWriter = class extends AbstractMessageWriter {
      constructor(writable, options) {
        super();
        this.writable = writable;
        this.options = ResolvedMessageWriterOptions.fromOptions(options);
        this.errorCount = 0;
        this.writeSemaphore = new semaphore_1.Semaphore(1);
        this.writable.onError((error) => this.fireError(error));
        this.writable.onClose(() => this.fireClose());
      }
      async write(msg) {
        return this.writeSemaphore.lock(async () => {
          const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer) => {
            if (this.options.contentEncoder !== void 0) {
              return this.options.contentEncoder.encode(buffer);
            } else {
              return buffer;
            }
          });
          return payload.then((buffer) => {
            const headers = [];
            headers.push(ContentLength, buffer.byteLength.toString(), CRLF);
            headers.push(CRLF);
            return this.doWrite(msg, headers, buffer);
          }, (error) => {
            this.fireError(error);
            throw error;
          });
        });
      }
      async doWrite(msg, headers, data) {
        try {
          await this.writable.write(headers.join(""), "ascii");
          return this.writable.write(data);
        } catch (error) {
          this.handleError(error, msg);
          return Promise.reject(error);
        }
      }
      handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
      end() {
        this.writable.end();
      }
    };
    exports.WriteableStreamMessageWriter = WriteableStreamMessageWriter;
  }
});

// server/node_modules/vscode-jsonrpc/lib/common/messageBuffer.js
var require_messageBuffer = __commonJS({
  "server/node_modules/vscode-jsonrpc/lib/common/messageBuffer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AbstractMessageBuffer = void 0;
    var CR = 13;
    var LF = 10;
    var CRLF = "\r\n";
    var AbstractMessageBuffer = class {
      constructor(encoding = "utf-8") {
        this._encoding = encoding;
        this._chunks = [];
        this._totalLength = 0;
      }
      get encoding() {
        return this._encoding;
      }
      append(chunk) {
        const toAppend = typeof chunk === "string" ? this.fromString(chunk, this._encoding) : chunk;
        this._chunks.push(toAppend);
        this._totalLength += toAppend.byteLength;
      }
      tryReadHeaders(lowerCaseKeys = false) {
        if (this._chunks.length === 0) {
          return void 0;
        }
        let state = 0;
        let chunkIndex = 0;
        let offset = 0;
        let chunkBytesRead = 0;
        row:
        while (chunkIndex < this._chunks.length) {
          const chunk = this._chunks[chunkIndex];
          offset = 0;
          column:
          while (offset < chunk.length) {
            const value = chunk[offset];
            switch (value) {
              case CR:
                switch (state) {
                  case 0:
                    state = 1;
                    break;
                  case 2:
                    state = 3;
                    break;
                  default:
                    state = 0;
                }
                break;
              case LF:
                switch (state) {
                  case 1:
                    state = 2;
                    break;
                  case 3:
                    state = 4;
                    offset++;
                    break row;
                  default:
                    state = 0;
                }
                break;
              default:
                state = 0;
            }
            offset++;
          }
          chunkBytesRead += chunk.byteLength;
          chunkIndex++;
        }
        if (state !== 4) {
          return void 0;
        }
        const buffer = this._read(chunkBytesRead + offset);
        const result = /* @__PURE__ */ new Map();
        const headers = this.toString(buffer, "ascii").split(CRLF);
        if (headers.length < 2) {
          return result;
        }
        for (let i = 0; i < headers.length - 2; i++) {
          const header = headers[i];
          const index = header.indexOf(":");
          if (index === -1) {
            throw new Error(`Message header must separate key and value using ':'
${header}`);
          }
          const key = header.substr(0, index);
          const value = header.substr(index + 1).trim();
          result.set(lowerCaseKeys ? key.toLowerCase() : key, value);
        }
        return result;
      }
      tryReadBody(length) {
        if (this._totalLength < length) {
          return void 0;
        }
        return this._read(length);
      }
      get numberOfBytes() {
        return this._totalLength;
      }
      _read(byteCount) {
        if (byteCount === 0) {
          return this.emptyBuffer();
        }
        if (byteCount > this._totalLength) {
          throw new Error(`Cannot read so many bytes!`);
        }
        if (this._chunks[0].byteLength === byteCount) {
          const chunk = this._chunks[0];
          this._chunks.shift();
          this._totalLength -= byteCount;
          return this.asNative(chunk);
        }
        if (this._chunks[0].byteLength > byteCount) {
          const chunk = this._chunks[0];
          const result2 = this.asNative(chunk, byteCount);
          this._chunks[0] = chunk.slice(byteCount);
          this._totalLength -= byteCount;
          return result2;
        }
        const result = this.allocNative(byteCount);
        let resultOffset = 0;
        let chunkIndex = 0;
        while (byteCount > 0) {
          const chunk = this._chunks[chunkIndex];
          if (chunk.byteLength > byteCount) {
            const chunkPart = chunk.slice(0, byteCount);
            result.set(chunkPart, resultOffset);
            resultOffset += byteCount;
            this._chunks[chunkIndex] = chunk.slice(byteCount);
            this._totalLength -= byteCount;
            byteCount -= byteCount;
          } else {
            result.set(chunk, resultOffset);
            resultOffset += chunk.byteLength;
            this._chunks.shift();
            this._totalLength -= chunk.byteLength;
            byteCount -= chunk.byteLength;
          }
        }
        return result;
      }
    };
    exports.AbstractMessageBuffer = AbstractMessageBuffer;
  }
});

// server/node_modules/vscode-jsonrpc/lib/common/connection.js
var require_connection = __commonJS({
  "server/node_modules/vscode-jsonrpc/lib/common/connection.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createMessageConnection = exports.ConnectionOptions = exports.MessageStrategy = exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.RequestCancellationReceiverStrategy = exports.IdCancellationReceiverStrategy = exports.ConnectionStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.TraceValues = exports.Trace = exports.NullLogger = exports.ProgressType = exports.ProgressToken = void 0;
    var ral_1 = require_ral();
    var Is2 = require_is();
    var messages_1 = require_messages();
    var linkedMap_1 = require_linkedMap();
    var events_1 = require_events();
    var cancellation_1 = require_cancellation();
    var CancelNotification;
    (function (CancelNotification2) {
      CancelNotification2.type = new messages_1.NotificationType("$/cancelRequest");
    })(CancelNotification || (CancelNotification = {}));
    var ProgressToken;
    (function (ProgressToken2) {
      function is(value) {
        return typeof value === "string" || typeof value === "number";
      }
      ProgressToken2.is = is;
    })(ProgressToken || (exports.ProgressToken = ProgressToken = {}));
    var ProgressNotification;
    (function (ProgressNotification2) {
      ProgressNotification2.type = new messages_1.NotificationType("$/progress");
    })(ProgressNotification || (ProgressNotification = {}));
    var ProgressType = class {
      constructor() {
      }
    };
    exports.ProgressType = ProgressType;
    var StarRequestHandler;
    (function (StarRequestHandler2) {
      function is(value) {
        return Is2.func(value);
      }
      StarRequestHandler2.is = is;
    })(StarRequestHandler || (StarRequestHandler = {}));
    exports.NullLogger = Object.freeze({
      error: () => {
      },
      warn: () => {
      },
      info: () => {
      },
      log: () => {
      }
    });
    var Trace;
    (function (Trace2) {
      Trace2[Trace2["Off"] = 0] = "Off";
      Trace2[Trace2["Messages"] = 1] = "Messages";
      Trace2[Trace2["Compact"] = 2] = "Compact";
      Trace2[Trace2["Verbose"] = 3] = "Verbose";
    })(Trace || (exports.Trace = Trace = {}));
    var TraceValues;
    (function (TraceValues2) {
      TraceValues2.Off = "off";
      TraceValues2.Messages = "messages";
      TraceValues2.Compact = "compact";
      TraceValues2.Verbose = "verbose";
    })(TraceValues || (exports.TraceValues = TraceValues = {}));
    (function (Trace2) {
      function fromString(value) {
        if (!Is2.string(value)) {
          return Trace2.Off;
        }
        value = value.toLowerCase();
        switch (value) {
          case "off":
            return Trace2.Off;
          case "messages":
            return Trace2.Messages;
          case "compact":
            return Trace2.Compact;
          case "verbose":
            return Trace2.Verbose;
          default:
            return Trace2.Off;
        }
      }
      Trace2.fromString = fromString;
      function toString3(value) {
        switch (value) {
          case Trace2.Off:
            return "off";
          case Trace2.Messages:
            return "messages";
          case Trace2.Compact:
            return "compact";
          case Trace2.Verbose:
            return "verbose";
          default:
            return "off";
        }
      }
      Trace2.toString = toString3;
    })(Trace || (exports.Trace = Trace = {}));
    var TraceFormat;
    (function (TraceFormat2) {
      TraceFormat2["Text"] = "text";
      TraceFormat2["JSON"] = "json";
    })(TraceFormat || (exports.TraceFormat = TraceFormat = {}));
    (function (TraceFormat2) {
      function fromString(value) {
        if (!Is2.string(value)) {
          return TraceFormat2.Text;
        }
        value = value.toLowerCase();
        if (value === "json") {
          return TraceFormat2.JSON;
        } else {
          return TraceFormat2.Text;
        }
      }
      TraceFormat2.fromString = fromString;
    })(TraceFormat || (exports.TraceFormat = TraceFormat = {}));
    var SetTraceNotification;
    (function (SetTraceNotification2) {
      SetTraceNotification2.type = new messages_1.NotificationType("$/setTrace");
    })(SetTraceNotification || (exports.SetTraceNotification = SetTraceNotification = {}));
    var LogTraceNotification;
    (function (LogTraceNotification2) {
      LogTraceNotification2.type = new messages_1.NotificationType("$/logTrace");
    })(LogTraceNotification || (exports.LogTraceNotification = LogTraceNotification = {}));
    var ConnectionErrors;
    (function (ConnectionErrors2) {
      ConnectionErrors2[ConnectionErrors2["Closed"] = 1] = "Closed";
      ConnectionErrors2[ConnectionErrors2["Disposed"] = 2] = "Disposed";
      ConnectionErrors2[ConnectionErrors2["AlreadyListening"] = 3] = "AlreadyListening";
    })(ConnectionErrors || (exports.ConnectionErrors = ConnectionErrors = {}));
    var ConnectionError = class _ConnectionError extends Error {
      constructor(code, message) {
        super(message);
        this.code = code;
        Object.setPrototypeOf(this, _ConnectionError.prototype);
      }
    };
    exports.ConnectionError = ConnectionError;
    var ConnectionStrategy;
    (function (ConnectionStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && Is2.func(candidate.cancelUndispatched);
      }
      ConnectionStrategy2.is = is;
    })(ConnectionStrategy || (exports.ConnectionStrategy = ConnectionStrategy = {}));
    var IdCancellationReceiverStrategy;
    (function (IdCancellationReceiverStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && (candidate.kind === void 0 || candidate.kind === "id") && Is2.func(candidate.createCancellationTokenSource) && (candidate.dispose === void 0 || Is2.func(candidate.dispose));
      }
      IdCancellationReceiverStrategy2.is = is;
    })(IdCancellationReceiverStrategy || (exports.IdCancellationReceiverStrategy = IdCancellationReceiverStrategy = {}));
    var RequestCancellationReceiverStrategy;
    (function (RequestCancellationReceiverStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && candidate.kind === "request" && Is2.func(candidate.createCancellationTokenSource) && (candidate.dispose === void 0 || Is2.func(candidate.dispose));
      }
      RequestCancellationReceiverStrategy2.is = is;
    })(RequestCancellationReceiverStrategy || (exports.RequestCancellationReceiverStrategy = RequestCancellationReceiverStrategy = {}));
    var CancellationReceiverStrategy;
    (function (CancellationReceiverStrategy2) {
      CancellationReceiverStrategy2.Message = Object.freeze({
        createCancellationTokenSource(_) {
          return new cancellation_1.CancellationTokenSource();
        }
      });
      function is(value) {
        return IdCancellationReceiverStrategy.is(value) || RequestCancellationReceiverStrategy.is(value);
      }
      CancellationReceiverStrategy2.is = is;
    })(CancellationReceiverStrategy || (exports.CancellationReceiverStrategy = CancellationReceiverStrategy = {}));
    var CancellationSenderStrategy;
    (function (CancellationSenderStrategy2) {
      CancellationSenderStrategy2.Message = Object.freeze({
        sendCancellation(conn, id) {
          return conn.sendNotification(CancelNotification.type, { id });
        },
        cleanup(_) {
        }
      });
      function is(value) {
        const candidate = value;
        return candidate && Is2.func(candidate.sendCancellation) && Is2.func(candidate.cleanup);
      }
      CancellationSenderStrategy2.is = is;
    })(CancellationSenderStrategy || (exports.CancellationSenderStrategy = CancellationSenderStrategy = {}));
    var CancellationStrategy;
    (function (CancellationStrategy2) {
      CancellationStrategy2.Message = Object.freeze({
        receiver: CancellationReceiverStrategy.Message,
        sender: CancellationSenderStrategy.Message
      });
      function is(value) {
        const candidate = value;
        return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
      }
      CancellationStrategy2.is = is;
    })(CancellationStrategy || (exports.CancellationStrategy = CancellationStrategy = {}));
    var MessageStrategy;
    (function (MessageStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && Is2.func(candidate.handleMessage);
      }
      MessageStrategy2.is = is;
    })(MessageStrategy || (exports.MessageStrategy = MessageStrategy = {}));
    var ConnectionOptions;
    (function (ConnectionOptions2) {
      function is(value) {
        const candidate = value;
        return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy) || MessageStrategy.is(candidate.messageStrategy));
      }
      ConnectionOptions2.is = is;
    })(ConnectionOptions || (exports.ConnectionOptions = ConnectionOptions = {}));
    var ConnectionState;
    (function (ConnectionState2) {
      ConnectionState2[ConnectionState2["New"] = 1] = "New";
      ConnectionState2[ConnectionState2["Listening"] = 2] = "Listening";
      ConnectionState2[ConnectionState2["Closed"] = 3] = "Closed";
      ConnectionState2[ConnectionState2["Disposed"] = 4] = "Disposed";
    })(ConnectionState || (ConnectionState = {}));
    function createMessageConnection(messageReader2, messageWriter2, _logger, options) {
      const logger = _logger !== void 0 ? _logger : exports.NullLogger;
      let sequenceNumber = 0;
      let notificationSequenceNumber = 0;
      let unknownResponseSequenceNumber = 0;
      const version = "2.0";
      let starRequestHandler = void 0;
      const requestHandlers = /* @__PURE__ */ new Map();
      let starNotificationHandler = void 0;
      const notificationHandlers = /* @__PURE__ */ new Map();
      const progressHandlers = /* @__PURE__ */ new Map();
      let timer;
      let messageQueue = new linkedMap_1.LinkedMap();
      let responsePromises = /* @__PURE__ */ new Map();
      let knownCanceledRequests = /* @__PURE__ */ new Set();
      let requestTokens = /* @__PURE__ */ new Map();
      let trace = Trace.Off;
      let traceFormat = TraceFormat.Text;
      let tracer;
      let state = ConnectionState.New;
      const errorEmitter = new events_1.Emitter();
      const closeEmitter = new events_1.Emitter();
      const unhandledNotificationEmitter = new events_1.Emitter();
      const unhandledProgressEmitter = new events_1.Emitter();
      const disposeEmitter = new events_1.Emitter();
      const cancellationStrategy = options && options.cancellationStrategy ? options.cancellationStrategy : CancellationStrategy.Message;
      function createRequestQueueKey(id) {
        if (id === null) {
          throw new Error(`Can't send requests with id null since the response can't be correlated.`);
        }
        return "req-" + id.toString();
      }
      function createResponseQueueKey(id) {
        if (id === null) {
          return "res-unknown-" + (++unknownResponseSequenceNumber).toString();
        } else {
          return "res-" + id.toString();
        }
      }
      function createNotificationQueueKey() {
        return "not-" + (++notificationSequenceNumber).toString();
      }
      function addMessageToQueue(queue, message) {
        if (messages_1.Message.isRequest(message)) {
          queue.set(createRequestQueueKey(message.id), message);
        } else if (messages_1.Message.isResponse(message)) {
          queue.set(createResponseQueueKey(message.id), message);
        } else {
          queue.set(createNotificationQueueKey(), message);
        }
      }
      function cancelUndispatched(_message) {
        return void 0;
      }
      function isListening() {
        return state === ConnectionState.Listening;
      }
      function isClosed() {
        return state === ConnectionState.Closed;
      }
      function isDisposed() {
        return state === ConnectionState.Disposed;
      }
      function closeHandler() {
        if (state === ConnectionState.New || state === ConnectionState.Listening) {
          state = ConnectionState.Closed;
          closeEmitter.fire(void 0);
        }
      }
      function readErrorHandler(error) {
        errorEmitter.fire([error, void 0, void 0]);
      }
      function writeErrorHandler(data) {
        errorEmitter.fire(data);
      }
      messageReader2.onClose(closeHandler);
      messageReader2.onError(readErrorHandler);
      messageWriter2.onClose(closeHandler);
      messageWriter2.onError(writeErrorHandler);
      function triggerMessageQueue() {
        if (timer || messageQueue.size === 0) {
          return;
        }
        timer = (0, ral_1.default)().timer.setImmediate(() => {
          timer = void 0;
          processMessageQueue();
        });
      }
      function handleMessage(message) {
        if (messages_1.Message.isRequest(message)) {
          handleRequest(message);
        } else if (messages_1.Message.isNotification(message)) {
          handleNotification(message);
        } else if (messages_1.Message.isResponse(message)) {
          handleResponse(message);
        } else {
          handleInvalidMessage(message);
        }
      }
      function processMessageQueue() {
        if (messageQueue.size === 0) {
          return;
        }
        const message = messageQueue.shift();
        try {
          const messageStrategy = options?.messageStrategy;
          if (MessageStrategy.is(messageStrategy)) {
            messageStrategy.handleMessage(message, handleMessage);
          } else {
            handleMessage(message);
          }
        } finally {
          triggerMessageQueue();
        }
      }
      const callback = (message) => {
        try {
          if (messages_1.Message.isNotification(message) && message.method === CancelNotification.type.method) {
            const cancelId = message.params.id;
            const key = createRequestQueueKey(cancelId);
            const toCancel = messageQueue.get(key);
            if (messages_1.Message.isRequest(toCancel)) {
              const strategy = options?.connectionStrategy;
              const response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
              if (response && (response.error !== void 0 || response.result !== void 0)) {
                messageQueue.delete(key);
                requestTokens.delete(cancelId);
                response.id = toCancel.id;
                traceSendingResponse(response, message.method, Date.now());
                messageWriter2.write(response).catch(() => logger.error(`Sending response for canceled message failed.`));
                return;
              }
            }
            const cancellationToken = requestTokens.get(cancelId);
            if (cancellationToken !== void 0) {
              cancellationToken.cancel();
              traceReceivedNotification(message);
              return;
            } else {
              knownCanceledRequests.add(cancelId);
            }
          }
          addMessageToQueue(messageQueue, message);
        } finally {
          triggerMessageQueue();
        }
      };
      function handleRequest(requestMessage) {
        if (isDisposed()) {
          return;
        }
        function reply(resultOrError, method, startTime2) {
          const message = {
            jsonrpc: version,
            id: requestMessage.id
          };
          if (resultOrError instanceof messages_1.ResponseError) {
            message.error = resultOrError.toJson();
          } else {
            message.result = resultOrError === void 0 ? null : resultOrError;
          }
          traceSendingResponse(message, method, startTime2);
          messageWriter2.write(message).catch(() => logger.error(`Sending response failed.`));
        }
        function replyError(error, method, startTime2) {
          const message = {
            jsonrpc: version,
            id: requestMessage.id,
            error: error.toJson()
          };
          traceSendingResponse(message, method, startTime2);
          messageWriter2.write(message).catch(() => logger.error(`Sending response failed.`));
        }
        function replySuccess(result, method, startTime2) {
          if (result === void 0) {
            result = null;
          }
          const message = {
            jsonrpc: version,
            id: requestMessage.id,
            result
          };
          traceSendingResponse(message, method, startTime2);
          messageWriter2.write(message).catch(() => logger.error(`Sending response failed.`));
        }
        traceReceivedRequest(requestMessage);
        const element = requestHandlers.get(requestMessage.method);
        let type;
        let requestHandler;
        if (element) {
          type = element.type;
          requestHandler = element.handler;
        }
        const startTime = Date.now();
        if (requestHandler || starRequestHandler) {
          const tokenKey = requestMessage.id ?? String(Date.now());
          const cancellationSource = IdCancellationReceiverStrategy.is(cancellationStrategy.receiver) ? cancellationStrategy.receiver.createCancellationTokenSource(tokenKey) : cancellationStrategy.receiver.createCancellationTokenSource(requestMessage);
          if (requestMessage.id !== null && knownCanceledRequests.has(requestMessage.id)) {
            cancellationSource.cancel();
          }
          if (requestMessage.id !== null) {
            requestTokens.set(tokenKey, cancellationSource);
          }
          try {
            let handlerResult;
            if (requestHandler) {
              if (requestMessage.params === void 0) {
                if (type !== void 0 && type.numberOfParams !== 0) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but received none.`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(cancellationSource.token);
              } else if (Array.isArray(requestMessage.params)) {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byName) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
              } else {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
              }
            } else if (starRequestHandler) {
              handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
            }
            const promise = handlerResult;
            if (!handlerResult) {
              requestTokens.delete(tokenKey);
              replySuccess(handlerResult, requestMessage.method, startTime);
            } else if (promise.then) {
              promise.then((resultOrError) => {
                requestTokens.delete(tokenKey);
                reply(resultOrError, requestMessage.method, startTime);
              }, (error) => {
                requestTokens.delete(tokenKey);
                if (error instanceof messages_1.ResponseError) {
                  replyError(error, requestMessage.method, startTime);
                } else if (error && Is2.string(error.message)) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                } else {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                }
              });
            } else {
              requestTokens.delete(tokenKey);
              reply(handlerResult, requestMessage.method, startTime);
            }
          } catch (error) {
            requestTokens.delete(tokenKey);
            if (error instanceof messages_1.ResponseError) {
              reply(error, requestMessage.method, startTime);
            } else if (error && Is2.string(error.message)) {
              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
            } else {
              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
            }
          }
        } else {
          replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
        }
      }
      function handleResponse(responseMessage) {
        if (isDisposed()) {
          return;
        }
        if (responseMessage.id === null) {
          if (responseMessage.error) {
            logger.error(`Received response message without id: Error is: 
${JSON.stringify(responseMessage.error, void 0, 4)}`);
          } else {
            logger.error(`Received response message without id. No further error information provided.`);
          }
        } else {
          const key = responseMessage.id;
          const responsePromise = responsePromises.get(key);
          traceReceivedResponse(responseMessage, responsePromise);
          if (responsePromise !== void 0) {
            responsePromises.delete(key);
            try {
              if (responseMessage.error) {
                const error = responseMessage.error;
                responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
              } else if (responseMessage.result !== void 0) {
                responsePromise.resolve(responseMessage.result);
              } else {
                throw new Error("Should never happen.");
              }
            } catch (error) {
              if (error.message) {
                logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
              } else {
                logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
              }
            }
          }
        }
      }
      function handleNotification(message) {
        if (isDisposed()) {
          return;
        }
        let type = void 0;
        let notificationHandler;
        if (message.method === CancelNotification.type.method) {
          const cancelId = message.params.id;
          knownCanceledRequests.delete(cancelId);
          traceReceivedNotification(message);
          return;
        } else {
          const element = notificationHandlers.get(message.method);
          if (element) {
            notificationHandler = element.handler;
            type = element.type;
          }
        }
        if (notificationHandler || starNotificationHandler) {
          try {
            traceReceivedNotification(message);
            if (notificationHandler) {
              if (message.params === void 0) {
                if (type !== void 0) {
                  if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {
                    logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received none.`);
                  }
                }
                notificationHandler();
              } else if (Array.isArray(message.params)) {
                const params = message.params;
                if (message.method === ProgressNotification.type.method && params.length === 2 && ProgressToken.is(params[0])) {
                  notificationHandler({ token: params[0], value: params[1] });
                } else {
                  if (type !== void 0) {
                    if (type.parameterStructures === messages_1.ParameterStructures.byName) {
                      logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);
                    }
                    if (type.numberOfParams !== message.params.length) {
                      logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${params.length} arguments`);
                    }
                  }
                  notificationHandler(...params);
                }
              } else {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                  logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);
                }
                notificationHandler(message.params);
              }
            } else if (starNotificationHandler) {
              starNotificationHandler(message.method, message.params);
            }
          } catch (error) {
            if (error.message) {
              logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
            } else {
              logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
            }
          }
        } else {
          unhandledNotificationEmitter.fire(message);
        }
      }
      function handleInvalidMessage(message) {
        if (!message) {
          logger.error("Received empty message.");
          return;
        }
        logger.error(`Received message which is neither a response nor a notification message:
${JSON.stringify(message, null, 4)}`);
        const responseMessage = message;
        if (Is2.string(responseMessage.id) || Is2.number(responseMessage.id)) {
          const key = responseMessage.id;
          const responseHandler = responsePromises.get(key);
          if (responseHandler) {
            responseHandler.reject(new Error("The received response has neither a result nor an error property."));
          }
        }
      }
      function stringifyTrace(params) {
        if (params === void 0 || params === null) {
          return void 0;
        }
        switch (trace) {
          case Trace.Verbose:
            return JSON.stringify(params, null, 4);
          case Trace.Compact:
            return JSON.stringify(params);
          default:
            return void 0;
        }
      }
      function traceSendingRequest(message) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
            data = `Params: ${stringifyTrace(message.params)}

`;
          }
          tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
        } else {
          logLSPMessage("send-request", message);
        }
      }
      function traceSendingNotification(message) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message.params) {
              data = `Params: ${stringifyTrace(message.params)}

`;
            } else {
              data = "No parameters provided.\n\n";
            }
          }
          tracer.log(`Sending notification '${message.method}'.`, data);
        } else {
          logLSPMessage("send-notification", message);
        }
      }
      function traceSendingResponse(message, method, startTime) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message.error && message.error.data) {
              data = `Error data: ${stringifyTrace(message.error.data)}

`;
            } else {
              if (message.result) {
                data = `Result: ${stringifyTrace(message.result)}

`;
              } else if (message.error === void 0) {
                data = "No result returned.\n\n";
              }
            }
          }
          tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
        } else {
          logLSPMessage("send-response", message);
        }
      }
      function traceReceivedRequest(message) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
            data = `Params: ${stringifyTrace(message.params)}

`;
          }
          tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
        } else {
          logLSPMessage("receive-request", message);
        }
      }
      function traceReceivedNotification(message) {
        if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message.params) {
              data = `Params: ${stringifyTrace(message.params)}

`;
            } else {
              data = "No parameters provided.\n\n";
            }
          }
          tracer.log(`Received notification '${message.method}'.`, data);
        } else {
          logLSPMessage("receive-notification", message);
        }
      }
      function traceReceivedResponse(message, responsePromise) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message.error && message.error.data) {
              data = `Error data: ${stringifyTrace(message.error.data)}

`;
            } else {
              if (message.result) {
                data = `Result: ${stringifyTrace(message.result)}

`;
              } else if (message.error === void 0) {
                data = "No result returned.\n\n";
              }
            }
          }
          if (responsePromise) {
            const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : "";
            tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
          } else {
            tracer.log(`Received response ${message.id} without active response promise.`, data);
          }
        } else {
          logLSPMessage("receive-response", message);
        }
      }
      function logLSPMessage(type, message) {
        if (!tracer || trace === Trace.Off) {
          return;
        }
        const lspMessage = {
          isLSPMessage: true,
          type,
          message,
          timestamp: Date.now()
        };
        tracer.log(lspMessage);
      }
      function throwIfClosedOrDisposed() {
        if (isClosed()) {
          throw new ConnectionError(ConnectionErrors.Closed, "Connection is closed.");
        }
        if (isDisposed()) {
          throw new ConnectionError(ConnectionErrors.Disposed, "Connection is disposed.");
        }
      }
      function throwIfListening() {
        if (isListening()) {
          throw new ConnectionError(ConnectionErrors.AlreadyListening, "Connection is already listening");
        }
      }
      function throwIfNotListening() {
        if (!isListening()) {
          throw new Error("Call listen() first.");
        }
      }
      function undefinedToNull(param) {
        if (param === void 0) {
          return null;
        } else {
          return param;
        }
      }
      function nullToUndefined(param) {
        if (param === null) {
          return void 0;
        } else {
          return param;
        }
      }
      function isNamedParam(param) {
        return param !== void 0 && param !== null && !Array.isArray(param) && typeof param === "object";
      }
      function computeSingleParam(parameterStructures, param) {
        switch (parameterStructures) {
          case messages_1.ParameterStructures.auto:
            if (isNamedParam(param)) {
              return nullToUndefined(param);
            } else {
              return [undefinedToNull(param)];
            }
          case messages_1.ParameterStructures.byName:
            if (!isNamedParam(param)) {
              throw new Error(`Received parameters by name but param is not an object literal.`);
            }
            return nullToUndefined(param);
          case messages_1.ParameterStructures.byPosition:
            return [undefinedToNull(param)];
          default:
            throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
        }
      }
      function computeMessageParams(type, params) {
        let result;
        const numberOfParams = type.numberOfParams;
        switch (numberOfParams) {
          case 0:
            result = void 0;
            break;
          case 1:
            result = computeSingleParam(type.parameterStructures, params[0]);
            break;
          default:
            result = [];
            for (let i = 0; i < params.length && i < numberOfParams; i++) {
              result.push(undefinedToNull(params[i]));
            }
            if (params.length < numberOfParams) {
              for (let i = params.length; i < numberOfParams; i++) {
                result.push(null);
              }
            }
            break;
        }
        return result;
      }
      const connection2 = {
        sendNotification: (type, ...args) => {
          throwIfClosedOrDisposed();
          let method;
          let messageParams;
          if (Is2.string(type)) {
            method = type;
            const first = args[0];
            let paramStart = 0;
            let parameterStructures = messages_1.ParameterStructures.auto;
            if (messages_1.ParameterStructures.is(first)) {
              paramStart = 1;
              parameterStructures = first;
            }
            let paramEnd = args.length;
            const numberOfParams = paramEnd - paramStart;
            switch (numberOfParams) {
              case 0:
                messageParams = void 0;
                break;
              case 1:
                messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                break;
              default:
                if (parameterStructures === messages_1.ParameterStructures.byName) {
                  throw new Error(`Received ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
                }
                messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                break;
            }
          } else {
            const params = args;
            method = type.method;
            messageParams = computeMessageParams(type, params);
          }
          const notificationMessage = {
            jsonrpc: version,
            method,
            params: messageParams
          };
          traceSendingNotification(notificationMessage);
          return messageWriter2.write(notificationMessage).catch((error) => {
            logger.error(`Sending notification failed.`);
            throw error;
          });
        },
        onNotification: (type, handler) => {
          throwIfClosedOrDisposed();
          let method;
          if (Is2.func(type)) {
            starNotificationHandler = type;
          } else if (handler) {
            if (Is2.string(type)) {
              method = type;
              notificationHandlers.set(type, { type: void 0, handler });
            } else {
              method = type.method;
              notificationHandlers.set(type.method, { type, handler });
            }
          }
          return {
            dispose: () => {
              if (method !== void 0) {
                notificationHandlers.delete(method);
              } else {
                starNotificationHandler = void 0;
              }
            }
          };
        },
        onProgress: (_type, token, handler) => {
          if (progressHandlers.has(token)) {
            throw new Error(`Progress handler for token ${token} already registered`);
          }
          progressHandlers.set(token, handler);
          return {
            dispose: () => {
              progressHandlers.delete(token);
            }
          };
        },
        sendProgress: (_type, token, value) => {
          return connection2.sendNotification(ProgressNotification.type, { token, value });
        },
        onUnhandledProgress: unhandledProgressEmitter.event,
        sendRequest: (type, ...args) => {
          throwIfClosedOrDisposed();
          throwIfNotListening();
          let method;
          let messageParams;
          let token = void 0;
          if (Is2.string(type)) {
            method = type;
            const first = args[0];
            const last = args[args.length - 1];
            let paramStart = 0;
            let parameterStructures = messages_1.ParameterStructures.auto;
            if (messages_1.ParameterStructures.is(first)) {
              paramStart = 1;
              parameterStructures = first;
            }
            let paramEnd = args.length;
            if (cancellation_1.CancellationToken.is(last)) {
              paramEnd = paramEnd - 1;
              token = last;
            }
            const numberOfParams = paramEnd - paramStart;
            switch (numberOfParams) {
              case 0:
                messageParams = void 0;
                break;
              case 1:
                messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                break;
              default:
                if (parameterStructures === messages_1.ParameterStructures.byName) {
                  throw new Error(`Received ${numberOfParams} parameters for 'by Name' request parameter structure.`);
                }
                messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                break;
            }
          } else {
            const params = args;
            method = type.method;
            messageParams = computeMessageParams(type, params);
            const numberOfParams = type.numberOfParams;
            token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : void 0;
          }
          const id = sequenceNumber++;
          let disposable;
          if (token) {
            disposable = token.onCancellationRequested(() => {
              const p = cancellationStrategy.sender.sendCancellation(connection2, id);
              if (p === void 0) {
                logger.log(`Received no promise from cancellation strategy when cancelling id ${id}`);
                return Promise.resolve();
              } else {
                return p.catch(() => {
                  logger.log(`Sending cancellation messages for id ${id} failed`);
                });
              }
            });
          }
          const requestMessage = {
            jsonrpc: version,
            id,
            method,
            params: messageParams
          };
          traceSendingRequest(requestMessage);
          if (typeof cancellationStrategy.sender.enableCancellation === "function") {
            cancellationStrategy.sender.enableCancellation(requestMessage);
          }
          return new Promise(async (resolve, reject) => {
            const resolveWithCleanup = (r) => {
              resolve(r);
              cancellationStrategy.sender.cleanup(id);
              disposable?.dispose();
            };
            const rejectWithCleanup = (r) => {
              reject(r);
              cancellationStrategy.sender.cleanup(id);
              disposable?.dispose();
            };
            const responsePromise = { method, timerStart: Date.now(), resolve: resolveWithCleanup, reject: rejectWithCleanup };
            try {
              await messageWriter2.write(requestMessage);
              responsePromises.set(id, responsePromise);
            } catch (error) {
              logger.error(`Sending request failed.`);
              responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, error.message ? error.message : "Unknown reason"));
              throw error;
            }
          });
        },
        onRequest: (type, handler) => {
          throwIfClosedOrDisposed();
          let method = null;
          if (StarRequestHandler.is(type)) {
            method = void 0;
            starRequestHandler = type;
          } else if (Is2.string(type)) {
            method = null;
            if (handler !== void 0) {
              method = type;
              requestHandlers.set(type, { handler, type: void 0 });
            }
          } else {
            if (handler !== void 0) {
              method = type.method;
              requestHandlers.set(type.method, { type, handler });
            }
          }
          return {
            dispose: () => {
              if (method === null) {
                return;
              }
              if (method !== void 0) {
                requestHandlers.delete(method);
              } else {
                starRequestHandler = void 0;
              }
            }
          };
        },
        hasPendingResponse: () => {
          return responsePromises.size > 0;
        },
        trace: async (_value, _tracer, sendNotificationOrTraceOptions) => {
          let _sendNotification = false;
          let _traceFormat = TraceFormat.Text;
          if (sendNotificationOrTraceOptions !== void 0) {
            if (Is2.boolean(sendNotificationOrTraceOptions)) {
              _sendNotification = sendNotificationOrTraceOptions;
            } else {
              _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
              _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
            }
          }
          trace = _value;
          traceFormat = _traceFormat;
          if (trace === Trace.Off) {
            tracer = void 0;
          } else {
            tracer = _tracer;
          }
          if (_sendNotification && !isClosed() && !isDisposed()) {
            await connection2.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });
          }
        },
        onError: errorEmitter.event,
        onClose: closeEmitter.event,
        onUnhandledNotification: unhandledNotificationEmitter.event,
        onDispose: disposeEmitter.event,
        end: () => {
          messageWriter2.end();
        },
        dispose: () => {
          if (isDisposed()) {
            return;
          }
          state = ConnectionState.Disposed;
          disposeEmitter.fire(void 0);
          const error = new messages_1.ResponseError(messages_1.ErrorCodes.PendingResponseRejected, "Pending response rejected since connection got disposed");
          for (const promise of responsePromises.values()) {
            promise.reject(error);
          }
          responsePromises = /* @__PURE__ */ new Map();
          requestTokens = /* @__PURE__ */ new Map();
          knownCanceledRequests = /* @__PURE__ */ new Set();
          messageQueue = new linkedMap_1.LinkedMap();
          if (Is2.func(messageWriter2.dispose)) {
            messageWriter2.dispose();
          }
          if (Is2.func(messageReader2.dispose)) {
            messageReader2.dispose();
          }
        },
        listen: () => {
          throwIfClosedOrDisposed();
          throwIfListening();
          state = ConnectionState.Listening;
          messageReader2.listen(callback);
        },
        inspect: () => {
          (0, ral_1.default)().console.log("inspect");
        }
      };
      connection2.onNotification(LogTraceNotification.type, (params) => {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        const verbose = trace === Trace.Verbose || trace === Trace.Compact;
        tracer.log(params.message, verbose ? params.verbose : void 0);
      });
      connection2.onNotification(ProgressNotification.type, (params) => {
        const handler = progressHandlers.get(params.token);
        if (handler) {
          handler(params.value);
        } else {
          unhandledProgressEmitter.fire(params);
        }
      });
      return connection2;
    }
    exports.createMessageConnection = createMessageConnection;
  }
});

// server/node_modules/vscode-jsonrpc/lib/common/api.js
var require_api = __commonJS({
  "server/node_modules/vscode-jsonrpc/lib/common/api.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProgressType = exports.ProgressToken = exports.createMessageConnection = exports.NullLogger = exports.ConnectionOptions = exports.ConnectionStrategy = exports.AbstractMessageBuffer = exports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = exports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = exports.SharedArrayReceiverStrategy = exports.SharedArraySenderStrategy = exports.CancellationToken = exports.CancellationTokenSource = exports.Emitter = exports.Event = exports.Disposable = exports.LRUCache = exports.Touch = exports.LinkedMap = exports.ParameterStructures = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.ErrorCodes = exports.ResponseError = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType0 = exports.RequestType = exports.Message = exports.RAL = void 0;
    exports.MessageStrategy = exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.TraceValues = exports.Trace = void 0;
    var messages_1 = require_messages();
    Object.defineProperty(exports, "Message", {
      enumerable: true, get: function () {
        return messages_1.Message;
      }
    });
    Object.defineProperty(exports, "RequestType", {
      enumerable: true, get: function () {
        return messages_1.RequestType;
      }
    });
    Object.defineProperty(exports, "RequestType0", {
      enumerable: true, get: function () {
        return messages_1.RequestType0;
      }
    });
    Object.defineProperty(exports, "RequestType1", {
      enumerable: true, get: function () {
        return messages_1.RequestType1;
      }
    });
    Object.defineProperty(exports, "RequestType2", {
      enumerable: true, get: function () {
        return messages_1.RequestType2;
      }
    });
    Object.defineProperty(exports, "RequestType3", {
      enumerable: true, get: function () {
        return messages_1.RequestType3;
      }
    });
    Object.defineProperty(exports, "RequestType4", {
      enumerable: true, get: function () {
        return messages_1.RequestType4;
      }
    });
    Object.defineProperty(exports, "RequestType5", {
      enumerable: true, get: function () {
        return messages_1.RequestType5;
      }
    });
    Object.defineProperty(exports, "RequestType6", {
      enumerable: true, get: function () {
        return messages_1.RequestType6;
      }
    });
    Object.defineProperty(exports, "RequestType7", {
      enumerable: true, get: function () {
        return messages_1.RequestType7;
      }
    });
    Object.defineProperty(exports, "RequestType8", {
      enumerable: true, get: function () {
        return messages_1.RequestType8;
      }
    });
    Object.defineProperty(exports, "RequestType9", {
      enumerable: true, get: function () {
        return messages_1.RequestType9;
      }
    });
    Object.defineProperty(exports, "ResponseError", {
      enumerable: true, get: function () {
        return messages_1.ResponseError;
      }
    });
    Object.defineProperty(exports, "ErrorCodes", {
      enumerable: true, get: function () {
        return messages_1.ErrorCodes;
      }
    });
    Object.defineProperty(exports, "NotificationType", {
      enumerable: true, get: function () {
        return messages_1.NotificationType;
      }
    });
    Object.defineProperty(exports, "NotificationType0", {
      enumerable: true, get: function () {
        return messages_1.NotificationType0;
      }
    });
    Object.defineProperty(exports, "NotificationType1", {
      enumerable: true, get: function () {
        return messages_1.NotificationType1;
      }
    });
    Object.defineProperty(exports, "NotificationType2", {
      enumerable: true, get: function () {
        return messages_1.NotificationType2;
      }
    });
    Object.defineProperty(exports, "NotificationType3", {
      enumerable: true, get: function () {
        return messages_1.NotificationType3;
      }
    });
    Object.defineProperty(exports, "NotificationType4", {
      enumerable: true, get: function () {
        return messages_1.NotificationType4;
      }
    });
    Object.defineProperty(exports, "NotificationType5", {
      enumerable: true, get: function () {
        return messages_1.NotificationType5;
      }
    });
    Object.defineProperty(exports, "NotificationType6", {
      enumerable: true, get: function () {
        return messages_1.NotificationType6;
      }
    });
    Object.defineProperty(exports, "NotificationType7", {
      enumerable: true, get: function () {
        return messages_1.NotificationType7;
      }
    });
    Object.defineProperty(exports, "NotificationType8", {
      enumerable: true, get: function () {
        return messages_1.NotificationType8;
      }
    });
    Object.defineProperty(exports, "NotificationType9", {
      enumerable: true, get: function () {
        return messages_1.NotificationType9;
      }
    });
    Object.defineProperty(exports, "ParameterStructures", {
      enumerable: true, get: function () {
        return messages_1.ParameterStructures;
      }
    });
    var linkedMap_1 = require_linkedMap();
    Object.defineProperty(exports, "LinkedMap", {
      enumerable: true, get: function () {
        return linkedMap_1.LinkedMap;
      }
    });
    Object.defineProperty(exports, "LRUCache", {
      enumerable: true, get: function () {
        return linkedMap_1.LRUCache;
      }
    });
    Object.defineProperty(exports, "Touch", {
      enumerable: true, get: function () {
        return linkedMap_1.Touch;
      }
    });
    var disposable_1 = require_disposable();
    Object.defineProperty(exports, "Disposable", {
      enumerable: true, get: function () {
        return disposable_1.Disposable;
      }
    });
    var events_1 = require_events();
    Object.defineProperty(exports, "Event", {
      enumerable: true, get: function () {
        return events_1.Event;
      }
    });
    Object.defineProperty(exports, "Emitter", {
      enumerable: true, get: function () {
        return events_1.Emitter;
      }
    });
    var cancellation_1 = require_cancellation();
    Object.defineProperty(exports, "CancellationTokenSource", {
      enumerable: true, get: function () {
        return cancellation_1.CancellationTokenSource;
      }
    });
    Object.defineProperty(exports, "CancellationToken", {
      enumerable: true, get: function () {
        return cancellation_1.CancellationToken;
      }
    });
    var sharedArrayCancellation_1 = require_sharedArrayCancellation();
    Object.defineProperty(exports, "SharedArraySenderStrategy", {
      enumerable: true, get: function () {
        return sharedArrayCancellation_1.SharedArraySenderStrategy;
      }
    });
    Object.defineProperty(exports, "SharedArrayReceiverStrategy", {
      enumerable: true, get: function () {
        return sharedArrayCancellation_1.SharedArrayReceiverStrategy;
      }
    });
    var messageReader_1 = require_messageReader();
    Object.defineProperty(exports, "MessageReader", {
      enumerable: true, get: function () {
        return messageReader_1.MessageReader;
      }
    });
    Object.defineProperty(exports, "AbstractMessageReader", {
      enumerable: true, get: function () {
        return messageReader_1.AbstractMessageReader;
      }
    });
    Object.defineProperty(exports, "ReadableStreamMessageReader", {
      enumerable: true, get: function () {
        return messageReader_1.ReadableStreamMessageReader;
      }
    });
    var messageWriter_1 = require_messageWriter();
    Object.defineProperty(exports, "MessageWriter", {
      enumerable: true, get: function () {
        return messageWriter_1.MessageWriter;
      }
    });
    Object.defineProperty(exports, "AbstractMessageWriter", {
      enumerable: true, get: function () {
        return messageWriter_1.AbstractMessageWriter;
      }
    });
    Object.defineProperty(exports, "WriteableStreamMessageWriter", {
      enumerable: true, get: function () {
        return messageWriter_1.WriteableStreamMessageWriter;
      }
    });
    var messageBuffer_1 = require_messageBuffer();
    Object.defineProperty(exports, "AbstractMessageBuffer", {
      enumerable: true, get: function () {
        return messageBuffer_1.AbstractMessageBuffer;
      }
    });
    var connection_1 = require_connection();
    Object.defineProperty(exports, "ConnectionStrategy", {
      enumerable: true, get: function () {
        return connection_1.ConnectionStrategy;
      }
    });
    Object.defineProperty(exports, "ConnectionOptions", {
      enumerable: true, get: function () {
        return connection_1.ConnectionOptions;
      }
    });
    Object.defineProperty(exports, "NullLogger", {
      enumerable: true, get: function () {
        return connection_1.NullLogger;
      }
    });
    Object.defineProperty(exports, "createMessageConnection", {
      enumerable: true, get: function () {
        return connection_1.createMessageConnection;
      }
    });
    Object.defineProperty(exports, "ProgressToken", {
      enumerable: true, get: function () {
        return connection_1.ProgressToken;
      }
    });
    Object.defineProperty(exports, "ProgressType", {
      enumerable: true, get: function () {
        return connection_1.ProgressType;
      }
    });
    Object.defineProperty(exports, "Trace", {
      enumerable: true, get: function () {
        return connection_1.Trace;
      }
    });
    Object.defineProperty(exports, "TraceValues", {
      enumerable: true, get: function () {
        return connection_1.TraceValues;
      }
    });
    Object.defineProperty(exports, "TraceFormat", {
      enumerable: true, get: function () {
        return connection_1.TraceFormat;
      }
    });
    Object.defineProperty(exports, "SetTraceNotification", {
      enumerable: true, get: function () {
        return connection_1.SetTraceNotification;
      }
    });
    Object.defineProperty(exports, "LogTraceNotification", {
      enumerable: true, get: function () {
        return connection_1.LogTraceNotification;
      }
    });
    Object.defineProperty(exports, "ConnectionErrors", {
      enumerable: true, get: function () {
        return connection_1.ConnectionErrors;
      }
    });
    Object.defineProperty(exports, "ConnectionError", {
      enumerable: true, get: function () {
        return connection_1.ConnectionError;
      }
    });
    Object.defineProperty(exports, "CancellationReceiverStrategy", {
      enumerable: true, get: function () {
        return connection_1.CancellationReceiverStrategy;
      }
    });
    Object.defineProperty(exports, "CancellationSenderStrategy", {
      enumerable: true, get: function () {
        return connection_1.CancellationSenderStrategy;
      }
    });
    Object.defineProperty(exports, "CancellationStrategy", {
      enumerable: true, get: function () {
        return connection_1.CancellationStrategy;
      }
    });
    Object.defineProperty(exports, "MessageStrategy", {
      enumerable: true, get: function () {
        return connection_1.MessageStrategy;
      }
    });
    var ral_1 = require_ral();
    exports.RAL = ral_1.default;
  }
});

// server/node_modules/vscode-jsonrpc/lib/browser/ril.js
var require_ril = __commonJS({
  "server/node_modules/vscode-jsonrpc/lib/browser/ril.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var api_1 = require_api();
    var MessageBuffer = class _MessageBuffer extends api_1.AbstractMessageBuffer {
      constructor(encoding = "utf-8") {
        super(encoding);
        this.asciiDecoder = new TextDecoder("ascii");
      }
      emptyBuffer() {
        return _MessageBuffer.emptyBuffer;
      }
      fromString(value, _encoding) {
        return new TextEncoder().encode(value);
      }
      toString(value, encoding) {
        if (encoding === "ascii") {
          return this.asciiDecoder.decode(value);
        } else {
          return new TextDecoder(encoding).decode(value);
        }
      }
      asNative(buffer, length) {
        if (length === void 0) {
          return buffer;
        } else {
          return buffer.slice(0, length);
        }
      }
      allocNative(length) {
        return new Uint8Array(length);
      }
    };
    MessageBuffer.emptyBuffer = new Uint8Array(0);
    var ReadableStreamWrapper = class {
      constructor(socket) {
        this.socket = socket;
        this._onData = new api_1.Emitter();
        this._messageListener = (event) => {
          const blob = event.data;
          blob.arrayBuffer().then((buffer) => {
            this._onData.fire(new Uint8Array(buffer));
          }, () => {
            (0, api_1.RAL)().console.error(`Converting blob to array buffer failed.`);
          });
        };
        this.socket.addEventListener("message", this._messageListener);
      }
      onClose(listener) {
        this.socket.addEventListener("close", listener);
        return api_1.Disposable.create(() => this.socket.removeEventListener("close", listener));
      }
      onError(listener) {
        this.socket.addEventListener("error", listener);
        return api_1.Disposable.create(() => this.socket.removeEventListener("error", listener));
      }
      onEnd(listener) {
        this.socket.addEventListener("end", listener);
        return api_1.Disposable.create(() => this.socket.removeEventListener("end", listener));
      }
      onData(listener) {
        return this._onData.event(listener);
      }
    };
    var WritableStreamWrapper = class {
      constructor(socket) {
        this.socket = socket;
      }
      onClose(listener) {
        this.socket.addEventListener("close", listener);
        return api_1.Disposable.create(() => this.socket.removeEventListener("close", listener));
      }
      onError(listener) {
        this.socket.addEventListener("error", listener);
        return api_1.Disposable.create(() => this.socket.removeEventListener("error", listener));
      }
      onEnd(listener) {
        this.socket.addEventListener("end", listener);
        return api_1.Disposable.create(() => this.socket.removeEventListener("end", listener));
      }
      write(data, encoding) {
        if (typeof data === "string") {
          if (encoding !== void 0 && encoding !== "utf-8") {
            throw new Error(`In a Browser environments only utf-8 text encoding is supported. But got encoding: ${encoding}`);
          }
          this.socket.send(data);
        } else {
          this.socket.send(data);
        }
        return Promise.resolve();
      }
      end() {
        this.socket.close();
      }
    };
    var _textEncoder = new TextEncoder();
    var _ril = Object.freeze({
      messageBuffer: Object.freeze({
        create: (encoding) => new MessageBuffer(encoding)
      }),
      applicationJson: Object.freeze({
        encoder: Object.freeze({
          name: "application/json",
          encode: (msg, options) => {
            if (options.charset !== "utf-8") {
              throw new Error(`In a Browser environments only utf-8 text encoding is supported. But got encoding: ${options.charset}`);
            }
            return Promise.resolve(_textEncoder.encode(JSON.stringify(msg, void 0, 0)));
          }
        }),
        decoder: Object.freeze({
          name: "application/json",
          decode: (buffer, options) => {
            if (!(buffer instanceof Uint8Array)) {
              throw new Error(`In a Browser environments only Uint8Arrays are supported.`);
            }
            return Promise.resolve(JSON.parse(new TextDecoder(options.charset).decode(buffer)));
          }
        })
      }),
      stream: Object.freeze({
        asReadableStream: (socket) => new ReadableStreamWrapper(socket),
        asWritableStream: (socket) => new WritableStreamWrapper(socket)
      }),
      console,
      timer: Object.freeze({
        setTimeout(callback, ms, ...args) {
          const handle = setTimeout(callback, ms, ...args);
          return { dispose: () => clearTimeout(handle) };
        },
        setImmediate(callback, ...args) {
          const handle = setTimeout(callback, 0, ...args);
          return { dispose: () => clearTimeout(handle) };
        },
        setInterval(callback, ms, ...args) {
          const handle = setInterval(callback, ms, ...args);
          return { dispose: () => clearInterval(handle) };
        }
      })
    });
    function RIL() {
      return _ril;
    }
    (function (RIL2) {
      function install() {
        api_1.RAL.install(_ril);
      }
      RIL2.install = install;
    })(RIL || (RIL = {}));
    exports.default = RIL;
  }
});

// server/node_modules/vscode-jsonrpc/lib/browser/main.js
var require_main = __commonJS({
  "server/node_modules/vscode-jsonrpc/lib/browser/main.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true, get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function (m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createMessageConnection = exports.BrowserMessageWriter = exports.BrowserMessageReader = void 0;
    var ril_1 = require_ril();
    ril_1.default.install();
    var api_1 = require_api();
    __exportStar(require_api(), exports);
    var BrowserMessageReader2 = class extends api_1.AbstractMessageReader {
      constructor(port) {
        super();
        this._onData = new api_1.Emitter();
        this._messageListener = (event) => {
          this._onData.fire(event.data);
        };
        port.addEventListener("error", (event) => this.fireError(event));
        port.onmessage = this._messageListener;
      }
      listen(callback) {
        return this._onData.event(callback);
      }
    };
    exports.BrowserMessageReader = BrowserMessageReader2;
    var BrowserMessageWriter2 = class extends api_1.AbstractMessageWriter {
      constructor(port) {
        super();
        this.port = port;
        this.errorCount = 0;
        port.addEventListener("error", (event) => this.fireError(event));
      }
      write(msg) {
        try {
          this.port.postMessage(msg);
          return Promise.resolve();
        } catch (error) {
          this.handleError(error, msg);
          return Promise.reject(error);
        }
      }
      handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
      end() {
      }
    };
    exports.BrowserMessageWriter = BrowserMessageWriter2;
    function createMessageConnection(reader, writer, logger, options) {
      if (logger === void 0) {
        logger = api_1.NullLogger;
      }
      if (api_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
      }
      return (0, api_1.createMessageConnection)(reader, writer, logger, options);
    }
    exports.createMessageConnection = createMessageConnection;
  }
});

// server/node_modules/vscode-jsonrpc/browser.js
var require_browser = __commonJS({
  "server/node_modules/vscode-jsonrpc/browser.js"(exports, module2) {
    "use strict";
    module2.exports = require_main();
  }
});

// server/node_modules/vscode-languageserver-types/lib/esm/main.js
var main_exports = {};
__export(main_exports, {
  AnnotatedTextEdit: () => AnnotatedTextEdit,
  ChangeAnnotation: () => ChangeAnnotation,
  ChangeAnnotationIdentifier: () => ChangeAnnotationIdentifier,
  CodeAction: () => CodeAction,
  CodeActionContext: () => CodeActionContext,
  CodeActionKind: () => CodeActionKind,
  CodeActionTriggerKind: () => CodeActionTriggerKind,
  CodeDescription: () => CodeDescription,
  CodeLens: () => CodeLens,
  Color: () => Color,
  ColorInformation: () => ColorInformation,
  ColorPresentation: () => ColorPresentation,
  Command: () => Command,
  CompletionItem: () => CompletionItem,
  CompletionItemKind: () => CompletionItemKind,
  CompletionItemLabelDetails: () => CompletionItemLabelDetails,
  CompletionItemTag: () => CompletionItemTag,
  CompletionList: () => CompletionList,
  CreateFile: () => CreateFile,
  DeleteFile: () => DeleteFile,
  Diagnostic: () => Diagnostic,
  DiagnosticRelatedInformation: () => DiagnosticRelatedInformation,
  DiagnosticSeverity: () => DiagnosticSeverity,
  DiagnosticTag: () => DiagnosticTag,
  DocumentHighlight: () => DocumentHighlight,
  DocumentHighlightKind: () => DocumentHighlightKind,
  DocumentLink: () => DocumentLink,
  DocumentSymbol: () => DocumentSymbol,
  DocumentUri: () => DocumentUri,
  EOL: () => EOL,
  FoldingRange: () => FoldingRange,
  FoldingRangeKind: () => FoldingRangeKind,
  FormattingOptions: () => FormattingOptions,
  Hover: () => Hover,
  InlayHint: () => InlayHint,
  InlayHintKind: () => InlayHintKind,
  InlayHintLabelPart: () => InlayHintLabelPart,
  InlineCompletionContext: () => InlineCompletionContext,
  InlineCompletionItem: () => InlineCompletionItem,
  InlineCompletionList: () => InlineCompletionList,
  InlineCompletionTriggerKind: () => InlineCompletionTriggerKind,
  InlineValueContext: () => InlineValueContext,
  InlineValueEvaluatableExpression: () => InlineValueEvaluatableExpression,
  InlineValueText: () => InlineValueText,
  InlineValueVariableLookup: () => InlineValueVariableLookup,
  InsertReplaceEdit: () => InsertReplaceEdit,
  InsertTextFormat: () => InsertTextFormat,
  InsertTextMode: () => InsertTextMode,
  Location: () => Location,
  LocationLink: () => LocationLink,
  MarkedString: () => MarkedString,
  MarkupContent: () => MarkupContent,
  MarkupKind: () => MarkupKind,
  OptionalVersionedTextDocumentIdentifier: () => OptionalVersionedTextDocumentIdentifier,
  ParameterInformation: () => ParameterInformation,
  Position: () => Position,
  Range: () => Range,
  RenameFile: () => RenameFile,
  SelectedCompletionInfo: () => SelectedCompletionInfo,
  SelectionRange: () => SelectionRange,
  SemanticTokenModifiers: () => SemanticTokenModifiers,
  SemanticTokenTypes: () => SemanticTokenTypes,
  SemanticTokens: () => SemanticTokens,
  SignatureInformation: () => SignatureInformation,
  StringValue: () => StringValue,
  SymbolInformation: () => SymbolInformation,
  SymbolKind: () => SymbolKind,
  SymbolTag: () => SymbolTag,
  TextDocument: () => TextDocument,
  TextDocumentEdit: () => TextDocumentEdit,
  TextDocumentIdentifier: () => TextDocumentIdentifier,
  TextDocumentItem: () => TextDocumentItem,
  TextEdit: () => TextEdit,
  URI: () => URI,
  VersionedTextDocumentIdentifier: () => VersionedTextDocumentIdentifier,
  WorkspaceChange: () => WorkspaceChange,
  WorkspaceEdit: () => WorkspaceEdit,
  WorkspaceFolder: () => WorkspaceFolder,
  WorkspaceSymbol: () => WorkspaceSymbol,
  integer: () => integer,
  uinteger: () => uinteger
});
var DocumentUri, URI, integer, uinteger, Position, Range, Location, LocationLink, Color, ColorInformation, ColorPresentation, FoldingRangeKind, FoldingRange, DiagnosticRelatedInformation, DiagnosticSeverity, DiagnosticTag, CodeDescription, Diagnostic, Command, TextEdit, ChangeAnnotation, ChangeAnnotationIdentifier, AnnotatedTextEdit, TextDocumentEdit, CreateFile, RenameFile, DeleteFile, WorkspaceEdit, TextEditChangeImpl, ChangeAnnotations, WorkspaceChange, TextDocumentIdentifier, VersionedTextDocumentIdentifier, OptionalVersionedTextDocumentIdentifier, TextDocumentItem, MarkupKind, MarkupContent, CompletionItemKind, InsertTextFormat, CompletionItemTag, InsertReplaceEdit, InsertTextMode, CompletionItemLabelDetails, CompletionItem, CompletionList, MarkedString, Hover, ParameterInformation, SignatureInformation, DocumentHighlightKind, DocumentHighlight, SymbolKind, SymbolTag, SymbolInformation, WorkspaceSymbol, DocumentSymbol, CodeActionKind, CodeActionTriggerKind, CodeActionContext, CodeAction, CodeLens, FormattingOptions, DocumentLink, SelectionRange, SemanticTokenTypes, SemanticTokenModifiers, SemanticTokens, InlineValueText, InlineValueVariableLookup, InlineValueEvaluatableExpression, InlineValueContext, InlayHintKind, InlayHintLabelPart, InlayHint, StringValue, InlineCompletionItem, InlineCompletionList, InlineCompletionTriggerKind, SelectedCompletionInfo, InlineCompletionContext, WorkspaceFolder, EOL, TextDocument, FullTextDocument, Is;
var init_main = __esm({
  "server/node_modules/vscode-languageserver-types/lib/esm/main.js"() {
    "use strict";
    (function (DocumentUri2) {
      function is(value) {
        return typeof value === "string";
      }
      DocumentUri2.is = is;
    })(DocumentUri || (DocumentUri = {}));
    (function (URI2) {
      function is(value) {
        return typeof value === "string";
      }
      URI2.is = is;
    })(URI || (URI = {}));
    (function (integer2) {
      integer2.MIN_VALUE = -2147483648;
      integer2.MAX_VALUE = 2147483647;
      function is(value) {
        return typeof value === "number" && integer2.MIN_VALUE <= value && value <= integer2.MAX_VALUE;
      }
      integer2.is = is;
    })(integer || (integer = {}));
    (function (uinteger2) {
      uinteger2.MIN_VALUE = 0;
      uinteger2.MAX_VALUE = 2147483647;
      function is(value) {
        return typeof value === "number" && uinteger2.MIN_VALUE <= value && value <= uinteger2.MAX_VALUE;
      }
      uinteger2.is = is;
    })(uinteger || (uinteger = {}));
    (function (Position2) {
      function create(line, character) {
        if (line === Number.MAX_VALUE) {
          line = uinteger.MAX_VALUE;
        }
        if (character === Number.MAX_VALUE) {
          character = uinteger.MAX_VALUE;
        }
        return { line, character };
      }
      Position2.create = create;
      function is(value) {
        let candidate = value;
        return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);
      }
      Position2.is = is;
    })(Position || (Position = {}));
    (function (Range3) {
      function create(one, two, three, four) {
        if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {
          return { start: Position.create(one, two), end: Position.create(three, four) };
        } else if (Position.is(one) && Position.is(two)) {
          return { start: one, end: two };
        } else {
          throw new Error(`Range#create called with invalid arguments[${one}, ${two}, ${three}, ${four}]`);
        }
      }
      Range3.create = create;
      function is(value) {
        let candidate = value;
        return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);
      }
      Range3.is = is;
    })(Range || (Range = {}));
    (function (Location2) {
      function create(uri, range) {
        return { uri, range };
      }
      Location2.create = create;
      function is(value) {
        let candidate = value;
        return Is.objectLiteral(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
      }
      Location2.is = is;
    })(Location || (Location = {}));
    (function (LocationLink2) {
      function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
        return { targetUri, targetRange, targetSelectionRange, originSelectionRange };
      }
      LocationLink2.create = create;
      function is(value) {
        let candidate = value;
        return Is.objectLiteral(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri) && Range.is(candidate.targetSelectionRange) && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
      }
      LocationLink2.is = is;
    })(LocationLink || (LocationLink = {}));
    (function (Color3) {
      function create(red, green, blue, alpha) {
        return {
          red,
          green,
          blue,
          alpha
        };
      }
      Color3.create = create;
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1) && Is.numberRange(candidate.green, 0, 1) && Is.numberRange(candidate.blue, 0, 1) && Is.numberRange(candidate.alpha, 0, 1);
      }
      Color3.is = is;
    })(Color || (Color = {}));
    (function (ColorInformation3) {
      function create(range, color) {
        return {
          range,
          color
        };
      }
      ColorInformation3.create = create;
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && Range.is(candidate.range) && Color.is(candidate.color);
      }
      ColorInformation3.is = is;
    })(ColorInformation || (ColorInformation = {}));
    (function (ColorPresentation3) {
      function create(label, textEdit, additionalTextEdits) {
        return {
          label,
          textEdit,
          additionalTextEdits
        };
      }
      ColorPresentation3.create = create;
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate)) && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
      }
      ColorPresentation3.is = is;
    })(ColorPresentation || (ColorPresentation = {}));
    (function (FoldingRangeKind2) {
      FoldingRangeKind2.Comment = "comment";
      FoldingRangeKind2.Imports = "imports";
      FoldingRangeKind2.Region = "region";
    })(FoldingRangeKind || (FoldingRangeKind = {}));
    (function (FoldingRange2) {
      function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {
        const result = {
          startLine,
          endLine
        };
        if (Is.defined(startCharacter)) {
          result.startCharacter = startCharacter;
        }
        if (Is.defined(endCharacter)) {
          result.endCharacter = endCharacter;
        }
        if (Is.defined(kind)) {
          result.kind = kind;
        }
        if (Is.defined(collapsedText)) {
          result.collapsedText = collapsedText;
        }
        return result;
      }
      FoldingRange2.create = create;
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine) && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter)) && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter)) && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
      }
      FoldingRange2.is = is;
    })(FoldingRange || (FoldingRange = {}));
    (function (DiagnosticRelatedInformation2) {
      function create(location, message) {
        return {
          location,
          message
        };
      }
      DiagnosticRelatedInformation2.create = create;
      function is(value) {
        let candidate = value;
        return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
      }
      DiagnosticRelatedInformation2.is = is;
    })(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));
    (function (DiagnosticSeverity2) {
      DiagnosticSeverity2.Error = 1;
      DiagnosticSeverity2.Warning = 2;
      DiagnosticSeverity2.Information = 3;
      DiagnosticSeverity2.Hint = 4;
    })(DiagnosticSeverity || (DiagnosticSeverity = {}));
    (function (DiagnosticTag2) {
      DiagnosticTag2.Unnecessary = 1;
      DiagnosticTag2.Deprecated = 2;
    })(DiagnosticTag || (DiagnosticTag = {}));
    (function (CodeDescription2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.href);
      }
      CodeDescription2.is = is;
    })(CodeDescription || (CodeDescription = {}));
    (function (Diagnostic2) {
      function create(range, message, severity, code, source, relatedInformation) {
        let result = { range, message };
        if (Is.defined(severity)) {
          result.severity = severity;
        }
        if (Is.defined(code)) {
          result.code = code;
        }
        if (Is.defined(source)) {
          result.source = source;
        }
        if (Is.defined(relatedInformation)) {
          result.relatedInformation = relatedInformation;
        }
        return result;
      }
      Diagnostic2.create = create;
      function is(value) {
        var _a;
        let candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && Is.string(candidate.message) && (Is.number(candidate.severity) || Is.undefined(candidate.severity)) && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code)) && (Is.undefined(candidate.codeDescription) || Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)) && (Is.string(candidate.source) || Is.undefined(candidate.source)) && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
      }
      Diagnostic2.is = is;
    })(Diagnostic || (Diagnostic = {}));
    (function (Command2) {
      function create(title, command, ...args) {
        let result = { title, command };
        if (Is.defined(args) && args.length > 0) {
          result.arguments = args;
        }
        return result;
      }
      Command2.create = create;
      function is(value) {
        let candidate = value;
        return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
      }
      Command2.is = is;
    })(Command || (Command = {}));
    (function (TextEdit3) {
      function replace(range, newText) {
        return { range, newText };
      }
      TextEdit3.replace = replace;
      function insert(position, newText) {
        return { range: { start: position, end: position }, newText };
      }
      TextEdit3.insert = insert;
      function del(range) {
        return { range, newText: "" };
      }
      TextEdit3.del = del;
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.newText) && Range.is(candidate.range);
      }
      TextEdit3.is = is;
    })(TextEdit || (TextEdit = {}));
    (function (ChangeAnnotation2) {
      function create(label, needsConfirmation, description) {
        const result = { label };
        if (needsConfirmation !== void 0) {
          result.needsConfirmation = needsConfirmation;
        }
        if (description !== void 0) {
          result.description = description;
        }
        return result;
      }
      ChangeAnnotation2.create = create;
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
      }
      ChangeAnnotation2.is = is;
    })(ChangeAnnotation || (ChangeAnnotation = {}));
    (function (ChangeAnnotationIdentifier2) {
      function is(value) {
        const candidate = value;
        return Is.string(candidate);
      }
      ChangeAnnotationIdentifier2.is = is;
    })(ChangeAnnotationIdentifier || (ChangeAnnotationIdentifier = {}));
    (function (AnnotatedTextEdit2) {
      function replace(range, newText, annotation) {
        return { range, newText, annotationId: annotation };
      }
      AnnotatedTextEdit2.replace = replace;
      function insert(position, newText, annotation) {
        return { range: { start: position, end: position }, newText, annotationId: annotation };
      }
      AnnotatedTextEdit2.insert = insert;
      function del(range, annotation) {
        return { range, newText: "", annotationId: annotation };
      }
      AnnotatedTextEdit2.del = del;
      function is(value) {
        const candidate = value;
        return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
      }
      AnnotatedTextEdit2.is = is;
    })(AnnotatedTextEdit || (AnnotatedTextEdit = {}));
    (function (TextDocumentEdit2) {
      function create(textDocument, edits) {
        return { textDocument, edits };
      }
      TextDocumentEdit2.create = create;
      function is(value) {
        let candidate = value;
        return Is.defined(candidate) && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument) && Array.isArray(candidate.edits);
      }
      TextDocumentEdit2.is = is;
    })(TextDocumentEdit || (TextDocumentEdit = {}));
    (function (CreateFile2) {
      function create(uri, options, annotation) {
        let result = {
          kind: "create",
          uri
        };
        if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
          result.options = options;
        }
        if (annotation !== void 0) {
          result.annotationId = annotation;
        }
        return result;
      }
      CreateFile2.create = create;
      function is(value) {
        let candidate = value;
        return candidate && candidate.kind === "create" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
      }
      CreateFile2.is = is;
    })(CreateFile || (CreateFile = {}));
    (function (RenameFile2) {
      function create(oldUri, newUri, options, annotation) {
        let result = {
          kind: "rename",
          oldUri,
          newUri
        };
        if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
          result.options = options;
        }
        if (annotation !== void 0) {
          result.annotationId = annotation;
        }
        return result;
      }
      RenameFile2.create = create;
      function is(value) {
        let candidate = value;
        return candidate && candidate.kind === "rename" && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
      }
      RenameFile2.is = is;
    })(RenameFile || (RenameFile = {}));
    (function (DeleteFile2) {
      function create(uri, options, annotation) {
        let result = {
          kind: "delete",
          uri
        };
        if (options !== void 0 && (options.recursive !== void 0 || options.ignoreIfNotExists !== void 0)) {
          result.options = options;
        }
        if (annotation !== void 0) {
          result.annotationId = annotation;
        }
        return result;
      }
      DeleteFile2.create = create;
      function is(value) {
        let candidate = value;
        return candidate && candidate.kind === "delete" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.recursive === void 0 || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === void 0 || Is.boolean(candidate.options.ignoreIfNotExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
      }
      DeleteFile2.is = is;
    })(DeleteFile || (DeleteFile = {}));
    (function (WorkspaceEdit2) {
      function is(value) {
        let candidate = value;
        return candidate && (candidate.changes !== void 0 || candidate.documentChanges !== void 0) && (candidate.documentChanges === void 0 || candidate.documentChanges.every((change) => {
          if (Is.string(change.kind)) {
            return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
          } else {
            return TextDocumentEdit.is(change);
          }
        }));
      }
      WorkspaceEdit2.is = is;
    })(WorkspaceEdit || (WorkspaceEdit = {}));
    TextEditChangeImpl = class {
      constructor(edits, changeAnnotations) {
        this.edits = edits;
        this.changeAnnotations = changeAnnotations;
      }
      insert(position, newText, annotation) {
        let edit;
        let id;
        if (annotation === void 0) {
          edit = TextEdit.insert(position, newText);
        } else if (ChangeAnnotationIdentifier.is(annotation)) {
          id = annotation;
          edit = AnnotatedTextEdit.insert(position, newText, annotation);
        } else {
          this.assertChangeAnnotations(this.changeAnnotations);
          id = this.changeAnnotations.manage(annotation);
          edit = AnnotatedTextEdit.insert(position, newText, id);
        }
        this.edits.push(edit);
        if (id !== void 0) {
          return id;
        }
      }
      replace(range, newText, annotation) {
        let edit;
        let id;
        if (annotation === void 0) {
          edit = TextEdit.replace(range, newText);
        } else if (ChangeAnnotationIdentifier.is(annotation)) {
          id = annotation;
          edit = AnnotatedTextEdit.replace(range, newText, annotation);
        } else {
          this.assertChangeAnnotations(this.changeAnnotations);
          id = this.changeAnnotations.manage(annotation);
          edit = AnnotatedTextEdit.replace(range, newText, id);
        }
        this.edits.push(edit);
        if (id !== void 0) {
          return id;
        }
      }
      delete(range, annotation) {
        let edit;
        let id;
        if (annotation === void 0) {
          edit = TextEdit.del(range);
        } else if (ChangeAnnotationIdentifier.is(annotation)) {
          id = annotation;
          edit = AnnotatedTextEdit.del(range, annotation);
        } else {
          this.assertChangeAnnotations(this.changeAnnotations);
          id = this.changeAnnotations.manage(annotation);
          edit = AnnotatedTextEdit.del(range, id);
        }
        this.edits.push(edit);
        if (id !== void 0) {
          return id;
        }
      }
      add(edit) {
        this.edits.push(edit);
      }
      all() {
        return this.edits;
      }
      clear() {
        this.edits.splice(0, this.edits.length);
      }
      assertChangeAnnotations(value) {
        if (value === void 0) {
          throw new Error(`Text edit change is not configured to manage change annotations.`);
        }
      }
    };
    ChangeAnnotations = class {
      constructor(annotations) {
        this._annotations = annotations === void 0 ? /* @__PURE__ */ Object.create(null) : annotations;
        this._counter = 0;
        this._size = 0;
      }
      all() {
        return this._annotations;
      }
      get size() {
        return this._size;
      }
      manage(idOrAnnotation, annotation) {
        let id;
        if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {
          id = idOrAnnotation;
        } else {
          id = this.nextId();
          annotation = idOrAnnotation;
        }
        if (this._annotations[id] !== void 0) {
          throw new Error(`Id ${id} is already in use.`);
        }
        if (annotation === void 0) {
          throw new Error(`No annotation provided for id ${id}`);
        }
        this._annotations[id] = annotation;
        this._size++;
        return id;
      }
      nextId() {
        this._counter++;
        return this._counter.toString();
      }
    };
    WorkspaceChange = class {
      constructor(workspaceEdit) {
        this._textEditChanges = /* @__PURE__ */ Object.create(null);
        if (workspaceEdit !== void 0) {
          this._workspaceEdit = workspaceEdit;
          if (workspaceEdit.documentChanges) {
            this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);
            workspaceEdit.changeAnnotations = this._changeAnnotations.all();
            workspaceEdit.documentChanges.forEach((change) => {
              if (TextDocumentEdit.is(change)) {
                const textEditChange = new TextEditChangeImpl(change.edits, this._changeAnnotations);
                this._textEditChanges[change.textDocument.uri] = textEditChange;
              }
            });
          } else if (workspaceEdit.changes) {
            Object.keys(workspaceEdit.changes).forEach((key) => {
              const textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
              this._textEditChanges[key] = textEditChange;
            });
          }
        } else {
          this._workspaceEdit = {};
        }
      }
      /**
       * Returns the underlying {@link WorkspaceEdit} literal
       * use to be returned from a workspace edit operation like rename.
       */
      get edit() {
        this.initDocumentChanges();
        if (this._changeAnnotations !== void 0) {
          if (this._changeAnnotations.size === 0) {
            this._workspaceEdit.changeAnnotations = void 0;
          } else {
            this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
          }
        }
        return this._workspaceEdit;
      }
      getTextEditChange(key) {
        if (OptionalVersionedTextDocumentIdentifier.is(key)) {
          this.initDocumentChanges();
          if (this._workspaceEdit.documentChanges === void 0) {
            throw new Error("Workspace edit is not configured for document changes.");
          }
          const textDocument = { uri: key.uri, version: key.version };
          let result = this._textEditChanges[textDocument.uri];
          if (!result) {
            const edits = [];
            const textDocumentEdit = {
              textDocument,
              edits
            };
            this._workspaceEdit.documentChanges.push(textDocumentEdit);
            result = new TextEditChangeImpl(edits, this._changeAnnotations);
            this._textEditChanges[textDocument.uri] = result;
          }
          return result;
        } else {
          this.initChanges();
          if (this._workspaceEdit.changes === void 0) {
            throw new Error("Workspace edit is not configured for normal text edit changes.");
          }
          let result = this._textEditChanges[key];
          if (!result) {
            let edits = [];
            this._workspaceEdit.changes[key] = edits;
            result = new TextEditChangeImpl(edits);
            this._textEditChanges[key] = result;
          }
          return result;
        }
      }
      initDocumentChanges() {
        if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
          this._changeAnnotations = new ChangeAnnotations();
          this._workspaceEdit.documentChanges = [];
          this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
        }
      }
      initChanges() {
        if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
          this._workspaceEdit.changes = /* @__PURE__ */ Object.create(null);
        }
      }
      createFile(uri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === void 0) {
          throw new Error("Workspace edit is not configured for document changes.");
        }
        let annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
          annotation = optionsOrAnnotation;
        } else {
          options = optionsOrAnnotation;
        }
        let operation;
        let id;
        if (annotation === void 0) {
          operation = CreateFile.create(uri, options);
        } else {
          id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
          operation = CreateFile.create(uri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== void 0) {
          return id;
        }
      }
      renameFile(oldUri, newUri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === void 0) {
          throw new Error("Workspace edit is not configured for document changes.");
        }
        let annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
          annotation = optionsOrAnnotation;
        } else {
          options = optionsOrAnnotation;
        }
        let operation;
        let id;
        if (annotation === void 0) {
          operation = RenameFile.create(oldUri, newUri, options);
        } else {
          id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
          operation = RenameFile.create(oldUri, newUri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== void 0) {
          return id;
        }
      }
      deleteFile(uri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === void 0) {
          throw new Error("Workspace edit is not configured for document changes.");
        }
        let annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
          annotation = optionsOrAnnotation;
        } else {
          options = optionsOrAnnotation;
        }
        let operation;
        let id;
        if (annotation === void 0) {
          operation = DeleteFile.create(uri, options);
        } else {
          id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
          operation = DeleteFile.create(uri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== void 0) {
          return id;
        }
      }
    };
    (function (TextDocumentIdentifier3) {
      function create(uri) {
        return { uri };
      }
      TextDocumentIdentifier3.create = create;
      function is(value) {
        let candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri);
      }
      TextDocumentIdentifier3.is = is;
    })(TextDocumentIdentifier || (TextDocumentIdentifier = {}));
    (function (VersionedTextDocumentIdentifier2) {
      function create(uri, version) {
        return { uri, version };
      }
      VersionedTextDocumentIdentifier2.create = create;
      function is(value) {
        let candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);
      }
      VersionedTextDocumentIdentifier2.is = is;
    })(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));
    (function (OptionalVersionedTextDocumentIdentifier2) {
      function create(uri, version) {
        return { uri, version };
      }
      OptionalVersionedTextDocumentIdentifier2.create = create;
      function is(value) {
        let candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));
      }
      OptionalVersionedTextDocumentIdentifier2.is = is;
    })(OptionalVersionedTextDocumentIdentifier || (OptionalVersionedTextDocumentIdentifier = {}));
    (function (TextDocumentItem2) {
      function create(uri, languageId, version, text) {
        return { uri, languageId, version, text };
      }
      TextDocumentItem2.create = create;
      function is(value) {
        let candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);
      }
      TextDocumentItem2.is = is;
    })(TextDocumentItem || (TextDocumentItem = {}));
    (function (MarkupKind2) {
      MarkupKind2.PlainText = "plaintext";
      MarkupKind2.Markdown = "markdown";
      function is(value) {
        const candidate = value;
        return candidate === MarkupKind2.PlainText || candidate === MarkupKind2.Markdown;
      }
      MarkupKind2.is = is;
    })(MarkupKind || (MarkupKind = {}));
    (function (MarkupContent2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
      }
      MarkupContent2.is = is;
    })(MarkupContent || (MarkupContent = {}));
    (function (CompletionItemKind3) {
      CompletionItemKind3.Text = 1;
      CompletionItemKind3.Method = 2;
      CompletionItemKind3.Function = 3;
      CompletionItemKind3.Constructor = 4;
      CompletionItemKind3.Field = 5;
      CompletionItemKind3.Variable = 6;
      CompletionItemKind3.Class = 7;
      CompletionItemKind3.Interface = 8;
      CompletionItemKind3.Module = 9;
      CompletionItemKind3.Property = 10;
      CompletionItemKind3.Unit = 11;
      CompletionItemKind3.Value = 12;
      CompletionItemKind3.Enum = 13;
      CompletionItemKind3.Keyword = 14;
      CompletionItemKind3.Snippet = 15;
      CompletionItemKind3.Color = 16;
      CompletionItemKind3.File = 17;
      CompletionItemKind3.Reference = 18;
      CompletionItemKind3.Folder = 19;
      CompletionItemKind3.EnumMember = 20;
      CompletionItemKind3.Constant = 21;
      CompletionItemKind3.Struct = 22;
      CompletionItemKind3.Event = 23;
      CompletionItemKind3.Operator = 24;
      CompletionItemKind3.TypeParameter = 25;
    })(CompletionItemKind || (CompletionItemKind = {}));
    (function (InsertTextFormat2) {
      InsertTextFormat2.PlainText = 1;
      InsertTextFormat2.Snippet = 2;
    })(InsertTextFormat || (InsertTextFormat = {}));
    (function (CompletionItemTag2) {
      CompletionItemTag2.Deprecated = 1;
    })(CompletionItemTag || (CompletionItemTag = {}));
    (function (InsertReplaceEdit2) {
      function create(newText, insert, replace) {
        return { newText, insert, replace };
      }
      InsertReplaceEdit2.create = create;
      function is(value) {
        const candidate = value;
        return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);
      }
      InsertReplaceEdit2.is = is;
    })(InsertReplaceEdit || (InsertReplaceEdit = {}));
    (function (InsertTextMode2) {
      InsertTextMode2.asIs = 1;
      InsertTextMode2.adjustIndentation = 2;
    })(InsertTextMode || (InsertTextMode = {}));
    (function (CompletionItemLabelDetails2) {
      function is(value) {
        const candidate = value;
        return candidate && (Is.string(candidate.detail) || candidate.detail === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
      }
      CompletionItemLabelDetails2.is = is;
    })(CompletionItemLabelDetails || (CompletionItemLabelDetails = {}));
    (function (CompletionItem3) {
      function create(label) {
        return { label };
      }
      CompletionItem3.create = create;
    })(CompletionItem || (CompletionItem = {}));
    (function (CompletionList2) {
      function create(items, isIncomplete) {
        return { items: items ? items : [], isIncomplete: !!isIncomplete };
      }
      CompletionList2.create = create;
    })(CompletionList || (CompletionList = {}));
    (function (MarkedString2) {
      function fromPlainText(plainText) {
        return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&");
      }
      MarkedString2.fromPlainText = fromPlainText;
      function is(value) {
        const candidate = value;
        return Is.string(candidate) || Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value);
      }
      MarkedString2.is = is;
    })(MarkedString || (MarkedString = {}));
    (function (Hover2) {
      function is(value) {
        let candidate = value;
        return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) || MarkedString.is(candidate.contents) || Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === void 0 || Range.is(value.range));
      }
      Hover2.is = is;
    })(Hover || (Hover = {}));
    (function (ParameterInformation2) {
      function create(label, documentation) {
        return documentation ? { label, documentation } : { label };
      }
      ParameterInformation2.create = create;
    })(ParameterInformation || (ParameterInformation = {}));
    (function (SignatureInformation2) {
      function create(label, documentation, ...parameters) {
        let result = { label };
        if (Is.defined(documentation)) {
          result.documentation = documentation;
        }
        if (Is.defined(parameters)) {
          result.parameters = parameters;
        } else {
          result.parameters = [];
        }
        return result;
      }
      SignatureInformation2.create = create;
    })(SignatureInformation || (SignatureInformation = {}));
    (function (DocumentHighlightKind2) {
      DocumentHighlightKind2.Text = 1;
      DocumentHighlightKind2.Read = 2;
      DocumentHighlightKind2.Write = 3;
    })(DocumentHighlightKind || (DocumentHighlightKind = {}));
    (function (DocumentHighlight2) {
      function create(range, kind) {
        let result = { range };
        if (Is.number(kind)) {
          result.kind = kind;
        }
        return result;
      }
      DocumentHighlight2.create = create;
    })(DocumentHighlight || (DocumentHighlight = {}));
    (function (SymbolKind2) {
      SymbolKind2.File = 1;
      SymbolKind2.Module = 2;
      SymbolKind2.Namespace = 3;
      SymbolKind2.Package = 4;
      SymbolKind2.Class = 5;
      SymbolKind2.Method = 6;
      SymbolKind2.Property = 7;
      SymbolKind2.Field = 8;
      SymbolKind2.Constructor = 9;
      SymbolKind2.Enum = 10;
      SymbolKind2.Interface = 11;
      SymbolKind2.Function = 12;
      SymbolKind2.Variable = 13;
      SymbolKind2.Constant = 14;
      SymbolKind2.String = 15;
      SymbolKind2.Number = 16;
      SymbolKind2.Boolean = 17;
      SymbolKind2.Array = 18;
      SymbolKind2.Object = 19;
      SymbolKind2.Key = 20;
      SymbolKind2.Null = 21;
      SymbolKind2.EnumMember = 22;
      SymbolKind2.Struct = 23;
      SymbolKind2.Event = 24;
      SymbolKind2.Operator = 25;
      SymbolKind2.TypeParameter = 26;
    })(SymbolKind || (SymbolKind = {}));
    (function (SymbolTag2) {
      SymbolTag2.Deprecated = 1;
    })(SymbolTag || (SymbolTag = {}));
    (function (SymbolInformation2) {
      function create(name, kind, range, uri, containerName) {
        let result = {
          name,
          kind,
          location: { uri, range }
        };
        if (containerName) {
          result.containerName = containerName;
        }
        return result;
      }
      SymbolInformation2.create = create;
    })(SymbolInformation || (SymbolInformation = {}));
    (function (WorkspaceSymbol2) {
      function create(name, kind, uri, range) {
        return range !== void 0 ? { name, kind, location: { uri, range } } : { name, kind, location: { uri } };
      }
      WorkspaceSymbol2.create = create;
    })(WorkspaceSymbol || (WorkspaceSymbol = {}));
    (function (DocumentSymbol2) {
      function create(name, detail, kind, range, selectionRange, children) {
        let result = {
          name,
          detail,
          kind,
          range,
          selectionRange
        };
        if (children !== void 0) {
          result.children = children;
        }
        return result;
      }
      DocumentSymbol2.create = create;
      function is(value) {
        let candidate = value;
        return candidate && Is.string(candidate.name) && Is.number(candidate.kind) && Range.is(candidate.range) && Range.is(candidate.selectionRange) && (candidate.detail === void 0 || Is.string(candidate.detail)) && (candidate.deprecated === void 0 || Is.boolean(candidate.deprecated)) && (candidate.children === void 0 || Array.isArray(candidate.children)) && (candidate.tags === void 0 || Array.isArray(candidate.tags));
      }
      DocumentSymbol2.is = is;
    })(DocumentSymbol || (DocumentSymbol = {}));
    (function (CodeActionKind2) {
      CodeActionKind2.Empty = "";
      CodeActionKind2.QuickFix = "quickfix";
      CodeActionKind2.Refactor = "refactor";
      CodeActionKind2.RefactorExtract = "refactor.extract";
      CodeActionKind2.RefactorInline = "refactor.inline";
      CodeActionKind2.RefactorRewrite = "refactor.rewrite";
      CodeActionKind2.Source = "source";
      CodeActionKind2.SourceOrganizeImports = "source.organizeImports";
      CodeActionKind2.SourceFixAll = "source.fixAll";
    })(CodeActionKind || (CodeActionKind = {}));
    (function (CodeActionTriggerKind2) {
      CodeActionTriggerKind2.Invoked = 1;
      CodeActionTriggerKind2.Automatic = 2;
    })(CodeActionTriggerKind || (CodeActionTriggerKind = {}));
    (function (CodeActionContext2) {
      function create(diagnostics, only, triggerKind) {
        let result = { diagnostics };
        if (only !== void 0 && only !== null) {
          result.only = only;
        }
        if (triggerKind !== void 0 && triggerKind !== null) {
          result.triggerKind = triggerKind;
        }
        return result;
      }
      CodeActionContext2.create = create;
      function is(value) {
        let candidate = value;
        return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === void 0 || Is.typedArray(candidate.only, Is.string)) && (candidate.triggerKind === void 0 || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);
      }
      CodeActionContext2.is = is;
    })(CodeActionContext || (CodeActionContext = {}));
    (function (CodeAction2) {
      function create(title, kindOrCommandOrEdit, kind) {
        let result = { title };
        let checkKind = true;
        if (typeof kindOrCommandOrEdit === "string") {
          checkKind = false;
          result.kind = kindOrCommandOrEdit;
        } else if (Command.is(kindOrCommandOrEdit)) {
          result.command = kindOrCommandOrEdit;
        } else {
          result.edit = kindOrCommandOrEdit;
        }
        if (checkKind && kind !== void 0) {
          result.kind = kind;
        }
        return result;
      }
      CodeAction2.create = create;
      function is(value) {
        let candidate = value;
        return candidate && Is.string(candidate.title) && (candidate.diagnostics === void 0 || Is.typedArray(candidate.diagnostics, Diagnostic.is)) && (candidate.kind === void 0 || Is.string(candidate.kind)) && (candidate.edit !== void 0 || candidate.command !== void 0) && (candidate.command === void 0 || Command.is(candidate.command)) && (candidate.isPreferred === void 0 || Is.boolean(candidate.isPreferred)) && (candidate.edit === void 0 || WorkspaceEdit.is(candidate.edit));
      }
      CodeAction2.is = is;
    })(CodeAction || (CodeAction = {}));
    (function (CodeLens2) {
      function create(range, data) {
        let result = { range };
        if (Is.defined(data)) {
          result.data = data;
        }
        return result;
      }
      CodeLens2.create = create;
      function is(value) {
        let candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));
      }
      CodeLens2.is = is;
    })(CodeLens || (CodeLens = {}));
    (function (FormattingOptions2) {
      function create(tabSize, insertSpaces) {
        return { tabSize, insertSpaces };
      }
      FormattingOptions2.create = create;
      function is(value) {
        let candidate = value;
        return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
      }
      FormattingOptions2.is = is;
    })(FormattingOptions || (FormattingOptions = {}));
    (function (DocumentLink2) {
      function create(range, target, data) {
        return { range, target, data };
      }
      DocumentLink2.create = create;
      function is(value) {
        let candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
      }
      DocumentLink2.is = is;
    })(DocumentLink || (DocumentLink = {}));
    (function (SelectionRange2) {
      function create(range, parent) {
        return { range, parent };
      }
      SelectionRange2.create = create;
      function is(value) {
        let candidate = value;
        return Is.objectLiteral(candidate) && Range.is(candidate.range) && (candidate.parent === void 0 || SelectionRange2.is(candidate.parent));
      }
      SelectionRange2.is = is;
    })(SelectionRange || (SelectionRange = {}));
    (function (SemanticTokenTypes2) {
      SemanticTokenTypes2["namespace"] = "namespace";
      SemanticTokenTypes2["type"] = "type";
      SemanticTokenTypes2["class"] = "class";
      SemanticTokenTypes2["enum"] = "enum";
      SemanticTokenTypes2["interface"] = "interface";
      SemanticTokenTypes2["struct"] = "struct";
      SemanticTokenTypes2["typeParameter"] = "typeParameter";
      SemanticTokenTypes2["parameter"] = "parameter";
      SemanticTokenTypes2["variable"] = "variable";
      SemanticTokenTypes2["property"] = "property";
      SemanticTokenTypes2["enumMember"] = "enumMember";
      SemanticTokenTypes2["event"] = "event";
      SemanticTokenTypes2["function"] = "function";
      SemanticTokenTypes2["method"] = "method";
      SemanticTokenTypes2["macro"] = "macro";
      SemanticTokenTypes2["keyword"] = "keyword";
      SemanticTokenTypes2["modifier"] = "modifier";
      SemanticTokenTypes2["comment"] = "comment";
      SemanticTokenTypes2["string"] = "string";
      SemanticTokenTypes2["number"] = "number";
      SemanticTokenTypes2["regexp"] = "regexp";
      SemanticTokenTypes2["operator"] = "operator";
      SemanticTokenTypes2["decorator"] = "decorator";
    })(SemanticTokenTypes || (SemanticTokenTypes = {}));
    (function (SemanticTokenModifiers2) {
      SemanticTokenModifiers2["declaration"] = "declaration";
      SemanticTokenModifiers2["definition"] = "definition";
      SemanticTokenModifiers2["readonly"] = "readonly";
      SemanticTokenModifiers2["static"] = "static";
      SemanticTokenModifiers2["deprecated"] = "deprecated";
      SemanticTokenModifiers2["abstract"] = "abstract";
      SemanticTokenModifiers2["async"] = "async";
      SemanticTokenModifiers2["modification"] = "modification";
      SemanticTokenModifiers2["documentation"] = "documentation";
      SemanticTokenModifiers2["defaultLibrary"] = "defaultLibrary";
    })(SemanticTokenModifiers || (SemanticTokenModifiers = {}));
    (function (SemanticTokens2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (candidate.resultId === void 0 || typeof candidate.resultId === "string") && Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === "number");
      }
      SemanticTokens2.is = is;
    })(SemanticTokens || (SemanticTokens = {}));
    (function (InlineValueText2) {
      function create(range, text) {
        return { range, text };
      }
      InlineValueText2.create = create;
      function is(value) {
        const candidate = value;
        return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && Is.string(candidate.text);
      }
      InlineValueText2.is = is;
    })(InlineValueText || (InlineValueText = {}));
    (function (InlineValueVariableLookup2) {
      function create(range, variableName, caseSensitiveLookup) {
        return { range, variableName, caseSensitiveLookup };
      }
      InlineValueVariableLookup2.create = create;
      function is(value) {
        const candidate = value;
        return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup) && (Is.string(candidate.variableName) || candidate.variableName === void 0);
      }
      InlineValueVariableLookup2.is = is;
    })(InlineValueVariableLookup || (InlineValueVariableLookup = {}));
    (function (InlineValueEvaluatableExpression2) {
      function create(range, expression) {
        return { range, expression };
      }
      InlineValueEvaluatableExpression2.create = create;
      function is(value) {
        const candidate = value;
        return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && (Is.string(candidate.expression) || candidate.expression === void 0);
      }
      InlineValueEvaluatableExpression2.is = is;
    })(InlineValueEvaluatableExpression || (InlineValueEvaluatableExpression = {}));
    (function (InlineValueContext2) {
      function create(frameId, stoppedLocation) {
        return { frameId, stoppedLocation };
      }
      InlineValueContext2.create = create;
      function is(value) {
        const candidate = value;
        return Is.defined(candidate) && Range.is(value.stoppedLocation);
      }
      InlineValueContext2.is = is;
    })(InlineValueContext || (InlineValueContext = {}));
    (function (InlayHintKind2) {
      InlayHintKind2.Type = 1;
      InlayHintKind2.Parameter = 2;
      function is(value) {
        return value === 1 || value === 2;
      }
      InlayHintKind2.is = is;
    })(InlayHintKind || (InlayHintKind = {}));
    (function (InlayHintLabelPart2) {
      function create(value) {
        return { value };
      }
      InlayHintLabelPart2.create = create;
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (candidate.tooltip === void 0 || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.location === void 0 || Location.is(candidate.location)) && (candidate.command === void 0 || Command.is(candidate.command));
      }
      InlayHintLabelPart2.is = is;
    })(InlayHintLabelPart || (InlayHintLabelPart = {}));
    (function (InlayHint2) {
      function create(position, label, kind) {
        const result = { position, label };
        if (kind !== void 0) {
          result.kind = kind;
        }
        return result;
      }
      InlayHint2.create = create;
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && Position.is(candidate.position) && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is)) && (candidate.kind === void 0 || InlayHintKind.is(candidate.kind)) && candidate.textEdits === void 0 || Is.typedArray(candidate.textEdits, TextEdit.is) && (candidate.tooltip === void 0 || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.paddingLeft === void 0 || Is.boolean(candidate.paddingLeft)) && (candidate.paddingRight === void 0 || Is.boolean(candidate.paddingRight));
      }
      InlayHint2.is = is;
    })(InlayHint || (InlayHint = {}));
    (function (StringValue2) {
      function createSnippet(value) {
        return { kind: "snippet", value };
      }
      StringValue2.createSnippet = createSnippet;
    })(StringValue || (StringValue = {}));
    (function (InlineCompletionItem2) {
      function create(insertText, filterText, range, command) {
        return { insertText, filterText, range, command };
      }
      InlineCompletionItem2.create = create;
    })(InlineCompletionItem || (InlineCompletionItem = {}));
    (function (InlineCompletionList2) {
      function create(items) {
        return { items };
      }
      InlineCompletionList2.create = create;
    })(InlineCompletionList || (InlineCompletionList = {}));
    (function (InlineCompletionTriggerKind2) {
      InlineCompletionTriggerKind2.Invoked = 0;
      InlineCompletionTriggerKind2.Automatic = 1;
    })(InlineCompletionTriggerKind || (InlineCompletionTriggerKind = {}));
    (function (SelectedCompletionInfo2) {
      function create(range, text) {
        return { range, text };
      }
      SelectedCompletionInfo2.create = create;
    })(SelectedCompletionInfo || (SelectedCompletionInfo = {}));
    (function (InlineCompletionContext2) {
      function create(triggerKind, selectedCompletionInfo) {
        return { triggerKind, selectedCompletionInfo };
      }
      InlineCompletionContext2.create = create;
    })(InlineCompletionContext || (InlineCompletionContext = {}));
    (function (WorkspaceFolder2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && URI.is(candidate.uri) && Is.string(candidate.name);
      }
      WorkspaceFolder2.is = is;
    })(WorkspaceFolder || (WorkspaceFolder = {}));
    EOL = ["\n", "\r\n", "\r"];
    (function (TextDocument3) {
      function create(uri, languageId, version, content) {
        return new FullTextDocument(uri, languageId, version, content);
      }
      TextDocument3.create = create;
      function is(value) {
        let candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount) && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
      }
      TextDocument3.is = is;
      function applyEdits(document2, edits) {
        let text = document2.getText();
        let sortedEdits = mergeSort2(edits, (a, b) => {
          let diff = a.range.start.line - b.range.start.line;
          if (diff === 0) {
            return a.range.start.character - b.range.start.character;
          }
          return diff;
        });
        let lastModifiedOffset = text.length;
        for (let i = sortedEdits.length - 1; i >= 0; i--) {
          let e = sortedEdits[i];
          let startOffset = document2.offsetAt(e.range.start);
          let endOffset = document2.offsetAt(e.range.end);
          if (endOffset <= lastModifiedOffset) {
            text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
          } else {
            throw new Error("Overlapping edit");
          }
          lastModifiedOffset = startOffset;
        }
        return text;
      }
      TextDocument3.applyEdits = applyEdits;
      function mergeSort2(data, compare) {
        if (data.length <= 1) {
          return data;
        }
        const p = data.length / 2 | 0;
        const left = data.slice(0, p);
        const right = data.slice(p);
        mergeSort2(left, compare);
        mergeSort2(right, compare);
        let leftIdx = 0;
        let rightIdx = 0;
        let i = 0;
        while (leftIdx < left.length && rightIdx < right.length) {
          let ret = compare(left[leftIdx], right[rightIdx]);
          if (ret <= 0) {
            data[i++] = left[leftIdx++];
          } else {
            data[i++] = right[rightIdx++];
          }
        }
        while (leftIdx < left.length) {
          data[i++] = left[leftIdx++];
        }
        while (rightIdx < right.length) {
          data[i++] = right[rightIdx++];
        }
        return data;
      }
    })(TextDocument || (TextDocument = {}));
    FullTextDocument = class {
      constructor(uri, languageId, version, content) {
        this._uri = uri;
        this._languageId = languageId;
        this._version = version;
        this._content = content;
        this._lineOffsets = void 0;
      }
      get uri() {
        return this._uri;
      }
      get languageId() {
        return this._languageId;
      }
      get version() {
        return this._version;
      }
      getText(range) {
        if (range) {
          let start = this.offsetAt(range.start);
          let end = this.offsetAt(range.end);
          return this._content.substring(start, end);
        }
        return this._content;
      }
      update(event, version) {
        this._content = event.text;
        this._version = version;
        this._lineOffsets = void 0;
      }
      getLineOffsets() {
        if (this._lineOffsets === void 0) {
          let lineOffsets = [];
          let text = this._content;
          let isLineStart = true;
          for (let i = 0; i < text.length; i++) {
            if (isLineStart) {
              lineOffsets.push(i);
              isLineStart = false;
            }
            let ch = text.charAt(i);
            isLineStart = ch === "\r" || ch === "\n";
            if (ch === "\r" && i + 1 < text.length && text.charAt(i + 1) === "\n") {
              i++;
            }
          }
          if (isLineStart && text.length > 0) {
            lineOffsets.push(text.length);
          }
          this._lineOffsets = lineOffsets;
        }
        return this._lineOffsets;
      }
      positionAt(offset) {
        offset = Math.max(Math.min(offset, this._content.length), 0);
        let lineOffsets = this.getLineOffsets();
        let low = 0, high = lineOffsets.length;
        if (high === 0) {
          return Position.create(0, offset);
        }
        while (low < high) {
          let mid = Math.floor((low + high) / 2);
          if (lineOffsets[mid] > offset) {
            high = mid;
          } else {
            low = mid + 1;
          }
        }
        let line = low - 1;
        return Position.create(line, offset - lineOffsets[line]);
      }
      offsetAt(position) {
        let lineOffsets = this.getLineOffsets();
        if (position.line >= lineOffsets.length) {
          return this._content.length;
        } else if (position.line < 0) {
          return 0;
        }
        let lineOffset = lineOffsets[position.line];
        let nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
      }
      get lineCount() {
        return this.getLineOffsets().length;
      }
    };
    (function (Is2) {
      const toString3 = Object.prototype.toString;
      function defined(value) {
        return typeof value !== "undefined";
      }
      Is2.defined = defined;
      function undefined2(value) {
        return typeof value === "undefined";
      }
      Is2.undefined = undefined2;
      function boolean(value) {
        return value === true || value === false;
      }
      Is2.boolean = boolean;
      function string(value) {
        return toString3.call(value) === "[object String]";
      }
      Is2.string = string;
      function number(value) {
        return toString3.call(value) === "[object Number]";
      }
      Is2.number = number;
      function numberRange(value, min, max) {
        return toString3.call(value) === "[object Number]" && min <= value && value <= max;
      }
      Is2.numberRange = numberRange;
      function integer2(value) {
        return toString3.call(value) === "[object Number]" && -2147483648 <= value && value <= 2147483647;
      }
      Is2.integer = integer2;
      function uinteger2(value) {
        return toString3.call(value) === "[object Number]" && 0 <= value && value <= 2147483647;
      }
      Is2.uinteger = uinteger2;
      function func(value) {
        return toString3.call(value) === "[object Function]";
      }
      Is2.func = func;
      function objectLiteral(value) {
        return value !== null && typeof value === "object";
      }
      Is2.objectLiteral = objectLiteral;
      function typedArray(value, check) {
        return Array.isArray(value) && value.every(check);
      }
      Is2.typedArray = typedArray;
    })(Is || (Is = {}));
  }
});

// server/node_modules/vscode-languageserver-protocol/lib/common/messages.js
var require_messages2 = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/lib/common/messages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProtocolNotificationType = exports.ProtocolNotificationType0 = exports.ProtocolRequestType = exports.ProtocolRequestType0 = exports.RegistrationType = exports.MessageDirection = void 0;
    var vscode_jsonrpc_1 = require_main();
    var MessageDirection;
    (function (MessageDirection2) {
      MessageDirection2["clientToServer"] = "clientToServer";
      MessageDirection2["serverToClient"] = "serverToClient";
      MessageDirection2["both"] = "both";
    })(MessageDirection || (exports.MessageDirection = MessageDirection = {}));
    var RegistrationType = class {
      constructor(method) {
        this.method = method;
      }
    };
    exports.RegistrationType = RegistrationType;
    var ProtocolRequestType0 = class extends vscode_jsonrpc_1.RequestType0 {
      constructor(method) {
        super(method);
      }
    };
    exports.ProtocolRequestType0 = ProtocolRequestType0;
    var ProtocolRequestType = class extends vscode_jsonrpc_1.RequestType {
      constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
      }
    };
    exports.ProtocolRequestType = ProtocolRequestType;
    var ProtocolNotificationType0 = class extends vscode_jsonrpc_1.NotificationType0 {
      constructor(method) {
        super(method);
      }
    };
    exports.ProtocolNotificationType0 = ProtocolNotificationType0;
    var ProtocolNotificationType = class extends vscode_jsonrpc_1.NotificationType {
      constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
      }
    };
    exports.ProtocolNotificationType = ProtocolNotificationType;
  }
});

// server/node_modules/vscode-languageserver-protocol/lib/common/utils/is.js
var require_is2 = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/lib/common/utils/is.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.objectLiteral = exports.typedArray = exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;
    function boolean(value) {
      return value === true || value === false;
    }
    exports.boolean = boolean;
    function string(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports.string = string;
    function number(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports.number = number;
    function error(value) {
      return value instanceof Error;
    }
    exports.error = error;
    function func(value) {
      return typeof value === "function";
    }
    exports.func = func;
    function array(value) {
      return Array.isArray(value);
    }
    exports.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string(elem));
    }
    exports.stringArray = stringArray;
    function typedArray(value, check) {
      return Array.isArray(value) && value.every(check);
    }
    exports.typedArray = typedArray;
    function objectLiteral(value) {
      return value !== null && typeof value === "object";
    }
    exports.objectLiteral = objectLiteral;
  }
});

// server/node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js
var require_protocol_implementation = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ImplementationRequest = void 0;
    var messages_1 = require_messages2();
    var ImplementationRequest;
    (function (ImplementationRequest2) {
      ImplementationRequest2.method = "textDocument/implementation";
      ImplementationRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ImplementationRequest2.type = new messages_1.ProtocolRequestType(ImplementationRequest2.method);
    })(ImplementationRequest || (exports.ImplementationRequest = ImplementationRequest = {}));
  }
});

// server/node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js
var require_protocol_typeDefinition = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TypeDefinitionRequest = void 0;
    var messages_1 = require_messages2();
    var TypeDefinitionRequest;
    (function (TypeDefinitionRequest2) {
      TypeDefinitionRequest2.method = "textDocument/typeDefinition";
      TypeDefinitionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeDefinitionRequest2.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest2.method);
    })(TypeDefinitionRequest || (exports.TypeDefinitionRequest = TypeDefinitionRequest = {}));
  }
});

// server/node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolder.js
var require_protocol_workspaceFolder = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DidChangeWorkspaceFoldersNotification = exports.WorkspaceFoldersRequest = void 0;
    var messages_1 = require_messages2();
    var WorkspaceFoldersRequest;
    (function (WorkspaceFoldersRequest2) {
      WorkspaceFoldersRequest2.method = "workspace/workspaceFolders";
      WorkspaceFoldersRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      WorkspaceFoldersRequest2.type = new messages_1.ProtocolRequestType0(WorkspaceFoldersRequest2.method);
    })(WorkspaceFoldersRequest || (exports.WorkspaceFoldersRequest = WorkspaceFoldersRequest = {}));
    var DidChangeWorkspaceFoldersNotification;
    (function (DidChangeWorkspaceFoldersNotification2) {
      DidChangeWorkspaceFoldersNotification2.method = "workspace/didChangeWorkspaceFolders";
      DidChangeWorkspaceFoldersNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeWorkspaceFoldersNotification2.type = new messages_1.ProtocolNotificationType(DidChangeWorkspaceFoldersNotification2.method);
    })(DidChangeWorkspaceFoldersNotification || (exports.DidChangeWorkspaceFoldersNotification = DidChangeWorkspaceFoldersNotification = {}));
  }
});

// server/node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js
var require_protocol_configuration = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConfigurationRequest = void 0;
    var messages_1 = require_messages2();
    var ConfigurationRequest;
    (function (ConfigurationRequest2) {
      ConfigurationRequest2.method = "workspace/configuration";
      ConfigurationRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      ConfigurationRequest2.type = new messages_1.ProtocolRequestType(ConfigurationRequest2.method);
    })(ConfigurationRequest || (exports.ConfigurationRequest = ConfigurationRequest = {}));
  }
});

// server/node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js
var require_protocol_colorProvider = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ColorPresentationRequest = exports.DocumentColorRequest = void 0;
    var messages_1 = require_messages2();
    var DocumentColorRequest;
    (function (DocumentColorRequest2) {
      DocumentColorRequest2.method = "textDocument/documentColor";
      DocumentColorRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentColorRequest2.type = new messages_1.ProtocolRequestType(DocumentColorRequest2.method);
    })(DocumentColorRequest || (exports.DocumentColorRequest = DocumentColorRequest = {}));
    var ColorPresentationRequest;
    (function (ColorPresentationRequest2) {
      ColorPresentationRequest2.method = "textDocument/colorPresentation";
      ColorPresentationRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ColorPresentationRequest2.type = new messages_1.ProtocolRequestType(ColorPresentationRequest2.method);
    })(ColorPresentationRequest || (exports.ColorPresentationRequest = ColorPresentationRequest = {}));
  }
});

// server/node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js
var require_protocol_foldingRange = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FoldingRangeRefreshRequest = exports.FoldingRangeRequest = void 0;
    var messages_1 = require_messages2();
    var FoldingRangeRequest;
    (function (FoldingRangeRequest2) {
      FoldingRangeRequest2.method = "textDocument/foldingRange";
      FoldingRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      FoldingRangeRequest2.type = new messages_1.ProtocolRequestType(FoldingRangeRequest2.method);
    })(FoldingRangeRequest || (exports.FoldingRangeRequest = FoldingRangeRequest = {}));
    var FoldingRangeRefreshRequest;
    (function (FoldingRangeRefreshRequest2) {
      FoldingRangeRefreshRequest2.method = `workspace/foldingRange/refresh`;
      FoldingRangeRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      FoldingRangeRefreshRequest2.type = new messages_1.ProtocolRequestType0(FoldingRangeRefreshRequest2.method);
    })(FoldingRangeRefreshRequest || (exports.FoldingRangeRefreshRequest = FoldingRangeRefreshRequest = {}));
  }
});

// server/node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js
var require_protocol_declaration = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DeclarationRequest = void 0;
    var messages_1 = require_messages2();
    var DeclarationRequest;
    (function (DeclarationRequest2) {
      DeclarationRequest2.method = "textDocument/declaration";
      DeclarationRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DeclarationRequest2.type = new messages_1.ProtocolRequestType(DeclarationRequest2.method);
    })(DeclarationRequest || (exports.DeclarationRequest = DeclarationRequest = {}));
  }
});

// server/node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js
var require_protocol_selectionRange = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SelectionRangeRequest = void 0;
    var messages_1 = require_messages2();
    var SelectionRangeRequest;
    (function (SelectionRangeRequest2) {
      SelectionRangeRequest2.method = "textDocument/selectionRange";
      SelectionRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SelectionRangeRequest2.type = new messages_1.ProtocolRequestType(SelectionRangeRequest2.method);
    })(SelectionRangeRequest || (exports.SelectionRangeRequest = SelectionRangeRequest = {}));
  }
});

// server/node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js
var require_protocol_progress = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WorkDoneProgressCancelNotification = exports.WorkDoneProgressCreateRequest = exports.WorkDoneProgress = void 0;
    var vscode_jsonrpc_1 = require_main();
    var messages_1 = require_messages2();
    var WorkDoneProgress;
    (function (WorkDoneProgress2) {
      WorkDoneProgress2.type = new vscode_jsonrpc_1.ProgressType();
      function is(value) {
        return value === WorkDoneProgress2.type;
      }
      WorkDoneProgress2.is = is;
    })(WorkDoneProgress || (exports.WorkDoneProgress = WorkDoneProgress = {}));
    var WorkDoneProgressCreateRequest;
    (function (WorkDoneProgressCreateRequest2) {
      WorkDoneProgressCreateRequest2.method = "window/workDoneProgress/create";
      WorkDoneProgressCreateRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      WorkDoneProgressCreateRequest2.type = new messages_1.ProtocolRequestType(WorkDoneProgressCreateRequest2.method);
    })(WorkDoneProgressCreateRequest || (exports.WorkDoneProgressCreateRequest = WorkDoneProgressCreateRequest = {}));
    var WorkDoneProgressCancelNotification;
    (function (WorkDoneProgressCancelNotification2) {
      WorkDoneProgressCancelNotification2.method = "window/workDoneProgress/cancel";
      WorkDoneProgressCancelNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkDoneProgressCancelNotification2.type = new messages_1.ProtocolNotificationType(WorkDoneProgressCancelNotification2.method);
    })(WorkDoneProgressCancelNotification || (exports.WorkDoneProgressCancelNotification = WorkDoneProgressCancelNotification = {}));
  }
});

// server/node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js
var require_protocol_callHierarchy = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CallHierarchyOutgoingCallsRequest = exports.CallHierarchyIncomingCallsRequest = exports.CallHierarchyPrepareRequest = void 0;
    var messages_1 = require_messages2();
    var CallHierarchyPrepareRequest;
    (function (CallHierarchyPrepareRequest2) {
      CallHierarchyPrepareRequest2.method = "textDocument/prepareCallHierarchy";
      CallHierarchyPrepareRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CallHierarchyPrepareRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest2.method);
    })(CallHierarchyPrepareRequest || (exports.CallHierarchyPrepareRequest = CallHierarchyPrepareRequest = {}));
    var CallHierarchyIncomingCallsRequest;
    (function (CallHierarchyIncomingCallsRequest2) {
      CallHierarchyIncomingCallsRequest2.method = "callHierarchy/incomingCalls";
      CallHierarchyIncomingCallsRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CallHierarchyIncomingCallsRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest2.method);
    })(CallHierarchyIncomingCallsRequest || (exports.CallHierarchyIncomingCallsRequest = CallHierarchyIncomingCallsRequest = {}));
    var CallHierarchyOutgoingCallsRequest;
    (function (CallHierarchyOutgoingCallsRequest2) {
      CallHierarchyOutgoingCallsRequest2.method = "callHierarchy/outgoingCalls";
      CallHierarchyOutgoingCallsRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CallHierarchyOutgoingCallsRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest2.method);
    })(CallHierarchyOutgoingCallsRequest || (exports.CallHierarchyOutgoingCallsRequest = CallHierarchyOutgoingCallsRequest = {}));
  }
});

// server/node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js
var require_protocol_semanticTokens = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SemanticTokensRefreshRequest = exports.SemanticTokensRangeRequest = exports.SemanticTokensDeltaRequest = exports.SemanticTokensRequest = exports.SemanticTokensRegistrationType = exports.TokenFormat = void 0;
    var messages_1 = require_messages2();
    var TokenFormat;
    (function (TokenFormat2) {
      TokenFormat2.Relative = "relative";
    })(TokenFormat || (exports.TokenFormat = TokenFormat = {}));
    var SemanticTokensRegistrationType;
    (function (SemanticTokensRegistrationType2) {
      SemanticTokensRegistrationType2.method = "textDocument/semanticTokens";
      SemanticTokensRegistrationType2.type = new messages_1.RegistrationType(SemanticTokensRegistrationType2.method);
    })(SemanticTokensRegistrationType || (exports.SemanticTokensRegistrationType = SemanticTokensRegistrationType = {}));
    var SemanticTokensRequest;
    (function (SemanticTokensRequest2) {
      SemanticTokensRequest2.method = "textDocument/semanticTokens/full";
      SemanticTokensRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SemanticTokensRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensRequest2.method);
      SemanticTokensRequest2.registrationMethod = SemanticTokensRegistrationType.method;
    })(SemanticTokensRequest || (exports.SemanticTokensRequest = SemanticTokensRequest = {}));
    var SemanticTokensDeltaRequest;
    (function (SemanticTokensDeltaRequest2) {
      SemanticTokensDeltaRequest2.method = "textDocument/semanticTokens/full/delta";
      SemanticTokensDeltaRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SemanticTokensDeltaRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensDeltaRequest2.method);
      SemanticTokensDeltaRequest2.registrationMethod = SemanticTokensRegistrationType.method;
    })(SemanticTokensDeltaRequest || (exports.SemanticTokensDeltaRequest = SemanticTokensDeltaRequest = {}));
    var SemanticTokensRangeRequest;
    (function (SemanticTokensRangeRequest2) {
      SemanticTokensRangeRequest2.method = "textDocument/semanticTokens/range";
      SemanticTokensRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SemanticTokensRangeRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest2.method);
      SemanticTokensRangeRequest2.registrationMethod = SemanticTokensRegistrationType.method;
    })(SemanticTokensRangeRequest || (exports.SemanticTokensRangeRequest = SemanticTokensRangeRequest = {}));
    var SemanticTokensRefreshRequest;
    (function (SemanticTokensRefreshRequest2) {
      SemanticTokensRefreshRequest2.method = `workspace/semanticTokens/refresh`;
      SemanticTokensRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      SemanticTokensRefreshRequest2.type = new messages_1.ProtocolRequestType0(SemanticTokensRefreshRequest2.method);
    })(SemanticTokensRefreshRequest || (exports.SemanticTokensRefreshRequest = SemanticTokensRefreshRequest = {}));
  }
});

// server/node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js
var require_protocol_showDocument = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ShowDocumentRequest = void 0;
    var messages_1 = require_messages2();
    var ShowDocumentRequest;
    (function (ShowDocumentRequest2) {
      ShowDocumentRequest2.method = "window/showDocument";
      ShowDocumentRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      ShowDocumentRequest2.type = new messages_1.ProtocolRequestType(ShowDocumentRequest2.method);
    })(ShowDocumentRequest || (exports.ShowDocumentRequest = ShowDocumentRequest = {}));
  }
});

// server/node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js
var require_protocol_linkedEditingRange = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LinkedEditingRangeRequest = void 0;
    var messages_1 = require_messages2();
    var LinkedEditingRangeRequest;
    (function (LinkedEditingRangeRequest2) {
      LinkedEditingRangeRequest2.method = "textDocument/linkedEditingRange";
      LinkedEditingRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      LinkedEditingRangeRequest2.type = new messages_1.ProtocolRequestType(LinkedEditingRangeRequest2.method);
    })(LinkedEditingRangeRequest || (exports.LinkedEditingRangeRequest = LinkedEditingRangeRequest = {}));
  }
});

// server/node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js
var require_protocol_fileOperations = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WillDeleteFilesRequest = exports.DidDeleteFilesNotification = exports.DidRenameFilesNotification = exports.WillRenameFilesRequest = exports.DidCreateFilesNotification = exports.WillCreateFilesRequest = exports.FileOperationPatternKind = void 0;
    var messages_1 = require_messages2();
    var FileOperationPatternKind;
    (function (FileOperationPatternKind2) {
      FileOperationPatternKind2.file = "file";
      FileOperationPatternKind2.folder = "folder";
    })(FileOperationPatternKind || (exports.FileOperationPatternKind = FileOperationPatternKind = {}));
    var WillCreateFilesRequest;
    (function (WillCreateFilesRequest2) {
      WillCreateFilesRequest2.method = "workspace/willCreateFiles";
      WillCreateFilesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillCreateFilesRequest2.type = new messages_1.ProtocolRequestType(WillCreateFilesRequest2.method);
    })(WillCreateFilesRequest || (exports.WillCreateFilesRequest = WillCreateFilesRequest = {}));
    var DidCreateFilesNotification;
    (function (DidCreateFilesNotification2) {
      DidCreateFilesNotification2.method = "workspace/didCreateFiles";
      DidCreateFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidCreateFilesNotification2.type = new messages_1.ProtocolNotificationType(DidCreateFilesNotification2.method);
    })(DidCreateFilesNotification || (exports.DidCreateFilesNotification = DidCreateFilesNotification = {}));
    var WillRenameFilesRequest;
    (function (WillRenameFilesRequest2) {
      WillRenameFilesRequest2.method = "workspace/willRenameFiles";
      WillRenameFilesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillRenameFilesRequest2.type = new messages_1.ProtocolRequestType(WillRenameFilesRequest2.method);
    })(WillRenameFilesRequest || (exports.WillRenameFilesRequest = WillRenameFilesRequest = {}));
    var DidRenameFilesNotification;
    (function (DidRenameFilesNotification2) {
      DidRenameFilesNotification2.method = "workspace/didRenameFiles";
      DidRenameFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidRenameFilesNotification2.type = new messages_1.ProtocolNotificationType(DidRenameFilesNotification2.method);
    })(DidRenameFilesNotification || (exports.DidRenameFilesNotification = DidRenameFilesNotification = {}));
    var DidDeleteFilesNotification;
    (function (DidDeleteFilesNotification2) {
      DidDeleteFilesNotification2.method = "workspace/didDeleteFiles";
      DidDeleteFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidDeleteFilesNotification2.type = new messages_1.ProtocolNotificationType(DidDeleteFilesNotification2.method);
    })(DidDeleteFilesNotification || (exports.DidDeleteFilesNotification = DidDeleteFilesNotification = {}));
    var WillDeleteFilesRequest;
    (function (WillDeleteFilesRequest2) {
      WillDeleteFilesRequest2.method = "workspace/willDeleteFiles";
      WillDeleteFilesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillDeleteFilesRequest2.type = new messages_1.ProtocolRequestType(WillDeleteFilesRequest2.method);
    })(WillDeleteFilesRequest || (exports.WillDeleteFilesRequest = WillDeleteFilesRequest = {}));
  }
});

// server/node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js
var require_protocol_moniker = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MonikerRequest = exports.MonikerKind = exports.UniquenessLevel = void 0;
    var messages_1 = require_messages2();
    var UniquenessLevel;
    (function (UniquenessLevel2) {
      UniquenessLevel2.document = "document";
      UniquenessLevel2.project = "project";
      UniquenessLevel2.group = "group";
      UniquenessLevel2.scheme = "scheme";
      UniquenessLevel2.global = "global";
    })(UniquenessLevel || (exports.UniquenessLevel = UniquenessLevel = {}));
    var MonikerKind;
    (function (MonikerKind2) {
      MonikerKind2.$import = "import";
      MonikerKind2.$export = "export";
      MonikerKind2.local = "local";
    })(MonikerKind || (exports.MonikerKind = MonikerKind = {}));
    var MonikerRequest;
    (function (MonikerRequest2) {
      MonikerRequest2.method = "textDocument/moniker";
      MonikerRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      MonikerRequest2.type = new messages_1.ProtocolRequestType(MonikerRequest2.method);
    })(MonikerRequest || (exports.MonikerRequest = MonikerRequest = {}));
  }
});

// server/node_modules/vscode-languageserver-protocol/lib/common/protocol.typeHierarchy.js
var require_protocol_typeHierarchy = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/lib/common/protocol.typeHierarchy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TypeHierarchySubtypesRequest = exports.TypeHierarchySupertypesRequest = exports.TypeHierarchyPrepareRequest = void 0;
    var messages_1 = require_messages2();
    var TypeHierarchyPrepareRequest;
    (function (TypeHierarchyPrepareRequest2) {
      TypeHierarchyPrepareRequest2.method = "textDocument/prepareTypeHierarchy";
      TypeHierarchyPrepareRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeHierarchyPrepareRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchyPrepareRequest2.method);
    })(TypeHierarchyPrepareRequest || (exports.TypeHierarchyPrepareRequest = TypeHierarchyPrepareRequest = {}));
    var TypeHierarchySupertypesRequest;
    (function (TypeHierarchySupertypesRequest2) {
      TypeHierarchySupertypesRequest2.method = "typeHierarchy/supertypes";
      TypeHierarchySupertypesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeHierarchySupertypesRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchySupertypesRequest2.method);
    })(TypeHierarchySupertypesRequest || (exports.TypeHierarchySupertypesRequest = TypeHierarchySupertypesRequest = {}));
    var TypeHierarchySubtypesRequest;
    (function (TypeHierarchySubtypesRequest2) {
      TypeHierarchySubtypesRequest2.method = "typeHierarchy/subtypes";
      TypeHierarchySubtypesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeHierarchySubtypesRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchySubtypesRequest2.method);
    })(TypeHierarchySubtypesRequest || (exports.TypeHierarchySubtypesRequest = TypeHierarchySubtypesRequest = {}));
  }
});

// server/node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineValue.js
var require_protocol_inlineValue = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineValue.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InlineValueRefreshRequest = exports.InlineValueRequest = void 0;
    var messages_1 = require_messages2();
    var InlineValueRequest;
    (function (InlineValueRequest2) {
      InlineValueRequest2.method = "textDocument/inlineValue";
      InlineValueRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InlineValueRequest2.type = new messages_1.ProtocolRequestType(InlineValueRequest2.method);
    })(InlineValueRequest || (exports.InlineValueRequest = InlineValueRequest = {}));
    var InlineValueRefreshRequest;
    (function (InlineValueRefreshRequest2) {
      InlineValueRefreshRequest2.method = `workspace/inlineValue/refresh`;
      InlineValueRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      InlineValueRefreshRequest2.type = new messages_1.ProtocolRequestType0(InlineValueRefreshRequest2.method);
    })(InlineValueRefreshRequest || (exports.InlineValueRefreshRequest = InlineValueRefreshRequest = {}));
  }
});

// server/node_modules/vscode-languageserver-protocol/lib/common/protocol.inlayHint.js
var require_protocol_inlayHint = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/lib/common/protocol.inlayHint.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InlayHintRefreshRequest = exports.InlayHintResolveRequest = exports.InlayHintRequest = void 0;
    var messages_1 = require_messages2();
    var InlayHintRequest;
    (function (InlayHintRequest2) {
      InlayHintRequest2.method = "textDocument/inlayHint";
      InlayHintRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InlayHintRequest2.type = new messages_1.ProtocolRequestType(InlayHintRequest2.method);
    })(InlayHintRequest || (exports.InlayHintRequest = InlayHintRequest = {}));
    var InlayHintResolveRequest;
    (function (InlayHintResolveRequest2) {
      InlayHintResolveRequest2.method = "inlayHint/resolve";
      InlayHintResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InlayHintResolveRequest2.type = new messages_1.ProtocolRequestType(InlayHintResolveRequest2.method);
    })(InlayHintResolveRequest || (exports.InlayHintResolveRequest = InlayHintResolveRequest = {}));
    var InlayHintRefreshRequest;
    (function (InlayHintRefreshRequest2) {
      InlayHintRefreshRequest2.method = `workspace/inlayHint/refresh`;
      InlayHintRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      InlayHintRefreshRequest2.type = new messages_1.ProtocolRequestType0(InlayHintRefreshRequest2.method);
    })(InlayHintRefreshRequest || (exports.InlayHintRefreshRequest = InlayHintRefreshRequest = {}));
  }
});

// server/node_modules/vscode-languageserver-protocol/lib/common/protocol.diagnostic.js
var require_protocol_diagnostic = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/lib/common/protocol.diagnostic.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DiagnosticRefreshRequest = exports.WorkspaceDiagnosticRequest = exports.DocumentDiagnosticRequest = exports.DocumentDiagnosticReportKind = exports.DiagnosticServerCancellationData = void 0;
    var vscode_jsonrpc_1 = require_main();
    var Is2 = require_is2();
    var messages_1 = require_messages2();
    var DiagnosticServerCancellationData;
    (function (DiagnosticServerCancellationData2) {
      function is(value) {
        const candidate = value;
        return candidate && Is2.boolean(candidate.retriggerRequest);
      }
      DiagnosticServerCancellationData2.is = is;
    })(DiagnosticServerCancellationData || (exports.DiagnosticServerCancellationData = DiagnosticServerCancellationData = {}));
    var DocumentDiagnosticReportKind;
    (function (DocumentDiagnosticReportKind2) {
      DocumentDiagnosticReportKind2.Full = "full";
      DocumentDiagnosticReportKind2.Unchanged = "unchanged";
    })(DocumentDiagnosticReportKind || (exports.DocumentDiagnosticReportKind = DocumentDiagnosticReportKind = {}));
    var DocumentDiagnosticRequest;
    (function (DocumentDiagnosticRequest2) {
      DocumentDiagnosticRequest2.method = "textDocument/diagnostic";
      DocumentDiagnosticRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentDiagnosticRequest2.type = new messages_1.ProtocolRequestType(DocumentDiagnosticRequest2.method);
      DocumentDiagnosticRequest2.partialResult = new vscode_jsonrpc_1.ProgressType();
    })(DocumentDiagnosticRequest || (exports.DocumentDiagnosticRequest = DocumentDiagnosticRequest = {}));
    var WorkspaceDiagnosticRequest;
    (function (WorkspaceDiagnosticRequest2) {
      WorkspaceDiagnosticRequest2.method = "workspace/diagnostic";
      WorkspaceDiagnosticRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkspaceDiagnosticRequest2.type = new messages_1.ProtocolRequestType(WorkspaceDiagnosticRequest2.method);
      WorkspaceDiagnosticRequest2.partialResult = new vscode_jsonrpc_1.ProgressType();
    })(WorkspaceDiagnosticRequest || (exports.WorkspaceDiagnosticRequest = WorkspaceDiagnosticRequest = {}));
    var DiagnosticRefreshRequest;
    (function (DiagnosticRefreshRequest2) {
      DiagnosticRefreshRequest2.method = `workspace/diagnostic/refresh`;
      DiagnosticRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      DiagnosticRefreshRequest2.type = new messages_1.ProtocolRequestType0(DiagnosticRefreshRequest2.method);
    })(DiagnosticRefreshRequest || (exports.DiagnosticRefreshRequest = DiagnosticRefreshRequest = {}));
  }
});

// server/node_modules/vscode-languageserver-protocol/lib/common/protocol.notebook.js
var require_protocol_notebook = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/lib/common/protocol.notebook.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DidCloseNotebookDocumentNotification = exports.DidSaveNotebookDocumentNotification = exports.DidChangeNotebookDocumentNotification = exports.NotebookCellArrayChange = exports.DidOpenNotebookDocumentNotification = exports.NotebookDocumentSyncRegistrationType = exports.NotebookDocument = exports.NotebookCell = exports.ExecutionSummary = exports.NotebookCellKind = void 0;
    var vscode_languageserver_types_1 = (init_main(), __toCommonJS(main_exports));
    var Is2 = require_is2();
    var messages_1 = require_messages2();
    var NotebookCellKind;
    (function (NotebookCellKind2) {
      NotebookCellKind2.Markup = 1;
      NotebookCellKind2.Code = 2;
      function is(value) {
        return value === 1 || value === 2;
      }
      NotebookCellKind2.is = is;
    })(NotebookCellKind || (exports.NotebookCellKind = NotebookCellKind = {}));
    var ExecutionSummary;
    (function (ExecutionSummary2) {
      function create(executionOrder, success) {
        const result = { executionOrder };
        if (success === true || success === false) {
          result.success = success;
        }
        return result;
      }
      ExecutionSummary2.create = create;
      function is(value) {
        const candidate = value;
        return Is2.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.executionOrder) && (candidate.success === void 0 || Is2.boolean(candidate.success));
      }
      ExecutionSummary2.is = is;
      function equals(one, other) {
        if (one === other) {
          return true;
        }
        if (one === null || one === void 0 || other === null || other === void 0) {
          return false;
        }
        return one.executionOrder === other.executionOrder && one.success === other.success;
      }
      ExecutionSummary2.equals = equals;
    })(ExecutionSummary || (exports.ExecutionSummary = ExecutionSummary = {}));
    var NotebookCell;
    (function (NotebookCell2) {
      function create(kind, document2) {
        return { kind, document: document2 };
      }
      NotebookCell2.create = create;
      function is(value) {
        const candidate = value;
        return Is2.objectLiteral(candidate) && NotebookCellKind.is(candidate.kind) && vscode_languageserver_types_1.DocumentUri.is(candidate.document) && (candidate.metadata === void 0 || Is2.objectLiteral(candidate.metadata));
      }
      NotebookCell2.is = is;
      function diff(one, two) {
        const result = /* @__PURE__ */ new Set();
        if (one.document !== two.document) {
          result.add("document");
        }
        if (one.kind !== two.kind) {
          result.add("kind");
        }
        if (one.executionSummary !== two.executionSummary) {
          result.add("executionSummary");
        }
        if ((one.metadata !== void 0 || two.metadata !== void 0) && !equalsMetadata(one.metadata, two.metadata)) {
          result.add("metadata");
        }
        if ((one.executionSummary !== void 0 || two.executionSummary !== void 0) && !ExecutionSummary.equals(one.executionSummary, two.executionSummary)) {
          result.add("executionSummary");
        }
        return result;
      }
      NotebookCell2.diff = diff;
      function equalsMetadata(one, other) {
        if (one === other) {
          return true;
        }
        if (one === null || one === void 0 || other === null || other === void 0) {
          return false;
        }
        if (typeof one !== typeof other) {
          return false;
        }
        if (typeof one !== "object") {
          return false;
        }
        const oneArray = Array.isArray(one);
        const otherArray = Array.isArray(other);
        if (oneArray !== otherArray) {
          return false;
        }
        if (oneArray && otherArray) {
          if (one.length !== other.length) {
            return false;
          }
          for (let i = 0; i < one.length; i++) {
            if (!equalsMetadata(one[i], other[i])) {
              return false;
            }
          }
        }
        if (Is2.objectLiteral(one) && Is2.objectLiteral(other)) {
          const oneKeys = Object.keys(one);
          const otherKeys = Object.keys(other);
          if (oneKeys.length !== otherKeys.length) {
            return false;
          }
          oneKeys.sort();
          otherKeys.sort();
          if (!equalsMetadata(oneKeys, otherKeys)) {
            return false;
          }
          for (let i = 0; i < oneKeys.length; i++) {
            const prop = oneKeys[i];
            if (!equalsMetadata(one[prop], other[prop])) {
              return false;
            }
          }
        }
        return true;
      }
    })(NotebookCell || (exports.NotebookCell = NotebookCell = {}));
    var NotebookDocument;
    (function (NotebookDocument2) {
      function create(uri, notebookType, version, cells) {
        return { uri, notebookType, version, cells };
      }
      NotebookDocument2.create = create;
      function is(value) {
        const candidate = value;
        return Is2.objectLiteral(candidate) && Is2.string(candidate.uri) && vscode_languageserver_types_1.integer.is(candidate.version) && Is2.typedArray(candidate.cells, NotebookCell.is);
      }
      NotebookDocument2.is = is;
    })(NotebookDocument || (exports.NotebookDocument = NotebookDocument = {}));
    var NotebookDocumentSyncRegistrationType;
    (function (NotebookDocumentSyncRegistrationType2) {
      NotebookDocumentSyncRegistrationType2.method = "notebookDocument/sync";
      NotebookDocumentSyncRegistrationType2.messageDirection = messages_1.MessageDirection.clientToServer;
      NotebookDocumentSyncRegistrationType2.type = new messages_1.RegistrationType(NotebookDocumentSyncRegistrationType2.method);
    })(NotebookDocumentSyncRegistrationType || (exports.NotebookDocumentSyncRegistrationType = NotebookDocumentSyncRegistrationType = {}));
    var DidOpenNotebookDocumentNotification;
    (function (DidOpenNotebookDocumentNotification2) {
      DidOpenNotebookDocumentNotification2.method = "notebookDocument/didOpen";
      DidOpenNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidOpenNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidOpenNotebookDocumentNotification2.method);
      DidOpenNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidOpenNotebookDocumentNotification || (exports.DidOpenNotebookDocumentNotification = DidOpenNotebookDocumentNotification = {}));
    var NotebookCellArrayChange;
    (function (NotebookCellArrayChange2) {
      function is(value) {
        const candidate = value;
        return Is2.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.start) && vscode_languageserver_types_1.uinteger.is(candidate.deleteCount) && (candidate.cells === void 0 || Is2.typedArray(candidate.cells, NotebookCell.is));
      }
      NotebookCellArrayChange2.is = is;
      function create(start, deleteCount, cells) {
        const result = { start, deleteCount };
        if (cells !== void 0) {
          result.cells = cells;
        }
        return result;
      }
      NotebookCellArrayChange2.create = create;
    })(NotebookCellArrayChange || (exports.NotebookCellArrayChange = NotebookCellArrayChange = {}));
    var DidChangeNotebookDocumentNotification;
    (function (DidChangeNotebookDocumentNotification2) {
      DidChangeNotebookDocumentNotification2.method = "notebookDocument/didChange";
      DidChangeNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidChangeNotebookDocumentNotification2.method);
      DidChangeNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidChangeNotebookDocumentNotification || (exports.DidChangeNotebookDocumentNotification = DidChangeNotebookDocumentNotification = {}));
    var DidSaveNotebookDocumentNotification;
    (function (DidSaveNotebookDocumentNotification2) {
      DidSaveNotebookDocumentNotification2.method = "notebookDocument/didSave";
      DidSaveNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidSaveNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidSaveNotebookDocumentNotification2.method);
      DidSaveNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidSaveNotebookDocumentNotification || (exports.DidSaveNotebookDocumentNotification = DidSaveNotebookDocumentNotification = {}));
    var DidCloseNotebookDocumentNotification;
    (function (DidCloseNotebookDocumentNotification2) {
      DidCloseNotebookDocumentNotification2.method = "notebookDocument/didClose";
      DidCloseNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidCloseNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidCloseNotebookDocumentNotification2.method);
      DidCloseNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidCloseNotebookDocumentNotification || (exports.DidCloseNotebookDocumentNotification = DidCloseNotebookDocumentNotification = {}));
  }
});

// server/node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineCompletion.js
var require_protocol_inlineCompletion = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineCompletion.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InlineCompletionRequest = void 0;
    var messages_1 = require_messages2();
    var InlineCompletionRequest;
    (function (InlineCompletionRequest2) {
      InlineCompletionRequest2.method = "textDocument/inlineCompletion";
      InlineCompletionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InlineCompletionRequest2.type = new messages_1.ProtocolRequestType(InlineCompletionRequest2.method);
    })(InlineCompletionRequest || (exports.InlineCompletionRequest = InlineCompletionRequest = {}));
  }
});

// server/node_modules/vscode-languageserver-protocol/lib/common/protocol.js
var require_protocol = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/lib/common/protocol.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WorkspaceSymbolRequest = exports.CodeActionResolveRequest = exports.CodeActionRequest = exports.DocumentSymbolRequest = exports.DocumentHighlightRequest = exports.ReferencesRequest = exports.DefinitionRequest = exports.SignatureHelpRequest = exports.SignatureHelpTriggerKind = exports.HoverRequest = exports.CompletionResolveRequest = exports.CompletionRequest = exports.CompletionTriggerKind = exports.PublishDiagnosticsNotification = exports.WatchKind = exports.RelativePattern = exports.FileChangeType = exports.DidChangeWatchedFilesNotification = exports.WillSaveTextDocumentWaitUntilRequest = exports.WillSaveTextDocumentNotification = exports.TextDocumentSaveReason = exports.DidSaveTextDocumentNotification = exports.DidCloseTextDocumentNotification = exports.DidChangeTextDocumentNotification = exports.TextDocumentContentChangeEvent = exports.DidOpenTextDocumentNotification = exports.TextDocumentSyncKind = exports.TelemetryEventNotification = exports.LogMessageNotification = exports.ShowMessageRequest = exports.ShowMessageNotification = exports.MessageType = exports.DidChangeConfigurationNotification = exports.ExitNotification = exports.ShutdownRequest = exports.InitializedNotification = exports.InitializeErrorCodes = exports.InitializeRequest = exports.WorkDoneProgressOptions = exports.TextDocumentRegistrationOptions = exports.StaticRegistrationOptions = exports.PositionEncodingKind = exports.FailureHandlingKind = exports.ResourceOperationKind = exports.UnregistrationRequest = exports.RegistrationRequest = exports.DocumentSelector = exports.NotebookCellTextDocumentFilter = exports.NotebookDocumentFilter = exports.TextDocumentFilter = void 0;
    exports.MonikerRequest = exports.MonikerKind = exports.UniquenessLevel = exports.WillDeleteFilesRequest = exports.DidDeleteFilesNotification = exports.WillRenameFilesRequest = exports.DidRenameFilesNotification = exports.WillCreateFilesRequest = exports.DidCreateFilesNotification = exports.FileOperationPatternKind = exports.LinkedEditingRangeRequest = exports.ShowDocumentRequest = exports.SemanticTokensRegistrationType = exports.SemanticTokensRefreshRequest = exports.SemanticTokensRangeRequest = exports.SemanticTokensDeltaRequest = exports.SemanticTokensRequest = exports.TokenFormat = exports.CallHierarchyPrepareRequest = exports.CallHierarchyOutgoingCallsRequest = exports.CallHierarchyIncomingCallsRequest = exports.WorkDoneProgressCancelNotification = exports.WorkDoneProgressCreateRequest = exports.WorkDoneProgress = exports.SelectionRangeRequest = exports.DeclarationRequest = exports.FoldingRangeRefreshRequest = exports.FoldingRangeRequest = exports.ColorPresentationRequest = exports.DocumentColorRequest = exports.ConfigurationRequest = exports.DidChangeWorkspaceFoldersNotification = exports.WorkspaceFoldersRequest = exports.TypeDefinitionRequest = exports.ImplementationRequest = exports.ApplyWorkspaceEditRequest = exports.ExecuteCommandRequest = exports.PrepareRenameRequest = exports.RenameRequest = exports.PrepareSupportDefaultBehavior = exports.DocumentOnTypeFormattingRequest = exports.DocumentRangesFormattingRequest = exports.DocumentRangeFormattingRequest = exports.DocumentFormattingRequest = exports.DocumentLinkResolveRequest = exports.DocumentLinkRequest = exports.CodeLensRefreshRequest = exports.CodeLensResolveRequest = exports.CodeLensRequest = exports.WorkspaceSymbolResolveRequest = void 0;
    exports.InlineCompletionRequest = exports.DidCloseNotebookDocumentNotification = exports.DidSaveNotebookDocumentNotification = exports.DidChangeNotebookDocumentNotification = exports.NotebookCellArrayChange = exports.DidOpenNotebookDocumentNotification = exports.NotebookDocumentSyncRegistrationType = exports.NotebookDocument = exports.NotebookCell = exports.ExecutionSummary = exports.NotebookCellKind = exports.DiagnosticRefreshRequest = exports.WorkspaceDiagnosticRequest = exports.DocumentDiagnosticRequest = exports.DocumentDiagnosticReportKind = exports.DiagnosticServerCancellationData = exports.InlayHintRefreshRequest = exports.InlayHintResolveRequest = exports.InlayHintRequest = exports.InlineValueRefreshRequest = exports.InlineValueRequest = exports.TypeHierarchySupertypesRequest = exports.TypeHierarchySubtypesRequest = exports.TypeHierarchyPrepareRequest = void 0;
    var messages_1 = require_messages2();
    var vscode_languageserver_types_1 = (init_main(), __toCommonJS(main_exports));
    var Is2 = require_is2();
    var protocol_implementation_1 = require_protocol_implementation();
    Object.defineProperty(exports, "ImplementationRequest", {
      enumerable: true, get: function () {
        return protocol_implementation_1.ImplementationRequest;
      }
    });
    var protocol_typeDefinition_1 = require_protocol_typeDefinition();
    Object.defineProperty(exports, "TypeDefinitionRequest", {
      enumerable: true, get: function () {
        return protocol_typeDefinition_1.TypeDefinitionRequest;
      }
    });
    var protocol_workspaceFolder_1 = require_protocol_workspaceFolder();
    Object.defineProperty(exports, "WorkspaceFoldersRequest", {
      enumerable: true, get: function () {
        return protocol_workspaceFolder_1.WorkspaceFoldersRequest;
      }
    });
    Object.defineProperty(exports, "DidChangeWorkspaceFoldersNotification", {
      enumerable: true, get: function () {
        return protocol_workspaceFolder_1.DidChangeWorkspaceFoldersNotification;
      }
    });
    var protocol_configuration_1 = require_protocol_configuration();
    Object.defineProperty(exports, "ConfigurationRequest", {
      enumerable: true, get: function () {
        return protocol_configuration_1.ConfigurationRequest;
      }
    });
    var protocol_colorProvider_1 = require_protocol_colorProvider();
    Object.defineProperty(exports, "DocumentColorRequest", {
      enumerable: true, get: function () {
        return protocol_colorProvider_1.DocumentColorRequest;
      }
    });
    Object.defineProperty(exports, "ColorPresentationRequest", {
      enumerable: true, get: function () {
        return protocol_colorProvider_1.ColorPresentationRequest;
      }
    });
    var protocol_foldingRange_1 = require_protocol_foldingRange();
    Object.defineProperty(exports, "FoldingRangeRequest", {
      enumerable: true, get: function () {
        return protocol_foldingRange_1.FoldingRangeRequest;
      }
    });
    Object.defineProperty(exports, "FoldingRangeRefreshRequest", {
      enumerable: true, get: function () {
        return protocol_foldingRange_1.FoldingRangeRefreshRequest;
      }
    });
    var protocol_declaration_1 = require_protocol_declaration();
    Object.defineProperty(exports, "DeclarationRequest", {
      enumerable: true, get: function () {
        return protocol_declaration_1.DeclarationRequest;
      }
    });
    var protocol_selectionRange_1 = require_protocol_selectionRange();
    Object.defineProperty(exports, "SelectionRangeRequest", {
      enumerable: true, get: function () {
        return protocol_selectionRange_1.SelectionRangeRequest;
      }
    });
    var protocol_progress_1 = require_protocol_progress();
    Object.defineProperty(exports, "WorkDoneProgress", {
      enumerable: true, get: function () {
        return protocol_progress_1.WorkDoneProgress;
      }
    });
    Object.defineProperty(exports, "WorkDoneProgressCreateRequest", {
      enumerable: true, get: function () {
        return protocol_progress_1.WorkDoneProgressCreateRequest;
      }
    });
    Object.defineProperty(exports, "WorkDoneProgressCancelNotification", {
      enumerable: true, get: function () {
        return protocol_progress_1.WorkDoneProgressCancelNotification;
      }
    });
    var protocol_callHierarchy_1 = require_protocol_callHierarchy();
    Object.defineProperty(exports, "CallHierarchyIncomingCallsRequest", {
      enumerable: true, get: function () {
        return protocol_callHierarchy_1.CallHierarchyIncomingCallsRequest;
      }
    });
    Object.defineProperty(exports, "CallHierarchyOutgoingCallsRequest", {
      enumerable: true, get: function () {
        return protocol_callHierarchy_1.CallHierarchyOutgoingCallsRequest;
      }
    });
    Object.defineProperty(exports, "CallHierarchyPrepareRequest", {
      enumerable: true, get: function () {
        return protocol_callHierarchy_1.CallHierarchyPrepareRequest;
      }
    });
    var protocol_semanticTokens_1 = require_protocol_semanticTokens();
    Object.defineProperty(exports, "TokenFormat", {
      enumerable: true, get: function () {
        return protocol_semanticTokens_1.TokenFormat;
      }
    });
    Object.defineProperty(exports, "SemanticTokensRequest", {
      enumerable: true, get: function () {
        return protocol_semanticTokens_1.SemanticTokensRequest;
      }
    });
    Object.defineProperty(exports, "SemanticTokensDeltaRequest", {
      enumerable: true, get: function () {
        return protocol_semanticTokens_1.SemanticTokensDeltaRequest;
      }
    });
    Object.defineProperty(exports, "SemanticTokensRangeRequest", {
      enumerable: true, get: function () {
        return protocol_semanticTokens_1.SemanticTokensRangeRequest;
      }
    });
    Object.defineProperty(exports, "SemanticTokensRefreshRequest", {
      enumerable: true, get: function () {
        return protocol_semanticTokens_1.SemanticTokensRefreshRequest;
      }
    });
    Object.defineProperty(exports, "SemanticTokensRegistrationType", {
      enumerable: true, get: function () {
        return protocol_semanticTokens_1.SemanticTokensRegistrationType;
      }
    });
    var protocol_showDocument_1 = require_protocol_showDocument();
    Object.defineProperty(exports, "ShowDocumentRequest", {
      enumerable: true, get: function () {
        return protocol_showDocument_1.ShowDocumentRequest;
      }
    });
    var protocol_linkedEditingRange_1 = require_protocol_linkedEditingRange();
    Object.defineProperty(exports, "LinkedEditingRangeRequest", {
      enumerable: true, get: function () {
        return protocol_linkedEditingRange_1.LinkedEditingRangeRequest;
      }
    });
    var protocol_fileOperations_1 = require_protocol_fileOperations();
    Object.defineProperty(exports, "FileOperationPatternKind", {
      enumerable: true, get: function () {
        return protocol_fileOperations_1.FileOperationPatternKind;
      }
    });
    Object.defineProperty(exports, "DidCreateFilesNotification", {
      enumerable: true, get: function () {
        return protocol_fileOperations_1.DidCreateFilesNotification;
      }
    });
    Object.defineProperty(exports, "WillCreateFilesRequest", {
      enumerable: true, get: function () {
        return protocol_fileOperations_1.WillCreateFilesRequest;
      }
    });
    Object.defineProperty(exports, "DidRenameFilesNotification", {
      enumerable: true, get: function () {
        return protocol_fileOperations_1.DidRenameFilesNotification;
      }
    });
    Object.defineProperty(exports, "WillRenameFilesRequest", {
      enumerable: true, get: function () {
        return protocol_fileOperations_1.WillRenameFilesRequest;
      }
    });
    Object.defineProperty(exports, "DidDeleteFilesNotification", {
      enumerable: true, get: function () {
        return protocol_fileOperations_1.DidDeleteFilesNotification;
      }
    });
    Object.defineProperty(exports, "WillDeleteFilesRequest", {
      enumerable: true, get: function () {
        return protocol_fileOperations_1.WillDeleteFilesRequest;
      }
    });
    var protocol_moniker_1 = require_protocol_moniker();
    Object.defineProperty(exports, "UniquenessLevel", {
      enumerable: true, get: function () {
        return protocol_moniker_1.UniquenessLevel;
      }
    });
    Object.defineProperty(exports, "MonikerKind", {
      enumerable: true, get: function () {
        return protocol_moniker_1.MonikerKind;
      }
    });
    Object.defineProperty(exports, "MonikerRequest", {
      enumerable: true, get: function () {
        return protocol_moniker_1.MonikerRequest;
      }
    });
    var protocol_typeHierarchy_1 = require_protocol_typeHierarchy();
    Object.defineProperty(exports, "TypeHierarchyPrepareRequest", {
      enumerable: true, get: function () {
        return protocol_typeHierarchy_1.TypeHierarchyPrepareRequest;
      }
    });
    Object.defineProperty(exports, "TypeHierarchySubtypesRequest", {
      enumerable: true, get: function () {
        return protocol_typeHierarchy_1.TypeHierarchySubtypesRequest;
      }
    });
    Object.defineProperty(exports, "TypeHierarchySupertypesRequest", {
      enumerable: true, get: function () {
        return protocol_typeHierarchy_1.TypeHierarchySupertypesRequest;
      }
    });
    var protocol_inlineValue_1 = require_protocol_inlineValue();
    Object.defineProperty(exports, "InlineValueRequest", {
      enumerable: true, get: function () {
        return protocol_inlineValue_1.InlineValueRequest;
      }
    });
    Object.defineProperty(exports, "InlineValueRefreshRequest", {
      enumerable: true, get: function () {
        return protocol_inlineValue_1.InlineValueRefreshRequest;
      }
    });
    var protocol_inlayHint_1 = require_protocol_inlayHint();
    Object.defineProperty(exports, "InlayHintRequest", {
      enumerable: true, get: function () {
        return protocol_inlayHint_1.InlayHintRequest;
      }
    });
    Object.defineProperty(exports, "InlayHintResolveRequest", {
      enumerable: true, get: function () {
        return protocol_inlayHint_1.InlayHintResolveRequest;
      }
    });
    Object.defineProperty(exports, "InlayHintRefreshRequest", {
      enumerable: true, get: function () {
        return protocol_inlayHint_1.InlayHintRefreshRequest;
      }
    });
    var protocol_diagnostic_1 = require_protocol_diagnostic();
    Object.defineProperty(exports, "DiagnosticServerCancellationData", {
      enumerable: true, get: function () {
        return protocol_diagnostic_1.DiagnosticServerCancellationData;
      }
    });
    Object.defineProperty(exports, "DocumentDiagnosticReportKind", {
      enumerable: true, get: function () {
        return protocol_diagnostic_1.DocumentDiagnosticReportKind;
      }
    });
    Object.defineProperty(exports, "DocumentDiagnosticRequest", {
      enumerable: true, get: function () {
        return protocol_diagnostic_1.DocumentDiagnosticRequest;
      }
    });
    Object.defineProperty(exports, "WorkspaceDiagnosticRequest", {
      enumerable: true, get: function () {
        return protocol_diagnostic_1.WorkspaceDiagnosticRequest;
      }
    });
    Object.defineProperty(exports, "DiagnosticRefreshRequest", {
      enumerable: true, get: function () {
        return protocol_diagnostic_1.DiagnosticRefreshRequest;
      }
    });
    var protocol_notebook_1 = require_protocol_notebook();
    Object.defineProperty(exports, "NotebookCellKind", {
      enumerable: true, get: function () {
        return protocol_notebook_1.NotebookCellKind;
      }
    });
    Object.defineProperty(exports, "ExecutionSummary", {
      enumerable: true, get: function () {
        return protocol_notebook_1.ExecutionSummary;
      }
    });
    Object.defineProperty(exports, "NotebookCell", {
      enumerable: true, get: function () {
        return protocol_notebook_1.NotebookCell;
      }
    });
    Object.defineProperty(exports, "NotebookDocument", {
      enumerable: true, get: function () {
        return protocol_notebook_1.NotebookDocument;
      }
    });
    Object.defineProperty(exports, "NotebookDocumentSyncRegistrationType", {
      enumerable: true, get: function () {
        return protocol_notebook_1.NotebookDocumentSyncRegistrationType;
      }
    });
    Object.defineProperty(exports, "DidOpenNotebookDocumentNotification", {
      enumerable: true, get: function () {
        return protocol_notebook_1.DidOpenNotebookDocumentNotification;
      }
    });
    Object.defineProperty(exports, "NotebookCellArrayChange", {
      enumerable: true, get: function () {
        return protocol_notebook_1.NotebookCellArrayChange;
      }
    });
    Object.defineProperty(exports, "DidChangeNotebookDocumentNotification", {
      enumerable: true, get: function () {
        return protocol_notebook_1.DidChangeNotebookDocumentNotification;
      }
    });
    Object.defineProperty(exports, "DidSaveNotebookDocumentNotification", {
      enumerable: true, get: function () {
        return protocol_notebook_1.DidSaveNotebookDocumentNotification;
      }
    });
    Object.defineProperty(exports, "DidCloseNotebookDocumentNotification", {
      enumerable: true, get: function () {
        return protocol_notebook_1.DidCloseNotebookDocumentNotification;
      }
    });
    var protocol_inlineCompletion_1 = require_protocol_inlineCompletion();
    Object.defineProperty(exports, "InlineCompletionRequest", {
      enumerable: true, get: function () {
        return protocol_inlineCompletion_1.InlineCompletionRequest;
      }
    });
    var TextDocumentFilter;
    (function (TextDocumentFilter2) {
      function is(value) {
        const candidate = value;
        return Is2.string(candidate) || (Is2.string(candidate.language) || Is2.string(candidate.scheme) || Is2.string(candidate.pattern));
      }
      TextDocumentFilter2.is = is;
    })(TextDocumentFilter || (exports.TextDocumentFilter = TextDocumentFilter = {}));
    var NotebookDocumentFilter;
    (function (NotebookDocumentFilter2) {
      function is(value) {
        const candidate = value;
        return Is2.objectLiteral(candidate) && (Is2.string(candidate.notebookType) || Is2.string(candidate.scheme) || Is2.string(candidate.pattern));
      }
      NotebookDocumentFilter2.is = is;
    })(NotebookDocumentFilter || (exports.NotebookDocumentFilter = NotebookDocumentFilter = {}));
    var NotebookCellTextDocumentFilter;
    (function (NotebookCellTextDocumentFilter2) {
      function is(value) {
        const candidate = value;
        return Is2.objectLiteral(candidate) && (Is2.string(candidate.notebook) || NotebookDocumentFilter.is(candidate.notebook)) && (candidate.language === void 0 || Is2.string(candidate.language));
      }
      NotebookCellTextDocumentFilter2.is = is;
    })(NotebookCellTextDocumentFilter || (exports.NotebookCellTextDocumentFilter = NotebookCellTextDocumentFilter = {}));
    var DocumentSelector;
    (function (DocumentSelector2) {
      function is(value) {
        if (!Array.isArray(value)) {
          return false;
        }
        for (let elem of value) {
          if (!Is2.string(elem) && !TextDocumentFilter.is(elem) && !NotebookCellTextDocumentFilter.is(elem)) {
            return false;
          }
        }
        return true;
      }
      DocumentSelector2.is = is;
    })(DocumentSelector || (exports.DocumentSelector = DocumentSelector = {}));
    var RegistrationRequest;
    (function (RegistrationRequest2) {
      RegistrationRequest2.method = "client/registerCapability";
      RegistrationRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      RegistrationRequest2.type = new messages_1.ProtocolRequestType(RegistrationRequest2.method);
    })(RegistrationRequest || (exports.RegistrationRequest = RegistrationRequest = {}));
    var UnregistrationRequest;
    (function (UnregistrationRequest2) {
      UnregistrationRequest2.method = "client/unregisterCapability";
      UnregistrationRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      UnregistrationRequest2.type = new messages_1.ProtocolRequestType(UnregistrationRequest2.method);
    })(UnregistrationRequest || (exports.UnregistrationRequest = UnregistrationRequest = {}));
    var ResourceOperationKind;
    (function (ResourceOperationKind2) {
      ResourceOperationKind2.Create = "create";
      ResourceOperationKind2.Rename = "rename";
      ResourceOperationKind2.Delete = "delete";
    })(ResourceOperationKind || (exports.ResourceOperationKind = ResourceOperationKind = {}));
    var FailureHandlingKind;
    (function (FailureHandlingKind2) {
      FailureHandlingKind2.Abort = "abort";
      FailureHandlingKind2.Transactional = "transactional";
      FailureHandlingKind2.TextOnlyTransactional = "textOnlyTransactional";
      FailureHandlingKind2.Undo = "undo";
    })(FailureHandlingKind || (exports.FailureHandlingKind = FailureHandlingKind = {}));
    var PositionEncodingKind;
    (function (PositionEncodingKind2) {
      PositionEncodingKind2.UTF8 = "utf-8";
      PositionEncodingKind2.UTF16 = "utf-16";
      PositionEncodingKind2.UTF32 = "utf-32";
    })(PositionEncodingKind || (exports.PositionEncodingKind = PositionEncodingKind = {}));
    var StaticRegistrationOptions;
    (function (StaticRegistrationOptions2) {
      function hasId(value) {
        const candidate = value;
        return candidate && Is2.string(candidate.id) && candidate.id.length > 0;
      }
      StaticRegistrationOptions2.hasId = hasId;
    })(StaticRegistrationOptions || (exports.StaticRegistrationOptions = StaticRegistrationOptions = {}));
    var TextDocumentRegistrationOptions;
    (function (TextDocumentRegistrationOptions2) {
      function is(value) {
        const candidate = value;
        return candidate && (candidate.documentSelector === null || DocumentSelector.is(candidate.documentSelector));
      }
      TextDocumentRegistrationOptions2.is = is;
    })(TextDocumentRegistrationOptions || (exports.TextDocumentRegistrationOptions = TextDocumentRegistrationOptions = {}));
    var WorkDoneProgressOptions;
    (function (WorkDoneProgressOptions2) {
      function is(value) {
        const candidate = value;
        return Is2.objectLiteral(candidate) && (candidate.workDoneProgress === void 0 || Is2.boolean(candidate.workDoneProgress));
      }
      WorkDoneProgressOptions2.is = is;
      function hasWorkDoneProgress(value) {
        const candidate = value;
        return candidate && Is2.boolean(candidate.workDoneProgress);
      }
      WorkDoneProgressOptions2.hasWorkDoneProgress = hasWorkDoneProgress;
    })(WorkDoneProgressOptions || (exports.WorkDoneProgressOptions = WorkDoneProgressOptions = {}));
    var InitializeRequest;
    (function (InitializeRequest2) {
      InitializeRequest2.method = "initialize";
      InitializeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InitializeRequest2.type = new messages_1.ProtocolRequestType(InitializeRequest2.method);
    })(InitializeRequest || (exports.InitializeRequest = InitializeRequest = {}));
    var InitializeErrorCodes;
    (function (InitializeErrorCodes2) {
      InitializeErrorCodes2.unknownProtocolVersion = 1;
    })(InitializeErrorCodes || (exports.InitializeErrorCodes = InitializeErrorCodes = {}));
    var InitializedNotification;
    (function (InitializedNotification2) {
      InitializedNotification2.method = "initialized";
      InitializedNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      InitializedNotification2.type = new messages_1.ProtocolNotificationType(InitializedNotification2.method);
    })(InitializedNotification || (exports.InitializedNotification = InitializedNotification = {}));
    var ShutdownRequest;
    (function (ShutdownRequest2) {
      ShutdownRequest2.method = "shutdown";
      ShutdownRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ShutdownRequest2.type = new messages_1.ProtocolRequestType0(ShutdownRequest2.method);
    })(ShutdownRequest || (exports.ShutdownRequest = ShutdownRequest = {}));
    var ExitNotification;
    (function (ExitNotification2) {
      ExitNotification2.method = "exit";
      ExitNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      ExitNotification2.type = new messages_1.ProtocolNotificationType0(ExitNotification2.method);
    })(ExitNotification || (exports.ExitNotification = ExitNotification = {}));
    var DidChangeConfigurationNotification;
    (function (DidChangeConfigurationNotification2) {
      DidChangeConfigurationNotification2.method = "workspace/didChangeConfiguration";
      DidChangeConfigurationNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeConfigurationNotification2.type = new messages_1.ProtocolNotificationType(DidChangeConfigurationNotification2.method);
    })(DidChangeConfigurationNotification || (exports.DidChangeConfigurationNotification = DidChangeConfigurationNotification = {}));
    var MessageType;
    (function (MessageType2) {
      MessageType2.Error = 1;
      MessageType2.Warning = 2;
      MessageType2.Info = 3;
      MessageType2.Log = 4;
      MessageType2.Debug = 5;
    })(MessageType || (exports.MessageType = MessageType = {}));
    var ShowMessageNotification;
    (function (ShowMessageNotification2) {
      ShowMessageNotification2.method = "window/showMessage";
      ShowMessageNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
      ShowMessageNotification2.type = new messages_1.ProtocolNotificationType(ShowMessageNotification2.method);
    })(ShowMessageNotification || (exports.ShowMessageNotification = ShowMessageNotification = {}));
    var ShowMessageRequest;
    (function (ShowMessageRequest2) {
      ShowMessageRequest2.method = "window/showMessageRequest";
      ShowMessageRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      ShowMessageRequest2.type = new messages_1.ProtocolRequestType(ShowMessageRequest2.method);
    })(ShowMessageRequest || (exports.ShowMessageRequest = ShowMessageRequest = {}));
    var LogMessageNotification;
    (function (LogMessageNotification2) {
      LogMessageNotification2.method = "window/logMessage";
      LogMessageNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
      LogMessageNotification2.type = new messages_1.ProtocolNotificationType(LogMessageNotification2.method);
    })(LogMessageNotification || (exports.LogMessageNotification = LogMessageNotification = {}));
    var TelemetryEventNotification;
    (function (TelemetryEventNotification2) {
      TelemetryEventNotification2.method = "telemetry/event";
      TelemetryEventNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
      TelemetryEventNotification2.type = new messages_1.ProtocolNotificationType(TelemetryEventNotification2.method);
    })(TelemetryEventNotification || (exports.TelemetryEventNotification = TelemetryEventNotification = {}));
    var TextDocumentSyncKind2;
    (function (TextDocumentSyncKind3) {
      TextDocumentSyncKind3.None = 0;
      TextDocumentSyncKind3.Full = 1;
      TextDocumentSyncKind3.Incremental = 2;
    })(TextDocumentSyncKind2 || (exports.TextDocumentSyncKind = TextDocumentSyncKind2 = {}));
    var DidOpenTextDocumentNotification;
    (function (DidOpenTextDocumentNotification2) {
      DidOpenTextDocumentNotification2.method = "textDocument/didOpen";
      DidOpenTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidOpenTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification2.method);
    })(DidOpenTextDocumentNotification || (exports.DidOpenTextDocumentNotification = DidOpenTextDocumentNotification = {}));
    var TextDocumentContentChangeEvent;
    (function (TextDocumentContentChangeEvent2) {
      function isIncremental(event) {
        let candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range !== void 0 && (candidate.rangeLength === void 0 || typeof candidate.rangeLength === "number");
      }
      TextDocumentContentChangeEvent2.isIncremental = isIncremental;
      function isFull(event) {
        let candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range === void 0 && candidate.rangeLength === void 0;
      }
      TextDocumentContentChangeEvent2.isFull = isFull;
    })(TextDocumentContentChangeEvent || (exports.TextDocumentContentChangeEvent = TextDocumentContentChangeEvent = {}));
    var DidChangeTextDocumentNotification;
    (function (DidChangeTextDocumentNotification2) {
      DidChangeTextDocumentNotification2.method = "textDocument/didChange";
      DidChangeTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification2.method);
    })(DidChangeTextDocumentNotification || (exports.DidChangeTextDocumentNotification = DidChangeTextDocumentNotification = {}));
    var DidCloseTextDocumentNotification;
    (function (DidCloseTextDocumentNotification2) {
      DidCloseTextDocumentNotification2.method = "textDocument/didClose";
      DidCloseTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidCloseTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification2.method);
    })(DidCloseTextDocumentNotification || (exports.DidCloseTextDocumentNotification = DidCloseTextDocumentNotification = {}));
    var DidSaveTextDocumentNotification;
    (function (DidSaveTextDocumentNotification2) {
      DidSaveTextDocumentNotification2.method = "textDocument/didSave";
      DidSaveTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidSaveTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification2.method);
    })(DidSaveTextDocumentNotification || (exports.DidSaveTextDocumentNotification = DidSaveTextDocumentNotification = {}));
    var TextDocumentSaveReason;
    (function (TextDocumentSaveReason2) {
      TextDocumentSaveReason2.Manual = 1;
      TextDocumentSaveReason2.AfterDelay = 2;
      TextDocumentSaveReason2.FocusOut = 3;
    })(TextDocumentSaveReason || (exports.TextDocumentSaveReason = TextDocumentSaveReason = {}));
    var WillSaveTextDocumentNotification;
    (function (WillSaveTextDocumentNotification2) {
      WillSaveTextDocumentNotification2.method = "textDocument/willSave";
      WillSaveTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillSaveTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification2.method);
    })(WillSaveTextDocumentNotification || (exports.WillSaveTextDocumentNotification = WillSaveTextDocumentNotification = {}));
    var WillSaveTextDocumentWaitUntilRequest;
    (function (WillSaveTextDocumentWaitUntilRequest2) {
      WillSaveTextDocumentWaitUntilRequest2.method = "textDocument/willSaveWaitUntil";
      WillSaveTextDocumentWaitUntilRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillSaveTextDocumentWaitUntilRequest2.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest2.method);
    })(WillSaveTextDocumentWaitUntilRequest || (exports.WillSaveTextDocumentWaitUntilRequest = WillSaveTextDocumentWaitUntilRequest = {}));
    var DidChangeWatchedFilesNotification;
    (function (DidChangeWatchedFilesNotification2) {
      DidChangeWatchedFilesNotification2.method = "workspace/didChangeWatchedFiles";
      DidChangeWatchedFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeWatchedFilesNotification2.type = new messages_1.ProtocolNotificationType(DidChangeWatchedFilesNotification2.method);
    })(DidChangeWatchedFilesNotification || (exports.DidChangeWatchedFilesNotification = DidChangeWatchedFilesNotification = {}));
    var FileChangeType;
    (function (FileChangeType2) {
      FileChangeType2.Created = 1;
      FileChangeType2.Changed = 2;
      FileChangeType2.Deleted = 3;
    })(FileChangeType || (exports.FileChangeType = FileChangeType = {}));
    var RelativePattern;
    (function (RelativePattern2) {
      function is(value) {
        const candidate = value;
        return Is2.objectLiteral(candidate) && (vscode_languageserver_types_1.URI.is(candidate.baseUri) || vscode_languageserver_types_1.WorkspaceFolder.is(candidate.baseUri)) && Is2.string(candidate.pattern);
      }
      RelativePattern2.is = is;
    })(RelativePattern || (exports.RelativePattern = RelativePattern = {}));
    var WatchKind;
    (function (WatchKind2) {
      WatchKind2.Create = 1;
      WatchKind2.Change = 2;
      WatchKind2.Delete = 4;
    })(WatchKind || (exports.WatchKind = WatchKind = {}));
    var PublishDiagnosticsNotification;
    (function (PublishDiagnosticsNotification2) {
      PublishDiagnosticsNotification2.method = "textDocument/publishDiagnostics";
      PublishDiagnosticsNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
      PublishDiagnosticsNotification2.type = new messages_1.ProtocolNotificationType(PublishDiagnosticsNotification2.method);
    })(PublishDiagnosticsNotification || (exports.PublishDiagnosticsNotification = PublishDiagnosticsNotification = {}));
    var CompletionTriggerKind;
    (function (CompletionTriggerKind2) {
      CompletionTriggerKind2.Invoked = 1;
      CompletionTriggerKind2.TriggerCharacter = 2;
      CompletionTriggerKind2.TriggerForIncompleteCompletions = 3;
    })(CompletionTriggerKind || (exports.CompletionTriggerKind = CompletionTriggerKind = {}));
    var CompletionRequest;
    (function (CompletionRequest2) {
      CompletionRequest2.method = "textDocument/completion";
      CompletionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CompletionRequest2.type = new messages_1.ProtocolRequestType(CompletionRequest2.method);
    })(CompletionRequest || (exports.CompletionRequest = CompletionRequest = {}));
    var CompletionResolveRequest;
    (function (CompletionResolveRequest2) {
      CompletionResolveRequest2.method = "completionItem/resolve";
      CompletionResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CompletionResolveRequest2.type = new messages_1.ProtocolRequestType(CompletionResolveRequest2.method);
    })(CompletionResolveRequest || (exports.CompletionResolveRequest = CompletionResolveRequest = {}));
    var HoverRequest;
    (function (HoverRequest2) {
      HoverRequest2.method = "textDocument/hover";
      HoverRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      HoverRequest2.type = new messages_1.ProtocolRequestType(HoverRequest2.method);
    })(HoverRequest || (exports.HoverRequest = HoverRequest = {}));
    var SignatureHelpTriggerKind;
    (function (SignatureHelpTriggerKind2) {
      SignatureHelpTriggerKind2.Invoked = 1;
      SignatureHelpTriggerKind2.TriggerCharacter = 2;
      SignatureHelpTriggerKind2.ContentChange = 3;
    })(SignatureHelpTriggerKind || (exports.SignatureHelpTriggerKind = SignatureHelpTriggerKind = {}));
    var SignatureHelpRequest;
    (function (SignatureHelpRequest2) {
      SignatureHelpRequest2.method = "textDocument/signatureHelp";
      SignatureHelpRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SignatureHelpRequest2.type = new messages_1.ProtocolRequestType(SignatureHelpRequest2.method);
    })(SignatureHelpRequest || (exports.SignatureHelpRequest = SignatureHelpRequest = {}));
    var DefinitionRequest;
    (function (DefinitionRequest2) {
      DefinitionRequest2.method = "textDocument/definition";
      DefinitionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DefinitionRequest2.type = new messages_1.ProtocolRequestType(DefinitionRequest2.method);
    })(DefinitionRequest || (exports.DefinitionRequest = DefinitionRequest = {}));
    var ReferencesRequest;
    (function (ReferencesRequest2) {
      ReferencesRequest2.method = "textDocument/references";
      ReferencesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ReferencesRequest2.type = new messages_1.ProtocolRequestType(ReferencesRequest2.method);
    })(ReferencesRequest || (exports.ReferencesRequest = ReferencesRequest = {}));
    var DocumentHighlightRequest;
    (function (DocumentHighlightRequest2) {
      DocumentHighlightRequest2.method = "textDocument/documentHighlight";
      DocumentHighlightRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentHighlightRequest2.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest2.method);
    })(DocumentHighlightRequest || (exports.DocumentHighlightRequest = DocumentHighlightRequest = {}));
    var DocumentSymbolRequest;
    (function (DocumentSymbolRequest2) {
      DocumentSymbolRequest2.method = "textDocument/documentSymbol";
      DocumentSymbolRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentSymbolRequest2.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest2.method);
    })(DocumentSymbolRequest || (exports.DocumentSymbolRequest = DocumentSymbolRequest = {}));
    var CodeActionRequest;
    (function (CodeActionRequest2) {
      CodeActionRequest2.method = "textDocument/codeAction";
      CodeActionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeActionRequest2.type = new messages_1.ProtocolRequestType(CodeActionRequest2.method);
    })(CodeActionRequest || (exports.CodeActionRequest = CodeActionRequest = {}));
    var CodeActionResolveRequest;
    (function (CodeActionResolveRequest2) {
      CodeActionResolveRequest2.method = "codeAction/resolve";
      CodeActionResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeActionResolveRequest2.type = new messages_1.ProtocolRequestType(CodeActionResolveRequest2.method);
    })(CodeActionResolveRequest || (exports.CodeActionResolveRequest = CodeActionResolveRequest = {}));
    var WorkspaceSymbolRequest;
    (function (WorkspaceSymbolRequest2) {
      WorkspaceSymbolRequest2.method = "workspace/symbol";
      WorkspaceSymbolRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkspaceSymbolRequest2.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest2.method);
    })(WorkspaceSymbolRequest || (exports.WorkspaceSymbolRequest = WorkspaceSymbolRequest = {}));
    var WorkspaceSymbolResolveRequest;
    (function (WorkspaceSymbolResolveRequest2) {
      WorkspaceSymbolResolveRequest2.method = "workspaceSymbol/resolve";
      WorkspaceSymbolResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkspaceSymbolResolveRequest2.type = new messages_1.ProtocolRequestType(WorkspaceSymbolResolveRequest2.method);
    })(WorkspaceSymbolResolveRequest || (exports.WorkspaceSymbolResolveRequest = WorkspaceSymbolResolveRequest = {}));
    var CodeLensRequest;
    (function (CodeLensRequest2) {
      CodeLensRequest2.method = "textDocument/codeLens";
      CodeLensRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeLensRequest2.type = new messages_1.ProtocolRequestType(CodeLensRequest2.method);
    })(CodeLensRequest || (exports.CodeLensRequest = CodeLensRequest = {}));
    var CodeLensResolveRequest;
    (function (CodeLensResolveRequest2) {
      CodeLensResolveRequest2.method = "codeLens/resolve";
      CodeLensResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeLensResolveRequest2.type = new messages_1.ProtocolRequestType(CodeLensResolveRequest2.method);
    })(CodeLensResolveRequest || (exports.CodeLensResolveRequest = CodeLensResolveRequest = {}));
    var CodeLensRefreshRequest;
    (function (CodeLensRefreshRequest2) {
      CodeLensRefreshRequest2.method = `workspace/codeLens/refresh`;
      CodeLensRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      CodeLensRefreshRequest2.type = new messages_1.ProtocolRequestType0(CodeLensRefreshRequest2.method);
    })(CodeLensRefreshRequest || (exports.CodeLensRefreshRequest = CodeLensRefreshRequest = {}));
    var DocumentLinkRequest;
    (function (DocumentLinkRequest2) {
      DocumentLinkRequest2.method = "textDocument/documentLink";
      DocumentLinkRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentLinkRequest2.type = new messages_1.ProtocolRequestType(DocumentLinkRequest2.method);
    })(DocumentLinkRequest || (exports.DocumentLinkRequest = DocumentLinkRequest = {}));
    var DocumentLinkResolveRequest;
    (function (DocumentLinkResolveRequest2) {
      DocumentLinkResolveRequest2.method = "documentLink/resolve";
      DocumentLinkResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentLinkResolveRequest2.type = new messages_1.ProtocolRequestType(DocumentLinkResolveRequest2.method);
    })(DocumentLinkResolveRequest || (exports.DocumentLinkResolveRequest = DocumentLinkResolveRequest = {}));
    var DocumentFormattingRequest;
    (function (DocumentFormattingRequest2) {
      DocumentFormattingRequest2.method = "textDocument/formatting";
      DocumentFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest2.method);
    })(DocumentFormattingRequest || (exports.DocumentFormattingRequest = DocumentFormattingRequest = {}));
    var DocumentRangeFormattingRequest;
    (function (DocumentRangeFormattingRequest2) {
      DocumentRangeFormattingRequest2.method = "textDocument/rangeFormatting";
      DocumentRangeFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentRangeFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest2.method);
    })(DocumentRangeFormattingRequest || (exports.DocumentRangeFormattingRequest = DocumentRangeFormattingRequest = {}));
    var DocumentRangesFormattingRequest;
    (function (DocumentRangesFormattingRequest2) {
      DocumentRangesFormattingRequest2.method = "textDocument/rangesFormatting";
      DocumentRangesFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentRangesFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentRangesFormattingRequest2.method);
    })(DocumentRangesFormattingRequest || (exports.DocumentRangesFormattingRequest = DocumentRangesFormattingRequest = {}));
    var DocumentOnTypeFormattingRequest;
    (function (DocumentOnTypeFormattingRequest2) {
      DocumentOnTypeFormattingRequest2.method = "textDocument/onTypeFormatting";
      DocumentOnTypeFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentOnTypeFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest2.method);
    })(DocumentOnTypeFormattingRequest || (exports.DocumentOnTypeFormattingRequest = DocumentOnTypeFormattingRequest = {}));
    var PrepareSupportDefaultBehavior;
    (function (PrepareSupportDefaultBehavior2) {
      PrepareSupportDefaultBehavior2.Identifier = 1;
    })(PrepareSupportDefaultBehavior || (exports.PrepareSupportDefaultBehavior = PrepareSupportDefaultBehavior = {}));
    var RenameRequest;
    (function (RenameRequest2) {
      RenameRequest2.method = "textDocument/rename";
      RenameRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      RenameRequest2.type = new messages_1.ProtocolRequestType(RenameRequest2.method);
    })(RenameRequest || (exports.RenameRequest = RenameRequest = {}));
    var PrepareRenameRequest;
    (function (PrepareRenameRequest2) {
      PrepareRenameRequest2.method = "textDocument/prepareRename";
      PrepareRenameRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      PrepareRenameRequest2.type = new messages_1.ProtocolRequestType(PrepareRenameRequest2.method);
    })(PrepareRenameRequest || (exports.PrepareRenameRequest = PrepareRenameRequest = {}));
    var ExecuteCommandRequest;
    (function (ExecuteCommandRequest2) {
      ExecuteCommandRequest2.method = "workspace/executeCommand";
      ExecuteCommandRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ExecuteCommandRequest2.type = new messages_1.ProtocolRequestType(ExecuteCommandRequest2.method);
    })(ExecuteCommandRequest || (exports.ExecuteCommandRequest = ExecuteCommandRequest = {}));
    var ApplyWorkspaceEditRequest;
    (function (ApplyWorkspaceEditRequest2) {
      ApplyWorkspaceEditRequest2.method = "workspace/applyEdit";
      ApplyWorkspaceEditRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      ApplyWorkspaceEditRequest2.type = new messages_1.ProtocolRequestType("workspace/applyEdit");
    })(ApplyWorkspaceEditRequest || (exports.ApplyWorkspaceEditRequest = ApplyWorkspaceEditRequest = {}));
  }
});

// server/node_modules/vscode-languageserver-protocol/lib/common/connection.js
var require_connection2 = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/lib/common/connection.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createProtocolConnection = void 0;
    var vscode_jsonrpc_1 = require_main();
    function createProtocolConnection(input, output, logger, options) {
      if (vscode_jsonrpc_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
      }
      return (0, vscode_jsonrpc_1.createMessageConnection)(input, output, logger, options);
    }
    exports.createProtocolConnection = createProtocolConnection;
  }
});

// server/node_modules/vscode-languageserver-protocol/lib/common/api.js
var require_api2 = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/lib/common/api.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true, get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function (m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LSPErrorCodes = exports.createProtocolConnection = void 0;
    __exportStar(require_main(), exports);
    __exportStar((init_main(), __toCommonJS(main_exports)), exports);
    __exportStar(require_messages2(), exports);
    __exportStar(require_protocol(), exports);
    var connection_1 = require_connection2();
    Object.defineProperty(exports, "createProtocolConnection", {
      enumerable: true, get: function () {
        return connection_1.createProtocolConnection;
      }
    });
    var LSPErrorCodes;
    (function (LSPErrorCodes2) {
      LSPErrorCodes2.lspReservedErrorRangeStart = -32899;
      LSPErrorCodes2.RequestFailed = -32803;
      LSPErrorCodes2.ServerCancelled = -32802;
      LSPErrorCodes2.ContentModified = -32801;
      LSPErrorCodes2.RequestCancelled = -32800;
      LSPErrorCodes2.lspReservedErrorRangeEnd = -32800;
    })(LSPErrorCodes || (exports.LSPErrorCodes = LSPErrorCodes = {}));
  }
});

// server/node_modules/vscode-languageserver-protocol/lib/browser/main.js
var require_main2 = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/lib/browser/main.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true, get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function (m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createProtocolConnection = void 0;
    var browser_1 = require_browser();
    __exportStar(require_browser(), exports);
    __exportStar(require_api2(), exports);
    function createProtocolConnection(reader, writer, logger, options) {
      return (0, browser_1.createMessageConnection)(reader, writer, logger, options);
    }
    exports.createProtocolConnection = createProtocolConnection;
  }
});

// server/node_modules/vscode-languageserver/lib/common/semanticTokens.js
var require_semanticTokens = __commonJS({
  "server/node_modules/vscode-languageserver/lib/common/semanticTokens.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SemanticTokensBuilder = exports.SemanticTokensDiff = exports.SemanticTokensFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main2();
    var SemanticTokensFeature = (Base) => {
      return class extends Base {
        get semanticTokens() {
          return {
            refresh: () => {
              return this.connection.sendRequest(vscode_languageserver_protocol_1.SemanticTokensRefreshRequest.type);
            },
            on: (handler) => {
              const type = vscode_languageserver_protocol_1.SemanticTokensRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            },
            onDelta: (handler) => {
              const type = vscode_languageserver_protocol_1.SemanticTokensDeltaRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            },
            onRange: (handler) => {
              const type = vscode_languageserver_protocol_1.SemanticTokensRangeRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            }
          };
        }
      };
    };
    exports.SemanticTokensFeature = SemanticTokensFeature;
    var SemanticTokensDiff = class {
      constructor(originalSequence, modifiedSequence) {
        this.originalSequence = originalSequence;
        this.modifiedSequence = modifiedSequence;
      }
      computeDiff() {
        const originalLength = this.originalSequence.length;
        const modifiedLength = this.modifiedSequence.length;
        let startIndex = 0;
        while (startIndex < modifiedLength && startIndex < originalLength && this.originalSequence[startIndex] === this.modifiedSequence[startIndex]) {
          startIndex++;
        }
        if (startIndex < modifiedLength && startIndex < originalLength) {
          let originalEndIndex = originalLength - 1;
          let modifiedEndIndex = modifiedLength - 1;
          while (originalEndIndex >= startIndex && modifiedEndIndex >= startIndex && this.originalSequence[originalEndIndex] === this.modifiedSequence[modifiedEndIndex]) {
            originalEndIndex--;
            modifiedEndIndex--;
          }
          if (originalEndIndex < startIndex || modifiedEndIndex < startIndex) {
            originalEndIndex++;
            modifiedEndIndex++;
          }
          const deleteCount = originalEndIndex - startIndex + 1;
          const newData = this.modifiedSequence.slice(startIndex, modifiedEndIndex + 1);
          if (newData.length === 1 && newData[0] === this.originalSequence[originalEndIndex]) {
            return [
              { start: startIndex, deleteCount: deleteCount - 1 }
            ];
          } else {
            return [
              { start: startIndex, deleteCount, data: newData }
            ];
          }
        } else if (startIndex < modifiedLength) {
          return [
            { start: startIndex, deleteCount: 0, data: this.modifiedSequence.slice(startIndex) }
          ];
        } else if (startIndex < originalLength) {
          return [
            { start: startIndex, deleteCount: originalLength - startIndex }
          ];
        } else {
          return [];
        }
      }
    };
    exports.SemanticTokensDiff = SemanticTokensDiff;
    var SemanticTokensBuilder = class {
      constructor() {
        this._prevData = void 0;
        this.initialize();
      }
      initialize() {
        this._id = Date.now();
        this._prevLine = 0;
        this._prevChar = 0;
        this._data = [];
        this._dataLen = 0;
      }
      push(line, char, length, tokenType, tokenModifiers) {
        let pushLine = line;
        let pushChar = char;
        if (this._dataLen > 0) {
          pushLine -= this._prevLine;
          if (pushLine === 0) {
            pushChar -= this._prevChar;
          }
        }
        this._data[this._dataLen++] = pushLine;
        this._data[this._dataLen++] = pushChar;
        this._data[this._dataLen++] = length;
        this._data[this._dataLen++] = tokenType;
        this._data[this._dataLen++] = tokenModifiers;
        this._prevLine = line;
        this._prevChar = char;
      }
      get id() {
        return this._id.toString();
      }
      previousResult(id) {
        if (this.id === id) {
          this._prevData = this._data;
        }
        this.initialize();
      }
      build() {
        this._prevData = void 0;
        return {
          resultId: this.id,
          data: this._data
        };
      }
      canBuildEdits() {
        return this._prevData !== void 0;
      }
      buildEdits() {
        if (this._prevData !== void 0) {
          return {
            resultId: this.id,
            edits: new SemanticTokensDiff(this._prevData, this._data).computeDiff()
          };
        } else {
          return this.build();
        }
      }
    };
    exports.SemanticTokensBuilder = SemanticTokensBuilder;
  }
});

// server/node_modules/vscode-languageserver/lib/common/inlineCompletion.proposed.js
var require_inlineCompletion_proposed = __commonJS({
  "server/node_modules/vscode-languageserver/lib/common/inlineCompletion.proposed.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InlineCompletionFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main2();
    var InlineCompletionFeature = (Base) => {
      return class extends Base {
        get inlineCompletion() {
          return {
            on: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.InlineCompletionRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params));
              });
            }
          };
        }
      };
    };
    exports.InlineCompletionFeature = InlineCompletionFeature;
  }
});

// server/node_modules/vscode-languageserver/lib/common/textDocuments.js
var require_textDocuments = __commonJS({
  "server/node_modules/vscode-languageserver/lib/common/textDocuments.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TextDocuments = void 0;
    var vscode_languageserver_protocol_1 = require_main2();
    var TextDocuments2 = class {
      /**
       * Create a new text document manager.
       */
      constructor(configuration) {
        this._configuration = configuration;
        this._syncedDocuments = /* @__PURE__ */ new Map();
        this._onDidChangeContent = new vscode_languageserver_protocol_1.Emitter();
        this._onDidOpen = new vscode_languageserver_protocol_1.Emitter();
        this._onDidClose = new vscode_languageserver_protocol_1.Emitter();
        this._onDidSave = new vscode_languageserver_protocol_1.Emitter();
        this._onWillSave = new vscode_languageserver_protocol_1.Emitter();
      }
      /**
       * An event that fires when a text document managed by this manager
       * has been opened.
       */
      get onDidOpen() {
        return this._onDidOpen.event;
      }
      /**
       * An event that fires when a text document managed by this manager
       * has been opened or the content changes.
       */
      get onDidChangeContent() {
        return this._onDidChangeContent.event;
      }
      /**
       * An event that fires when a text document managed by this manager
       * will be saved.
       */
      get onWillSave() {
        return this._onWillSave.event;
      }
      /**
       * Sets a handler that will be called if a participant wants to provide
       * edits during a text document save.
       */
      onWillSaveWaitUntil(handler) {
        this._willSaveWaitUntil = handler;
      }
      /**
       * An event that fires when a text document managed by this manager
       * has been saved.
       */
      get onDidSave() {
        return this._onDidSave.event;
      }
      /**
       * An event that fires when a text document managed by this manager
       * has been closed.
       */
      get onDidClose() {
        return this._onDidClose.event;
      }
      /**
       * Returns the document for the given URI. Returns undefined if
       * the document is not managed by this instance.
       *
       * @param uri The text document's URI to retrieve.
       * @return the text document or `undefined`.
       */
      get(uri) {
        return this._syncedDocuments.get(uri);
      }
      /**
       * Returns all text documents managed by this instance.
       *
       * @return all text documents.
       */
      all() {
        return Array.from(this._syncedDocuments.values());
      }
      /**
       * Returns the URIs of all text documents managed by this instance.
       *
       * @return the URI's of all text documents.
       */
      keys() {
        return Array.from(this._syncedDocuments.keys());
      }
      /**
       * Listens for `low level` notification on the given connection to
       * update the text documents managed by this instance.
       *
       * Please note that the connection only provides handlers not an event model. Therefore
       * listening on a connection will overwrite the following handlers on a connection:
       * `onDidOpenTextDocument`, `onDidChangeTextDocument`, `onDidCloseTextDocument`,
       * `onWillSaveTextDocument`, `onWillSaveTextDocumentWaitUntil` and `onDidSaveTextDocument`.
       *
       * Use the corresponding events on the TextDocuments instance instead.
       *
       * @param connection The connection to listen on.
       */
      listen(connection2) {
        connection2.__textDocumentSync = vscode_languageserver_protocol_1.TextDocumentSyncKind.Incremental;
        const disposables = [];
        disposables.push(connection2.onDidOpenTextDocument((event) => {
          const td = event.textDocument;
          const document2 = this._configuration.create(td.uri, td.languageId, td.version, td.text);
          this._syncedDocuments.set(td.uri, document2);
          const toFire = Object.freeze({ document: document2 });
          this._onDidOpen.fire(toFire);
          this._onDidChangeContent.fire(toFire);
        }));
        disposables.push(connection2.onDidChangeTextDocument((event) => {
          const td = event.textDocument;
          const changes = event.contentChanges;
          if (changes.length === 0) {
            return;
          }
          const { version } = td;
          if (version === null || version === void 0) {
            throw new Error(`Received document change event for ${td.uri} without valid version identifier`);
          }
          let syncedDocument = this._syncedDocuments.get(td.uri);
          if (syncedDocument !== void 0) {
            syncedDocument = this._configuration.update(syncedDocument, changes, version);
            this._syncedDocuments.set(td.uri, syncedDocument);
            this._onDidChangeContent.fire(Object.freeze({ document: syncedDocument }));
          }
        }));
        disposables.push(connection2.onDidCloseTextDocument((event) => {
          let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
          if (syncedDocument !== void 0) {
            this._syncedDocuments.delete(event.textDocument.uri);
            this._onDidClose.fire(Object.freeze({ document: syncedDocument }));
          }
        }));
        disposables.push(connection2.onWillSaveTextDocument((event) => {
          let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
          if (syncedDocument !== void 0) {
            this._onWillSave.fire(Object.freeze({ document: syncedDocument, reason: event.reason }));
          }
        }));
        disposables.push(connection2.onWillSaveTextDocumentWaitUntil((event, token) => {
          let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
          if (syncedDocument !== void 0 && this._willSaveWaitUntil) {
            return this._willSaveWaitUntil(Object.freeze({ document: syncedDocument, reason: event.reason }), token);
          } else {
            return [];
          }
        }));
        disposables.push(connection2.onDidSaveTextDocument((event) => {
          let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
          if (syncedDocument !== void 0) {
            this._onDidSave.fire(Object.freeze({ document: syncedDocument }));
          }
        }));
        return vscode_languageserver_protocol_1.Disposable.create(() => {
          disposables.forEach((disposable) => disposable.dispose());
        });
      }
    };
    exports.TextDocuments = TextDocuments2;
  }
});

// server/node_modules/vscode-languageserver/lib/common/notebook.js
var require_notebook = __commonJS({
  "server/node_modules/vscode-languageserver/lib/common/notebook.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NotebookDocuments = exports.NotebookSyncFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main2();
    var textDocuments_1 = require_textDocuments();
    var NotebookSyncFeature = (Base) => {
      return class extends Base {
        get synchronization() {
          return {
            onDidOpenNotebookDocument: (handler) => {
              return this.connection.onNotification(vscode_languageserver_protocol_1.DidOpenNotebookDocumentNotification.type, (params) => {
                handler(params);
              });
            },
            onDidChangeNotebookDocument: (handler) => {
              return this.connection.onNotification(vscode_languageserver_protocol_1.DidChangeNotebookDocumentNotification.type, (params) => {
                handler(params);
              });
            },
            onDidSaveNotebookDocument: (handler) => {
              return this.connection.onNotification(vscode_languageserver_protocol_1.DidSaveNotebookDocumentNotification.type, (params) => {
                handler(params);
              });
            },
            onDidCloseNotebookDocument: (handler) => {
              return this.connection.onNotification(vscode_languageserver_protocol_1.DidCloseNotebookDocumentNotification.type, (params) => {
                handler(params);
              });
            }
          };
        }
      };
    };
    exports.NotebookSyncFeature = NotebookSyncFeature;
    var CellTextDocumentConnection = class _CellTextDocumentConnection {
      onDidOpenTextDocument(handler) {
        this.openHandler = handler;
        return vscode_languageserver_protocol_1.Disposable.create(() => {
          this.openHandler = void 0;
        });
      }
      openTextDocument(params) {
        this.openHandler && this.openHandler(params);
      }
      onDidChangeTextDocument(handler) {
        this.changeHandler = handler;
        return vscode_languageserver_protocol_1.Disposable.create(() => {
          this.changeHandler = handler;
        });
      }
      changeTextDocument(params) {
        this.changeHandler && this.changeHandler(params);
      }
      onDidCloseTextDocument(handler) {
        this.closeHandler = handler;
        return vscode_languageserver_protocol_1.Disposable.create(() => {
          this.closeHandler = void 0;
        });
      }
      closeTextDocument(params) {
        this.closeHandler && this.closeHandler(params);
      }
      onWillSaveTextDocument() {
        return _CellTextDocumentConnection.NULL_DISPOSE;
      }
      onWillSaveTextDocumentWaitUntil() {
        return _CellTextDocumentConnection.NULL_DISPOSE;
      }
      onDidSaveTextDocument() {
        return _CellTextDocumentConnection.NULL_DISPOSE;
      }
    };
    CellTextDocumentConnection.NULL_DISPOSE = Object.freeze({
      dispose: () => {
      }
    });
    var NotebookDocuments = class {
      constructor(configurationOrTextDocuments) {
        if (configurationOrTextDocuments instanceof textDocuments_1.TextDocuments) {
          this._cellTextDocuments = configurationOrTextDocuments;
        } else {
          this._cellTextDocuments = new textDocuments_1.TextDocuments(configurationOrTextDocuments);
        }
        this.notebookDocuments = /* @__PURE__ */ new Map();
        this.notebookCellMap = /* @__PURE__ */ new Map();
        this._onDidOpen = new vscode_languageserver_protocol_1.Emitter();
        this._onDidChange = new vscode_languageserver_protocol_1.Emitter();
        this._onDidSave = new vscode_languageserver_protocol_1.Emitter();
        this._onDidClose = new vscode_languageserver_protocol_1.Emitter();
      }
      get cellTextDocuments() {
        return this._cellTextDocuments;
      }
      getCellTextDocument(cell) {
        return this._cellTextDocuments.get(cell.document);
      }
      getNotebookDocument(uri) {
        return this.notebookDocuments.get(uri);
      }
      getNotebookCell(uri) {
        const value = this.notebookCellMap.get(uri);
        return value && value[0];
      }
      findNotebookDocumentForCell(cell) {
        const key = typeof cell === "string" ? cell : cell.document;
        const value = this.notebookCellMap.get(key);
        return value && value[1];
      }
      get onDidOpen() {
        return this._onDidOpen.event;
      }
      get onDidSave() {
        return this._onDidSave.event;
      }
      get onDidChange() {
        return this._onDidChange.event;
      }
      get onDidClose() {
        return this._onDidClose.event;
      }
      /**
       * Listens for `low level` notification on the given connection to
       * update the notebook documents managed by this instance.
       *
       * Please note that the connection only provides handlers not an event model. Therefore
       * listening on a connection will overwrite the following handlers on a connection:
       * `onDidOpenNotebookDocument`, `onDidChangeNotebookDocument`, `onDidSaveNotebookDocument`,
       *  and `onDidCloseNotebookDocument`.
       *
       * @param connection The connection to listen on.
       */
      listen(connection2) {
        const cellTextDocumentConnection = new CellTextDocumentConnection();
        const disposables = [];
        disposables.push(this.cellTextDocuments.listen(cellTextDocumentConnection));
        disposables.push(connection2.notebooks.synchronization.onDidOpenNotebookDocument((params) => {
          this.notebookDocuments.set(params.notebookDocument.uri, params.notebookDocument);
          for (const cellTextDocument of params.cellTextDocuments) {
            cellTextDocumentConnection.openTextDocument({ textDocument: cellTextDocument });
          }
          this.updateCellMap(params.notebookDocument);
          this._onDidOpen.fire(params.notebookDocument);
        }));
        disposables.push(connection2.notebooks.synchronization.onDidChangeNotebookDocument((params) => {
          const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);
          if (notebookDocument === void 0) {
            return;
          }
          notebookDocument.version = params.notebookDocument.version;
          const oldMetadata = notebookDocument.metadata;
          let metadataChanged = false;
          const change = params.change;
          if (change.metadata !== void 0) {
            metadataChanged = true;
            notebookDocument.metadata = change.metadata;
          }
          const opened = [];
          const closed = [];
          const data = [];
          const text = [];
          if (change.cells !== void 0) {
            const changedCells = change.cells;
            if (changedCells.structure !== void 0) {
              const array = changedCells.structure.array;
              notebookDocument.cells.splice(array.start, array.deleteCount, ...array.cells !== void 0 ? array.cells : []);
              if (changedCells.structure.didOpen !== void 0) {
                for (const open of changedCells.structure.didOpen) {
                  cellTextDocumentConnection.openTextDocument({ textDocument: open });
                  opened.push(open.uri);
                }
              }
              if (changedCells.structure.didClose) {
                for (const close of changedCells.structure.didClose) {
                  cellTextDocumentConnection.closeTextDocument({ textDocument: close });
                  closed.push(close.uri);
                }
              }
            }
            if (changedCells.data !== void 0) {
              const cellUpdates = new Map(changedCells.data.map((cell) => [cell.document, cell]));
              for (let i = 0; i <= notebookDocument.cells.length; i++) {
                const change2 = cellUpdates.get(notebookDocument.cells[i].document);
                if (change2 !== void 0) {
                  const old = notebookDocument.cells.splice(i, 1, change2);
                  data.push({ old: old[0], new: change2 });
                  cellUpdates.delete(change2.document);
                  if (cellUpdates.size === 0) {
                    break;
                  }
                }
              }
            }
            if (changedCells.textContent !== void 0) {
              for (const cellTextDocument of changedCells.textContent) {
                cellTextDocumentConnection.changeTextDocument({ textDocument: cellTextDocument.document, contentChanges: cellTextDocument.changes });
                text.push(cellTextDocument.document.uri);
              }
            }
          }
          this.updateCellMap(notebookDocument);
          const changeEvent = { notebookDocument };
          if (metadataChanged) {
            changeEvent.metadata = { old: oldMetadata, new: notebookDocument.metadata };
          }
          const added = [];
          for (const open of opened) {
            added.push(this.getNotebookCell(open));
          }
          const removed = [];
          for (const close of closed) {
            removed.push(this.getNotebookCell(close));
          }
          const textContent = [];
          for (const change2 of text) {
            textContent.push(this.getNotebookCell(change2));
          }
          if (added.length > 0 || removed.length > 0 || data.length > 0 || textContent.length > 0) {
            changeEvent.cells = { added, removed, changed: { data, textContent } };
          }
          if (changeEvent.metadata !== void 0 || changeEvent.cells !== void 0) {
            this._onDidChange.fire(changeEvent);
          }
        }));
        disposables.push(connection2.notebooks.synchronization.onDidSaveNotebookDocument((params) => {
          const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);
          if (notebookDocument === void 0) {
            return;
          }
          this._onDidSave.fire(notebookDocument);
        }));
        disposables.push(connection2.notebooks.synchronization.onDidCloseNotebookDocument((params) => {
          const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);
          if (notebookDocument === void 0) {
            return;
          }
          this._onDidClose.fire(notebookDocument);
          for (const cellTextDocument of params.cellTextDocuments) {
            cellTextDocumentConnection.closeTextDocument({ textDocument: cellTextDocument });
          }
          this.notebookDocuments.delete(params.notebookDocument.uri);
          for (const cell of notebookDocument.cells) {
            this.notebookCellMap.delete(cell.document);
          }
        }));
        return vscode_languageserver_protocol_1.Disposable.create(() => {
          disposables.forEach((disposable) => disposable.dispose());
        });
      }
      updateCellMap(notebookDocument) {
        for (const cell of notebookDocument.cells) {
          this.notebookCellMap.set(cell.document, [cell, notebookDocument]);
        }
      }
    };
    exports.NotebookDocuments = NotebookDocuments;
  }
});

// server/node_modules/vscode-languageserver/lib/common/utils/is.js
var require_is3 = __commonJS({
  "server/node_modules/vscode-languageserver/lib/common/utils/is.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.thenable = exports.typedArray = exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;
    function boolean(value) {
      return value === true || value === false;
    }
    exports.boolean = boolean;
    function string(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports.string = string;
    function number(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports.number = number;
    function error(value) {
      return value instanceof Error;
    }
    exports.error = error;
    function func(value) {
      return typeof value === "function";
    }
    exports.func = func;
    function array(value) {
      return Array.isArray(value);
    }
    exports.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string(elem));
    }
    exports.stringArray = stringArray;
    function typedArray(value, check) {
      return Array.isArray(value) && value.every(check);
    }
    exports.typedArray = typedArray;
    function thenable(value) {
      return value && func(value.then);
    }
    exports.thenable = thenable;
  }
});

// server/node_modules/vscode-languageserver/lib/common/utils/uuid.js
var require_uuid = __commonJS({
  "server/node_modules/vscode-languageserver/lib/common/utils/uuid.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generateUuid = exports.parse = exports.isUUID = exports.v4 = exports.empty = void 0;
    var ValueUUID = class {
      constructor(_value) {
        this._value = _value;
      }
      asHex() {
        return this._value;
      }
      equals(other) {
        return this.asHex() === other.asHex();
      }
    };
    var V4UUID = class _V4UUID extends ValueUUID {
      static _oneOf(array) {
        return array[Math.floor(array.length * Math.random())];
      }
      static _randomHex() {
        return _V4UUID._oneOf(_V4UUID._chars);
      }
      constructor() {
        super([
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          "-",
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          "-",
          "4",
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          "-",
          _V4UUID._oneOf(_V4UUID._timeHighBits),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          "-",
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex()
        ].join(""));
      }
    };
    V4UUID._chars = ["0", "1", "2", "3", "4", "5", "6", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
    V4UUID._timeHighBits = ["8", "9", "a", "b"];
    exports.empty = new ValueUUID("00000000-0000-0000-0000-000000000000");
    function v4() {
      return new V4UUID();
    }
    exports.v4 = v4;
    var _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
    function isUUID(value) {
      return _UUIDPattern.test(value);
    }
    exports.isUUID = isUUID;
    function parse(value) {
      if (!isUUID(value)) {
        throw new Error("invalid uuid");
      }
      return new ValueUUID(value);
    }
    exports.parse = parse;
    function generateUuid() {
      return v4().asHex();
    }
    exports.generateUuid = generateUuid;
  }
});

// server/node_modules/vscode-languageserver/lib/common/progress.js
var require_progress = __commonJS({
  "server/node_modules/vscode-languageserver/lib/common/progress.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.attachPartialResult = exports.ProgressFeature = exports.attachWorkDone = void 0;
    var vscode_languageserver_protocol_1 = require_main2();
    var uuid_1 = require_uuid();
    var WorkDoneProgressReporterImpl = class _WorkDoneProgressReporterImpl {
      constructor(_connection, _token) {
        this._connection = _connection;
        this._token = _token;
        _WorkDoneProgressReporterImpl.Instances.set(this._token, this);
      }
      begin(title, percentage, message, cancellable) {
        let param = {
          kind: "begin",
          title,
          percentage,
          message,
          cancellable
        };
        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, param);
      }
      report(arg0, arg1) {
        let param = {
          kind: "report"
        };
        if (typeof arg0 === "number") {
          param.percentage = arg0;
          if (arg1 !== void 0) {
            param.message = arg1;
          }
        } else {
          param.message = arg0;
        }
        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, param);
      }
      done() {
        _WorkDoneProgressReporterImpl.Instances.delete(this._token);
        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, { kind: "end" });
      }
    };
    WorkDoneProgressReporterImpl.Instances = /* @__PURE__ */ new Map();
    var WorkDoneProgressServerReporterImpl = class extends WorkDoneProgressReporterImpl {
      constructor(connection2, token) {
        super(connection2, token);
        this._source = new vscode_languageserver_protocol_1.CancellationTokenSource();
      }
      get token() {
        return this._source.token;
      }
      done() {
        this._source.dispose();
        super.done();
      }
      cancel() {
        this._source.cancel();
      }
    };
    var NullProgressReporter = class {
      constructor() {
      }
      begin() {
      }
      report() {
      }
      done() {
      }
    };
    var NullProgressServerReporter = class extends NullProgressReporter {
      constructor() {
        super();
        this._source = new vscode_languageserver_protocol_1.CancellationTokenSource();
      }
      get token() {
        return this._source.token;
      }
      done() {
        this._source.dispose();
      }
      cancel() {
        this._source.cancel();
      }
    };
    function attachWorkDone(connection2, params) {
      if (params === void 0 || params.workDoneToken === void 0) {
        return new NullProgressReporter();
      }
      const token = params.workDoneToken;
      delete params.workDoneToken;
      return new WorkDoneProgressReporterImpl(connection2, token);
    }
    exports.attachWorkDone = attachWorkDone;
    var ProgressFeature = (Base) => {
      return class extends Base {
        constructor() {
          super();
          this._progressSupported = false;
        }
        initialize(capabilities) {
          super.initialize(capabilities);
          if (capabilities?.window?.workDoneProgress === true) {
            this._progressSupported = true;
            this.connection.onNotification(vscode_languageserver_protocol_1.WorkDoneProgressCancelNotification.type, (params) => {
              let progress = WorkDoneProgressReporterImpl.Instances.get(params.token);
              if (progress instanceof WorkDoneProgressServerReporterImpl || progress instanceof NullProgressServerReporter) {
                progress.cancel();
              }
            });
          }
        }
        attachWorkDoneProgress(token) {
          if (token === void 0) {
            return new NullProgressReporter();
          } else {
            return new WorkDoneProgressReporterImpl(this.connection, token);
          }
        }
        createWorkDoneProgress() {
          if (this._progressSupported) {
            const token = (0, uuid_1.generateUuid)();
            return this.connection.sendRequest(vscode_languageserver_protocol_1.WorkDoneProgressCreateRequest.type, { token }).then(() => {
              const result = new WorkDoneProgressServerReporterImpl(this.connection, token);
              return result;
            });
          } else {
            return Promise.resolve(new NullProgressServerReporter());
          }
        }
      };
    };
    exports.ProgressFeature = ProgressFeature;
    var ResultProgress;
    (function (ResultProgress2) {
      ResultProgress2.type = new vscode_languageserver_protocol_1.ProgressType();
    })(ResultProgress || (ResultProgress = {}));
    var ResultProgressReporterImpl = class {
      constructor(_connection, _token) {
        this._connection = _connection;
        this._token = _token;
      }
      report(data) {
        this._connection.sendProgress(ResultProgress.type, this._token, data);
      }
    };
    function attachPartialResult(connection2, params) {
      if (params === void 0 || params.partialResultToken === void 0) {
        return void 0;
      }
      const token = params.partialResultToken;
      delete params.partialResultToken;
      return new ResultProgressReporterImpl(connection2, token);
    }
    exports.attachPartialResult = attachPartialResult;
  }
});

// server/node_modules/vscode-languageserver/lib/common/configuration.js
var require_configuration = __commonJS({
  "server/node_modules/vscode-languageserver/lib/common/configuration.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConfigurationFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main2();
    var Is2 = require_is3();
    var ConfigurationFeature = (Base) => {
      return class extends Base {
        getConfiguration(arg) {
          if (!arg) {
            return this._getConfiguration({});
          } else if (Is2.string(arg)) {
            return this._getConfiguration({ section: arg });
          } else {
            return this._getConfiguration(arg);
          }
        }
        _getConfiguration(arg) {
          let params = {
            items: Array.isArray(arg) ? arg : [arg]
          };
          return this.connection.sendRequest(vscode_languageserver_protocol_1.ConfigurationRequest.type, params).then((result) => {
            if (Array.isArray(result)) {
              return Array.isArray(arg) ? result : result[0];
            } else {
              return Array.isArray(arg) ? [] : null;
            }
          });
        }
      };
    };
    exports.ConfigurationFeature = ConfigurationFeature;
  }
});

// server/node_modules/vscode-languageserver/lib/common/workspaceFolder.js
var require_workspaceFolder = __commonJS({
  "server/node_modules/vscode-languageserver/lib/common/workspaceFolder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WorkspaceFoldersFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main2();
    var WorkspaceFoldersFeature = (Base) => {
      return class extends Base {
        constructor() {
          super();
          this._notificationIsAutoRegistered = false;
        }
        initialize(capabilities) {
          super.initialize(capabilities);
          let workspaceCapabilities = capabilities.workspace;
          if (workspaceCapabilities && workspaceCapabilities.workspaceFolders) {
            this._onDidChangeWorkspaceFolders = new vscode_languageserver_protocol_1.Emitter();
            this.connection.onNotification(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type, (params) => {
              this._onDidChangeWorkspaceFolders.fire(params.event);
            });
          }
        }
        fillServerCapabilities(capabilities) {
          super.fillServerCapabilities(capabilities);
          const changeNotifications = capabilities.workspace?.workspaceFolders?.changeNotifications;
          this._notificationIsAutoRegistered = changeNotifications === true || typeof changeNotifications === "string";
        }
        getWorkspaceFolders() {
          return this.connection.sendRequest(vscode_languageserver_protocol_1.WorkspaceFoldersRequest.type);
        }
        get onDidChangeWorkspaceFolders() {
          if (!this._onDidChangeWorkspaceFolders) {
            throw new Error("Client doesn't support sending workspace folder change events.");
          }
          if (!this._notificationIsAutoRegistered && !this._unregistration) {
            this._unregistration = this.connection.client.register(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type);
          }
          return this._onDidChangeWorkspaceFolders.event;
        }
      };
    };
    exports.WorkspaceFoldersFeature = WorkspaceFoldersFeature;
  }
});

// server/node_modules/vscode-languageserver/lib/common/callHierarchy.js
var require_callHierarchy = __commonJS({
  "server/node_modules/vscode-languageserver/lib/common/callHierarchy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CallHierarchyFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main2();
    var CallHierarchyFeature = (Base) => {
      return class extends Base {
        get callHierarchy() {
          return {
            onPrepare: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.CallHierarchyPrepareRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), void 0);
              });
            },
            onIncomingCalls: (handler) => {
              const type = vscode_languageserver_protocol_1.CallHierarchyIncomingCallsRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            },
            onOutgoingCalls: (handler) => {
              const type = vscode_languageserver_protocol_1.CallHierarchyOutgoingCallsRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            }
          };
        }
      };
    };
    exports.CallHierarchyFeature = CallHierarchyFeature;
  }
});

// server/node_modules/vscode-languageserver/lib/common/showDocument.js
var require_showDocument = __commonJS({
  "server/node_modules/vscode-languageserver/lib/common/showDocument.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ShowDocumentFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main2();
    var ShowDocumentFeature = (Base) => {
      return class extends Base {
        showDocument(params) {
          return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowDocumentRequest.type, params);
        }
      };
    };
    exports.ShowDocumentFeature = ShowDocumentFeature;
  }
});

// server/node_modules/vscode-languageserver/lib/common/fileOperations.js
var require_fileOperations = __commonJS({
  "server/node_modules/vscode-languageserver/lib/common/fileOperations.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FileOperationsFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main2();
    var FileOperationsFeature = (Base) => {
      return class extends Base {
        onDidCreateFiles(handler) {
          return this.connection.onNotification(vscode_languageserver_protocol_1.DidCreateFilesNotification.type, (params) => {
            handler(params);
          });
        }
        onDidRenameFiles(handler) {
          return this.connection.onNotification(vscode_languageserver_protocol_1.DidRenameFilesNotification.type, (params) => {
            handler(params);
          });
        }
        onDidDeleteFiles(handler) {
          return this.connection.onNotification(vscode_languageserver_protocol_1.DidDeleteFilesNotification.type, (params) => {
            handler(params);
          });
        }
        onWillCreateFiles(handler) {
          return this.connection.onRequest(vscode_languageserver_protocol_1.WillCreateFilesRequest.type, (params, cancel) => {
            return handler(params, cancel);
          });
        }
        onWillRenameFiles(handler) {
          return this.connection.onRequest(vscode_languageserver_protocol_1.WillRenameFilesRequest.type, (params, cancel) => {
            return handler(params, cancel);
          });
        }
        onWillDeleteFiles(handler) {
          return this.connection.onRequest(vscode_languageserver_protocol_1.WillDeleteFilesRequest.type, (params, cancel) => {
            return handler(params, cancel);
          });
        }
      };
    };
    exports.FileOperationsFeature = FileOperationsFeature;
  }
});

// server/node_modules/vscode-languageserver/lib/common/linkedEditingRange.js
var require_linkedEditingRange = __commonJS({
  "server/node_modules/vscode-languageserver/lib/common/linkedEditingRange.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LinkedEditingRangeFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main2();
    var LinkedEditingRangeFeature = (Base) => {
      return class extends Base {
        onLinkedEditingRange(handler) {
          return this.connection.onRequest(vscode_languageserver_protocol_1.LinkedEditingRangeRequest.type, (params, cancel) => {
            return handler(params, cancel, this.attachWorkDoneProgress(params), void 0);
          });
        }
      };
    };
    exports.LinkedEditingRangeFeature = LinkedEditingRangeFeature;
  }
});

// server/node_modules/vscode-languageserver/lib/common/typeHierarchy.js
var require_typeHierarchy = __commonJS({
  "server/node_modules/vscode-languageserver/lib/common/typeHierarchy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TypeHierarchyFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main2();
    var TypeHierarchyFeature = (Base) => {
      return class extends Base {
        get typeHierarchy() {
          return {
            onPrepare: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.TypeHierarchyPrepareRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), void 0);
              });
            },
            onSupertypes: (handler) => {
              const type = vscode_languageserver_protocol_1.TypeHierarchySupertypesRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            },
            onSubtypes: (handler) => {
              const type = vscode_languageserver_protocol_1.TypeHierarchySubtypesRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            }
          };
        }
      };
    };
    exports.TypeHierarchyFeature = TypeHierarchyFeature;
  }
});

// server/node_modules/vscode-languageserver/lib/common/inlineValue.js
var require_inlineValue = __commonJS({
  "server/node_modules/vscode-languageserver/lib/common/inlineValue.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InlineValueFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main2();
    var InlineValueFeature = (Base) => {
      return class extends Base {
        get inlineValue() {
          return {
            refresh: () => {
              return this.connection.sendRequest(vscode_languageserver_protocol_1.InlineValueRefreshRequest.type);
            },
            on: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.InlineValueRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params));
              });
            }
          };
        }
      };
    };
    exports.InlineValueFeature = InlineValueFeature;
  }
});

// server/node_modules/vscode-languageserver/lib/common/foldingRange.js
var require_foldingRange = __commonJS({
  "server/node_modules/vscode-languageserver/lib/common/foldingRange.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FoldingRangeFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main2();
    var FoldingRangeFeature = (Base) => {
      return class extends Base {
        get foldingRange() {
          return {
            refresh: () => {
              return this.connection.sendRequest(vscode_languageserver_protocol_1.FoldingRangeRefreshRequest.type);
            },
            on: (handler) => {
              const type = vscode_languageserver_protocol_1.FoldingRangeRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            }
          };
        }
      };
    };
    exports.FoldingRangeFeature = FoldingRangeFeature;
  }
});

// server/node_modules/vscode-languageserver/lib/common/inlayHint.js
var require_inlayHint = __commonJS({
  "server/node_modules/vscode-languageserver/lib/common/inlayHint.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InlayHintFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main2();
    var InlayHintFeature = (Base) => {
      return class extends Base {
        get inlayHint() {
          return {
            refresh: () => {
              return this.connection.sendRequest(vscode_languageserver_protocol_1.InlayHintRefreshRequest.type);
            },
            on: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.InlayHintRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params));
              });
            },
            resolve: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.InlayHintResolveRequest.type, (params, cancel) => {
                return handler(params, cancel);
              });
            }
          };
        }
      };
    };
    exports.InlayHintFeature = InlayHintFeature;
  }
});

// server/node_modules/vscode-languageserver/lib/common/diagnostic.js
var require_diagnostic = __commonJS({
  "server/node_modules/vscode-languageserver/lib/common/diagnostic.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DiagnosticFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main2();
    var DiagnosticFeature = (Base) => {
      return class extends Base {
        get diagnostics() {
          return {
            refresh: () => {
              return this.connection.sendRequest(vscode_languageserver_protocol_1.DiagnosticRefreshRequest.type);
            },
            on: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.partialResult, params));
              });
            },
            onWorkspace: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.WorkspaceDiagnosticRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(vscode_languageserver_protocol_1.WorkspaceDiagnosticRequest.partialResult, params));
              });
            }
          };
        }
      };
    };
    exports.DiagnosticFeature = DiagnosticFeature;
  }
});

// server/node_modules/vscode-languageserver/lib/common/moniker.js
var require_moniker = __commonJS({
  "server/node_modules/vscode-languageserver/lib/common/moniker.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MonikerFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main2();
    var MonikerFeature = (Base) => {
      return class extends Base {
        get moniker() {
          return {
            on: (handler) => {
              const type = vscode_languageserver_protocol_1.MonikerRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            }
          };
        }
      };
    };
    exports.MonikerFeature = MonikerFeature;
  }
});

// server/node_modules/vscode-languageserver/lib/common/server.js
var require_server = __commonJS({
  "server/node_modules/vscode-languageserver/lib/common/server.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConnection = exports.combineFeatures = exports.combineNotebooksFeatures = exports.combineLanguagesFeatures = exports.combineWorkspaceFeatures = exports.combineWindowFeatures = exports.combineClientFeatures = exports.combineTracerFeatures = exports.combineTelemetryFeatures = exports.combineConsoleFeatures = exports._NotebooksImpl = exports._LanguagesImpl = exports.BulkUnregistration = exports.BulkRegistration = exports.ErrorMessageTracker = void 0;
    var vscode_languageserver_protocol_1 = require_main2();
    var Is2 = require_is3();
    var UUID = require_uuid();
    var progress_1 = require_progress();
    var configuration_1 = require_configuration();
    var workspaceFolder_1 = require_workspaceFolder();
    var callHierarchy_1 = require_callHierarchy();
    var semanticTokens_1 = require_semanticTokens();
    var showDocument_1 = require_showDocument();
    var fileOperations_1 = require_fileOperations();
    var linkedEditingRange_1 = require_linkedEditingRange();
    var typeHierarchy_1 = require_typeHierarchy();
    var inlineValue_1 = require_inlineValue();
    var foldingRange_1 = require_foldingRange();
    var inlayHint_1 = require_inlayHint();
    var diagnostic_1 = require_diagnostic();
    var notebook_1 = require_notebook();
    var moniker_1 = require_moniker();
    function null2Undefined(value) {
      if (value === null) {
        return void 0;
      }
      return value;
    }
    var ErrorMessageTracker = class {
      constructor() {
        this._messages = /* @__PURE__ */ Object.create(null);
      }
      /**
       * Add a message to the tracker.
       *
       * @param message The message to add.
       */
      add(message) {
        let count = this._messages[message];
        if (!count) {
          count = 0;
        }
        count++;
        this._messages[message] = count;
      }
      /**
       * Send all tracked messages to the connection's window.
       *
       * @param connection The connection established between client and server.
       */
      sendErrors(connection2) {
        Object.keys(this._messages).forEach((message) => {
          connection2.window.showErrorMessage(message);
        });
      }
    };
    exports.ErrorMessageTracker = ErrorMessageTracker;
    var RemoteConsoleImpl = class {
      constructor() {
      }
      rawAttach(connection2) {
        this._rawConnection = connection2;
      }
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      fillServerCapabilities(_capabilities) {
      }
      initialize(_capabilities) {
      }
      error(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Error, message);
      }
      warn(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Warning, message);
      }
      info(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Info, message);
      }
      log(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Log, message);
      }
      debug(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Debug, message);
      }
      send(type, message) {
        if (this._rawConnection) {
          this._rawConnection.sendNotification(vscode_languageserver_protocol_1.LogMessageNotification.type, { type, message }).catch(() => {
            (0, vscode_languageserver_protocol_1.RAL)().console.error(`Sending log message failed`);
          });
        }
      }
    };
    var _RemoteWindowImpl = class {
      constructor() {
      }
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      showErrorMessage(message, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Error, message, actions };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
      }
      showWarningMessage(message, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Warning, message, actions };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
      }
      showInformationMessage(message, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Info, message, actions };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
      }
    };
    var RemoteWindowImpl = (0, showDocument_1.ShowDocumentFeature)((0, progress_1.ProgressFeature)(_RemoteWindowImpl));
    var BulkRegistration;
    (function (BulkRegistration2) {
      function create() {
        return new BulkRegistrationImpl();
      }
      BulkRegistration2.create = create;
    })(BulkRegistration || (exports.BulkRegistration = BulkRegistration = {}));
    var BulkRegistrationImpl = class {
      constructor() {
        this._registrations = [];
        this._registered = /* @__PURE__ */ new Set();
      }
      add(type, registerOptions) {
        const method = Is2.string(type) ? type : type.method;
        if (this._registered.has(method)) {
          throw new Error(`${method} is already added to this registration`);
        }
        const id = UUID.generateUuid();
        this._registrations.push({
          id,
          method,
          registerOptions: registerOptions || {}
        });
        this._registered.add(method);
      }
      asRegistrationParams() {
        return {
          registrations: this._registrations
        };
      }
    };
    var BulkUnregistration;
    (function (BulkUnregistration2) {
      function create() {
        return new BulkUnregistrationImpl(void 0, []);
      }
      BulkUnregistration2.create = create;
    })(BulkUnregistration || (exports.BulkUnregistration = BulkUnregistration = {}));
    var BulkUnregistrationImpl = class {
      constructor(_connection, unregistrations) {
        this._connection = _connection;
        this._unregistrations = /* @__PURE__ */ new Map();
        unregistrations.forEach((unregistration) => {
          this._unregistrations.set(unregistration.method, unregistration);
        });
      }
      get isAttached() {
        return !!this._connection;
      }
      attach(connection2) {
        this._connection = connection2;
      }
      add(unregistration) {
        this._unregistrations.set(unregistration.method, unregistration);
      }
      dispose() {
        let unregistrations = [];
        for (let unregistration of this._unregistrations.values()) {
          unregistrations.push(unregistration);
        }
        let params = {
          unregisterations: unregistrations
        };
        this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).catch(() => {
          this._connection.console.info(`Bulk unregistration failed.`);
        });
      }
      disposeSingle(arg) {
        const method = Is2.string(arg) ? arg : arg.method;
        const unregistration = this._unregistrations.get(method);
        if (!unregistration) {
          return false;
        }
        let params = {
          unregisterations: [unregistration]
        };
        this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).then(() => {
          this._unregistrations.delete(method);
        }, (_error) => {
          this._connection.console.info(`Un-registering request handler for ${unregistration.id} failed.`);
        });
        return true;
      }
    };
    var RemoteClientImpl = class {
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      register(typeOrRegistrations, registerOptionsOrType, registerOptions) {
        if (typeOrRegistrations instanceof BulkRegistrationImpl) {
          return this.registerMany(typeOrRegistrations);
        } else if (typeOrRegistrations instanceof BulkUnregistrationImpl) {
          return this.registerSingle1(typeOrRegistrations, registerOptionsOrType, registerOptions);
        } else {
          return this.registerSingle2(typeOrRegistrations, registerOptionsOrType);
        }
      }
      registerSingle1(unregistration, type, registerOptions) {
        const method = Is2.string(type) ? type : type.method;
        const id = UUID.generateUuid();
        let params = {
          registrations: [{ id, method, registerOptions: registerOptions || {} }]
        };
        if (!unregistration.isAttached) {
          unregistration.attach(this.connection);
        }
        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {
          unregistration.add({ id, method });
          return unregistration;
        }, (_error) => {
          this.connection.console.info(`Registering request handler for ${method} failed.`);
          return Promise.reject(_error);
        });
      }
      registerSingle2(type, registerOptions) {
        const method = Is2.string(type) ? type : type.method;
        const id = UUID.generateUuid();
        let params = {
          registrations: [{ id, method, registerOptions: registerOptions || {} }]
        };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {
          return vscode_languageserver_protocol_1.Disposable.create(() => {
            this.unregisterSingle(id, method).catch(() => {
              this.connection.console.info(`Un-registering capability with id ${id} failed.`);
            });
          });
        }, (_error) => {
          this.connection.console.info(`Registering request handler for ${method} failed.`);
          return Promise.reject(_error);
        });
      }
      unregisterSingle(id, method) {
        let params = {
          unregisterations: [{ id, method }]
        };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).catch(() => {
          this.connection.console.info(`Un-registering request handler for ${id} failed.`);
        });
      }
      registerMany(registrations) {
        let params = registrations.asRegistrationParams();
        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then(() => {
          return new BulkUnregistrationImpl(this._connection, params.registrations.map((registration) => {
            return { id: registration.id, method: registration.method };
          }));
        }, (_error) => {
          this.connection.console.info(`Bulk registration failed.`);
          return Promise.reject(_error);
        });
      }
    };
    var _RemoteWorkspaceImpl = class {
      constructor() {
      }
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      applyEdit(paramOrEdit) {
        function isApplyWorkspaceEditParams(value) {
          return value && !!value.edit;
        }
        let params = isApplyWorkspaceEditParams(paramOrEdit) ? paramOrEdit : { edit: paramOrEdit };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ApplyWorkspaceEditRequest.type, params);
      }
    };
    var RemoteWorkspaceImpl = (0, fileOperations_1.FileOperationsFeature)((0, workspaceFolder_1.WorkspaceFoldersFeature)((0, configuration_1.ConfigurationFeature)(_RemoteWorkspaceImpl)));
    var TracerImpl = class {
      constructor() {
        this._trace = vscode_languageserver_protocol_1.Trace.Off;
      }
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      set trace(value) {
        this._trace = value;
      }
      log(message, verbose) {
        if (this._trace === vscode_languageserver_protocol_1.Trace.Off) {
          return;
        }
        this.connection.sendNotification(vscode_languageserver_protocol_1.LogTraceNotification.type, {
          message,
          verbose: this._trace === vscode_languageserver_protocol_1.Trace.Verbose ? verbose : void 0
        }).catch(() => {
        });
      }
    };
    var TelemetryImpl = class {
      constructor() {
      }
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      logEvent(data) {
        this.connection.sendNotification(vscode_languageserver_protocol_1.TelemetryEventNotification.type, data).catch(() => {
          this.connection.console.log(`Sending TelemetryEventNotification failed`);
        });
      }
    };
    var _LanguagesImpl = class {
      constructor() {
      }
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      attachWorkDoneProgress(params) {
        return (0, progress_1.attachWorkDone)(this.connection, params);
      }
      attachPartialResultProgress(_type, params) {
        return (0, progress_1.attachPartialResult)(this.connection, params);
      }
    };
    exports._LanguagesImpl = _LanguagesImpl;
    var LanguagesImpl = (0, foldingRange_1.FoldingRangeFeature)((0, moniker_1.MonikerFeature)((0, diagnostic_1.DiagnosticFeature)((0, inlayHint_1.InlayHintFeature)((0, inlineValue_1.InlineValueFeature)((0, typeHierarchy_1.TypeHierarchyFeature)((0, linkedEditingRange_1.LinkedEditingRangeFeature)((0, semanticTokens_1.SemanticTokensFeature)((0, callHierarchy_1.CallHierarchyFeature)(_LanguagesImpl)))))))));
    var _NotebooksImpl = class {
      constructor() {
      }
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      attachWorkDoneProgress(params) {
        return (0, progress_1.attachWorkDone)(this.connection, params);
      }
      attachPartialResultProgress(_type, params) {
        return (0, progress_1.attachPartialResult)(this.connection, params);
      }
    };
    exports._NotebooksImpl = _NotebooksImpl;
    var NotebooksImpl = (0, notebook_1.NotebookSyncFeature)(_NotebooksImpl);
    function combineConsoleFeatures(one, two) {
      return function (Base) {
        return two(one(Base));
      };
    }
    exports.combineConsoleFeatures = combineConsoleFeatures;
    function combineTelemetryFeatures(one, two) {
      return function (Base) {
        return two(one(Base));
      };
    }
    exports.combineTelemetryFeatures = combineTelemetryFeatures;
    function combineTracerFeatures(one, two) {
      return function (Base) {
        return two(one(Base));
      };
    }
    exports.combineTracerFeatures = combineTracerFeatures;
    function combineClientFeatures(one, two) {
      return function (Base) {
        return two(one(Base));
      };
    }
    exports.combineClientFeatures = combineClientFeatures;
    function combineWindowFeatures(one, two) {
      return function (Base) {
        return two(one(Base));
      };
    }
    exports.combineWindowFeatures = combineWindowFeatures;
    function combineWorkspaceFeatures(one, two) {
      return function (Base) {
        return two(one(Base));
      };
    }
    exports.combineWorkspaceFeatures = combineWorkspaceFeatures;
    function combineLanguagesFeatures(one, two) {
      return function (Base) {
        return two(one(Base));
      };
    }
    exports.combineLanguagesFeatures = combineLanguagesFeatures;
    function combineNotebooksFeatures(one, two) {
      return function (Base) {
        return two(one(Base));
      };
    }
    exports.combineNotebooksFeatures = combineNotebooksFeatures;
    function combineFeatures(one, two) {
      function combine(one2, two2, func) {
        if (one2 && two2) {
          return func(one2, two2);
        } else if (one2) {
          return one2;
        } else {
          return two2;
        }
      }
      let result = {
        __brand: "features",
        console: combine(one.console, two.console, combineConsoleFeatures),
        tracer: combine(one.tracer, two.tracer, combineTracerFeatures),
        telemetry: combine(one.telemetry, two.telemetry, combineTelemetryFeatures),
        client: combine(one.client, two.client, combineClientFeatures),
        window: combine(one.window, two.window, combineWindowFeatures),
        workspace: combine(one.workspace, two.workspace, combineWorkspaceFeatures),
        languages: combine(one.languages, two.languages, combineLanguagesFeatures),
        notebooks: combine(one.notebooks, two.notebooks, combineNotebooksFeatures)
      };
      return result;
    }
    exports.combineFeatures = combineFeatures;
    function createConnection2(connectionFactory, watchDog, factories) {
      const logger = factories && factories.console ? new (factories.console(RemoteConsoleImpl))() : new RemoteConsoleImpl();
      const connection2 = connectionFactory(logger);
      logger.rawAttach(connection2);
      const tracer = factories && factories.tracer ? new (factories.tracer(TracerImpl))() : new TracerImpl();
      const telemetry = factories && factories.telemetry ? new (factories.telemetry(TelemetryImpl))() : new TelemetryImpl();
      const client = factories && factories.client ? new (factories.client(RemoteClientImpl))() : new RemoteClientImpl();
      const remoteWindow = factories && factories.window ? new (factories.window(RemoteWindowImpl))() : new RemoteWindowImpl();
      const workspace = factories && factories.workspace ? new (factories.workspace(RemoteWorkspaceImpl))() : new RemoteWorkspaceImpl();
      const languages = factories && factories.languages ? new (factories.languages(LanguagesImpl))() : new LanguagesImpl();
      const notebooks = factories && factories.notebooks ? new (factories.notebooks(NotebooksImpl))() : new NotebooksImpl();
      const allRemotes = [logger, tracer, telemetry, client, remoteWindow, workspace, languages, notebooks];
      function asPromise(value) {
        if (value instanceof Promise) {
          return value;
        } else if (Is2.thenable(value)) {
          return new Promise((resolve, reject) => {
            value.then((resolved) => resolve(resolved), (error) => reject(error));
          });
        } else {
          return Promise.resolve(value);
        }
      }
      let shutdownHandler = void 0;
      let initializeHandler = void 0;
      let exitHandler = void 0;
      let protocolConnection = {
        listen: () => connection2.listen(),
        sendRequest: (type, ...params) => connection2.sendRequest(Is2.string(type) ? type : type.method, ...params),
        onRequest: (type, handler) => connection2.onRequest(type, handler),
        sendNotification: (type, param) => {
          const method = Is2.string(type) ? type : type.method;
          return connection2.sendNotification(method, param);
        },
        onNotification: (type, handler) => connection2.onNotification(type, handler),
        onProgress: connection2.onProgress,
        sendProgress: connection2.sendProgress,
        onInitialize: (handler) => {
          initializeHandler = handler;
          return {
            dispose: () => {
              initializeHandler = void 0;
            }
          };
        },
        onInitialized: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.InitializedNotification.type, handler),
        onShutdown: (handler) => {
          shutdownHandler = handler;
          return {
            dispose: () => {
              shutdownHandler = void 0;
            }
          };
        },
        onExit: (handler) => {
          exitHandler = handler;
          return {
            dispose: () => {
              exitHandler = void 0;
            }
          };
        },
        get console() {
          return logger;
        },
        get telemetry() {
          return telemetry;
        },
        get tracer() {
          return tracer;
        },
        get client() {
          return client;
        },
        get window() {
          return remoteWindow;
        },
        get workspace() {
          return workspace;
        },
        get languages() {
          return languages;
        },
        get notebooks() {
          return notebooks;
        },
        onDidChangeConfiguration: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, handler),
        onDidChangeWatchedFiles: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type, handler),
        __textDocumentSync: void 0,
        onDidOpenTextDocument: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type, handler),
        onDidChangeTextDocument: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, handler),
        onDidCloseTextDocument: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type, handler),
        onWillSaveTextDocument: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type, handler),
        onWillSaveTextDocumentWaitUntil: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type, handler),
        onDidSaveTextDocument: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type, handler),
        sendDiagnostics: (params) => connection2.sendNotification(vscode_languageserver_protocol_1.PublishDiagnosticsNotification.type, params),
        onHover: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.HoverRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
        }),
        onCompletion: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CompletionRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onCompletionResolve: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, handler),
        onSignatureHelp: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
        }),
        onDeclaration: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DeclarationRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onDefinition: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onTypeDefinition: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.TypeDefinitionRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onImplementation: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.ImplementationRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onReferences: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onDocumentHighlight: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onDocumentSymbol: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onWorkspaceSymbol: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onWorkspaceSymbolResolve: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.WorkspaceSymbolResolveRequest.type, handler),
        onCodeAction: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onCodeActionResolve: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CodeActionResolveRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onCodeLens: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onCodeLensResolve: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onDocumentFormatting: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
        }),
        onDocumentRangeFormatting: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
        }),
        onDocumentOnTypeFormatting: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onRenameRequest: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.RenameRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
        }),
        onPrepareRename: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.PrepareRenameRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onDocumentLinks: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onDocumentLinkResolve: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onDocumentColor: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentColorRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onColorPresentation: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onFoldingRanges: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.FoldingRangeRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onSelectionRanges: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.SelectionRangeRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onExecuteCommand: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
        }),
        dispose: () => connection2.dispose()
      };
      for (let remote of allRemotes) {
        remote.attach(protocolConnection);
      }
      connection2.onRequest(vscode_languageserver_protocol_1.InitializeRequest.type, (params) => {
        watchDog.initialize(params);
        if (Is2.string(params.trace)) {
          tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.trace);
        }
        for (let remote of allRemotes) {
          remote.initialize(params.capabilities);
        }
        if (initializeHandler) {
          let result = initializeHandler(params, new vscode_languageserver_protocol_1.CancellationTokenSource().token, (0, progress_1.attachWorkDone)(connection2, params), void 0);
          return asPromise(result).then((value) => {
            if (value instanceof vscode_languageserver_protocol_1.ResponseError) {
              return value;
            }
            let result2 = value;
            if (!result2) {
              result2 = { capabilities: {} };
            }
            let capabilities = result2.capabilities;
            if (!capabilities) {
              capabilities = {};
              result2.capabilities = capabilities;
            }
            if (capabilities.textDocumentSync === void 0 || capabilities.textDocumentSync === null) {
              capabilities.textDocumentSync = Is2.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
            } else if (!Is2.number(capabilities.textDocumentSync) && !Is2.number(capabilities.textDocumentSync.change)) {
              capabilities.textDocumentSync.change = Is2.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
            }
            for (let remote of allRemotes) {
              remote.fillServerCapabilities(capabilities);
            }
            return result2;
          });
        } else {
          let result = { capabilities: { textDocumentSync: vscode_languageserver_protocol_1.TextDocumentSyncKind.None } };
          for (let remote of allRemotes) {
            remote.fillServerCapabilities(result.capabilities);
          }
          return result;
        }
      });
      connection2.onRequest(vscode_languageserver_protocol_1.ShutdownRequest.type, () => {
        watchDog.shutdownReceived = true;
        if (shutdownHandler) {
          return shutdownHandler(new vscode_languageserver_protocol_1.CancellationTokenSource().token);
        } else {
          return void 0;
        }
      });
      connection2.onNotification(vscode_languageserver_protocol_1.ExitNotification.type, () => {
        try {
          if (exitHandler) {
            exitHandler();
          }
        } finally {
          if (watchDog.shutdownReceived) {
            watchDog.exit(0);
          } else {
            watchDog.exit(1);
          }
        }
      });
      connection2.onNotification(vscode_languageserver_protocol_1.SetTraceNotification.type, (params) => {
        tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.value);
      });
      return protocolConnection;
    }
    exports.createConnection = createConnection2;
  }
});

// server/node_modules/vscode-languageserver/lib/common/api.js
var require_api3 = __commonJS({
  "server/node_modules/vscode-languageserver/lib/common/api.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true, get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function (m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProposedFeatures = exports.NotebookDocuments = exports.TextDocuments = exports.SemanticTokensBuilder = void 0;
    var semanticTokens_1 = require_semanticTokens();
    Object.defineProperty(exports, "SemanticTokensBuilder", {
      enumerable: true, get: function () {
        return semanticTokens_1.SemanticTokensBuilder;
      }
    });
    var ic = require_inlineCompletion_proposed();
    __exportStar(require_main2(), exports);
    var textDocuments_1 = require_textDocuments();
    Object.defineProperty(exports, "TextDocuments", {
      enumerable: true, get: function () {
        return textDocuments_1.TextDocuments;
      }
    });
    var notebook_1 = require_notebook();
    Object.defineProperty(exports, "NotebookDocuments", {
      enumerable: true, get: function () {
        return notebook_1.NotebookDocuments;
      }
    });
    __exportStar(require_server(), exports);
    var ProposedFeatures;
    (function (ProposedFeatures2) {
      ProposedFeatures2.all = {
        __brand: "features",
        languages: ic.InlineCompletionFeature
      };
    })(ProposedFeatures || (exports.ProposedFeatures = ProposedFeatures = {}));
  }
});

// server/node_modules/vscode-languageserver-protocol/browser.js
var require_browser2 = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/browser.js"(exports, module2) {
    "use strict";
    module2.exports = require_main2();
  }
});

// server/node_modules/vscode-languageserver/lib/browser/main.js
var require_main3 = __commonJS({
  "server/node_modules/vscode-languageserver/lib/browser/main.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true, get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function (m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConnection = void 0;
    var api_1 = require_api3();
    __exportStar(require_browser2(), exports);
    __exportStar(require_api3(), exports);
    var _shutdownReceived = false;
    var watchDog = {
      initialize: (_params) => {
      },
      get shutdownReceived() {
        return _shutdownReceived;
      },
      set shutdownReceived(value) {
        _shutdownReceived = value;
      },
      exit: (_code) => {
      }
    };
    function createConnection2(arg1, arg2, arg3, arg4) {
      let factories;
      let reader;
      let writer;
      let options;
      if (arg1 !== void 0 && arg1.__brand === "features") {
        factories = arg1;
        arg1 = arg2;
        arg2 = arg3;
        arg3 = arg4;
      }
      if (api_1.ConnectionStrategy.is(arg1) || api_1.ConnectionOptions.is(arg1)) {
        options = arg1;
      } else {
        reader = arg1;
        writer = arg2;
        options = arg3;
      }
      const connectionFactory = (logger) => {
        return (0, api_1.createProtocolConnection)(reader, writer, logger, options);
      };
      return (0, api_1.createConnection)(connectionFactory, watchDog, factories);
    }
    exports.createConnection = createConnection2;
  }
});

// server/node_modules/vscode-languageserver/browser.js
var require_browser3 = __commonJS({
  "server/node_modules/vscode-languageserver/browser.js"(exports, module2) {
    "use strict";
    module2.exports = require_main3();
  }
});

// server/node_modules/dayjs/dayjs.min.js
var require_dayjs_min = __commonJS({
  "server/node_modules/dayjs/dayjs.min.js"(exports, module2) {
    !function (t, e) {
      "object" == typeof exports && "undefined" != typeof module2 ? module2.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).dayjs = e();
    }(exports, function () {
      "use strict";
      var t = 1e3, e = 6e4, n = 36e5, r = "millisecond", i = "second", s = "minute", u = "hour", a = "day", o = "week", c = "month", f = "quarter", h = "year", d = "date", l = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = {
        name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function (t2) {
          var e2 = ["th", "st", "nd", "rd"], n2 = t2 % 100;
          return "[" + t2 + (e2[(n2 - 20) % 10] || e2[n2] || e2[0]) + "]";
        }
      }, m = function (t2, e2, n2) {
        var r2 = String(t2);
        return !r2 || r2.length >= e2 ? t2 : "" + Array(e2 + 1 - r2.length).join(n2) + t2;
      }, v = {
        s: m, z: function (t2) {
          var e2 = -t2.utcOffset(), n2 = Math.abs(e2), r2 = Math.floor(n2 / 60), i2 = n2 % 60;
          return (e2 <= 0 ? "+" : "-") + m(r2, 2, "0") + ":" + m(i2, 2, "0");
        }, m: function t2(e2, n2) {
          if (e2.date() < n2.date())
            return -t2(n2, e2);
          var r2 = 12 * (n2.year() - e2.year()) + (n2.month() - e2.month()), i2 = e2.clone().add(r2, c), s2 = n2 - i2 < 0, u2 = e2.clone().add(r2 + (s2 ? -1 : 1), c);
          return +(-(r2 + (n2 - i2) / (s2 ? i2 - u2 : u2 - i2)) || 0);
        }, a: function (t2) {
          return t2 < 0 ? Math.ceil(t2) || 0 : Math.floor(t2);
        }, p: function (t2) {
          return { M: c, y: h, w: o, d: a, D: d, h: u, m: s, s: i, ms: r, Q: f }[t2] || String(t2 || "").toLowerCase().replace(/s$/, "");
        }, u: function (t2) {
          return void 0 === t2;
        }
      }, g = "en", D = {};
      D[g] = M;
      var p = "$isDayjsObject", S = function (t2) {
        return t2 instanceof _ || !(!t2 || !t2[p]);
      }, w = function t2(e2, n2, r2) {
        var i2;
        if (!e2)
          return g;
        if ("string" == typeof e2) {
          var s2 = e2.toLowerCase();
          D[s2] && (i2 = s2), n2 && (D[s2] = n2, i2 = s2);
          var u2 = e2.split("-");
          if (!i2 && u2.length > 1)
            return t2(u2[0]);
        } else {
          var a2 = e2.name;
          D[a2] = e2, i2 = a2;
        }
        return !r2 && i2 && (g = i2), i2 || !r2 && g;
      }, O = function (t2, e2) {
        if (S(t2))
          return t2.clone();
        var n2 = "object" == typeof e2 ? e2 : {};
        return n2.date = t2, n2.args = arguments, new _(n2);
      }, b = v;
      b.l = w, b.i = S, b.w = function (t2, e2) {
        return O(t2, { locale: e2.$L, utc: e2.$u, x: e2.$x, $offset: e2.$offset });
      };
      var _ = function () {
        function M2(t2) {
          this.$L = w(t2.locale, null, true), this.parse(t2), this.$x = this.$x || t2.x || {}, this[p] = true;
        }
        var m2 = M2.prototype;
        return m2.parse = function (t2) {
          this.$d = function (t3) {
            var e2 = t3.date, n2 = t3.utc;
            if (null === e2)
              return /* @__PURE__ */ new Date(NaN);
            if (b.u(e2))
              return /* @__PURE__ */ new Date();
            if (e2 instanceof Date)
              return new Date(e2);
            if ("string" == typeof e2 && !/Z$/i.test(e2)) {
              var r2 = e2.match($);
              if (r2) {
                var i2 = r2[2] - 1 || 0, s2 = (r2[7] || "0").substring(0, 3);
                return n2 ? new Date(Date.UTC(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2)) : new Date(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2);
              }
            }
            return new Date(e2);
          }(t2), this.init();
        }, m2.init = function () {
          var t2 = this.$d;
          this.$y = t2.getFullYear(), this.$M = t2.getMonth(), this.$D = t2.getDate(), this.$W = t2.getDay(), this.$H = t2.getHours(), this.$m = t2.getMinutes(), this.$s = t2.getSeconds(), this.$ms = t2.getMilliseconds();
        }, m2.$utils = function () {
          return b;
        }, m2.isValid = function () {
          return !(this.$d.toString() === l);
        }, m2.isSame = function (t2, e2) {
          var n2 = O(t2);
          return this.startOf(e2) <= n2 && n2 <= this.endOf(e2);
        }, m2.isAfter = function (t2, e2) {
          return O(t2) < this.startOf(e2);
        }, m2.isBefore = function (t2, e2) {
          return this.endOf(e2) < O(t2);
        }, m2.$g = function (t2, e2, n2) {
          return b.u(t2) ? this[e2] : this.set(n2, t2);
        }, m2.unix = function () {
          return Math.floor(this.valueOf() / 1e3);
        }, m2.valueOf = function () {
          return this.$d.getTime();
        }, m2.startOf = function (t2, e2) {
          var n2 = this, r2 = !!b.u(e2) || e2, f2 = b.p(t2), l2 = function (t3, e3) {
            var i2 = b.w(n2.$u ? Date.UTC(n2.$y, e3, t3) : new Date(n2.$y, e3, t3), n2);
            return r2 ? i2 : i2.endOf(a);
          }, $2 = function (t3, e3) {
            return b.w(n2.toDate()[t3].apply(n2.toDate("s"), (r2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), n2);
          }, y2 = this.$W, M3 = this.$M, m3 = this.$D, v2 = "set" + (this.$u ? "UTC" : "");
          switch (f2) {
            case h:
              return r2 ? l2(1, 0) : l2(31, 11);
            case c:
              return r2 ? l2(1, M3) : l2(0, M3 + 1);
            case o:
              var g2 = this.$locale().weekStart || 0, D2 = (y2 < g2 ? y2 + 7 : y2) - g2;
              return l2(r2 ? m3 - D2 : m3 + (6 - D2), M3);
            case a:
            case d:
              return $2(v2 + "Hours", 0);
            case u:
              return $2(v2 + "Minutes", 1);
            case s:
              return $2(v2 + "Seconds", 2);
            case i:
              return $2(v2 + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, m2.endOf = function (t2) {
          return this.startOf(t2, false);
        }, m2.$set = function (t2, e2) {
          var n2, o2 = b.p(t2), f2 = "set" + (this.$u ? "UTC" : ""), l2 = (n2 = {}, n2[a] = f2 + "Date", n2[d] = f2 + "Date", n2[c] = f2 + "Month", n2[h] = f2 + "FullYear", n2[u] = f2 + "Hours", n2[s] = f2 + "Minutes", n2[i] = f2 + "Seconds", n2[r] = f2 + "Milliseconds", n2)[o2], $2 = o2 === a ? this.$D + (e2 - this.$W) : e2;
          if (o2 === c || o2 === h) {
            var y2 = this.clone().set(d, 1);
            y2.$d[l2]($2), y2.init(), this.$d = y2.set(d, Math.min(this.$D, y2.daysInMonth())).$d;
          } else
            l2 && this.$d[l2]($2);
          return this.init(), this;
        }, m2.set = function (t2, e2) {
          return this.clone().$set(t2, e2);
        }, m2.get = function (t2) {
          return this[b.p(t2)]();
        }, m2.add = function (r2, f2) {
          var d2, l2 = this;
          r2 = Number(r2);
          var $2 = b.p(f2), y2 = function (t2) {
            var e2 = O(l2);
            return b.w(e2.date(e2.date() + Math.round(t2 * r2)), l2);
          };
          if ($2 === c)
            return this.set(c, this.$M + r2);
          if ($2 === h)
            return this.set(h, this.$y + r2);
          if ($2 === a)
            return y2(1);
          if ($2 === o)
            return y2(7);
          var M3 = (d2 = {}, d2[s] = e, d2[u] = n, d2[i] = t, d2)[$2] || 1, m3 = this.$d.getTime() + r2 * M3;
          return b.w(m3, this);
        }, m2.subtract = function (t2, e2) {
          return this.add(-1 * t2, e2);
        }, m2.format = function (t2) {
          var e2 = this, n2 = this.$locale();
          if (!this.isValid())
            return n2.invalidDate || l;
          var r2 = t2 || "YYYY-MM-DDTHH:mm:ssZ", i2 = b.z(this), s2 = this.$H, u2 = this.$m, a2 = this.$M, o2 = n2.weekdays, c2 = n2.months, f2 = n2.meridiem, h2 = function (t3, n3, i3, s3) {
            return t3 && (t3[n3] || t3(e2, r2)) || i3[n3].slice(0, s3);
          }, d2 = function (t3) {
            return b.s(s2 % 12 || 12, t3, "0");
          }, $2 = f2 || function (t3, e3, n3) {
            var r3 = t3 < 12 ? "AM" : "PM";
            return n3 ? r3.toLowerCase() : r3;
          };
          return r2.replace(y, function (t3, r3) {
            return r3 || function (t4) {
              switch (t4) {
                case "YY":
                  return String(e2.$y).slice(-2);
                case "YYYY":
                  return b.s(e2.$y, 4, "0");
                case "M":
                  return a2 + 1;
                case "MM":
                  return b.s(a2 + 1, 2, "0");
                case "MMM":
                  return h2(n2.monthsShort, a2, c2, 3);
                case "MMMM":
                  return h2(c2, a2);
                case "D":
                  return e2.$D;
                case "DD":
                  return b.s(e2.$D, 2, "0");
                case "d":
                  return String(e2.$W);
                case "dd":
                  return h2(n2.weekdaysMin, e2.$W, o2, 2);
                case "ddd":
                  return h2(n2.weekdaysShort, e2.$W, o2, 3);
                case "dddd":
                  return o2[e2.$W];
                case "H":
                  return String(s2);
                case "HH":
                  return b.s(s2, 2, "0");
                case "h":
                  return d2(1);
                case "hh":
                  return d2(2);
                case "a":
                  return $2(s2, u2, true);
                case "A":
                  return $2(s2, u2, false);
                case "m":
                  return String(u2);
                case "mm":
                  return b.s(u2, 2, "0");
                case "s":
                  return String(e2.$s);
                case "ss":
                  return b.s(e2.$s, 2, "0");
                case "SSS":
                  return b.s(e2.$ms, 3, "0");
                case "Z":
                  return i2;
              }
              return null;
            }(t3) || i2.replace(":", "");
          });
        }, m2.utcOffset = function () {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, m2.diff = function (r2, d2, l2) {
          var $2, y2 = this, M3 = b.p(d2), m3 = O(r2), v2 = (m3.utcOffset() - this.utcOffset()) * e, g2 = this - m3, D2 = function () {
            return b.m(y2, m3);
          };
          switch (M3) {
            case h:
              $2 = D2() / 12;
              break;
            case c:
              $2 = D2();
              break;
            case f:
              $2 = D2() / 3;
              break;
            case o:
              $2 = (g2 - v2) / 6048e5;
              break;
            case a:
              $2 = (g2 - v2) / 864e5;
              break;
            case u:
              $2 = g2 / n;
              break;
            case s:
              $2 = g2 / e;
              break;
            case i:
              $2 = g2 / t;
              break;
            default:
              $2 = g2;
          }
          return l2 ? $2 : b.a($2);
        }, m2.daysInMonth = function () {
          return this.endOf(c).$D;
        }, m2.$locale = function () {
          return D[this.$L];
        }, m2.locale = function (t2, e2) {
          if (!t2)
            return this.$L;
          var n2 = this.clone(), r2 = w(t2, e2, true);
          return r2 && (n2.$L = r2), n2;
        }, m2.clone = function () {
          return b.w(this.$d, this);
        }, m2.toDate = function () {
          return new Date(this.valueOf());
        }, m2.toJSON = function () {
          return this.isValid() ? this.toISOString() : null;
        }, m2.toISOString = function () {
          return this.$d.toISOString();
        }, m2.toString = function () {
          return this.$d.toUTCString();
        }, M2;
      }(), k = _.prototype;
      return O.prototype = k, [["$ms", r], ["$s", i], ["$m", s], ["$H", u], ["$W", a], ["$M", c], ["$y", h], ["$D", d]].forEach(function (t2) {
        k[t2[1]] = function (e2) {
          return this.$g(e2, t2[0], t2[1]);
        };
      }), O.extend = function (t2, e2) {
        return t2.$i || (t2(e2, _, O), t2.$i = true), O;
      }, O.locale = w, O.isDayjs = S, O.unix = function (t2) {
        return O(1e3 * t2);
      }, O.en = D[g], O.Ls = D, O.p = {}, O;
    });
  }
});

// server/node_modules/dayjs/plugin/duration.js
var require_duration = __commonJS({
  "server/node_modules/dayjs/plugin/duration.js"(exports, module2) {
    !function (t, s) {
      "object" == typeof exports && "undefined" != typeof module2 ? module2.exports = s() : "function" == typeof define && define.amd ? define(s) : (t = "undefined" != typeof globalThis ? globalThis : t || self).dayjs_plugin_duration = s();
    }(exports, function () {
      "use strict";
      var t, s, n = 1e3, i = 6e4, e = 36e5, r = 864e5, o = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, u = 31536e6, d = 2628e6, a = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/, h = { years: u, months: d, days: r, hours: e, minutes: i, seconds: n, milliseconds: 1, weeks: 6048e5 }, c = function (t2) {
        return t2 instanceof g;
      }, f = function (t2, s2, n2) {
        return new g(t2, n2, s2.$l);
      }, m = function (t2) {
        return s.p(t2) + "s";
      }, l = function (t2) {
        return t2 < 0;
      }, $ = function (t2) {
        return l(t2) ? Math.ceil(t2) : Math.floor(t2);
      }, y = function (t2) {
        return Math.abs(t2);
      }, v = function (t2, s2) {
        return t2 ? l(t2) ? { negative: true, format: "" + y(t2) + s2 } : { negative: false, format: "" + t2 + s2 } : { negative: false, format: "" };
      }, g = function () {
        function l2(t2, s2, n2) {
          var i2 = this;
          if (this.$d = {}, this.$l = n2, void 0 === t2 && (this.$ms = 0, this.parseFromMilliseconds()), s2)
            return f(t2 * h[m(s2)], this);
          if ("number" == typeof t2)
            return this.$ms = t2, this.parseFromMilliseconds(), this;
          if ("object" == typeof t2)
            return Object.keys(t2).forEach(function (s3) {
              i2.$d[m(s3)] = t2[s3];
            }), this.calMilliseconds(), this;
          if ("string" == typeof t2) {
            var e2 = t2.match(a);
            if (e2) {
              var r2 = e2.slice(2).map(function (t3) {
                return null != t3 ? Number(t3) : 0;
              });
              return this.$d.years = r2[0], this.$d.months = r2[1], this.$d.weeks = r2[2], this.$d.days = r2[3], this.$d.hours = r2[4], this.$d.minutes = r2[5], this.$d.seconds = r2[6], this.calMilliseconds(), this;
            }
          }
          return this;
        }
        var y2 = l2.prototype;
        return y2.calMilliseconds = function () {
          var t2 = this;
          this.$ms = Object.keys(this.$d).reduce(function (s2, n2) {
            return s2 + (t2.$d[n2] || 0) * h[n2];
          }, 0);
        }, y2.parseFromMilliseconds = function () {
          var t2 = this.$ms;
          this.$d.years = $(t2 / u), t2 %= u, this.$d.months = $(t2 / d), t2 %= d, this.$d.days = $(t2 / r), t2 %= r, this.$d.hours = $(t2 / e), t2 %= e, this.$d.minutes = $(t2 / i), t2 %= i, this.$d.seconds = $(t2 / n), t2 %= n, this.$d.milliseconds = t2;
        }, y2.toISOString = function () {
          var t2 = v(this.$d.years, "Y"), s2 = v(this.$d.months, "M"), n2 = +this.$d.days || 0;
          this.$d.weeks && (n2 += 7 * this.$d.weeks);
          var i2 = v(n2, "D"), e2 = v(this.$d.hours, "H"), r2 = v(this.$d.minutes, "M"), o2 = this.$d.seconds || 0;
          this.$d.milliseconds && (o2 += this.$d.milliseconds / 1e3, o2 = Math.round(1e3 * o2) / 1e3);
          var u2 = v(o2, "S"), d2 = t2.negative || s2.negative || i2.negative || e2.negative || r2.negative || u2.negative, a2 = e2.format || r2.format || u2.format ? "T" : "", h2 = (d2 ? "-" : "") + "P" + t2.format + s2.format + i2.format + a2 + e2.format + r2.format + u2.format;
          return "P" === h2 || "-P" === h2 ? "P0D" : h2;
        }, y2.toJSON = function () {
          return this.toISOString();
        }, y2.format = function (t2) {
          var n2 = t2 || "YYYY-MM-DDTHH:mm:ss", i2 = { Y: this.$d.years, YY: s.s(this.$d.years, 2, "0"), YYYY: s.s(this.$d.years, 4, "0"), M: this.$d.months, MM: s.s(this.$d.months, 2, "0"), D: this.$d.days, DD: s.s(this.$d.days, 2, "0"), H: this.$d.hours, HH: s.s(this.$d.hours, 2, "0"), m: this.$d.minutes, mm: s.s(this.$d.minutes, 2, "0"), s: this.$d.seconds, ss: s.s(this.$d.seconds, 2, "0"), SSS: s.s(this.$d.milliseconds, 3, "0") };
          return n2.replace(o, function (t3, s2) {
            return s2 || String(i2[t3]);
          });
        }, y2.as = function (t2) {
          return this.$ms / h[m(t2)];
        }, y2.get = function (t2) {
          var s2 = this.$ms, n2 = m(t2);
          return "milliseconds" === n2 ? s2 %= 1e3 : s2 = "weeks" === n2 ? $(s2 / h[n2]) : this.$d[n2], s2 || 0;
        }, y2.add = function (t2, s2, n2) {
          var i2;
          return i2 = s2 ? t2 * h[m(s2)] : c(t2) ? t2.$ms : f(t2, this).$ms, f(this.$ms + i2 * (n2 ? -1 : 1), this);
        }, y2.subtract = function (t2, s2) {
          return this.add(t2, s2, true);
        }, y2.locale = function (t2) {
          var s2 = this.clone();
          return s2.$l = t2, s2;
        }, y2.clone = function () {
          return f(this.$ms, this);
        }, y2.humanize = function (s2) {
          return t().add(this.$ms, "ms").locale(this.$l).fromNow(!s2);
        }, y2.valueOf = function () {
          return this.asMilliseconds();
        }, y2.milliseconds = function () {
          return this.get("milliseconds");
        }, y2.asMilliseconds = function () {
          return this.as("milliseconds");
        }, y2.seconds = function () {
          return this.get("seconds");
        }, y2.asSeconds = function () {
          return this.as("seconds");
        }, y2.minutes = function () {
          return this.get("minutes");
        }, y2.asMinutes = function () {
          return this.as("minutes");
        }, y2.hours = function () {
          return this.get("hours");
        }, y2.asHours = function () {
          return this.as("hours");
        }, y2.days = function () {
          return this.get("days");
        }, y2.asDays = function () {
          return this.as("days");
        }, y2.weeks = function () {
          return this.get("weeks");
        }, y2.asWeeks = function () {
          return this.as("weeks");
        }, y2.months = function () {
          return this.get("months");
        }, y2.asMonths = function () {
          return this.as("months");
        }, y2.years = function () {
          return this.get("years");
        }, y2.asYears = function () {
          return this.as("years");
        }, l2;
      }(), p = function (t2, s2, n2) {
        return t2.add(s2.years() * n2, "y").add(s2.months() * n2, "M").add(s2.days() * n2, "d").add(s2.hours() * n2, "h").add(s2.minutes() * n2, "m").add(s2.seconds() * n2, "s").add(s2.milliseconds() * n2, "ms");
      };
      return function (n2, i2, e2) {
        t = e2, s = e2().$utils(), e2.duration = function (t2, s2) {
          var n3 = e2.locale();
          return f(t2, { $l: n3 }, s2);
        }, e2.isDuration = c;
        var r2 = i2.prototype.add, o2 = i2.prototype.subtract;
        i2.prototype.add = function (t2, s2) {
          return c(t2) ? p(this, t2, 1) : r2.bind(this)(t2, s2);
        }, i2.prototype.subtract = function (t2, s2) {
          return c(t2) ? p(this, t2, -1) : o2.bind(this)(t2, s2);
        };
      };
    });
  }
});

// server/node_modules/dayjs/plugin/utc.js
var require_utc = __commonJS({
  "server/node_modules/dayjs/plugin/utc.js"(exports, module2) {
    !function (t, i) {
      "object" == typeof exports && "undefined" != typeof module2 ? module2.exports = i() : "function" == typeof define && define.amd ? define(i) : (t = "undefined" != typeof globalThis ? globalThis : t || self).dayjs_plugin_utc = i();
    }(exports, function () {
      "use strict";
      var t = "minute", i = /[+-]\d\d(?::?\d\d)?/g, e = /([+-]|\d\d)/g;
      return function (s, f, n) {
        var u = f.prototype;
        n.utc = function (t2) {
          var i2 = { date: t2, utc: true, args: arguments };
          return new f(i2);
        }, u.utc = function (i2) {
          var e2 = n(this.toDate(), { locale: this.$L, utc: true });
          return i2 ? e2.add(this.utcOffset(), t) : e2;
        }, u.local = function () {
          return n(this.toDate(), { locale: this.$L, utc: false });
        };
        var o = u.parse;
        u.parse = function (t2) {
          t2.utc && (this.$u = true), this.$utils().u(t2.$offset) || (this.$offset = t2.$offset), o.call(this, t2);
        };
        var r = u.init;
        u.init = function () {
          if (this.$u) {
            var t2 = this.$d;
            this.$y = t2.getUTCFullYear(), this.$M = t2.getUTCMonth(), this.$D = t2.getUTCDate(), this.$W = t2.getUTCDay(), this.$H = t2.getUTCHours(), this.$m = t2.getUTCMinutes(), this.$s = t2.getUTCSeconds(), this.$ms = t2.getUTCMilliseconds();
          } else
            r.call(this);
        };
        var a = u.utcOffset;
        u.utcOffset = function (s2, f2) {
          var n2 = this.$utils().u;
          if (n2(s2))
            return this.$u ? 0 : n2(this.$offset) ? a.call(this) : this.$offset;
          if ("string" == typeof s2 && (s2 = function (t2) {
            void 0 === t2 && (t2 = "");
            var s3 = t2.match(i);
            if (!s3)
              return null;
            var f3 = ("" + s3[0]).match(e) || ["-", 0, 0], n3 = f3[0], u3 = 60 * +f3[1] + +f3[2];
            return 0 === u3 ? 0 : "+" === n3 ? u3 : -u3;
          }(s2), null === s2))
            return this;
          var u2 = Math.abs(s2) <= 16 ? 60 * s2 : s2, o2 = this;
          if (f2)
            return o2.$offset = u2, o2.$u = 0 === s2, o2;
          if (0 !== s2) {
            var r2 = this.$u ? this.toDate().getTimezoneOffset() : -1 * this.utcOffset();
            (o2 = this.local().add(u2 + r2, t)).$offset = u2, o2.$x.$localOffset = r2;
          } else
            o2 = this.utc();
          return o2;
        };
        var h = u.format;
        u.format = function (t2) {
          var i2 = t2 || (this.$u ? "YYYY-MM-DDTHH:mm:ss[Z]" : "");
          return h.call(this, i2);
        }, u.valueOf = function () {
          var t2 = this.$utils().u(this.$offset) ? 0 : this.$offset + (this.$x.$localOffset || this.$d.getTimezoneOffset());
          return this.$d.valueOf() - 6e4 * t2;
        }, u.isUTC = function () {
          return !!this.$u;
        }, u.toISOString = function () {
          return this.toDate().toISOString();
        }, u.toString = function () {
          return this.toDate().toUTCString();
        };
        var l = u.toDate;
        u.toDate = function (t2) {
          return "s" === t2 && this.$offset ? n(this.format("YYYY-MM-DD HH:mm:ss:SSS")).toDate() : l.call(this);
        };
        var c = u.diff;
        u.diff = function (t2, i2, e2) {
          if (t2 && this.$u === t2.$u)
            return c.call(this, t2, i2, e2);
          var s2 = this.local(), f2 = n(t2).local();
          return c.call(s2, f2, i2, e2);
        };
      };
    });
  }
});

// server/node_modules/dayjs/plugin/timezone.js
var require_timezone = __commonJS({
  "server/node_modules/dayjs/plugin/timezone.js"(exports, module2) {
    !function (t, e) {
      "object" == typeof exports && "undefined" != typeof module2 ? module2.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).dayjs_plugin_timezone = e();
    }(exports, function () {
      "use strict";
      var t = { year: 0, month: 1, day: 2, hour: 3, minute: 4, second: 5 }, e = {};
      return function (n, i, o) {
        var r, a = function (t2, n2, i2) {
          void 0 === i2 && (i2 = {});
          var o2 = new Date(t2), r2 = function (t3, n3) {
            void 0 === n3 && (n3 = {});
            var i3 = n3.timeZoneName || "short", o3 = t3 + "|" + i3, r3 = e[o3];
            return r3 || (r3 = new Intl.DateTimeFormat("en-US", { hour12: false, timeZone: t3, year: "numeric", month: "2-digit", day: "2-digit", hour: "2-digit", minute: "2-digit", second: "2-digit", timeZoneName: i3 }), e[o3] = r3), r3;
          }(n2, i2);
          return r2.formatToParts(o2);
        }, u = function (e2, n2) {
          for (var i2 = a(e2, n2), r2 = [], u2 = 0; u2 < i2.length; u2 += 1) {
            var f2 = i2[u2], s2 = f2.type, m = f2.value, c = t[s2];
            c >= 0 && (r2[c] = parseInt(m, 10));
          }
          var d = r2[3], l = 24 === d ? 0 : d, h = r2[0] + "-" + r2[1] + "-" + r2[2] + " " + l + ":" + r2[4] + ":" + r2[5] + ":000", v = +e2;
          return (o.utc(h).valueOf() - (v -= v % 1e3)) / 6e4;
        }, f = i.prototype;
        f.tz = function (t2, e2) {
          void 0 === t2 && (t2 = r);
          var n2 = this.utcOffset(), i2 = this.toDate(), a2 = i2.toLocaleString("en-US", { timeZone: t2 }), u2 = Math.round((i2 - new Date(a2)) / 1e3 / 60), f2 = o(a2, { locale: this.$L }).$set("millisecond", this.$ms).utcOffset(15 * -Math.round(i2.getTimezoneOffset() / 15) - u2, true);
          if (e2) {
            var s2 = f2.utcOffset();
            f2 = f2.add(n2 - s2, "minute");
          }
          return f2.$x.$timezone = t2, f2;
        }, f.offsetName = function (t2) {
          var e2 = this.$x.$timezone || o.tz.guess(), n2 = a(this.valueOf(), e2, { timeZoneName: t2 }).find(function (t3) {
            return "timezonename" === t3.type.toLowerCase();
          });
          return n2 && n2.value;
        };
        var s = f.startOf;
        f.startOf = function (t2, e2) {
          if (!this.$x || !this.$x.$timezone)
            return s.call(this, t2, e2);
          var n2 = o(this.format("YYYY-MM-DD HH:mm:ss:SSS"), { locale: this.$L });
          return s.call(n2, t2, e2).tz(this.$x.$timezone, true);
        }, o.tz = function (t2, e2, n2) {
          var i2 = n2 && e2, a2 = n2 || e2 || r, f2 = u(+o(), a2);
          if ("string" != typeof t2)
            return o(t2).tz(a2);
          var s2 = function (t3, e3, n3) {
            var i3 = t3 - 60 * e3 * 1e3, o2 = u(i3, n3);
            if (e3 === o2)
              return [i3, e3];
            var r2 = u(i3 -= 60 * (o2 - e3) * 1e3, n3);
            return o2 === r2 ? [i3, o2] : [t3 - 60 * Math.min(o2, r2) * 1e3, Math.max(o2, r2)];
          }(o.utc(t2, i2).valueOf(), f2, a2), m = s2[0], c = s2[1], d = o(m).utcOffset(c);
          return d.$x.$timezone = a2, d;
        }, o.tz.guess = function () {
          return Intl.DateTimeFormat().resolvedOptions().timeZone;
        }, o.tz.setDefault = function (t2) {
          r = t2;
        };
      };
    });
  }
});

// server/node_modules/dayjs/plugin/customParseFormat.js
var require_customParseFormat = __commonJS({
  "server/node_modules/dayjs/plugin/customParseFormat.js"(exports, module2) {
    !function (e, t) {
      "object" == typeof exports && "undefined" != typeof module2 ? module2.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).dayjs_plugin_customParseFormat = t();
    }(exports, function () {
      "use strict";
      var e = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, t = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, n = /\d\d/, r = /\d\d?/, i = /\d*[^-_:/,()\s\d]+/, o = {}, s = function (e2) {
        return (e2 = +e2) + (e2 > 68 ? 1900 : 2e3);
      };
      var a = function (e2) {
        return function (t2) {
          this[e2] = +t2;
        };
      }, f = [/[+-]\d\d:?(\d\d)?|Z/, function (e2) {
        (this.zone || (this.zone = {})).offset = function (e3) {
          if (!e3)
            return 0;
          if ("Z" === e3)
            return 0;
          var t2 = e3.match(/([+-]|\d\d)/g), n2 = 60 * t2[1] + (+t2[2] || 0);
          return 0 === n2 ? 0 : "+" === t2[0] ? -n2 : n2;
        }(e2);
      }], h = function (e2) {
        var t2 = o[e2];
        return t2 && (t2.indexOf ? t2 : t2.s.concat(t2.f));
      }, u = function (e2, t2) {
        var n2, r2 = o.meridiem;
        if (r2) {
          for (var i2 = 1; i2 <= 24; i2 += 1)
            if (e2.indexOf(r2(i2, 0, t2)) > -1) {
              n2 = i2 > 12;
              break;
            }
        } else
          n2 = e2 === (t2 ? "pm" : "PM");
        return n2;
      }, d = {
        A: [i, function (e2) {
          this.afternoon = u(e2, false);
        }], a: [i, function (e2) {
          this.afternoon = u(e2, true);
        }], S: [/\d/, function (e2) {
          this.milliseconds = 100 * +e2;
        }], SS: [n, function (e2) {
          this.milliseconds = 10 * +e2;
        }], SSS: [/\d{3}/, function (e2) {
          this.milliseconds = +e2;
        }], s: [r, a("seconds")], ss: [r, a("seconds")], m: [r, a("minutes")], mm: [r, a("minutes")], H: [r, a("hours")], h: [r, a("hours")], HH: [r, a("hours")], hh: [r, a("hours")], D: [r, a("day")], DD: [n, a("day")], Do: [i, function (e2) {
          var t2 = o.ordinal, n2 = e2.match(/\d+/);
          if (this.day = n2[0], t2)
            for (var r2 = 1; r2 <= 31; r2 += 1)
              t2(r2).replace(/\[|\]/g, "") === e2 && (this.day = r2);
        }], M: [r, a("month")], MM: [n, a("month")], MMM: [i, function (e2) {
          var t2 = h("months"), n2 = (h("monthsShort") || t2.map(function (e3) {
            return e3.slice(0, 3);
          })).indexOf(e2) + 1;
          if (n2 < 1)
            throw new Error();
          this.month = n2 % 12 || n2;
        }], MMMM: [i, function (e2) {
          var t2 = h("months").indexOf(e2) + 1;
          if (t2 < 1)
            throw new Error();
          this.month = t2 % 12 || t2;
        }], Y: [/[+-]?\d+/, a("year")], YY: [n, function (e2) {
          this.year = s(e2);
        }], YYYY: [/\d{4}/, a("year")], Z: f, ZZ: f
      };
      function c(n2) {
        var r2, i2;
        r2 = n2, i2 = o && o.formats;
        for (var s2 = (n2 = r2.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function (t2, n3, r3) {
          var o2 = r3 && r3.toUpperCase();
          return n3 || i2[r3] || e[r3] || i2[o2].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function (e2, t3, n4) {
            return t3 || n4.slice(1);
          });
        })).match(t), a2 = s2.length, f2 = 0; f2 < a2; f2 += 1) {
          var h2 = s2[f2], u2 = d[h2], c2 = u2 && u2[0], l = u2 && u2[1];
          s2[f2] = l ? { regex: c2, parser: l } : h2.replace(/^\[|\]$/g, "");
        }
        return function (e2) {
          for (var t2 = {}, n3 = 0, r3 = 0; n3 < a2; n3 += 1) {
            var i3 = s2[n3];
            if ("string" == typeof i3)
              r3 += i3.length;
            else {
              var o2 = i3.regex, f3 = i3.parser, h3 = e2.slice(r3), u3 = o2.exec(h3)[0];
              f3.call(t2, u3), e2 = e2.replace(u3, "");
            }
          }
          return function (e3) {
            var t3 = e3.afternoon;
            if (void 0 !== t3) {
              var n4 = e3.hours;
              t3 ? n4 < 12 && (e3.hours += 12) : 12 === n4 && (e3.hours = 0), delete e3.afternoon;
            }
          }(t2), t2;
        };
      }
      return function (e2, t2, n2) {
        n2.p.customParseFormat = true, e2 && e2.parseTwoDigitYear && (s = e2.parseTwoDigitYear);
        var r2 = t2.prototype, i2 = r2.parse;
        r2.parse = function (e3) {
          var t3 = e3.date, r3 = e3.utc, s2 = e3.args;
          this.$u = r3;
          var a2 = s2[1];
          if ("string" == typeof a2) {
            var f2 = true === s2[2], h2 = true === s2[3], u2 = f2 || h2, d2 = s2[2];
            h2 && (d2 = s2[2]), o = this.$locale(), !f2 && d2 && (o = n2.Ls[d2]), this.$d = function (e4, t4, n3) {
              try {
                if (["x", "X"].indexOf(t4) > -1)
                  return new Date(("X" === t4 ? 1e3 : 1) * e4);
                var r4 = c(t4)(e4), i3 = r4.year, o2 = r4.month, s3 = r4.day, a3 = r4.hours, f3 = r4.minutes, h3 = r4.seconds, u3 = r4.milliseconds, d3 = r4.zone, l2 = /* @__PURE__ */ new Date(), m2 = s3 || (i3 || o2 ? 1 : l2.getDate()), M2 = i3 || l2.getFullYear(), Y = 0;
                i3 && !o2 || (Y = o2 > 0 ? o2 - 1 : l2.getMonth());
                var p = a3 || 0, v = f3 || 0, D = h3 || 0, g = u3 || 0;
                return d3 ? new Date(Date.UTC(M2, Y, m2, p, v, D, g + 60 * d3.offset * 1e3)) : n3 ? new Date(Date.UTC(M2, Y, m2, p, v, D, g)) : new Date(M2, Y, m2, p, v, D, g);
              } catch (e5) {
                return /* @__PURE__ */ new Date("");
              }
            }(t3, a2, r3), this.init(), d2 && true !== d2 && (this.$L = this.locale(d2).$L), u2 && t3 != this.format(a2) && (this.$d = /* @__PURE__ */ new Date("")), o = {};
          } else if (a2 instanceof Array)
            for (var l = a2.length, m = 1; m <= l; m += 1) {
              s2[1] = a2[m - 1];
              var M = n2.apply(this, s2);
              if (M.isValid()) {
                this.$d = M.$d, this.$L = M.$L, this.init();
                break;
              }
              m === l && (this.$d = /* @__PURE__ */ new Date(""));
            }
          else
            i2.call(this, e3);
        };
      };
    });
  }
});

// server/node_modules/dayjs/plugin/isoWeek.js
var require_isoWeek = __commonJS({
  "server/node_modules/dayjs/plugin/isoWeek.js"(exports, module2) {
    !function (e, t) {
      "object" == typeof exports && "undefined" != typeof module2 ? module2.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).dayjs_plugin_isoWeek = t();
    }(exports, function () {
      "use strict";
      var e = "day";
      return function (t, i, s) {
        var a = function (t2) {
          return t2.add(4 - t2.isoWeekday(), e);
        }, d = i.prototype;
        d.isoWeekYear = function () {
          return a(this).year();
        }, d.isoWeek = function (t2) {
          if (!this.$utils().u(t2))
            return this.add(7 * (t2 - this.isoWeek()), e);
          var i2, d2, n2, o, r = a(this), u = (i2 = this.isoWeekYear(), d2 = this.$u, n2 = (d2 ? s.utc : s)().year(i2).startOf("year"), o = 4 - n2.isoWeekday(), n2.isoWeekday() > 4 && (o += 7), n2.add(o, e));
          return r.diff(u, "week") + 1;
        }, d.isoWeekday = function (e2) {
          return this.$utils().u(e2) ? this.day() || 7 : this.day(this.day() % 7 ? e2 : e2 - 7);
        };
        var n = d.startOf;
        d.startOf = function (e2, t2) {
          var i2 = this.$utils(), s2 = !!i2.u(t2) || t2;
          return "isoweek" === i2.p(e2) ? s2 ? this.date(this.date() - (this.isoWeekday() - 1)).startOf("day") : this.date(this.date() - 1 - (this.isoWeekday() - 1) + 7).endOf("day") : n.bind(this)(e2, t2);
        };
      };
    });
  }
});

// server/node_modules/dayjs/plugin/dayOfYear.js
var require_dayOfYear = __commonJS({
  "server/node_modules/dayjs/plugin/dayOfYear.js"(exports, module2) {
    !function (e, t) {
      "object" == typeof exports && "undefined" != typeof module2 ? module2.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).dayjs_plugin_dayOfYear = t();
    }(exports, function () {
      "use strict";
      return function (e, t, n) {
        t.prototype.dayOfYear = function (e2) {
          var t2 = Math.round((n(this).startOf("day") - n(this).startOf("year")) / 864e5) + 1;
          return null == e2 ? t2 : this.add(e2 - t2, "day");
        };
      };
    });
  }
});

// server/node_modules/dayjs/plugin/quarterOfYear.js
var require_quarterOfYear = __commonJS({
  "server/node_modules/dayjs/plugin/quarterOfYear.js"(exports, module2) {
    !function (t, n) {
      "object" == typeof exports && "undefined" != typeof module2 ? module2.exports = n() : "function" == typeof define && define.amd ? define(n) : (t = "undefined" != typeof globalThis ? globalThis : t || self).dayjs_plugin_quarterOfYear = n();
    }(exports, function () {
      "use strict";
      var t = "month", n = "quarter";
      return function (e, i) {
        var r = i.prototype;
        r.quarter = function (t2) {
          return this.$utils().u(t2) ? Math.ceil((this.month() + 1) / 3) : this.month(this.month() % 3 + 3 * (t2 - 1));
        };
        var s = r.add;
        r.add = function (e2, i2) {
          return e2 = Number(e2), this.$utils().p(i2) === n ? this.add(3 * e2, t) : s.bind(this)(e2, i2);
        };
        var u = r.startOf;
        r.startOf = function (e2, i2) {
          var r2 = this.$utils(), s2 = !!r2.u(i2) || i2;
          if (r2.p(e2) === n) {
            var o = this.quarter() - 1;
            return s2 ? this.month(3 * o).startOf(t).startOf("day") : this.month(3 * o + 2).endOf(t).endOf("day");
          }
          return u.bind(this)(e2, i2);
        };
      };
    });
  }
});

// server/src/browserServerMain.ts
var import_browser = __toESM(require_browser3());
var import_vscode_languageserver = __toESM(require_main3());

// server/node_modules/vscode-languageserver-textdocument/lib/esm/main.js
var FullTextDocument2 = class _FullTextDocument {
  constructor(uri, languageId, version, content) {
    this._uri = uri;
    this._languageId = languageId;
    this._version = version;
    this._content = content;
    this._lineOffsets = void 0;
  }
  get uri() {
    return this._uri;
  }
  get languageId() {
    return this._languageId;
  }
  get version() {
    return this._version;
  }
  getText(range) {
    if (range) {
      const start = this.offsetAt(range.start);
      const end = this.offsetAt(range.end);
      return this._content.substring(start, end);
    }
    return this._content;
  }
  update(changes, version) {
    for (let change of changes) {
      if (_FullTextDocument.isIncremental(change)) {
        const range = getWellformedRange(change.range);
        const startOffset = this.offsetAt(range.start);
        const endOffset = this.offsetAt(range.end);
        this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);
        const startLine = Math.max(range.start.line, 0);
        const endLine = Math.max(range.end.line, 0);
        let lineOffsets = this._lineOffsets;
        const addedLineOffsets = computeLineOffsets(change.text, false, startOffset);
        if (endLine - startLine === addedLineOffsets.length) {
          for (let i = 0, len = addedLineOffsets.length; i < len; i++) {
            lineOffsets[i + startLine + 1] = addedLineOffsets[i];
          }
        } else {
          if (addedLineOffsets.length < 1e4) {
            lineOffsets.splice(startLine + 1, endLine - startLine, ...addedLineOffsets);
          } else {
            this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));
          }
        }
        const diff = change.text.length - (endOffset - startOffset);
        if (diff !== 0) {
          for (let i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++) {
            lineOffsets[i] = lineOffsets[i] + diff;
          }
        }
      } else if (_FullTextDocument.isFull(change)) {
        this._content = change.text;
        this._lineOffsets = void 0;
      } else {
        throw new Error("Unknown change event received");
      }
    }
    this._version = version;
  }
  getLineOffsets() {
    if (this._lineOffsets === void 0) {
      this._lineOffsets = computeLineOffsets(this._content, true);
    }
    return this._lineOffsets;
  }
  positionAt(offset) {
    offset = Math.max(Math.min(offset, this._content.length), 0);
    let lineOffsets = this.getLineOffsets();
    let low = 0, high = lineOffsets.length;
    if (high === 0) {
      return { line: 0, character: offset };
    }
    while (low < high) {
      let mid = Math.floor((low + high) / 2);
      if (lineOffsets[mid] > offset) {
        high = mid;
      } else {
        low = mid + 1;
      }
    }
    let line = low - 1;
    return { line, character: offset - lineOffsets[line] };
  }
  offsetAt(position) {
    let lineOffsets = this.getLineOffsets();
    if (position.line >= lineOffsets.length) {
      return this._content.length;
    } else if (position.line < 0) {
      return 0;
    }
    let lineOffset = lineOffsets[position.line];
    let nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
    return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
  }
  get lineCount() {
    return this.getLineOffsets().length;
  }
  static isIncremental(event) {
    let candidate = event;
    return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range !== void 0 && (candidate.rangeLength === void 0 || typeof candidate.rangeLength === "number");
  }
  static isFull(event) {
    let candidate = event;
    return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range === void 0 && candidate.rangeLength === void 0;
  }
};
var TextDocument2;
(function (TextDocument3) {
  function create(uri, languageId, version, content) {
    return new FullTextDocument2(uri, languageId, version, content);
  }
  TextDocument3.create = create;
  function update(document2, changes, version) {
    if (document2 instanceof FullTextDocument2) {
      document2.update(changes, version);
      return document2;
    } else {
      throw new Error("TextDocument.update: document must be created by TextDocument.create");
    }
  }
  TextDocument3.update = update;
  function applyEdits(document2, edits) {
    let text = document2.getText();
    let sortedEdits = mergeSort(edits.map(getWellformedEdit), (a, b) => {
      let diff = a.range.start.line - b.range.start.line;
      if (diff === 0) {
        return a.range.start.character - b.range.start.character;
      }
      return diff;
    });
    let lastModifiedOffset = 0;
    const spans = [];
    for (const e of sortedEdits) {
      let startOffset = document2.offsetAt(e.range.start);
      if (startOffset < lastModifiedOffset) {
        throw new Error("Overlapping edit");
      } else if (startOffset > lastModifiedOffset) {
        spans.push(text.substring(lastModifiedOffset, startOffset));
      }
      if (e.newText.length) {
        spans.push(e.newText);
      }
      lastModifiedOffset = document2.offsetAt(e.range.end);
    }
    spans.push(text.substr(lastModifiedOffset));
    return spans.join("");
  }
  TextDocument3.applyEdits = applyEdits;
})(TextDocument2 || (TextDocument2 = {}));
function mergeSort(data, compare) {
  if (data.length <= 1) {
    return data;
  }
  const p = data.length / 2 | 0;
  const left = data.slice(0, p);
  const right = data.slice(p);
  mergeSort(left, compare);
  mergeSort(right, compare);
  let leftIdx = 0;
  let rightIdx = 0;
  let i = 0;
  while (leftIdx < left.length && rightIdx < right.length) {
    let ret = compare(left[leftIdx], right[rightIdx]);
    if (ret <= 0) {
      data[i++] = left[leftIdx++];
    } else {
      data[i++] = right[rightIdx++];
    }
  }
  while (leftIdx < left.length) {
    data[i++] = left[leftIdx++];
  }
  while (rightIdx < right.length) {
    data[i++] = right[rightIdx++];
  }
  return data;
}
function computeLineOffsets(text, isAtLineStart, textOffset = 0) {
  const result = isAtLineStart ? [textOffset] : [];
  for (let i = 0; i < text.length; i++) {
    let ch = text.charCodeAt(i);
    if (ch === 13 || ch === 10) {
      if (ch === 13 && i + 1 < text.length && text.charCodeAt(i + 1) === 10) {
        i++;
      }
      result.push(textOffset + i + 1);
    }
  }
  return result;
}
function getWellformedRange(range) {
  const start = range.start;
  const end = range.end;
  if (start.line > end.line || start.line === end.line && start.character > end.character) {
    return { start: end, end: start };
  }
  return range;
}
function getWellformedEdit(textEdit) {
  const range = getWellformedRange(textEdit.range);
  if (range !== textEdit.range) {
    return { newText: textEdit.newText, range };
  }
  return textEdit;
}

// server/node_modules/@superoffice/webapi/dist/esm/Day_js.js
var import_dayjs = __toESM(require_dayjs_min(), 1);
var import_duration = __toESM(require_duration(), 1);
var import_utc = __toESM(require_utc(), 1);
var import_timezone = __toESM(require_timezone(), 1);
var import_customParseFormat = __toESM(require_customParseFormat(), 1);
var import_isoWeek = __toESM(require_isoWeek(), 1);
var import_dayOfYear = __toESM(require_dayOfYear(), 1);
var import_quarterOfYear = __toESM(require_quarterOfYear(), 1);
function initDayjs() {
  let init = import_dayjs.default;
  if (init && typeof init.extend == "function" && !init.soinit) {
    import_dayjs.default.extend(import_duration.default);
    import_dayjs.default.extend(import_duration.default);
    import_dayjs.default.extend(import_utc.default);
    import_dayjs.default.extend(import_timezone.default);
    import_dayjs.default.extend(import_customParseFormat.default);
    import_dayjs.default.extend(import_isoWeek.default);
    import_dayjs.default.extend(import_dayOfYear.default);
    import_dayjs.default.extend(import_quarterOfYear.default);
    init.soinit = true;
  }
}
function mkDuration(duration2, units) {
  if (typeof duration2 == "number" && units)
    return import_dayjs.default.duration(duration2, units);
  if (typeof duration2 == "string") {
    const durationS = duration2;
    const hms = durationS.match(/^([0-9]+):([0-9]+):([0-9]+)$/);
    if (hms)
      return import_dayjs.default.duration("PT" + hms[1] + "H" + hms[2] + "M" + hms[3] + "S");
    const hm = durationS.match(/^([0-9]+):([0-9]+)$/);
    if (hm)
      return import_dayjs.default.duration("PT" + hm[1] + "H" + hm[2] + "M");
  }
  return import_dayjs.default.duration(duration2);
}
initDayjs();

// server/node_modules/axios/lib/helpers/bind.js
function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}

// server/node_modules/axios/lib/utils.js
var { toString } = Object.prototype;
var { getPrototypeOf } = Object;
var kindOf = /* @__PURE__ */ ((cache) => (thing) => {
  const str = toString.call(thing);
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
var kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type;
};
var typeOfTest = (type) => (thing) => typeof thing === type;
var { isArray } = Array;
var isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
var isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
var isString = typeOfTest("string");
var isFunction = typeOfTest("function");
var isNumber = typeOfTest("number");
var isObject = (thing) => thing !== null && typeof thing === "object";
var isBoolean = (thing) => thing === true || thing === false;
var isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype3 = getPrototypeOf(val);
  return (prototype3 === null || prototype3 === Object.prototype || Object.getPrototypeOf(prototype3) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
var isDate = kindOfTest("Date");
var isFile = kindOfTest("File");
var isBlob = kindOfTest("Blob");
var isFileList = kindOfTest("FileList");
var isStream = (val) => isObject(val) && isFunction(val.pipe);
var isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
    kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
};
var isURLSearchParams = kindOfTest("URLSearchParams");
var trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i;
  let l;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray(obj)) {
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;
    for (i = 0; i < len; i++) {
      key = keys[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
var _global = (() => {
  if (typeof globalThis !== "undefined")
    return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
var isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}
var extend = (a, b, thisArg, { allOwnKeys } = {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction(val)) {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  }, { allOwnKeys });
  return a;
};
var stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
var inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
var toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null)
    return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
var endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === void 0 || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
var toArray = (thing) => {
  if (!thing)
    return null;
  if (isArray(thing))
    return thing;
  let i = thing.length;
  if (!isNumber(i))
    return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
};
var isTypedArray = /* @__PURE__ */ ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
var forEachEntry = (obj, fn) => {
  const generator = obj && obj[Symbol.iterator];
  const iterator = generator.call(obj);
  let result;
  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};
var matchAll = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
var isHTMLForm = kindOfTest("HTMLFormElement");
var toCamelCase = (str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer(m, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};
var hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
var isRegExp = kindOfTest("RegExp");
var reduceDescriptors = (obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
var freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
      return false;
    }
    const value = obj[name];
    if (!isFunction(value))
      return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name + "'");
      };
    }
  });
};
var toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define2 = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray(arrayOrString) ? define2(arrayOrString) : define2(String(arrayOrString).split(delimiter));
  return obj;
};
var noop = () => {
};
var toFiniteNumber = (value, defaultValue) => {
  value = +value;
  return Number.isFinite(value) ? value : defaultValue;
};
var ALPHA = "abcdefghijklmnopqrstuvwxyz";
var DIGIT = "0123456789";
var ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
var generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = "";
  const { length } = alphabet;
  while (size--) {
    str += alphabet[Math.random() * length | 0];
  }
  return str;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
}
var toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i) => {
    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack[i] = source;
        const target = isArray(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
var isAsyncFn = kindOfTest("AsyncFunction");
var isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
var utils_default = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable
};

// server/node_modules/axios/lib/core/AxiosError.js
function AxiosError(message, code, config, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  response && (this.response = response);
}
utils_default.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils_default.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
var prototype = AxiosError.prototype;
var descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code) => {
  descriptors[code] = { value: code };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, "isAxiosError", { value: true });
AxiosError.from = (error, code, config, request, response, customProps) => {
  const axiosError = Object.create(prototype);
  utils_default.toFlatObject(error, axiosError, function filter2(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError.call(axiosError, error.message, code, config, request, response);
  axiosError.cause = error;
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
var AxiosError_default = AxiosError;

// server/node_modules/axios/lib/helpers/null.js
var null_default = null;

// server/node_modules/axios/lib/helpers/toFormData.js
function isVisitable(thing) {
  return utils_default.isPlainObject(thing) || utils_default.isArray(thing);
}
function removeBrackets(key) {
  return utils_default.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path, key, dots) {
  if (!path)
    return key;
  return path.concat(key).map(function each(token, i) {
    token = removeBrackets(token);
    return !dots && i ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils_default.isArray(arr) && !arr.some(isVisitable);
}
var predicates = utils_default.toFlatObject(utils_default, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData(obj, formData, options) {
  if (!utils_default.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new (null_default || FormData)();
  options = utils_default.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils_default.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils_default.isSpecCompliantForm(formData);
  if (!utils_default.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null)
      return "";
    if (utils_default.isDate(value)) {
      return value.toISOString();
    }
    if (!useBlob && utils_default.isBlob(value)) {
      throw new AxiosError_default("Blob is not supported. Use a Buffer instead.");
    }
    if (utils_default.isArrayBuffer(value) || utils_default.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path) {
    let arr = value;
    if (value && !path && typeof value === "object") {
      if (utils_default.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils_default.isArray(value) && isFlatArray(value) || (utils_default.isFileList(value) || utils_default.endsWith(key, "[]")) && (arr = utils_default.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(function each(el, index) {
          !(utils_default.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
            convertValue(el)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path) {
    if (utils_default.isUndefined(value))
      return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path.join("."));
    }
    stack.push(value);
    utils_default.forEach(value, function each(el, key) {
      const result = !(utils_default.isUndefined(el) || el === null) && visitor.call(
        formData,
        el,
        utils_default.isString(key) ? key.trim() : key,
        path,
        exposedHelpers
      );
      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils_default.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
var toFormData_default = toFormData;

// server/node_modules/axios/lib/helpers/AxiosURLSearchParams.js
function encode(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData_default(params, this, options);
}
var prototype2 = AxiosURLSearchParams.prototype;
prototype2.append = function append(name, value) {
  this._pairs.push([name, value]);
};
prototype2.toString = function toString2(encoder) {
  const _encode = encoder ? function (value) {
    return encoder.call(this, value, encode);
  } : encode;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
var AxiosURLSearchParams_default = AxiosURLSearchParams;

// server/node_modules/axios/lib/helpers/buildURL.js
function encode2(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url, params, options) {
  if (!params) {
    return url;
  }
  const _encode = options && options.encode || encode2;
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils_default.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams_default(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
}

// server/node_modules/axios/lib/core/InterceptorManager.js
var InterceptorManager = class {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils_default.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  }
};
var InterceptorManager_default = InterceptorManager;

// server/node_modules/axios/lib/defaults/transitional.js
var transitional_default = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};

// server/node_modules/axios/lib/platform/browser/classes/URLSearchParams.js
var URLSearchParams_default = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams_default;

// server/node_modules/axios/lib/platform/browser/classes/FormData.js
var FormData_default = typeof FormData !== "undefined" ? FormData : null;

// server/node_modules/axios/lib/platform/browser/classes/Blob.js
var Blob_default = typeof Blob !== "undefined" ? Blob : null;

// server/node_modules/axios/lib/platform/browser/index.js
var browser_default = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams_default,
    FormData: FormData_default,
    Blob: Blob_default
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
};

// server/node_modules/axios/lib/platform/common/utils.js
var utils_exports = {};
__export(utils_exports, {
  hasBrowserEnv: () => hasBrowserEnv,
  hasStandardBrowserEnv: () => hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv: () => hasStandardBrowserWebWorkerEnv
});
var hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
var hasStandardBrowserEnv = ((product) => {
  return hasBrowserEnv && ["ReactNative", "NativeScript", "NS"].indexOf(product) < 0;
})(typeof navigator !== "undefined" && navigator.product);
var hasStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
    self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();

// server/node_modules/axios/lib/platform/index.js
var platform_default = {
  ...utils_exports,
  ...browser_default
};

// server/node_modules/axios/lib/helpers/toURLEncodedForm.js
function toURLEncodedForm(data, options) {
  return toFormData_default(data, new platform_default.classes.URLSearchParams(), Object.assign({
    visitor: function (value, key, path, helpers) {
      if (platform_default.isNode && utils_default.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}

// server/node_modules/axios/lib/helpers/formDataToJSON.js
function parsePropPath(name) {
  return utils_default.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
    return match[0] === "[]" ? "" : match[1] || match[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys[i];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path, value, target, index) {
    let name = path[index++];
    if (name === "__proto__")
      return true;
    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path.length;
    name = !name && utils_default.isArray(target) ? target.length : name;
    if (isLast) {
      if (utils_default.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }
      return !isNumericKey;
    }
    if (!target[name] || !utils_default.isObject(target[name])) {
      target[name] = [];
    }
    const result = buildPath(path, value, target[name], index);
    if (result && utils_default.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }
    return !isNumericKey;
  }
  if (utils_default.isFormData(formData) && utils_default.isFunction(formData.entries)) {
    const obj = {};
    utils_default.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });
    return obj;
  }
  return null;
}
var formDataToJSON_default = formDataToJSON;

// server/node_modules/axios/lib/defaults/index.js
function stringifySafely(rawValue, parser, encoder) {
  if (utils_default.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils_default.trim(rawValue);
    } catch (e) {
      if (e.name !== "SyntaxError") {
        throw e;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
var defaults = {
  transitional: transitional_default,
  adapter: ["xhr", "http"],
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils_default.isObject(data);
    if (isObjectPayload && utils_default.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils_default.isFormData(data);
    if (isFormData2) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON_default(data)) : data;
    }
    if (utils_default.isArrayBuffer(data) || utils_default.isBuffer(data) || utils_default.isStream(data) || utils_default.isFile(data) || utils_default.isBlob(data)) {
      return data;
    }
    if (utils_default.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils_default.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils_default.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData_default(
          isFileList2 ? { "files[]": data } : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional2 = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (data && utils_default.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === "SyntaxError") {
            throw AxiosError_default.from(e, AxiosError_default.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }
    return data;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform_default.classes.FormData,
    Blob: platform_default.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils_default.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults.headers[method] = {};
});
var defaults_default = defaults;

// server/node_modules/axios/lib/helpers/parseHeaders.js
var ignoreDuplicateOf = utils_default.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
var parseHeaders_default = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
    i = line.indexOf(":");
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};

// server/node_modules/axios/lib/core/AxiosHeaders.js
var $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils_default.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
var isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
  if (utils_default.isFunction(filter2)) {
    return filter2.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils_default.isString(value))
    return;
  if (utils_default.isString(filter2)) {
    return value.indexOf(filter2) !== -1;
  }
  if (utils_default.isRegExp(filter2)) {
    return filter2.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils_default.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function (arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
var AxiosHeaders = class {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils_default.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils_default.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils_default.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils_default.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders_default(header), valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils_default.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils_default.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils_default.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils_default.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys = Object.keys(this);
    let i = keys.length;
    let deleted = false;
    while (i--) {
      const key = keys[i];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format) {
    const self2 = this;
    const headers = {};
    utils_default.forEach(this, (value, header) => {
      const key = utils_default.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils_default.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils_default.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed = new this(first);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype3 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype3, _header);
        accessors[lHeader] = true;
      }
    }
    utils_default.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
};
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils_default.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1);
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils_default.freezeMethods(AxiosHeaders);
var AxiosHeaders_default = AxiosHeaders;

// server/node_modules/axios/lib/core/transformData.js
function transformData(fns, response) {
  const config = this || defaults_default;
  const context = response || config;
  const headers = AxiosHeaders_default.from(context.headers);
  let data = context.data;
  utils_default.forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data;
}

// server/node_modules/axios/lib/cancel/isCancel.js
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}

// server/node_modules/axios/lib/cancel/CanceledError.js
function CanceledError(message, config, request) {
  AxiosError_default.call(this, message == null ? "canceled" : message, AxiosError_default.ERR_CANCELED, config, request);
  this.name = "CanceledError";
}
utils_default.inherits(CanceledError, AxiosError_default, {
  __CANCEL__: true
});
var CanceledError_default = CanceledError;

// server/node_modules/axios/lib/core/settle.js
function settle(resolve, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError_default(
      "Request failed with status code " + response.status,
      [AxiosError_default.ERR_BAD_REQUEST, AxiosError_default.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}

// server/node_modules/axios/lib/helpers/cookies.js
var cookies_default = platform_default.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(name, value, expires, path, domain, secure) {
      const cookie = [name + "=" + encodeURIComponent(value)];
      utils_default.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
      utils_default.isString(path) && cookie.push("path=" + path);
      utils_default.isString(domain) && cookie.push("domain=" + domain);
      secure === true && cookie.push("secure");
      document.cookie = cookie.join("; ");
    },
    read(name) {
      const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
      return match ? decodeURIComponent(match[3]) : null;
    },
    remove(name) {
      this.write(name, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);

// server/node_modules/axios/lib/helpers/isAbsoluteURL.js
function isAbsoluteURL(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}

// server/node_modules/axios/lib/helpers/combineURLs.js
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}

// server/node_modules/axios/lib/core/buildFullPath.js
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}

// server/node_modules/axios/lib/helpers/isURLSameOrigin.js
var isURLSameOrigin_default = platform_default.hasStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function standardBrowserEnv() {
    const msie = /(msie|trident)/i.test(navigator.userAgent);
    const urlParsingNode = document.createElement("a");
    let originURL;
    function resolveURL(url) {
      let href = url;
      if (msie) {
        urlParsingNode.setAttribute("href", href);
        href = urlParsingNode.href;
      }
      urlParsingNode.setAttribute("href", href);
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
      };
    }
    originURL = resolveURL(window.location.href);
    return function isURLSameOrigin(requestURL) {
      const parsed = utils_default.isString(requestURL) ? resolveURL(requestURL) : requestURL;
      return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  /* @__PURE__ */ function nonStandardBrowserEnv() {
    return function isURLSameOrigin() {
      return true;
    };
  }()
);

// server/node_modules/axios/lib/helpers/parseProtocol.js
function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || "";
}

// server/node_modules/axios/lib/helpers/speedometer.js
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== void 0 ? min : 1e3;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now;
    let i = tail;
    let bytesCount = 0;
    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
var speedometer_default = speedometer;

// server/node_modules/axios/lib/adapters/xhr.js
function progressEventReducer(listener, isDownloadStream) {
  let bytesNotified = 0;
  const _speedometer = speedometer_default(50, 250);
  return (e) => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e
    };
    data[isDownloadStream ? "download" : "upload"] = true;
    listener(data);
  };
}
var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
var xhr_default = isXHRAdapterSupported && function (config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    let requestData = config.data;
    const requestHeaders = AxiosHeaders_default.from(config.headers).normalize();
    let { responseType, withXSRFToken } = config;
    let onCanceled;
    function done() {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(onCanceled);
      }
      if (config.signal) {
        config.signal.removeEventListener("abort", onCanceled);
      }
    }
    let contentType;
    if (utils_default.isFormData(requestData)) {
      if (platform_default.hasStandardBrowserEnv || platform_default.hasStandardBrowserWebWorkerEnv) {
        requestHeaders.setContentType(false);
      } else if ((contentType = requestHeaders.getContentType()) !== false) {
        const [type, ...tokens] = contentType ? contentType.split(";").map((token) => token.trim()).filter(Boolean) : [];
        requestHeaders.setContentType([type || "multipart/form-data", ...tokens].join("; "));
      }
    }
    let request = new XMLHttpRequest();
    if (config.auth) {
      const username = config.auth.username || "";
      const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
      requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
    }
    const fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
    request.timeout = config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders_default.from(
        "getAllResponseHeaders" in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };
      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request = null;
    }
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject(new AxiosError_default("Request aborted", AxiosError_default.ECONNABORTED, config, request));
      request = null;
    };
    request.onerror = function handleError() {
      reject(new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config, request));
      request = null;
    };
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = config.transitional || transitional_default;
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(new AxiosError_default(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED,
        config,
        request
      ));
      request = null;
    };
    if (platform_default.hasStandardBrowserEnv) {
      withXSRFToken && utils_default.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(config));
      if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin_default(fullPath)) {
        const xsrfValue = config.xsrfHeaderName && config.xsrfCookieName && cookies_default.read(config.xsrfCookieName);
        if (xsrfValue) {
          requestHeaders.set(config.xsrfHeaderName, xsrfValue);
        }
      }
    }
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils_default.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }
    if (!utils_default.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = config.responseType;
    }
    if (typeof config.onDownloadProgress === "function") {
      request.addEventListener("progress", progressEventReducer(config.onDownloadProgress, true));
    }
    if (typeof config.onUploadProgress === "function" && request.upload) {
      request.upload.addEventListener("progress", progressEventReducer(config.onUploadProgress));
    }
    if (config.cancelToken || config.signal) {
      onCanceled = (cancel) => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError_default(null, config, request) : cancel);
        request.abort();
        request = null;
      };
      config.cancelToken && config.cancelToken.subscribe(onCanceled);
      if (config.signal) {
        config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(fullPath);
    if (protocol && platform_default.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError_default("Unsupported protocol " + protocol + ":", AxiosError_default.ERR_BAD_REQUEST, config));
      return;
    }
    request.send(requestData || null);
  });
};

// server/node_modules/axios/lib/adapters/adapters.js
var knownAdapters = {
  http: null_default,
  xhr: xhr_default
};
utils_default.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value });
    } catch (e) {
    }
    Object.defineProperty(fn, "adapterName", { value });
  }
});
var renderReason = (reason) => `- ${reason}`;
var isResolvedHandle = (adapter) => utils_default.isFunction(adapter) || adapter === null || adapter === false;
var adapters_default = {
  getAdapter: (adapters) => {
    adapters = utils_default.isArray(adapters) ? adapters : [adapters];
    const { length } = adapters;
    let nameOrAdapter;
    let adapter;
    const rejectedReasons = {};
    for (let i = 0; i < length; i++) {
      nameOrAdapter = adapters[i];
      let id;
      adapter = nameOrAdapter;
      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
        if (adapter === void 0) {
          throw new AxiosError_default(`Unknown adapter '${id}'`);
        }
      }
      if (adapter) {
        break;
      }
      rejectedReasons[id || "#" + i] = adapter;
    }
    if (!adapter) {
      const reasons = Object.entries(rejectedReasons).map(
        ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
      );
      let s = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
      throw new AxiosError_default(
        `There is no suitable adapter to dispatch the request ` + s,
        "ERR_NOT_SUPPORT"
      );
    }
    return adapter;
  },
  adapters: knownAdapters
};

// server/node_modules/axios/lib/core/dispatchRequest.js
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError_default(null, config);
  }
}
function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = AxiosHeaders_default.from(config.headers);
  config.data = transformData.call(
    config,
    config.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config.method) !== -1) {
    config.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters_default.getAdapter(config.adapter || defaults_default.adapter);
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );
    response.headers = AxiosHeaders_default.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders_default.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}

// server/node_modules/axios/lib/core/mergeConfig.js
var headersToObject = (thing) => thing instanceof AxiosHeaders_default ? thing.toJSON() : thing;
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config = {};
  function getMergedValue(target, source, caseless) {
    if (utils_default.isPlainObject(target) && utils_default.isPlainObject(source)) {
      return utils_default.merge.call({ caseless }, target, source);
    } else if (utils_default.isPlainObject(source)) {
      return utils_default.merge({}, source);
    } else if (utils_default.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a, b, caseless) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(a, b, caseless);
    } else if (!utils_default.isUndefined(a)) {
      return getMergedValue(void 0, a, caseless);
    }
  }
  function valueFromConfig2(a, b) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(void 0, b);
    }
  }
  function defaultToConfig2(a, b) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(void 0, b);
    } else if (!utils_default.isUndefined(a)) {
      return getMergedValue(void 0, a);
    }
  }
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(void 0, a);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b) => mergeDeepProperties(headersToObject(a), headersToObject(b), true)
  };
  utils_default.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils_default.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
}

// server/node_modules/axios/lib/env/data.js
var VERSION = "1.6.7";

// server/node_modules/axios/lib/helpers/validator.js
var validators = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
  validators[type] = function validator(thing) {
    return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
  };
});
var deprecatedWarnings = {};
validators.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts) => {
    if (validator === false) {
      throw new AxiosError_default(
        formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
        AxiosError_default.ERR_DEPRECATED
      );
    }
    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version + " and will be removed in the near future"
        )
      );
    }
    return validator ? validator(value, opt, opts) : true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError_default("options must be an object", AxiosError_default.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === void 0 || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError_default("option " + opt + " must be " + result, AxiosError_default.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError_default("Unknown option " + opt, AxiosError_default.ERR_BAD_OPTION);
    }
  }
}
var validator_default = {
  assertOptions,
  validators
};

// server/node_modules/axios/lib/core/Axios.js
var validators2 = validator_default.validators;
var Axios = class {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager_default(),
      response: new InterceptorManager_default()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config) {
    try {
      return await this._request(configOrUrl, config);
    } catch (err) {
      if (err instanceof Error) {
        let dummy;
        Error.captureStackTrace ? Error.captureStackTrace(dummy = {}) : dummy = new Error();
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
        if (!err.stack) {
          err.stack = stack;
        } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
          err.stack += "\n" + stack;
        }
      }
      throw err;
    }
  }
  _request(configOrUrl, config) {
    if (typeof configOrUrl === "string") {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig(this.defaults, config);
    const { transitional: transitional2, paramsSerializer, headers } = config;
    if (transitional2 !== void 0) {
      validator_default.assertOptions(transitional2, {
        silentJSONParsing: validators2.transitional(validators2.boolean),
        forcedJSONParsing: validators2.transitional(validators2.boolean),
        clarifyTimeoutError: validators2.transitional(validators2.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils_default.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator_default.assertOptions(paramsSerializer, {
          encode: validators2.function,
          serialize: validators2.function
        }, true);
      }
    }
    config.method = (config.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils_default.merge(
      headers.common,
      headers[config.method]
    );
    headers && utils_default.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config.headers = AxiosHeaders_default.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config);
      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config;
    i = 0;
    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i = 0;
    len = responseInterceptorChain.length;
    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }
    return promise;
  }
  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
};
utils_default.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
  Axios.prototype[method] = function (url, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});
utils_default.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url,
        data
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
var Axios_default = Axios;

// server/node_modules/axios/lib/cancel/CancelToken.js
var CancelToken = class _CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners)
        return;
      let i = token._listeners.length;
      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve) => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message, config, request) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError_default(message, config, request);
      resolvePromise(token.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new _CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  }
};
var CancelToken_default = CancelToken;

// server/node_modules/axios/lib/helpers/spread.js
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}

// server/node_modules/axios/lib/helpers/isAxiosError.js
function isAxiosError(payload) {
  return utils_default.isObject(payload) && payload.isAxiosError === true;
}

// server/node_modules/axios/lib/helpers/HttpStatusCode.js
var HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});
var HttpStatusCode_default = HttpStatusCode;

// server/node_modules/axios/lib/axios.js
function createInstance(defaultConfig) {
  const context = new Axios_default(defaultConfig);
  const instance = bind(Axios_default.prototype.request, context);
  utils_default.extend(instance, Axios_default.prototype, context, { allOwnKeys: true });
  utils_default.extend(instance, context, null, { allOwnKeys: true });
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance;
}
var axios = createInstance(defaults_default);
axios.Axios = Axios_default;
axios.CanceledError = CanceledError_default;
axios.CancelToken = CancelToken_default;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData_default;
axios.AxiosError = AxiosError_default;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders_default;
axios.formToJSON = (thing) => formDataToJSON_default(utils_default.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters_default.getAdapter;
axios.HttpStatusCode = HttpStatusCode_default;
axios.default = axios;
var axios_default = axios;

// server/node_modules/axios/index.js
var {
  Axios: Axios2,
  AxiosError: AxiosError2,
  CanceledError: CanceledError2,
  isCancel: isCancel2,
  CancelToken: CancelToken2,
  VERSION: VERSION2,
  all: all2,
  Cancel,
  isAxiosError: isAxiosError2,
  spread: spread2,
  toFormData: toFormData2,
  AxiosHeaders: AxiosHeaders2,
  HttpStatusCode: HttpStatusCode2,
  formToJSON,
  getAdapter,
  mergeConfig: mergeConfig2
} = axios_default;

// server/node_modules/@superoffice/webapi/dist/esm/AxiosCacheHandler.js
var AxiosCache = class _AxiosCache {
  /**
   * duration in minutes
   */
  static store(key, value, duration2 = _AxiosCache.CACHE_INTERVAL) {
    if (_AxiosCache.isValid(key).isValid) {
      return;
    }
    const dateStamp = Date.now() + new Date(duration2 * 60 * 1e3).getTime();
    const finalValue = { value: JSON.stringify(value), dateStamp };
    const _axioCache = this.getCache();
    _axioCache[key] = finalValue;
    this.persistCache(_axioCache);
  }
  // Returns true if an object has been stored using the store method
  // and have yet not expired
  static isValid(key) {
    const _axioCache = this.getCache();
    if (!_axioCache[key]) {
      return {
        isValid: false
      };
    }
    const value = _axioCache[key];
    const timestamp = value.dateStamp;
    if (Number.isNaN(timestamp)) {
      return {
        isValid: false
      };
    }
    const date = new Date(timestamp);
    if (date.toString() === "Invalid Date") {
      return {
        isValid: false
      };
    }
    if (date.getTime() > Date.now()) {
      return {
        isValid: true,
        value: JSON.parse(value.value)
      };
    }
    delete _axioCache[key];
    this.persistCache(_axioCache);
    return {
      isValid: false
    };
  }
  static getCache() {
    return this._cache;
  }
  static persistCache(_axiosCache) {
    this._cache = _axiosCache;
  }
  static clear() {
    this._cache = {};
  }
};
AxiosCache._cache = {};
AxiosCache.CACHE_INTERVAL = 0.2;

// server/node_modules/@superoffice/webapi/dist/esm/SoApiConstants.js
var HEADER_NAME_BROWSER_TZ_OFFSET = "SO-Browser-TZ-Offset";
var HEADER_NAME_CULTURE = "SO-Culture";
var HEADER_NAME_ACCEPT_LANGUAGE = "Accept-Language";
var HEADER_NAME_LANGUAGE = "SO-Language";
var HEADER_NAME_TIMEZONE = "SO-Timezone";

// server/node_modules/@superoffice/webapi/dist/esm/WebApiBase.js
var WebApiStatus;
(function (WebApiStatus2) {
  WebApiStatus2[WebApiStatus2["Unknown"] = 0] = "Unknown";
  WebApiStatus2[WebApiStatus2["Pending"] = 1] = "Pending";
  WebApiStatus2[WebApiStatus2["Completed"] = 10] = "Completed";
  WebApiStatus2[WebApiStatus2["Failed"] = -1] = "Failed";
  WebApiStatus2[WebApiStatus2["Cancelled"] = -4] = "Cancelled";
})(WebApiStatus || (WebApiStatus = {}));
var ReturnBlobType;
(function (ReturnBlobType2) {
  ReturnBlobType2[ReturnBlobType2["AsArrayBuffer"] = 0] = "AsArrayBuffer";
  ReturnBlobType2[ReturnBlobType2["AsBase64"] = 1] = "AsBase64";
  ReturnBlobType2[ReturnBlobType2["AsString"] = 2] = "AsString";
})(ReturnBlobType || (ReturnBlobType = {}));
var WebApiPatchOp;
(function (WebApiPatchOp2) {
  WebApiPatchOp2["add"] = "add";
  WebApiPatchOp2["remove"] = "remove";
  WebApiPatchOp2["replace"] = "replace";
  WebApiPatchOp2["test"] = "test";
})(WebApiPatchOp || (WebApiPatchOp = {}));
var ResourceParsing;
(function (ResourceParsing2) {
  ResourceParsing2[ResourceParsing2["Parse"] = 0] = "Parse";
  ResourceParsing2[ResourceParsing2["DoNotParse"] = 1] = "DoNotParse";
})(ResourceParsing || (ResourceParsing = {}));
var WebApiBase = class _WebApiBase {
  constructor(options, createAxios = true) {
    var _a;
    const nodejs = typeof process !== "undefined" && process.versions && process.versions.node;
    const isBrowser = !nodejs && (typeof window !== "undefined" || typeof self !== "undefined");
    if (!isBrowser && !options.baseUrl)
      throw new Error("WebAPI: BaseURL is not defined.");
    if (!_WebApiBase._global_options)
      _WebApiBase._global_options = _WebApiBase.CloneOptions(options);
    this.SetBaseUrl(options);
    if (options.resourceManager && options.resourceManager.getCurrentLangCode) {
      options.languageCode = options.resourceManager.getCurrentLangCode();
    }
    if (options.resourceManager && options.resourceManager.getCurrentFormatCode) {
      options.cultureCode = options.resourceManager.getCurrentFormatCode();
    }
    if (!options.axios && createAxios) {
      options.axios = axios_default.create(options.axiosConfig);
      if (!isBrowser)
        options.axios.defaults.headers["User-Agent"] = "SO-TS-WebApi/1.0";
      options.axios.defaults.headers["Content-Type"] = "application/json";
      options.axios.defaults.headers[HEADER_NAME_BROWSER_TZ_OFFSET] = -(/* @__PURE__ */ new Date()).getTimezoneOffset();
      if (options.languageCode)
        options.axios.defaults.headers[HEADER_NAME_LANGUAGE] = options.languageCode;
      if (options.cultureCode)
        options.axios.defaults.headers[HEADER_NAME_CULTURE] = options.cultureCode;
      if (options.timezone)
        options.axios.defaults.headers[HEADER_NAME_TIMEZONE] = options.timezone;
      if (options.timezoneInclude) {
        options.axios.defaults.headers[HEADER_NAME_TIMEZONE] = (_a = options.axios.defaults.headers[HEADER_NAME_TIMEZONE]) !== null && _a !== void 0 ? _a : "";
        if (options.axios.defaults.headers[HEADER_NAME_TIMEZONE])
          options.axios.defaults.headers[HEADER_NAME_TIMEZONE] += ",";
        options.axios.defaults.headers[HEADER_NAME_TIMEZONE] += "includeTZOffset";
      }
      if (options.resourceParsing === ResourceParsing.DoNotParse) {
        options.axios.defaults.headers[HEADER_NAME_ACCEPT_LANGUAGE] = "";
        options.axios.defaults.headers[HEADER_NAME_LANGUAGE] = "";
        options.axios.defaults.headers[HEADER_NAME_CULTURE] = "";
        delete options.axios.defaults.headers[HEADER_NAME_LANGUAGE];
        delete options.axios.defaults.headers[HEADER_NAME_CULTURE];
      }
      if (options.cache) {
        options.axios.interceptors.request.use((request) => this.requestHandler(request, options.cache));
        options.axios.interceptors.response.use((response) => this.responseHandler(response, options.cache), (error) => this.errorHandler(error));
      } else {
        options.axios.interceptors.response.use(void 0, options.errorHandler);
      }
    }
    this._options = options;
    this._axios = options.axios;
  }
  responseHandler(response, cache) {
    if (response.config.url) {
      AxiosCache.store(response.config["cachekey"], response.data, cache.duration);
    }
    return response;
  }
  //Handler when cache hits in requestHandler
  errorHandler(error) {
    if (error && error.headers && error.headers.cached === "true") {
      return Promise.resolve(error);
    }
    if (this._options.errorHandler) {
      return this._options.errorHandler(error);
    }
    return Promise.reject(error);
  }
  requestHandler(request, cache) {
    if (cache.refresh) {
      return request;
    }
    request["cachekey"] = this.hashValue(request.url + JSON.stringify(request.data)) + (request.headers.get(HEADER_NAME_LANGUAGE) ? request.headers.get(HEADER_NAME_LANGUAGE) : "");
    const checkIsValidResponse = AxiosCache.isValid(request["cachekey"] || "");
    if (checkIsValidResponse.isValid) {
      request.headers.set("cached", "true");
      request.data = checkIsValidResponse.value || "{}";
      return Promise.reject(request);
    }
    return request;
  }
  SetBaseUrl(options) {
    if (options.baseUrl === "")
      options.baseUrl = "/api/";
    if (options.baseUrl.lastIndexOf("/") < options.baseUrl.length - 1)
      options.baseUrl += "/";
    if (options.basePath) {
      if (options.baseUrl.lastIndexOf("api/") < options.baseUrl.length - 4)
        options.baseUrl += "api/";
      options.baseUrl += options.basePath;
      options.basePath = void 0;
    }
  }
  hashValue(s) {
    if (!s)
      return "";
    return "_" + s.split("").reduce(function (a, b) {
      a = (a << 5) - a + b.charCodeAt(0);
      return a & a;
    }, 0);
  }
  static CloneOptions(options) {
    const clone = {
      baseUrl: options.baseUrl,
      resourceParsing: options.resourceParsing,
      languageCode: options.languageCode,
      cultureCode: options.cultureCode,
      timezone: options.timezone,
      timezoneInclude: options.timezoneInclude,
      axios: options.axios,
      axiosConfig: options.axiosConfig,
      resourceManager: options.resourceManager,
      cache: options.cache,
      errorHandler: options.errorHandler
    };
    return clone;
  }
  static GetAxiosRequestConfig(options, baseOptions) {
    var _a;
    let config = null;
    if (baseOptions) {
      if (baseOptions.axiosConfig)
        config = Object.assign({}, baseOptions.axiosConfig);
      config = config || {};
      if (baseOptions.baseUrl)
        config.baseURL = baseOptions.baseUrl;
    }
    config = config || {};
    config.params = config.params || {};
    config.headers = config.headers || {};
    config.headers["Accept"] = "application/json";
    if (options) {
      options.requestStatus = WebApiStatus.Pending;
      if (typeof options.languageCode == "string") {
        config.headers[HEADER_NAME_ACCEPT_LANGUAGE] = options.languageCode;
        config.headers[HEADER_NAME_LANGUAGE] = options.languageCode;
      }
      if (typeof options.cultureCode == "string") {
        config.headers[HEADER_NAME_CULTURE] = options.cultureCode;
      }
      if (typeof options.timezone == "string") {
        config.headers[HEADER_NAME_TIMEZONE] = options.timezone;
      }
      if (options.timezoneInclude) {
        config.headers[HEADER_NAME_TIMEZONE] = (_a = config.headers[HEADER_NAME_TIMEZONE]) !== null && _a !== void 0 ? _a : "";
        if (config.headers[HEADER_NAME_TIMEZONE])
          config.headers[HEADER_NAME_TIMEZONE] += ",";
        config.headers[HEADER_NAME_TIMEZONE] += "includeTZOffset";
      }
      if (options.abortController) {
        config.signal = options.abortController.signal;
      } else if (options.cancelToken) {
        config.cancelToken = options.cancelToken.token;
      }
      if (options.abortController) {
        config.signal = options.abortController.signal;
      }
      const getOptions = options;
      if (getOptions && getOptions.ifModifiedSince) {
        if (typeof getOptions.ifModifiedSince == "object")
          config.headers["If-Modified-Since"] = getOptions.ifModifiedSince.toUTCString();
        if (typeof getOptions.ifModifiedSince == "string")
          config.headers["If-Modified-Since"] = getOptions.ifModifiedSince;
        if (!getOptions.ifNotModifiedThrowError)
          config.validateStatus = _WebApiBase.validateModifiedStatus;
        else
          config.validateStatus = _WebApiBase.validate200Status;
      }
      if (getOptions && getOptions.ifUnmodifiedSince) {
        if (typeof getOptions.ifUnmodifiedSince == "object")
          config.headers["If-Unmodified-Since"] = getOptions.ifUnmodifiedSince.toUTCString();
        if (typeof getOptions.ifUnmodifiedSince == "string")
          config.headers["If-Unmodified-Since"] = getOptions.ifUnmodifiedSince;
      }
      const putOptions = options;
      if (putOptions && putOptions.ifUnmodifiedSince) {
        if (typeof putOptions.ifUnmodifiedSince == "object")
          config.headers["If-Unmodified-Since"] = putOptions.ifUnmodifiedSince.toUTCString();
        if (typeof putOptions.ifUnmodifiedSince == "string")
          config.headers["If-Unmodified-Since"] = putOptions.ifUnmodifiedSince;
      }
    }
    _WebApiBase.SetXSRFTokenFromHiddenField();
    return config;
  }
  static SetXSRFTokenFromHiddenField() {
    if (typeof window != "undefined" && document && document.cookie) {
      if (document.cookie.indexOf("XSRF-TOKEN") < 0) {
        let xsrfToken = void 0;
        let msg = void 0;
        const xsrfInput = document.getElementById("XSRF_TOKEN");
        if (xsrfInput) {
          xsrfToken = xsrfInput.value;
          msg = "Setting XSRF cookie from INPUT field";
        }
        if (!xsrfToken) {
          msg = "No XSRF cookie found.";
          if (console)
            console.log(msg);
        }
        if (xsrfToken) {
          let path = window.location.pathname;
          let lowpath = path.toLowerCase();
          if (lowpath.endsWith("default.aspx"))
            path = path.substring(0, path.length - 12);
          lowpath = path.toLowerCase();
          if (lowpath.endsWith("/"))
            path = path.substring(0, path.length - 1);
          lowpath = path.toLowerCase();
          if (lowpath.endsWith("/admin"))
            path = path.substring(0, path.length - 6);
          lowpath = path.toLowerCase();
          let scriptsPos = lowpath.indexOf("/scripts/");
          let exePos = lowpath.indexOf(".fcgi");
          if (exePos < 0)
            exePos = lowpath.indexOf(".exe");
          if (scriptsPos > 0 && exePos > 0) {
            path = path.substring(0, scriptsPos);
            let slashPos = path.lastIndexOf("/");
            if (slashPos > 1)
              path = path.substring(0, slashPos);
          }
          document.cookie = "XSRF-TOKEN=" + xsrfToken + ";SameSite=Lax;Secure;path=" + path;
          if (console)
            console.log(msg);
          document.cookie = "XSRF-FROM-INPUT=" + path + ";SameSite=Lax;Secure;";
        }
      }
    }
  }
  // `validateStatus` defines whether to resolve or reject the promise for a given
  // HTTP response status code. If `validateStatus` returns `true` (or is set to `null`
  // or `undefined`), the promise will be resolved; otherwise, the promise will be
  // rejected.
  // validate 304 Unmodified as ok
  static validateModifiedStatus(status) {
    const validate = status >= 200 && status < 300 || status === 304;
    return validate;
  }
  static validate200Status(status) {
    const validate = status >= 200 && status < 300;
    return validate;
  }
  static FigureOutOptions(baseUrlOrOptions, langOrconfigOrRMOrParse, langOrResourceOrRM, cultureCode) {
    let options = {};
    if (typeof baseUrlOrOptions == "object") {
      options = baseUrlOrOptions;
      options = _WebApiBase.CloneOptions(options);
    } else if (typeof baseUrlOrOptions == "string") {
      options = {
        baseUrl: baseUrlOrOptions
      };
    }
    if (typeof langOrconfigOrRMOrParse == "string") {
      options.languageCode = langOrconfigOrRMOrParse;
    } else if (typeof langOrconfigOrRMOrParse == "object") {
      if (langOrconfigOrRMOrParse.getCurrentLangCode && langOrconfigOrRMOrParse.getCurrentLangCode)
        options.resourceManager = langOrconfigOrRMOrParse;
      if (langOrconfigOrRMOrParse.auth || langOrconfigOrRMOrParse.baseURL || langOrconfigOrRMOrParse.url || langOrconfigOrRMOrParse.headers || langOrconfigOrRMOrParse.timeout)
        options.axiosConfig = langOrconfigOrRMOrParse;
    } else if (typeof langOrconfigOrRMOrParse == "number") {
      options.resourceParsing = langOrconfigOrRMOrParse;
    }
    if (typeof langOrResourceOrRM == "string") {
      options.languageCode = langOrResourceOrRM;
    } else if (typeof langOrResourceOrRM == "number") {
      options.resourceParsing = langOrResourceOrRM;
    } else if (typeof langOrResourceOrRM == "object") {
      if (langOrResourceOrRM.getCurrentLangCode && langOrResourceOrRM.getCurrentLangCode)
        options.resourceManager = langOrResourceOrRM;
      if (langOrResourceOrRM.auth || langOrResourceOrRM.baseURL || langOrResourceOrRM.url || langOrResourceOrRM.headers || langOrResourceOrRM.timeout)
        options.axiosConfig = langOrResourceOrRM;
    }
    if (cultureCode)
      options.cultureCode = cultureCode;
    if (_WebApiBase._global_options) {
      if (!options.baseUrl)
        options.baseUrl = _WebApiBase._global_options.baseUrl;
      if (!options.axios)
        options.axios = _WebApiBase._global_options.axios;
      if (!options.axiosConfig)
        options.axiosConfig = _WebApiBase._global_options.axiosConfig;
      if (!options.cultureCode)
        options.cultureCode = _WebApiBase._global_options.cultureCode;
      if (!options.languageCode)
        options.languageCode = _WebApiBase._global_options.languageCode;
      if (!options.timezone)
        options.timezone = _WebApiBase._global_options.timezone;
      if (options.timezoneInclude === void 0)
        options.timezoneInclude = _WebApiBase._global_options.timezoneInclude;
      if (!options.resourceManager)
        options.resourceManager = _WebApiBase._global_options.resourceManager;
      if (!options.errorHandler)
        options.errorHandler = _WebApiBase._global_options.errorHandler;
    }
    return options;
  }
  /** @deprecated Make a new cancel token that can be placed in an WebApiRequestOptions object. */
  MakeCancelToken() {
    return axios_default.CancelToken.source();
  }
  /** Make a new AbortController that can be placed in an  WebApiRequestOptions object */
  MakeAbortController() {
    return new AbortController();
  }
  /** @deprecated Make a new options object with an cancelToken on it. */
  MakeOptions() {
    const opts = {};
    opts.requestStatus = WebApiStatus.Unknown;
    opts.cancelToken = this.MakeCancelToken();
    return opts;
  }
  /** Make a new options object with an abortController on it */
  MakeAbortableOptions() {
    const opts = {};
    opts.requestStatus = WebApiStatus.Unknown;
    opts.abortController = this.MakeAbortController();
    return opts;
  }
  static SetPending(options) {
    var _a;
    if (options)
      options.requestStatus = WebApiStatus.Pending;
    if (options && options.threshold) {
      options.threshold.timeoutHandler = setTimeout(() => {
        if (options.threshold.timeout > 0)
          options.threshold.successCallback = null;
        options.threshold.callback();
      }, options.threshold.timeout);
    }
    if ((_a = options === null || options === void 0 ? void 0 : options.cancelToken) === null || _a === void 0 ? void 0 : _a.token.reason)
      options.requestStatus = WebApiStatus.Cancelled;
  }
  static SetCompleted(options) {
    var _a, _b;
    if (options) {
      if (options === null || options === void 0 ? void 0 : options.threshold) {
        clearTimeout(options.threshold.timeoutHandler);
        if (options.threshold.successCallback)
          options.threshold.successCallback();
      }
      if ((_b = (_a = options.cancelToken) === null || _a === void 0 ? void 0 : _a.token) === null || _b === void 0 ? void 0 : _b.reason)
        options.requestStatus = WebApiStatus.Cancelled;
      else
        options.requestStatus = WebApiStatus.Completed;
    }
  }
  static HandleError(options, config, err) {
    if (options) {
      if (options && options.threshold) {
        clearTimeout(options.threshold.timeoutHandler);
        if (options.threshold.errorCallback)
          options.threshold.errorCallback();
      }
      if (((config === null || config === void 0 ? void 0 : config.signal) || (config === null || config === void 0 ? void 0 : config.cancelToken)) && axios_default.isCancel(err)) {
        options.requestStatus = WebApiStatus.Cancelled;
      } else {
        options.requestStatus = WebApiStatus.Failed;
      }
    }
  }
};

// server/node_modules/@superoffice/webapi/dist/esm/Enums.js
var AddressType;
(function (AddressType2) {
  AddressType2["Unknown"] = "Unknown";
  AddressType2["ContactPostalAddress"] = "ContactPostalAddress";
  AddressType2["ContactStreetAddress"] = "ContactStreetAddress";
  AddressType2["PersonPrivateAddress"] = "PersonPrivateAddress";
  AddressType2["QuoteBillingAddress"] = "QuoteBillingAddress";
  AddressType2["QuoteShippingAddress"] = "QuoteShippingAddress";
})(AddressType || (AddressType = {}));
var AppointmentPrivate;
(function (AppointmentPrivate2) {
  AppointmentPrivate2["Public"] = "Public";
  AppointmentPrivate2["PrivateUser"] = "PrivateUser";
  AppointmentPrivate2["PrivateGroup"] = "PrivateGroup";
})(AppointmentPrivate || (AppointmentPrivate = {}));
var AppointmentStatus;
(function (AppointmentStatus2) {
  AppointmentStatus2["UnknownOrPostIt"] = "UnknownOrPostIt";
  AppointmentStatus2["NotStarted"] = "NotStarted";
  AppointmentStatus2["Started"] = "Started";
  AppointmentStatus2["Completed"] = "Completed";
  AppointmentStatus2["Hidden"] = "Hidden";
  AppointmentStatus2["Booking"] = "Booking";
  AppointmentStatus2["BookingMoved"] = "BookingMoved";
  AppointmentStatus2["BookingSeen"] = "BookingSeen";
  AppointmentStatus2["BookingMovedSeen"] = "BookingMovedSeen";
  AppointmentStatus2["BookingDeclined"] = "BookingDeclined";
  AppointmentStatus2["BookingDeleted"] = "BookingDeleted";
  AppointmentStatus2["Assignment"] = "Assignment";
  AppointmentStatus2["AssignmentSeen"] = "AssignmentSeen";
  AppointmentStatus2["AssignmentDeclined"] = "AssignmentDeclined";
})(AppointmentStatus || (AppointmentStatus = {}));
var AppointmentType;
(function (AppointmentType2) {
  AppointmentType2["Unknown"] = "Unknown";
  AppointmentType2["inDiary"] = "inDiary";
  AppointmentType2["inChecklist"] = "inChecklist";
  AppointmentType2["Note"] = "Note";
  AppointmentType2["Document"] = "Document";
  AppointmentType2["SavedReport"] = "SavedReport";
  AppointmentType2["BookingForDiary"] = "BookingForDiary";
  AppointmentType2["BookingForChecklist"] = "BookingForChecklist";
  AppointmentType2["MergeDraft"] = "MergeDraft";
  AppointmentType2["MergeFinal"] = "MergeFinal";
})(AppointmentType || (AppointmentType = {}));
var FieldAccess;
(function (FieldAccess2) {
  FieldAccess2["Normal"] = "Normal";
  FieldAccess2["Mandatory"] = "Mandatory";
  FieldAccess2["ReadOnly"] = "ReadOnly";
})(FieldAccess || (FieldAccess = {}));
var FieldMetadataType;
(function (FieldMetadataType2) {
  FieldMetadataType2["Checkbox"] = "Checkbox";
  FieldMetadataType2["Text"] = "Text";
  FieldMetadataType2["Password"] = "Password";
  FieldMetadataType2["Integer"] = "Integer";
  FieldMetadataType2["Double"] = "Double";
  FieldMetadataType2["List"] = "List";
  FieldMetadataType2["Date"] = "Date";
  FieldMetadataType2["Label"] = "Label";
})(FieldMetadataType || (FieldMetadataType = {}));
var DocTmplDirection;
(function (DocTmplDirection2) {
  DocTmplDirection2["Unknown"] = "Unknown";
  DocTmplDirection2["Incoming"] = "Incoming";
  DocTmplDirection2["Outgoing"] = "Outgoing";
  DocTmplDirection2["SaintAll"] = "SaintAll";
})(DocTmplDirection || (DocTmplDirection = {}));
var DocTmplQuoteType;
(function (DocTmplQuoteType2) {
  DocTmplQuoteType2["None"] = "None";
  DocTmplQuoteType2["MailBody"] = "MailBody";
  DocTmplQuoteType2["MainDocument"] = "MainDocument";
  DocTmplQuoteType2["QuoteLines"] = "QuoteLines";
  DocTmplQuoteType2["ConfirmationMailBody"] = "ConfirmationMailBody";
  DocTmplQuoteType2["ConfirmationLines"] = "ConfirmationLines";
})(DocTmplQuoteType || (DocTmplQuoteType = {}));
var DocTmplType;
(function (DocTmplType2) {
  DocTmplType2["Unknown"] = "Unknown";
  DocTmplType2["Appointment"] = "Appointment";
  DocTmplType2["Document"] = "Document";
  DocTmplType2["Email"] = "Email";
  DocTmplType2["Fax"] = "Fax";
  DocTmplType2["Phone"] = "Phone";
  DocTmplType2["Todo"] = "Todo";
  DocTmplType2["MergeDraft"] = "MergeDraft";
  DocTmplType2["MergeFinal"] = "MergeFinal";
  DocTmplType2["SavedReport"] = "SavedReport";
})(DocTmplType || (DocTmplType = {}));
var ExecuteOnEvent;
(function (ExecuteOnEvent2) {
  ExecuteOnEvent2["Never"] = "Never";
  ExecuteOnEvent2["Logon"] = "Logon";
  ExecuteOnEvent2["Logoff"] = "Logoff";
  ExecuteOnEvent2["LocalUpdate"] = "LocalUpdate";
  ExecuteOnEvent2["Wait"] = "Wait";
})(ExecuteOnEvent || (ExecuteOnEvent = {}));
var ExtraDataFieldType;
(function (ExtraDataFieldType2) {
  ExtraDataFieldType2["String"] = "String";
  ExtraDataFieldType2["Url"] = "Url";
  ExtraDataFieldType2["Image"] = "Image";
})(ExtraDataFieldType || (ExtraDataFieldType = {}));
var Navigation;
(function (Navigation2) {
  Navigation2["Invisible"] = "Invisible";
  Navigation2["ToolboxMenu"] = "ToolboxMenu";
  Navigation2["NavigatorButton"] = "NavigatorButton";
  Navigation2["ViewMenu"] = "ViewMenu";
  Navigation2["SelectionTaskCard"] = "SelectionTaskCard";
  Navigation2["ContactCard"] = "ContactCard";
  Navigation2["ContactArchive"] = "ContactArchive";
  Navigation2["ProjectCard"] = "ProjectCard";
  Navigation2["ProjectArchive"] = "ProjectArchive";
  Navigation2["SaleCard"] = "SaleCard";
  Navigation2["PersonCard"] = "PersonCard";
  Navigation2["ActivityDialog"] = "ActivityDialog";
  Navigation2["DocumentDialog"] = "DocumentDialog";
  Navigation2["BrowserPanel"] = "BrowserPanel";
  Navigation2["ContSelectionTask"] = "ContSelectionTask";
  Navigation2["AppntSelectionTask"] = "AppntSelectionTask";
  Navigation2["SaleSelectionTask"] = "SaleSelectionTask";
  Navigation2["DocSelectionTask"] = "DocSelectionTask";
  Navigation2["ProjSelectionTask"] = "ProjSelectionTask";
  Navigation2["CompanyMinicard"] = "CompanyMinicard";
  Navigation2["ProjectMinicard"] = "ProjectMinicard";
  Navigation2["DiaryMinicard"] = "DiaryMinicard";
  Navigation2["SelectionMinicard"] = "SelectionMinicard";
  Navigation2["ButtonPanelTask"] = "ButtonPanelTask";
  Navigation2["AppointmentDialogTask"] = "AppointmentDialogTask";
  Navigation2["SaleDialogTask"] = "SaleDialogTask";
  Navigation2["DocumentDialogTask"] = "DocumentDialogTask";
  Navigation2["PersonDialogTask"] = "PersonDialogTask";
  Navigation2["SaleMinicard"] = "SaleMinicard";
  Navigation2["SaleArchive"] = "SaleArchive";
  Navigation2["AppntSelectionShadowTask"] = "AppntSelectionShadowTask";
  Navigation2["SaleSelectionShadowTask"] = "SaleSelectionShadowTask";
  Navigation2["DocSelectionShadowTask"] = "DocSelectionShadowTask";
  Navigation2["ProjSelectionShadowTask"] = "ProjSelectionShadowTask";
  Navigation2["DiaryArchive"] = "DiaryArchive";
  Navigation2["SelectionContactArchive"] = "SelectionContactArchive";
  Navigation2["SelectionProjectArchive"] = "SelectionProjectArchive";
  Navigation2["SelectionSaleArchive"] = "SelectionSaleArchive";
  Navigation2["SelectionAppointmentArchive"] = "SelectionAppointmentArchive";
  Navigation2["SelectionDocumentArchive"] = "SelectionDocumentArchive";
  Navigation2["ContSelectionCustomTask"] = "ContSelectionCustomTask";
  Navigation2["AppntSelectionCustomTask"] = "AppntSelectionCustomTask";
  Navigation2["SaleSelectionCustomTask"] = "SaleSelectionCustomTask";
  Navigation2["DocSelectionCustomTask"] = "DocSelectionCustomTask";
  Navigation2["ProjSelectionCustomTask"] = "ProjSelectionCustomTask";
  Navigation2["CustomArchiveMiniCard"] = "CustomArchiveMiniCard";
  Navigation2["SelectionCard"] = "SelectionCard";
  Navigation2["ReportMinicard"] = "ReportMinicard";
  Navigation2["QuoteDialog"] = "QuoteDialog";
  Navigation2["QuoteDialogTask"] = "QuoteDialogTask";
  Navigation2["QuoteDialogArchive"] = "QuoteDialogArchive";
  Navigation2["QuoteLineDialogTask"] = "QuoteLineDialogTask";
  Navigation2["QuoteLineDialog"] = "QuoteLineDialog";
  Navigation2["QuoteLineSelectionMainTask"] = "QuoteLineSelectionMainTask";
  Navigation2["QuoteLineSelectionShadowTask"] = "QuoteLineSelectionShadowTask";
  Navigation2["SelectionQuoteLineArchive"] = "SelectionQuoteLineArchive";
  Navigation2["QuoteLineSelectionCustomTask"] = "QuoteLineSelectionCustomTask";
  Navigation2["FindSystem"] = "FindSystem";
  Navigation2["MailingSelectionTask"] = "MailingSelectionTask";
  Navigation2["ContactSelectionMailingsTask"] = "ContactSelectionMailingsTask";
  Navigation2["AppointmentSelectionMailingsTask"] = "AppointmentSelectionMailingsTask";
  Navigation2["SaleSelectionMailingsTask"] = "SaleSelectionMailingsTask";
  Navigation2["DocumentSelectionMailingsTask"] = "DocumentSelectionMailingsTask";
  Navigation2["ProjectSelectionMailingsTask"] = "ProjectSelectionMailingsTask";
  Navigation2["QuoteLineSelectionMailingsTask"] = "QuoteLineSelectionMailingsTask";
  Navigation2["TopPanelNewMenu"] = "TopPanelNewMenu";
  Navigation2["Dashboard"] = "Dashboard";
  Navigation2["PersonArchive"] = "PersonArchive";
  Navigation2["PersonMinicard"] = "PersonMinicard";
  Navigation2["CompanyCardTask"] = "CompanyCardTask";
  Navigation2["ProjectCardTask"] = "ProjectCardTask";
  Navigation2["TicketCard"] = "TicketCard";
  Navigation2["TicketMinicard"] = "TicketMinicard";
})(Navigation || (Navigation = {}));
var PrefDescAccessFlags;
(function (PrefDescAccessFlags2) {
  PrefDescAccessFlags2[PrefDescAccessFlags2["Unknown"] = 0] = "Unknown";
  PrefDescAccessFlags2[PrefDescAccessFlags2["WizardMode"] = 1] = "WizardMode";
  PrefDescAccessFlags2[PrefDescAccessFlags2["Level0"] = 2] = "Level0";
  PrefDescAccessFlags2[PrefDescAccessFlags2["adminGUI"] = 4] = "adminGUI";
  PrefDescAccessFlags2[PrefDescAccessFlags2["CRMGUI"] = 8] = "CRMGUI";
})(PrefDescAccessFlags || (PrefDescAccessFlags = {}));
var PrefDescValueType;
(function (PrefDescValueType2) {
  PrefDescValueType2["Unknown"] = "Unknown";
  PrefDescValueType2["Number"] = "Number";
  PrefDescValueType2["Text"] = "Text";
  PrefDescValueType2["Bool"] = "Bool";
  PrefDescValueType2["ListOfValues"] = "ListOfValues";
  PrefDescValueType2["ListTableRef"] = "ListTableRef";
  PrefDescValueType2["TimeList"] = "TimeList";
  PrefDescValueType2["ContactID"] = "ContactID";
  PrefDescValueType2["PersonID"] = "PersonID";
  PrefDescValueType2["ProjectID"] = "ProjectID";
  PrefDescValueType2["SelectionID"] = "SelectionID";
  PrefDescValueType2["PosSize"] = "PosSize";
  PrefDescValueType2["TimeZone"] = "TimeZone";
  PrefDescValueType2["Time"] = "Time";
  PrefDescValueType2["Password"] = "Password";
  PrefDescValueType2["MultiLineText"] = "MultiLineText";
})(PrefDescValueType || (PrefDescValueType = {}));
var SaleStatus;
(function (SaleStatus2) {
  SaleStatus2["Unknown"] = "Unknown";
  SaleStatus2["Open"] = "Open";
  SaleStatus2["Sold"] = "Sold";
  SaleStatus2["Lost"] = "Lost";
  SaleStatus2["Stalled"] = "Stalled";
  SaleStatus2["SaintAll"] = "SaintAll";
})(SaleStatus || (SaleStatus = {}));
var ShowState;
(function (ShowState2) {
  ShowState2[ShowState2["Minimized"] = 0] = "Minimized";
  ShowState2[ShowState2["Maximized"] = 1] = "Maximized";
  ShowState2[ShowState2["Default"] = 2] = "Default";
  ShowState2[ShowState2["UndefinedValue4"] = 4] = "UndefinedValue4";
  ShowState2[ShowState2["UndefinedValue8"] = 8] = "UndefinedValue8";
  ShowState2[ShowState2["UndefinedValue16"] = 16] = "UndefinedValue16";
  ShowState2[ShowState2["UndefinedValue32"] = 32] = "UndefinedValue32";
  ShowState2[ShowState2["UndefinedValue64"] = 64] = "UndefinedValue64";
  ShowState2[ShowState2["UndefinedValue128"] = 128] = "UndefinedValue128";
  ShowState2[ShowState2["ToolBar"] = 256] = "ToolBar";
  ShowState2[ShowState2["AddressBar"] = 512] = "AddressBar";
  ShowState2[ShowState2["StatusBar"] = 1024] = "StatusBar";
  ShowState2[ShowState2["MenuBar"] = 2048] = "MenuBar";
})(ShowState || (ShowState = {}));
var TaskDirection;
(function (TaskDirection2) {
  TaskDirection2["Unknown"] = "Unknown";
  TaskDirection2["Incoming"] = "Incoming";
  TaskDirection2["Outgoing"] = "Outgoing";
  TaskDirection2["SaintAll"] = "SaintAll";
})(TaskDirection || (TaskDirection = {}));
var TaskType;
(function (TaskType2) {
  TaskType2["Unknown"] = "Unknown";
  TaskType2["Appointment"] = "Appointment";
  TaskType2["Document"] = "Document";
  TaskType2["Email"] = "Email";
  TaskType2["Fax"] = "Fax";
  TaskType2["Phone"] = "Phone";
  TaskType2["ToDo"] = "ToDo";
  TaskType2["MailMergeDraft"] = "MailMergeDraft";
  TaskType2["MailMergeFinal"] = "MailMergeFinal";
  TaskType2["Report"] = "Report";
  TaskType2["SaintAll"] = "SaintAll";
})(TaskType || (TaskType = {}));
var PreferenceLevel;
(function (PreferenceLevel2) {
  PreferenceLevel2["Undefined"] = "Undefined";
  PreferenceLevel2["HardDefault"] = "HardDefault";
  PreferenceLevel2["SystemWide"] = "SystemWide";
  PreferenceLevel2["Database"] = "Database";
  PreferenceLevel2["Group"] = "Group";
  PreferenceLevel2["Individual"] = "Individual";
  PreferenceLevel2["PC"] = "PC";
})(PreferenceLevel || (PreferenceLevel = {}));
var DurationUnit;
(function (DurationUnit2) {
  DurationUnit2["Unknown"] = "Unknown";
  DurationUnit2["Second"] = "Second";
  DurationUnit2["Minute"] = "Minute";
  DurationUnit2["Hour"] = "Hour";
  DurationUnit2["Day"] = "Day";
  DurationUnit2["Week"] = "Week";
  DurationUnit2["Month"] = "Month";
  DurationUnit2["Quarter"] = "Quarter";
  DurationUnit2["HalfYear"] = "HalfYear";
  DurationUnit2["Year"] = "Year";
  DurationUnit2["Decade"] = "Decade";
  DurationUnit2["Century"] = "Century";
  DurationUnit2["Millenium"] = "Millenium";
})(DurationUnit || (DurationUnit = {}));
var SelectionUnionType;
(function (SelectionUnionType2) {
  SelectionUnionType2["Unknown"] = "Unknown";
  SelectionUnionType2["SubtractRightFromLeft"] = "SubtractRightFromLeft";
  SelectionUnionType2["SubtractLeftFromRight"] = "SubtractLeftFromRight";
  SelectionUnionType2["Intersect"] = "Intersect";
  SelectionUnionType2["XOR"] = "XOR";
  SelectionUnionType2["Union"] = "Union";
})(SelectionUnionType || (SelectionUnionType = {}));
var ShipmentStatus;
(function (ShipmentStatus2) {
  ShipmentStatus2["None"] = "None";
  ShipmentStatus2["Ok"] = "Ok";
  ShipmentStatus2["Canceled"] = "Canceled";
  ShipmentStatus2["Waiting"] = "Waiting";
  ShipmentStatus2["Started"] = "Started";
  ShipmentStatus2["StatusFailed"] = "StatusFailed";
  ShipmentStatus2["Retry"] = "Retry";
  ShipmentStatus2["Populating"] = "Populating";
  ShipmentStatus2["Deleted"] = "Deleted";
  ShipmentStatus2["AwaitPopulate"] = "AwaitPopulate";
  ShipmentStatus2["PopulatingOnly"] = "PopulatingOnly";
  ShipmentStatus2["PopulateAborted"] = "PopulateAborted";
  ShipmentStatus2["PopulateError"] = "PopulateError";
  ShipmentStatus2["TooManyRecipients"] = "TooManyRecipients";
})(ShipmentStatus || (ShipmentStatus = {}));
var ShipmentAddrStatus;
(function (ShipmentAddrStatus2) {
  ShipmentAddrStatus2["Unknown"] = "Unknown";
  ShipmentAddrStatus2["Ready"] = "Ready";
  ShipmentAddrStatus2["Duplicate"] = "Duplicate";
  ShipmentAddrStatus2["Blocked"] = "Blocked";
  ShipmentAddrStatus2["Sent"] = "Sent";
  ShipmentAddrStatus2["Bounced"] = "Bounced";
  ShipmentAddrStatus2["Opened"] = "Opened";
  ShipmentAddrStatus2["Clicked"] = "Clicked";
  ShipmentAddrStatus2["SoftBounced"] = "SoftBounced";
  ShipmentAddrStatus2["NoSubscription"] = "NoSubscription";
  ShipmentAddrStatus2["Complained"] = "Complained";
  ShipmentAddrStatus2["TooManyBounces"] = "TooManyBounces";
})(ShipmentAddrStatus || (ShipmentAddrStatus = {}));
var TicketOrigin;
(function (TicketOrigin2) {
  TicketOrigin2["Unknown"] = "Unknown";
  TicketOrigin2["Email"] = "Email";
  TicketOrigin2["SMS"] = "SMS";
  TicketOrigin2["Fax"] = "Fax";
  TicketOrigin2["Phone"] = "Phone";
  TicketOrigin2["Facebook"] = "Facebook";
  TicketOrigin2["Twitter"] = "Twitter";
  TicketOrigin2["Internal"] = "Internal";
  TicketOrigin2["CustomerCentre"] = "CustomerCentre";
  TicketOrigin2["EMarketing"] = "EMarketing";
  TicketOrigin2["AutoGenerated"] = "AutoGenerated";
  TicketOrigin2["Chat"] = "Chat";
  TicketOrigin2["Form"] = "Form";
})(TicketOrigin || (TicketOrigin = {}));
var TicketStatusTimeCounter;
(function (TicketStatusTimeCounter2) {
  TicketStatusTimeCounter2["None"] = "None";
  TicketStatusTimeCounter2["Internally"] = "Internally";
  TicketStatusTimeCounter2["Externally"] = "Externally";
  TicketStatusTimeCounter2["Queue"] = "Queue";
})(TicketStatusTimeCounter || (TicketStatusTimeCounter = {}));
var QuoteVersionState;
(function (QuoteVersionState2) {
  QuoteVersionState2["Unknown"] = "Unknown";
  QuoteVersionState2["Draft"] = "Draft";
  QuoteVersionState2["DraftNotCalculated"] = "DraftNotCalculated";
  QuoteVersionState2["DraftNeedsApproval"] = "DraftNeedsApproval";
  QuoteVersionState2["DraftApproved"] = "DraftApproved";
  QuoteVersionState2["DraftNotApproved"] = "DraftNotApproved";
  QuoteVersionState2["Sent"] = "Sent";
  QuoteVersionState2["Archived"] = "Archived";
  QuoteVersionState2["Lost"] = "Lost";
  QuoteVersionState2["Sold"] = "Sold";
})(QuoteVersionState || (QuoteVersionState = {}));
var BlobLinkType;
(function (BlobLinkType2) {
  BlobLinkType2["PersonImage"] = "PersonImage";
  BlobLinkType2["ProjectImage"] = "ProjectImage";
  BlobLinkType2["EventImage"] = "EventImage";
  BlobLinkType2["Thumbnail"] = "Thumbnail";
  BlobLinkType2["StatusMonitorImage"] = "StatusMonitorImage";
  BlobLinkType2["BatchTask"] = "BatchTask";
  BlobLinkType2["ProductImage"] = "ProductImage";
  BlobLinkType2["ProductThumbnail"] = "ProductThumbnail";
  BlobLinkType2["QuoteLineImage"] = "QuoteLineImage";
  BlobLinkType2["QuoteLineThumbnail"] = "QuoteLineThumbnail";
  BlobLinkType2["AccessToken"] = "AccessToken";
  BlobLinkType2["RefreshToken"] = "RefreshToken";
  BlobLinkType2["Dashboard"] = "Dashboard";
  BlobLinkType2["DashboardTile"] = "DashboardTile";
  BlobLinkType2["ChatTopicImage"] = "ChatTopicImage";
  BlobLinkType2["FormsBackgroundImage"] = "FormsBackgroundImage";
  BlobLinkType2["ContactImage"] = "ContactImage";
  BlobLinkType2["DashboardHtmlTileData"] = "DashboardHtmlTileData";
})(BlobLinkType || (BlobLinkType = {}));
var QuoteStatus;
(function (QuoteStatus2) {
  QuoteStatus2["Ok"] = "Ok";
  QuoteStatus2["OkWithInfo"] = "OkWithInfo";
  QuoteStatus2["Warning"] = "Warning";
  QuoteStatus2["Error"] = "Error";
})(QuoteStatus || (QuoteStatus = {}));
var ValueOverride;
(function (ValueOverride2) {
  ValueOverride2["None"] = "None";
  ValueOverride2["Total"] = "Total";
  ValueOverride2["DiscountPercent"] = "DiscountPercent";
  ValueOverride2["DiscountAmount"] = "DiscountAmount";
  ValueOverride2["EarningPercent"] = "EarningPercent";
  ValueOverride2["EarningAmount"] = "EarningAmount";
})(ValueOverride || (ValueOverride = {}));
var ErpActorType;
(function (ErpActorType2) {
  ErpActorType2["Unknown"] = "Unknown";
  ErpActorType2["Customer"] = "Customer";
  ErpActorType2["Supplier"] = "Supplier";
  ErpActorType2["Partner"] = "Partner";
  ErpActorType2["Person"] = "Person";
  ErpActorType2["Project"] = "Project";
  ErpActorType2["Employee"] = "Employee";
  ErpActorType2["Sale"] = "Sale";
})(ErpActorType || (ErpActorType = {}));
var CrmActorType;
(function (CrmActorType2) {
  CrmActorType2["Unknown"] = "Unknown";
  CrmActorType2["Contact"] = "Contact";
  CrmActorType2["Person"] = "Person";
  CrmActorType2["Project"] = "Project";
  CrmActorType2["Sale"] = "Sale";
})(CrmActorType || (CrmActorType = {}));
var PublishType;
(function (PublishType2) {
  PublishType2["Undefined"] = "Undefined";
  PublishType2["External"] = "External";
})(PublishType || (PublishType = {}));
var UdefJustification;
(function (UdefJustification2) {
  UdefJustification2["Default"] = "Default";
  UdefJustification2["Left"] = "Left";
  UdefJustification2["Center"] = "Center";
  UdefJustification2["Right"] = "Right";
})(UdefJustification || (UdefJustification = {}));
var RoleType;
(function (RoleType2) {
  RoleType2["Employee"] = "Employee";
  RoleType2["ExternalUser"] = "ExternalUser";
  RoleType2["Anonymous"] = "Anonymous";
  RoleType2["System"] = "System";
})(RoleType || (RoleType = {}));
var RecurrencePattern;
(function (RecurrencePattern2) {
  RecurrencePattern2["Unknown"] = "Unknown";
  RecurrencePattern2["Daily"] = "Daily";
  RecurrencePattern2["Weekly"] = "Weekly";
  RecurrencePattern2["Monthly"] = "Monthly";
  RecurrencePattern2["Yearly"] = "Yearly";
  RecurrencePattern2["Custom"] = "Custom";
})(RecurrencePattern || (RecurrencePattern = {}));
var ShowWindowState;
(function (ShowWindowState2) {
  ShowWindowState2["Normal"] = "Normal";
  ShowWindowState2["Maximized"] = "Maximized";
  ShowWindowState2["Minimized"] = "Minimized";
})(ShowWindowState || (ShowWindowState = {}));
var LicenseType;
(function (LicenseType2) {
  LicenseType2["Unknown"] = "Unknown";
  LicenseType2["SiteLicense"] = "SiteLicense";
  LicenseType2["SatelliteLicense"] = "SatelliteLicense";
  LicenseType2["UserLicense"] = "UserLicense";
})(LicenseType || (LicenseType = {}));
var EMailMergeTargetType;
(function (EMailMergeTargetType2) {
  EMailMergeTargetType2["BestFit"] = "BestFit";
  EMailMergeTargetType2["Electronic"] = "Electronic";
  EMailMergeTargetType2["Mail"] = "Mail";
  EMailMergeTargetType2["Fax"] = "Fax";
  EMailMergeTargetType2["Printer"] = "Printer";
  EMailMergeTargetType2["Xml"] = "Xml";
  EMailMergeTargetType2["XmlFax"] = "XmlFax";
})(EMailMergeTargetType || (EMailMergeTargetType = {}));
var AssignmentStatus;
(function (AssignmentStatus2) {
  AssignmentStatus2["Unknown"] = "Unknown";
  AssignmentStatus2["None"] = "None";
  AssignmentStatus2["Assigning"] = "Assigning";
  AssignmentStatus2["Seen"] = "Seen";
  AssignmentStatus2["Declined"] = "Declined";
})(AssignmentStatus || (AssignmentStatus = {}));
var ColorIndex;
(function (ColorIndex2) {
  ColorIndex2["LightBlue"] = "LightBlue";
  ColorIndex2["DarkBlue"] = "DarkBlue";
  ColorIndex2["LightGray"] = "LightGray";
  ColorIndex2["DarkGray"] = "DarkGray";
  ColorIndex2["LightGreen"] = "LightGreen";
  ColorIndex2["DarkGreen"] = "DarkGreen";
  ColorIndex2["LightYellow"] = "LightYellow";
  ColorIndex2["DarkYellow"] = "DarkYellow";
  ColorIndex2["LightRed"] = "LightRed";
  ColorIndex2["DarkRed"] = "DarkRed";
  ColorIndex2["BlueAlt1"] = "BlueAlt1";
  ColorIndex2["BlueAlt2"] = "BlueAlt2";
  ColorIndex2["BlueAlt3"] = "BlueAlt3";
  ColorIndex2["GrayAlt1"] = "GrayAlt1";
  ColorIndex2["GrayAlt2"] = "GrayAlt2";
  ColorIndex2["GrayAlt3"] = "GrayAlt3";
  ColorIndex2["GreenAlt1"] = "GreenAlt1";
  ColorIndex2["GreenAlt2"] = "GreenAlt2";
  ColorIndex2["GreenAlt3"] = "GreenAlt3";
  ColorIndex2["YellowAlt1"] = "YellowAlt1";
  ColorIndex2["YellowAlt2"] = "YellowAlt2";
  ColorIndex2["YellowAlt3"] = "YellowAlt3";
  ColorIndex2["RedAlt1"] = "RedAlt1";
  ColorIndex2["RedAlt2"] = "RedAlt2";
  ColorIndex2["RedAlt3"] = "RedAlt3";
})(ColorIndex || (ColorIndex = {}));
var UrlEncoding;
(function (UrlEncoding2) {
  UrlEncoding2["Unknown"] = "Unknown";
  UrlEncoding2["None"] = "None";
  UrlEncoding2["ANSI"] = "ANSI";
  UrlEncoding2["Unicode"] = "Unicode";
})(UrlEncoding || (UrlEncoding = {}));
var RelationTarget;
(function (RelationTarget2) {
  RelationTarget2["None"] = "None";
  RelationTarget2["Contact"] = "Contact";
  RelationTarget2["Person"] = "Person";
  RelationTarget2["Both"] = "Both";
})(RelationTarget || (RelationTarget = {}));
var UDefType;
(function (UDefType2) {
  UDefType2["Invalid"] = "Invalid";
  UDefType2["Contact"] = "Contact";
  UDefType2["Person"] = "Person";
  UDefType2["Project"] = "Project";
  UDefType2["Sale"] = "Sale";
  UDefType2["Temp"] = "Temp";
  UDefType2["Appointment"] = "Appointment";
  UDefType2["Document"] = "Document";
  UDefType2["None"] = "None";
})(UDefType || (UDefType = {}));
var UDefFieldType;
(function (UDefFieldType2) {
  UDefFieldType2["Number"] = "Number";
  UDefFieldType2["ShortText"] = "ShortText";
  UDefFieldType2["LongText"] = "LongText";
  UDefFieldType2["Date"] = "Date";
  UDefFieldType2["UnlimitedDate"] = "UnlimitedDate";
  UDefFieldType2["Checkbox"] = "Checkbox";
  UDefFieldType2["List"] = "List";
  UDefFieldType2["Decimal"] = "Decimal";
})(UDefFieldType || (UDefFieldType = {}));
var CustomFieldType;
(function (CustomFieldType2) {
  CustomFieldType2["Unknown"] = "Unknown";
  CustomFieldType2["Integer"] = "Integer";
  CustomFieldType2["ShortText"] = "ShortText";
  CustomFieldType2["LongText"] = "LongText";
  CustomFieldType2["Date"] = "Date";
  CustomFieldType2["Blob"] = "Blob";
  CustomFieldType2["Checkbox"] = "Checkbox";
  CustomFieldType2["MdoList"] = "MdoList";
  CustomFieldType2["Decimal"] = "Decimal";
  CustomFieldType2["DateTime"] = "DateTime";
  CustomFieldType2["Time"] = "Time";
  CustomFieldType2["TimeSpan"] = "TimeSpan";
  CustomFieldType2["RelationTo"] = "RelationTo";
  CustomFieldType2["Attachment"] = "Attachment";
  CustomFieldType2["DynamicLink"] = "DynamicLink";
  CustomFieldType2["ListText"] = "ListText";
})(CustomFieldType || (CustomFieldType = {}));
var SystemEventScope;
(function (SystemEventScope2) {
  SystemEventScope2["Undefined"] = "Undefined";
  SystemEventScope2["SystemWide"] = "SystemWide";
  SystemEventScope2["Database"] = "Database";
  SystemEventScope2["Group"] = "Group";
  SystemEventScope2["User"] = "User";
})(SystemEventScope || (SystemEventScope = {}));
var ImportEntityType;
(function (ImportEntityType2) {
  ImportEntityType2[ImportEntityType2["Unknown"] = 0] = "Unknown";
  ImportEntityType2[ImportEntityType2["Person"] = 1] = "Person";
  ImportEntityType2[ImportEntityType2["Contact"] = 2] = "Contact";
  ImportEntityType2[ImportEntityType2["Product"] = 4] = "Product";
})(ImportEntityType || (ImportEntityType = {}));
var ImportAction;
(function (ImportAction2) {
  ImportAction2[ImportAction2["Unknown"] = 0] = "Unknown";
  ImportAction2[ImportAction2["PersonAdded"] = 1] = "PersonAdded";
  ImportAction2[ImportAction2["PersonUpdated"] = 2] = "PersonUpdated";
  ImportAction2[ImportAction2["PersonNoChange"] = 4] = "PersonNoChange";
  ImportAction2[ImportAction2["ContactAdded"] = 8] = "ContactAdded";
  ImportAction2[ImportAction2["ContactUpdated"] = 16] = "ContactUpdated";
  ImportAction2[ImportAction2["ContactNoChange"] = 32] = "ContactNoChange";
  ImportAction2[ImportAction2["ProductAdded"] = 64] = "ProductAdded";
  ImportAction2[ImportAction2["ProductUpdated"] = 128] = "ProductUpdated";
  ImportAction2[ImportAction2["ProductNoChange"] = 256] = "ProductNoChange";
  ImportAction2[ImportAction2["Obs"] = 512] = "Obs";
  ImportAction2[ImportAction2["ObsERPDuplicate"] = 1024] = "ObsERPDuplicate";
})(ImportAction || (ImportAction = {}));
var FreeTextOperator;
(function (FreeTextOperator2) {
  FreeTextOperator2["Contains"] = "Contains";
  FreeTextOperator2["StartsWith"] = "StartsWith";
  FreeTextOperator2["ExactMatch"] = "ExactMatch";
})(FreeTextOperator || (FreeTextOperator = {}));
var ErpSyncResponseCode;
(function (ErpSyncResponseCode2) {
  ErpSyncResponseCode2["NoError"] = "NoError";
  ErpSyncResponseCode2["ErrorConnectorHasConnections"] = "ErrorConnectorHasConnections";
  ErpSyncResponseCode2["ErrorNotFound"] = "ErrorNotFound";
})(ErpSyncResponseCode || (ErpSyncResponseCode = {}));
var TicketBaseStatus;
(function (TicketBaseStatus2) {
  TicketBaseStatus2["Unknown"] = "Unknown";
  TicketBaseStatus2["Active"] = "Active";
  TicketBaseStatus2["Closed"] = "Closed";
  TicketBaseStatus2["Postponed"] = "Postponed";
  TicketBaseStatus2["Deleted"] = "Deleted";
  TicketBaseStatus2["Merged"] = "Merged";
  TicketBaseStatus2["PostponedSpecific"] = "PostponedSpecific";
  TicketBaseStatus2["Postponed1Hour"] = "Postponed1Hour";
  TicketBaseStatus2["Postponed2Hours"] = "Postponed2Hours";
  TicketBaseStatus2["Postponed3Hours"] = "Postponed3Hours";
  TicketBaseStatus2["Postponed4Hours"] = "Postponed4Hours";
  TicketBaseStatus2["PostponedDay"] = "PostponedDay";
  TicketBaseStatus2["PostponedWeek"] = "PostponedWeek";
  TicketBaseStatus2["PostponedMonth"] = "PostponedMonth";
})(TicketBaseStatus || (TicketBaseStatus = {}));
var ReportCategory;
(function (ReportCategory2) {
  ReportCategory2["None"] = "None";
  ReportCategory2["All"] = "All";
  ReportCategory2["Contact"] = "Contact";
  ReportCategory2["Project"] = "Project";
  ReportCategory2["Sale"] = "Sale";
  ReportCategory2["Appointment"] = "Appointment";
  ReportCategory2["Selection"] = "Selection";
  ReportCategory2["Person"] = "Person";
  ReportCategory2["Diary"] = "Diary";
  ReportCategory2["Favorites"] = "Favorites";
})(ReportCategory || (ReportCategory = {}));
var EMailPriority;
(function (EMailPriority2) {
  EMailPriority2["NoPriority"] = "NoPriority";
  EMailPriority2["Highest"] = "Highest";
  EMailPriority2["High"] = "High";
  EMailPriority2["Normal"] = "Normal";
  EMailPriority2["Low"] = "Low";
  EMailPriority2["Lowest"] = "Lowest";
})(EMailPriority || (EMailPriority = {}));
var EMailFlags;
(function (EMailFlags2) {
  EMailFlags2[EMailFlags2["None"] = 0] = "None";
  EMailFlags2[EMailFlags2["Seen"] = 1] = "Seen";
  EMailFlags2[EMailFlags2["Deleted"] = 2] = "Deleted";
  EMailFlags2[EMailFlags2["Recent"] = 4] = "Recent";
  EMailFlags2[EMailFlags2["Flagged"] = 8] = "Flagged";
  EMailFlags2[EMailFlags2["Draft"] = 16] = "Draft";
  EMailFlags2[EMailFlags2["Answered"] = 32] = "Answered";
})(EMailFlags || (EMailFlags = {}));
var BatchTaskState;
(function (BatchTaskState2) {
  BatchTaskState2["Unknown"] = "Unknown";
  BatchTaskState2["New"] = "New";
  BatchTaskState2["Aquired"] = "Aquired";
  BatchTaskState2["Started"] = "Started";
  BatchTaskState2["Succeeded"] = "Succeeded";
  BatchTaskState2["Failed"] = "Failed";
  BatchTaskState2["SucceededManualCleanup"] = "SucceededManualCleanup";
  BatchTaskState2["All"] = "All";
})(BatchTaskState || (BatchTaskState = {}));
var BatchTaskCancellationBehaviour;
(function (BatchTaskCancellationBehaviour2) {
  BatchTaskCancellationBehaviour2["CanCancel"] = "CanCancel";
  BatchTaskCancellationBehaviour2["CancelWithWarning"] = "CancelWithWarning";
  BatchTaskCancellationBehaviour2["CannotCancel"] = "CannotCancel";
})(BatchTaskCancellationBehaviour || (BatchTaskCancellationBehaviour = {}));
var SelectionType;
(function (SelectionType2) {
  SelectionType2["Static"] = "Static";
  SelectionType2["Dynamic"] = "Dynamic";
  SelectionType2["Combined"] = "Combined";
})(SelectionType || (SelectionType = {}));
var ReportLayout;
(function (ReportLayout2) {
  ReportLayout2["Unknown"] = "Unknown";
  ReportLayout2["List"] = "List";
  ReportLayout2["Label"] = "Label";
  ReportLayout2["GroupList"] = "GroupList";
  ReportLayout2["CrossTable"] = "CrossTable";
  ReportLayout2["CalendarWeek5"] = "CalendarWeek5";
  ReportLayout2["CalendarWeek7"] = "CalendarWeek7";
  ReportLayout2["CalendarMonth"] = "CalendarMonth";
  ReportLayout2["Text"] = "Text";
})(ReportLayout || (ReportLayout = {}));
var ReportPaperOrientation;
(function (ReportPaperOrientation2) {
  ReportPaperOrientation2["None"] = "None";
  ReportPaperOrientation2["Portrait"] = "Portrait";
  ReportPaperOrientation2["Landscape"] = "Landscape";
})(ReportPaperOrientation || (ReportPaperOrientation = {}));
var DocumentLockSemantics;
(function (DocumentLockSemantics2) {
  DocumentLockSemantics2["None"] = "None";
  DocumentLockSemantics2["Locking"] = "Locking";
  DocumentLockSemantics2["Versioning"] = "Versioning";
})(DocumentLockSemantics || (DocumentLockSemantics = {}));
var GeneratorEncoding;
(function (GeneratorEncoding2) {
  GeneratorEncoding2["Text"] = "Text";
  GeneratorEncoding2["Html"] = "Html";
  GeneratorEncoding2["Xml"] = "Xml";
  GeneratorEncoding2["MsWord"] = "MsWord";
  GeneratorEncoding2["MsExcel"] = "MsExcel";
  GeneratorEncoding2["MsPowerpoint"] = "MsPowerpoint";
  GeneratorEncoding2["MsOffice2007"] = "MsOffice2007";
  GeneratorEncoding2["MsOffice2007Xml"] = "MsOffice2007Xml";
  GeneratorEncoding2["Url"] = "Url";
  GeneratorEncoding2["UrlUnicode"] = "UrlUnicode";
  GeneratorEncoding2["Pdf"] = "Pdf";
  GeneratorEncoding2["Mime"] = "Mime";
  GeneratorEncoding2["OpenDocument"] = "OpenDocument";
  GeneratorEncoding2["OpenDocumentXml"] = "OpenDocumentXml";
})(GeneratorEncoding || (GeneratorEncoding = {}));
var DashboardLayout;
(function (DashboardLayout2) {
  DashboardLayout2["None"] = "None";
  DashboardLayout2["One"] = "One";
  DashboardLayout2["TwoVerticalSplit"] = "TwoVerticalSplit";
  DashboardLayout2["ThreeESplit"] = "ThreeESplit";
  DashboardLayout2["TwoHorizontalSplit"] = "TwoHorizontalSplit";
  DashboardLayout2["ThreeTSplit"] = "ThreeTSplit";
  DashboardLayout2["Four"] = "Four";
})(DashboardLayout || (DashboardLayout = {}));
var DashboardTileType;
(function (DashboardTileType2) {
  DashboardTileType2["None"] = "None";
  DashboardTileType2["Chart"] = "Chart";
  DashboardTileType2["Web"] = "Web";
  DashboardTileType2["List"] = "List";
  DashboardTileType2["Bignum"] = "Bignum";
})(DashboardTileType || (DashboardTileType = {}));
var DashboardTileEntityType;
(function (DashboardTileEntityType2) {
  DashboardTileEntityType2["None"] = "None";
  DashboardTileEntityType2["Company"] = "Company";
  DashboardTileEntityType2["Project"] = "Project";
  DashboardTileEntityType2["Sale"] = "Sale";
  DashboardTileEntityType2["Product"] = "Product";
  DashboardTileEntityType2["Activity"] = "Activity";
  DashboardTileEntityType2["Document"] = "Document";
  DashboardTileEntityType2["WebPanel"] = "WebPanel";
  DashboardTileEntityType2["Followup"] = "Followup";
})(DashboardTileEntityType || (DashboardTileEntityType = {}));
var DashboardTileOptionType;
(function (DashboardTileOptionType2) {
  DashboardTileOptionType2["None"] = "None";
  DashboardTileOptionType2["String"] = "String";
  DashboardTileOptionType2["Integer"] = "Integer";
  DashboardTileOptionType2["Boolean"] = "Boolean";
  DashboardTileOptionType2["List"] = "List";
})(DashboardTileOptionType || (DashboardTileOptionType = {}));
var DashTileType;
(function (DashTileType2) {
  DashTileType2["None"] = "None";
  DashTileType2["Pie"] = "Pie";
  DashTileType2["List"] = "List";
  DashTileType2["BigNum"] = "BigNum";
  DashTileType2["Bar"] = "Bar";
  DashTileType2["Line"] = "Line";
  DashTileType2["Area"] = "Area";
  DashTileType2["Column"] = "Column";
  DashTileType2["CombinedBarLine"] = "CombinedBarLine";
  DashTileType2["CombinedColumnLine"] = "CombinedColumnLine";
  DashTileType2["WebPanel"] = "WebPanel";
  DashTileType2["HTML"] = "HTML";
  DashTileType2["Gauge"] = "Gauge";
})(DashTileType || (DashTileType = {}));
var DashTileCurrencyMode;
(function (DashTileCurrencyMode2) {
  DashTileCurrencyMode2["None"] = "None";
  DashTileCurrencyMode2["Base"] = "Base";
  DashTileCurrencyMode2["Own"] = "Own";
  DashTileCurrencyMode2["Specified"] = "Specified";
})(DashTileCurrencyMode || (DashTileCurrencyMode = {}));
var DashTileMeasure;
(function (DashTileMeasure2) {
  DashTileMeasure2["None"] = "None";
  DashTileMeasure2["CountAll"] = "CountAll";
  DashTileMeasure2["Sum"] = "Sum";
  DashTileMeasure2["Average"] = "Average";
  DashTileMeasure2["Max"] = "Max";
  DashTileMeasure2["Min"] = "Min";
  DashTileMeasure2["Count"] = "Count";
})(DashTileMeasure || (DashTileMeasure = {}));
var DashTileEntityType;
(function (DashTileEntityType2) {
  DashTileEntityType2["None"] = "None";
  DashTileEntityType2["Contact"] = "Contact";
  DashTileEntityType2["Sale"] = "Sale";
  DashTileEntityType2["Project"] = "Project";
  DashTileEntityType2["Appointment"] = "Appointment";
  DashTileEntityType2["Person"] = "Person";
})(DashTileEntityType || (DashTileEntityType = {}));
var DashTileUsage;
(function (DashTileUsage2) {
  DashTileUsage2[DashTileUsage2["None"] = 0] = "None";
  DashTileUsage2[DashTileUsage2["Dashboard"] = 1] = "Dashboard";
  DashTileUsage2[DashTileUsage2["Selection"] = 2] = "Selection";
})(DashTileUsage || (DashTileUsage = {}));
var TargetAssignementLevel;
(function (TargetAssignementLevel2) {
  TargetAssignementLevel2[TargetAssignementLevel2["None"] = 0] = "None";
  TargetAssignementLevel2[TargetAssignementLevel2["Company"] = 1] = "Company";
  TargetAssignementLevel2[TargetAssignementLevel2["Group"] = 2] = "Group";
  TargetAssignementLevel2[TargetAssignementLevel2["Associate"] = 4] = "Associate";
})(TargetAssignementLevel || (TargetAssignementLevel = {}));
var TargetEntityType;
(function (TargetEntityType2) {
  TargetEntityType2["None"] = "None";
  TargetEntityType2["Sale"] = "Sale";
})(TargetEntityType || (TargetEntityType = {}));
var TargetMeasurementUnit;
(function (TargetMeasurementUnit2) {
  TargetMeasurementUnit2["None"] = "None";
  TargetMeasurementUnit2["Amount"] = "Amount";
  TargetMeasurementUnit2["Count"] = "Count";
  TargetMeasurementUnit2["Profit"] = "Profit";
})(TargetMeasurementUnit || (TargetMeasurementUnit = {}));
var TargetPeriodType;
(function (TargetPeriodType2) {
  TargetPeriodType2["None"] = "None";
  TargetPeriodType2["Year"] = "Year";
  TargetPeriodType2["HalfYear"] = "HalfYear";
  TargetPeriodType2["Quarter"] = "Quarter";
  TargetPeriodType2["Month"] = "Month";
})(TargetPeriodType || (TargetPeriodType = {}));
var TargetLevel;
(function (TargetLevel2) {
  TargetLevel2["None"] = "None";
  TargetLevel2["Global"] = "Global";
  TargetLevel2["Company"] = "Company";
  TargetLevel2["UserGroup"] = "UserGroup";
  TargetLevel2["Associate"] = "Associate";
})(TargetLevel || (TargetLevel = {}));
var LogEvent;
(function (LogEvent2) {
  LogEvent2["None"] = "None";
  LogEvent2["Create"] = "Create";
  LogEvent2["Edit"] = "Edit";
  LogEvent2["Delete"] = "Delete";
  LogEvent2["Lock"] = "Lock";
  LogEvent2["Unlock"] = "Unlock";
})(LogEvent || (LogEvent = {}));
var WorkflowDefinitionStatus;
(function (WorkflowDefinitionStatus2) {
  WorkflowDefinitionStatus2["None"] = "None";
  WorkflowDefinitionStatus2["Stopped"] = "Stopped";
  WorkflowDefinitionStatus2["Paused"] = "Paused";
  WorkflowDefinitionStatus2["Running"] = "Running";
})(WorkflowDefinitionStatus || (WorkflowDefinitionStatus = {}));
var EmailFromType;
(function (EmailFromType2) {
  EmailFromType2["FromOnlySpecified"] = "FromOnlySpecified";
  EmailFromType2["FromSalesContact"] = "FromSalesContact";
  EmailFromType2["FromSupportContact"] = "FromSupportContact";
})(EmailFromType || (EmailFromType = {}));
var EmailReplyToType;
(function (EmailReplyToType2) {
  EmailReplyToType2["ReplyToOnlySpecified"] = "ReplyToOnlySpecified";
  EmailReplyToType2["ReplyToSalesContact"] = "ReplyToSalesContact";
  EmailReplyToType2["ReplyToSupportContact"] = "ReplyToSupportContact";
  EmailReplyToType2["ReplyToEmpty"] = "ReplyToEmpty";
})(EmailReplyToType || (EmailReplyToType = {}));
var WorkflowTimeWaitAlgorithm;
(function (WorkflowTimeWaitAlgorithm2) {
  WorkflowTimeWaitAlgorithm2["None"] = "None";
  WorkflowTimeWaitAlgorithm2["NumIntervals"] = "NumIntervals";
  WorkflowTimeWaitAlgorithm2["UntilSpecified"] = "UntilSpecified";
  WorkflowTimeWaitAlgorithm2["UntilDateField"] = "UntilDateField";
})(WorkflowTimeWaitAlgorithm || (WorkflowTimeWaitAlgorithm = {}));
var WorkflowTimeWaitIntervalType;
(function (WorkflowTimeWaitIntervalType2) {
  WorkflowTimeWaitIntervalType2["None"] = "None";
  WorkflowTimeWaitIntervalType2["Seconds"] = "Seconds";
  WorkflowTimeWaitIntervalType2["Minutes"] = "Minutes";
  WorkflowTimeWaitIntervalType2["Hours"] = "Hours";
  WorkflowTimeWaitIntervalType2["WorkingDays"] = "WorkingDays";
  WorkflowTimeWaitIntervalType2["Days"] = "Days";
  WorkflowTimeWaitIntervalType2["Weeks"] = "Weeks";
})(WorkflowTimeWaitIntervalType || (WorkflowTimeWaitIntervalType = {}));
var WorkflowEventType;
(function (WorkflowEventType2) {
  WorkflowEventType2["None"] = "None";
  WorkflowEventType2["Run"] = "Run";
  WorkflowEventType2["Click"] = "Click";
})(WorkflowEventType || (WorkflowEventType = {}));
var WorkflowGoalType;
(function (WorkflowGoalType2) {
  WorkflowGoalType2["None"] = "None";
  WorkflowGoalType2["ContactUpdated"] = "ContactUpdated";
  WorkflowGoalType2["SaleCreatedOnContact"] = "SaleCreatedOnContact";
  WorkflowGoalType2["SaleCreatedOnCompany"] = "SaleCreatedOnCompany";
  WorkflowGoalType2["AppointmentCreated"] = "AppointmentCreated";
  WorkflowGoalType2["AddedToProject"] = "AddedToProject";
  WorkflowGoalType2["AddedToSelection"] = "AddedToSelection";
  WorkflowGoalType2["FormSubmitted"] = "FormSubmitted";
  WorkflowGoalType2["HadChat"] = "HadChat";
  WorkflowGoalType2["LinkClicked"] = "LinkClicked";
  WorkflowGoalType2["RequestCreated"] = "RequestCreated";
})(WorkflowGoalType || (WorkflowGoalType = {}));
var WorkflowStepType;
(function (WorkflowStepType2) {
  WorkflowStepType2["None"] = "None";
  WorkflowStepType2["SendEmail"] = "SendEmail";
  WorkflowStepType2["SendSMS"] = "SendSMS";
  WorkflowStepType2["WaitForTime"] = "WaitForTime";
  WorkflowStepType2["WaitForAction"] = "WaitForAction";
  WorkflowStepType2["Split"] = "Split";
  WorkflowStepType2["UpdateContact"] = "UpdateContact";
  WorkflowStepType2["AddToList"] = "AddToList";
  WorkflowStepType2["RemoveFromList"] = "RemoveFromList";
  WorkflowStepType2["CreateRequest"] = "CreateRequest";
  WorkflowStepType2["CreateFollowUp"] = "CreateFollowUp";
  WorkflowStepType2["CreateSale"] = "CreateSale";
  WorkflowStepType2["NotifyByEmail"] = "NotifyByEmail";
  WorkflowStepType2["NotifyBySMS"] = "NotifyBySMS";
  WorkflowStepType2["RunScript"] = "RunScript";
})(WorkflowStepType || (WorkflowStepType = {}));
var WorkflowTriggerType;
(function (WorkflowTriggerType2) {
  WorkflowTriggerType2["None"] = "None";
  WorkflowTriggerType2["ContactCreated"] = "ContactCreated";
  WorkflowTriggerType2["ContactUpdated"] = "ContactUpdated";
  WorkflowTriggerType2["AddedToProject"] = "AddedToProject";
  WorkflowTriggerType2["CreatedRequest"] = "CreatedRequest";
  WorkflowTriggerType2["LinkClicked"] = "LinkClicked";
  WorkflowTriggerType2["AddedToSelection"] = "AddedToSelection";
  WorkflowTriggerType2["FormSubmitted"] = "FormSubmitted";
  WorkflowTriggerType2["AddedMessage"] = "AddedMessage";
  WorkflowTriggerType2["StartedChat"] = "StartedChat";
  WorkflowTriggerType2["OrderPlaced"] = "OrderPlaced";
  WorkflowTriggerType2["SaleCreated"] = "SaleCreated";
  WorkflowTriggerType2["SaleSold"] = "SaleSold";
  WorkflowTriggerType2["SaleLost"] = "SaleLost";
})(WorkflowTriggerType || (WorkflowTriggerType = {}));
var ActivityStatus;
(function (ActivityStatus2) {
  ActivityStatus2["Unknown"] = "Unknown";
  ActivityStatus2["NotStarted"] = "NotStarted";
  ActivityStatus2["Started"] = "Started";
  ActivityStatus2["Completed"] = "Completed";
})(ActivityStatus || (ActivityStatus = {}));
var InvitationStatus;
(function (InvitationStatus2) {
  InvitationStatus2["Unknown"] = "Unknown";
  InvitationStatus2["None"] = "None";
  InvitationStatus2["Accepted"] = "Accepted";
  InvitationStatus2["Hidden"] = "Hidden";
  InvitationStatus2["Invitation"] = "Invitation";
  InvitationStatus2["Moved"] = "Moved";
  InvitationStatus2["Seen"] = "Seen";
  InvitationStatus2["MovedSeen"] = "MovedSeen";
  InvitationStatus2["Declined"] = "Declined";
  InvitationStatus2["Cancelled"] = "Cancelled";
})(InvitationStatus || (InvitationStatus = {}));
var BookingType;
(function (BookingType2) {
  BookingType2["Unknown"] = "Unknown";
  BookingType2["None"] = "None";
  BookingType2["Owner"] = "Owner";
  BookingType2["Participant"] = "Participant";
})(BookingType || (BookingType = {}));
var LocalizedTextType;
(function (LocalizedTextType2) {
  LocalizedTextType2["Unknown"] = "Unknown";
  LocalizedTextType2["Label"] = "Label";
  LocalizedTextType2["Table"] = "Table";
  LocalizedTextType2["Column"] = "Column";
  LocalizedTextType2["ImportField"] = "ImportField";
  LocalizedTextType2["ImportObject"] = "ImportObject";
  LocalizedTextType2["ImportGUICategory"] = "ImportGUICategory";
  LocalizedTextType2["StartupHints"] = "StartupHints";
  LocalizedTextType2["FunctionRightLabel"] = "FunctionRightLabel";
  LocalizedTextType2["FunctionRightDesc"] = "FunctionRightDesc";
  LocalizedTextType2["StatusMonitorName"] = "StatusMonitorName";
  LocalizedTextType2["UdefContactLabel"] = "UdefContactLabel";
  LocalizedTextType2["UdefPersonLabel"] = "UdefPersonLabel";
  LocalizedTextType2["UdefProjectLabel"] = "UdefProjectLabel";
  LocalizedTextType2["UdefSaleLabel"] = "UdefSaleLabel";
  LocalizedTextType2["UdefAppointmentLabel"] = "UdefAppointmentLabel";
  LocalizedTextType2["UdefDocumentLabel"] = "UdefDocumentLabel";
  LocalizedTextType2["PushNotificationText"] = "PushNotificationText";
})(LocalizedTextType || (LocalizedTextType = {}));
var ContactAction;
(function (ContactAction2) {
  ContactAction2[ContactAction2["Unknown"] = 0] = "Unknown";
  ContactAction2[ContactAction2["Created"] = 1] = "Created";
  ContactAction2[ContactAction2["Updated"] = 2] = "Updated";
  ContactAction2[ContactAction2["NewActivity"] = 4] = "NewActivity";
  ContactAction2[ContactAction2["ActivityCompleted"] = 8] = "ActivityCompleted";
  ContactAction2[ContactAction2["PersonAdded"] = 16] = "PersonAdded";
  ContactAction2[ContactAction2["PersonUpdated"] = 32] = "PersonUpdated";
  ContactAction2[ContactAction2["DocumentAdded"] = 64] = "DocumentAdded";
  ContactAction2[ContactAction2["All"] = 127] = "All";
  ContactAction2[ContactAction2["UndefinedValue128"] = 128] = "UndefinedValue128";
})(ContactAction || (ContactAction = {}));
var CheckoutState;
(function (CheckoutState2) {
  CheckoutState2["NotCheckedOut"] = "NotCheckedOut";
  CheckoutState2["CheckedOutOwn"] = "CheckedOutOwn";
  CheckoutState2["CheckedOutOther"] = "CheckedOutOther";
  CheckoutState2["LockingNotSupported"] = "LockingNotSupported";
})(CheckoutState || (CheckoutState = {}));
var StringSearchType;
(function (StringSearchType2) {
  StringSearchType2["Exact"] = "Exact";
  StringSearchType2["BeginsWith"] = "BeginsWith";
  StringSearchType2["EndsWith"] = "EndsWith";
  StringSearchType2["Contains"] = "Contains";
})(StringSearchType || (StringSearchType = {}));
var ReturnType;
(function (ReturnType2) {
  ReturnType2["None"] = "None";
  ReturnType2["Message"] = "Message";
  ReturnType2["SoProtocol"] = "SoProtocol";
  ReturnType2["CustomGui"] = "CustomGui";
  ReturnType2["Other"] = "Other";
  ReturnType2["URL"] = "URL";
})(ReturnType || (ReturnType = {}));
var ETableRight;
(function (ETableRight2) {
  ETableRight2[ETableRight2["None"] = 0] = "None";
  ETableRight2[ETableRight2["Select"] = 1] = "Select";
  ETableRight2[ETableRight2["Update"] = 2] = "Update";
  ETableRight2[ETableRight2["UR"] = 3] = "UR";
  ETableRight2[ETableRight2["Insert"] = 4] = "Insert";
  ETableRight2[ETableRight2["RI"] = 5] = "RI";
  ETableRight2[ETableRight2["URI"] = 7] = "URI";
  ETableRight2[ETableRight2["Delete"] = 8] = "Delete";
  ETableRight2[ETableRight2["UDR"] = 11] = "UDR";
  ETableRight2[ETableRight2["FULL"] = 15] = "FULL";
  ETableRight2[ETableRight2["Filtering"] = 16] = "Filtering";
  ETableRight2[ETableRight2["RF"] = 17] = "RF";
  ETableRight2[ETableRight2["FI"] = 20] = "FI";
  ETableRight2[ETableRight2["RestrictedUpdate"] = 32] = "RestrictedUpdate";
  ETableRight2[ETableRight2["Unused1"] = 64] = "Unused1";
  ETableRight2[ETableRight2["Uninitialized"] = 128] = "Uninitialized";
  ETableRight2[ETableRight2["R"] = 1] = "R";
  ETableRight2[ETableRight2["F"] = 16] = "F";
})(ETableRight || (ETableRight = {}));
var LicenseStatus;
(function (LicenseStatus2) {
  LicenseStatus2["Ok"] = "Ok";
  LicenseStatus2["NewLicenseAvailable"] = "NewLicenseAvailable";
  LicenseStatus2["NewCompanyNameAvailable"] = "NewCompanyNameAvailable";
  LicenseStatus2["NewSerialAvailable"] = "NewSerialAvailable";
  LicenseStatus2["UseCustomMessage"] = "UseCustomMessage";
  LicenseStatus2["UseCustomMessageAndUrl"] = "UseCustomMessageAndUrl";
  LicenseStatus2["ProblemWithLicense"] = "ProblemWithLicense";
  LicenseStatus2["UnknownError"] = "UnknownError";
})(LicenseStatus || (LicenseStatus = {}));
var RecurrenceUpdateMode;
(function (RecurrenceUpdateMode2) {
  RecurrenceUpdateMode2["Unknown"] = "Unknown";
  RecurrenceUpdateMode2["OnlyThis"] = "OnlyThis";
  RecurrenceUpdateMode2["ThisAndForward"] = "ThisAndForward";
  RecurrenceUpdateMode2["StopRecurrence"] = "StopRecurrence";
})(RecurrenceUpdateMode || (RecurrenceUpdateMode = {}));
var UserType;
(function (UserType2) {
  UserType2["Unknown"] = "Unknown";
  UserType2["InternalAssociate"] = "InternalAssociate";
  UserType2["ResourceAssociate"] = "ResourceAssociate";
  UserType2["ExternalAssociate"] = "ExternalAssociate";
  UserType2["AnonymousAssociate"] = "AnonymousAssociate";
  UserType2["SystemAssociate"] = "SystemAssociate";
})(UserType || (UserType = {}));
var ContactSourceType;
(function (ContactSourceType2) {
  ContactSourceType2[ContactSourceType2["Unknown"] = 0] = "Unknown";
  ContactSourceType2[ContactSourceType2["History"] = 1] = "History";
  ContactSourceType2[ContactSourceType2["Diary"] = 2] = "Diary";
  ContactSourceType2[ContactSourceType2["Favorites"] = 4] = "Favorites";
  ContactSourceType2[ContactSourceType2["All"] = 7] = "All";
  ContactSourceType2[ContactSourceType2["UndefinedValue8"] = 8] = "UndefinedValue8";
})(ContactSourceType || (ContactSourceType = {}));
var Visibility;
(function (Visibility2) {
  Visibility2["All"] = "All";
  Visibility2["Associate"] = "Associate";
  Visibility2["Group"] = "Group";
})(Visibility || (Visibility = {}));
var CredentialControlType;
(function (CredentialControlType2) {
  CredentialControlType2["Static"] = "Static";
  CredentialControlType2["Edit"] = "Edit";
  CredentialControlType2["Password"] = "Password";
  CredentialControlType2["Link"] = "Link";
  CredentialControlType2["Hidden"] = "Hidden";
})(CredentialControlType || (CredentialControlType = {}));
var RecurrenceEndType;
(function (RecurrenceEndType2) {
  RecurrenceEndType2["Unknown"] = "Unknown";
  RecurrenceEndType2["EndDate"] = "EndDate";
  RecurrenceEndType2["Counter"] = "Counter";
})(RecurrenceEndType || (RecurrenceEndType = {}));
var AssociateSourceType;
(function (AssociateSourceType2) {
  AssociateSourceType2[AssociateSourceType2["Unknown"] = 0] = "Unknown";
  AssociateSourceType2[AssociateSourceType2["History"] = 1] = "History";
  AssociateSourceType2[AssociateSourceType2["DiaryViewList"] = 2] = "DiaryViewList";
  AssociateSourceType2[AssociateSourceType2["Department"] = 4] = "Department";
  AssociateSourceType2[AssociateSourceType2["All"] = 7] = "All";
  AssociateSourceType2[AssociateSourceType2["UndefinedValue8"] = 8] = "UndefinedValue8";
})(AssociateSourceType || (AssociateSourceType = {}));
var RoleRelationToOwner;
(function (RoleRelationToOwner2) {
  RoleRelationToOwner2["MyOwn"] = "MyOwn";
  RoleRelationToOwner2["PrimaryGroup"] = "PrimaryGroup";
  RoleRelationToOwner2["OtherGroups"] = "OtherGroups";
  RoleRelationToOwner2["OtherAssociates"] = "OtherAssociates";
  RoleRelationToOwner2["ExternalUser"] = "ExternalUser";
  RoleRelationToOwner2["Anonymous"] = "Anonymous";
  RoleRelationToOwner2["MyCompany"] = "MyCompany";
  RoleRelationToOwner2["SameProject"] = "SameProject";
})(RoleRelationToOwner || (RoleRelationToOwner = {}));
var ExternalUserInfoModification;
(function (ExternalUserInfoModification2) {
  ExternalUserInfoModification2[ExternalUserInfoModification2["Unknown"] = 0] = "Unknown";
  ExternalUserInfoModification2[ExternalUserInfoModification2["UserName"] = 1] = "UserName";
  ExternalUserInfoModification2[ExternalUserInfoModification2["Password"] = 2] = "Password";
  ExternalUserInfoModification2[ExternalUserInfoModification2["Role"] = 4] = "Role";
  ExternalUserInfoModification2[ExternalUserInfoModification2["Active"] = 8] = "Active";
  ExternalUserInfoModification2[ExternalUserInfoModification2["All"] = 15] = "All";
  ExternalUserInfoModification2[ExternalUserInfoModification2["UndefinedValue16"] = 16] = "UndefinedValue16";
})(ExternalUserInfoModification || (ExternalUserInfoModification = {}));
var EFieldRight;
(function (EFieldRight2) {
  EFieldRight2[EFieldRight2["None"] = 0] = "None";
  EFieldRight2[EFieldRight2["Read"] = 1] = "Read";
  EFieldRight2[EFieldRight2["Write"] = 2] = "Write";
  EFieldRight2[EFieldRight2["Update"] = 3] = "Update";
  EFieldRight2[EFieldRight2["Unused1"] = 4] = "Unused1";
  EFieldRight2[EFieldRight2["Unused2"] = 8] = "Unused2";
  EFieldRight2[EFieldRight2["Unused3"] = 16] = "Unused3";
  EFieldRight2[EFieldRight2["Unused4"] = 32] = "Unused4";
  EFieldRight2[EFieldRight2["UIHintMandatory"] = 64] = "UIHintMandatory";
  EFieldRight2[EFieldRight2["UIHintReadOnly"] = 128] = "UIHintReadOnly";
  EFieldRight2[EFieldRight2["UIHints"] = 192] = "UIHints";
  EFieldRight2[EFieldRight2["UndefinedValue256"] = 256] = "UndefinedValue256";
  EFieldRight2[EFieldRight2["Nullable"] = 32] = "Nullable";
})(EFieldRight || (EFieldRight = {}));
var InterRestrictionOperator;
(function (InterRestrictionOperator2) {
  InterRestrictionOperator2["None"] = "None";
  InterRestrictionOperator2["And"] = "And";
  InterRestrictionOperator2["Or"] = "Or";
})(InterRestrictionOperator || (InterRestrictionOperator = {}));
var Weekday;
(function (Weekday2) {
  Weekday2[Weekday2["Unknown"] = 0] = "Unknown";
  Weekday2[Weekday2["Monday"] = 1] = "Monday";
  Weekday2[Weekday2["Tuesday"] = 2] = "Tuesday";
  Weekday2[Weekday2["Wednesday"] = 4] = "Wednesday";
  Weekday2[Weekday2["Thursday"] = 8] = "Thursday";
  Weekday2[Weekday2["Friday"] = 16] = "Friday";
  Weekday2[Weekday2["Saturday"] = 32] = "Saturday";
  Weekday2[Weekday2["Sunday"] = 64] = "Sunday";
})(Weekday || (Weekday = {}));
var RecurrenceYearlyPattern;
(function (RecurrenceYearlyPattern2) {
  RecurrenceYearlyPattern2["Unknown"] = "Unknown";
  RecurrenceYearlyPattern2["DayOfMonth"] = "DayOfMonth";
  RecurrenceYearlyPattern2["WeekdayOfMonth"] = "WeekdayOfMonth";
})(RecurrenceYearlyPattern || (RecurrenceYearlyPattern = {}));
var RecurrenceMonthlyPattern;
(function (RecurrenceMonthlyPattern2) {
  RecurrenceMonthlyPattern2["Unknown"] = "Unknown";
  RecurrenceMonthlyPattern2["DayOfMonth"] = "DayOfMonth";
  RecurrenceMonthlyPattern2["WeekdayOfMonth"] = "WeekdayOfMonth";
})(RecurrenceMonthlyPattern || (RecurrenceMonthlyPattern = {}));
var RecurrenceDailyPattern;
(function (RecurrenceDailyPattern2) {
  RecurrenceDailyPattern2["Unknown"] = "Unknown";
  RecurrenceDailyPattern2["EveryWorkday"] = "EveryWorkday";
  RecurrenceDailyPattern2["EveryWeekday"] = "EveryWeekday";
  RecurrenceDailyPattern2["EveryCyclicDay"] = "EveryCyclicDay";
})(RecurrenceDailyPattern || (RecurrenceDailyPattern = {}));
var WeekOfMonth;
(function (WeekOfMonth2) {
  WeekOfMonth2["Unknown"] = "Unknown";
  WeekOfMonth2["First"] = "First";
  WeekOfMonth2["Second"] = "Second";
  WeekOfMonth2["Third"] = "Third";
  WeekOfMonth2["Fourth"] = "Fourth";
  WeekOfMonth2["Last"] = "Last";
})(WeekOfMonth || (WeekOfMonth = {}));
var OrderBySortType;
(function (OrderBySortType2) {
  OrderBySortType2["ASC"] = "ASC";
  OrderBySortType2["DESC"] = "DESC";
})(OrderBySortType || (OrderBySortType = {}));
var EjUserStatus;
(function (EjUserStatus2) {
  EjUserStatus2["StatusNone"] = "StatusNone";
  EjUserStatus2["StatusNormal"] = "StatusNormal";
  EjUserStatus2["StatusNotAvailable"] = "StatusNotAvailable";
  EjUserStatus2["StatusDeleted"] = "StatusDeleted";
  EjUserStatus2["StatusReadOnly"] = "StatusReadOnly";
  EjUserStatus2["StatusSpm"] = "StatusSpm";
  EjUserStatus2["StatusSystem"] = "StatusSystem";
})(EjUserStatus || (EjUserStatus = {}));
var StatusScreenPanelType;
(function (StatusScreenPanelType2) {
  StatusScreenPanelType2["None"] = "None";
  StatusScreenPanelType2["OpenRequestsPerCategory"] = "OpenRequestsPerCategory";
  StatusScreenPanelType2["OpenRequestsPerTopCategory"] = "OpenRequestsPerTopCategory";
  StatusScreenPanelType2["OpenRequestsPerUser"] = "OpenRequestsPerUser";
  StatusScreenPanelType2["OpenRequestsPerUserGroup"] = "OpenRequestsPerUserGroup";
  StatusScreenPanelType2["OpenRequestsPerPriority"] = "OpenRequestsPerPriority";
  StatusScreenPanelType2["OpenRequestsPerStatus"] = "OpenRequestsPerStatus";
  StatusScreenPanelType2["OpenRequestsPerOrigin"] = "OpenRequestsPerOrigin";
  StatusScreenPanelType2["NumberOfCreatedRequestsPerDay"] = "NumberOfCreatedRequestsPerDay";
  StatusScreenPanelType2["NumberOfCreatedRequestsPerWeek"] = "NumberOfCreatedRequestsPerWeek";
  StatusScreenPanelType2["NumberOfCreatedRequestsPerMonth"] = "NumberOfCreatedRequestsPerMonth";
  StatusScreenPanelType2["UserResponseTimePerDay"] = "UserResponseTimePerDay";
  StatusScreenPanelType2["UserReponseTimePerWeek"] = "UserReponseTimePerWeek";
  StatusScreenPanelType2["UserResponseTimePerMonth"] = "UserResponseTimePerMonth";
  StatusScreenPanelType2["OwnOpenRequests"] = "OwnOpenRequests";
  StatusScreenPanelType2["UnassignedRequests"] = "UnassignedRequests";
  StatusScreenPanelType2["Hotlist"] = "Hotlist";
  StatusScreenPanelType2["StatusScreen"] = "StatusScreen";
})(StatusScreenPanelType || (StatusScreenPanelType = {}));
var NetServerBuildType;
(function (NetServerBuildType2) {
  NetServerBuildType2["Feature"] = "Feature";
  NetServerBuildType2["Stable"] = "Stable";
  NetServerBuildType2["Alpha"] = "Alpha";
  NetServerBuildType2["Beta"] = "Beta";
  NetServerBuildType2["ReleaseCandidate"] = "ReleaseCandidate";
  NetServerBuildType2["Release"] = "Release";
})(NetServerBuildType || (NetServerBuildType = {}));
var QuoteVersionButtonAction;
(function (QuoteVersionButtonAction2) {
  QuoteVersionButtonAction2["None"] = "None";
  QuoteVersionButtonAction2["ValidateVersion"] = "ValidateVersion";
  QuoteVersionButtonAction2["Edit"] = "Edit";
  QuoteVersionButtonAction2["Send"] = "Send";
  QuoteVersionButtonAction2["Approve"] = "Approve";
  QuoteVersionButtonAction2["Reject"] = "Reject";
  QuoteVersionButtonAction2["ValidateVersionAndSendIfPossible"] = "ValidateVersionAndSendIfPossible";
  QuoteVersionButtonAction2["ValidateVersionAndPlaceOrderIfPossible"] = "ValidateVersionAndPlaceOrderIfPossible";
  QuoteVersionButtonAction2["CloneVersion"] = "CloneVersion";
  QuoteVersionButtonAction2["SendConfirmation"] = "SendConfirmation";
  QuoteVersionButtonAction2["GetOrderState"] = "GetOrderState";
  QuoteVersionButtonAction2["UpdatePrices"] = "UpdatePrices";
})(QuoteVersionButtonAction || (QuoteVersionButtonAction = {}));
var TemporaryKeyDomain;
(function (TemporaryKeyDomain2) {
  TemporaryKeyDomain2["Unknown"] = "Unknown";
  TemporaryKeyDomain2["MailingRecipient"] = "MailingRecipient";
  TemporaryKeyDomain2["FormSubmitterRecipient"] = "FormSubmitterRecipient";
  TemporaryKeyDomain2["ViewTicketInCustomerCenter"] = "ViewTicketInCustomerCenter";
  TemporaryKeyDomain2["LoginCustomerCenter"] = "LoginCustomerCenter";
  TemporaryKeyDomain2["PublicFaq"] = "PublicFaq";
  TemporaryKeyDomain2["ChangePasswordCustomerCenter"] = "ChangePasswordCustomerCenter";
})(TemporaryKeyDomain || (TemporaryKeyDomain = {}));
var DocTmplPrivacyType;
(function (DocTmplPrivacyType2) {
  DocTmplPrivacyType2["None"] = "None";
  DocTmplPrivacyType2["PersonRegistered"] = "PersonRegistered";
})(DocTmplPrivacyType || (DocTmplPrivacyType = {}));
var WebhookState;
(function (WebhookState2) {
  WebhookState2["Unknown"] = "Unknown";
  WebhookState2["Active"] = "Active";
  WebhookState2["Stopped"] = "Stopped";
  WebhookState2["TooManyErrors"] = "TooManyErrors";
})(WebhookState || (WebhookState = {}));
var CommandAction;
(function (CommandAction2) {
  CommandAction2["Implicit"] = "Implicit";
  CommandAction2["YesNo"] = "YesNo";
  CommandAction2["OkCancel"] = "OkCancel";
  CommandAction2["Ok"] = "Ok";
})(CommandAction || (CommandAction = {}));
var CommandActionResult;
(function (CommandActionResult2) {
  CommandActionResult2["Implicit"] = "Implicit";
  CommandActionResult2["Yes"] = "Yes";
  CommandActionResult2["Ok"] = "Ok";
  CommandActionResult2["No"] = "No";
  CommandActionResult2["Cancel"] = "Cancel";
})(CommandActionResult || (CommandActionResult = {}));
var NotificationPlatform;
(function (NotificationPlatform2) {
  NotificationPlatform2["Apple"] = "Apple";
  NotificationPlatform2["Google"] = "Google";
  NotificationPlatform2["Microsoft"] = "Microsoft";
  NotificationPlatform2["AppleDeveloper"] = "AppleDeveloper";
  NotificationPlatform2["AppleAdHoc"] = "AppleAdHoc";
  NotificationPlatform2["GoogleDeveloper"] = "GoogleDeveloper";
})(NotificationPlatform || (NotificationPlatform = {}));
var NotificationMessageType;
(function (NotificationMessageType2) {
  NotificationMessageType2["Message"] = "Message";
  NotificationMessageType2["ImportantMessage"] = "ImportantMessage";
  NotificationMessageType2["RemoteAction"] = "RemoteAction";
  NotificationMessageType2["YesNoQuestion"] = "YesNoQuestion";
  NotificationMessageType2["ShowWebPage"] = "ShowWebPage";
})(NotificationMessageType || (NotificationMessageType = {}));
var CalMethod;
(function (CalMethod2) {
  CalMethod2["Unknown"] = "Unknown";
  CalMethod2["Add"] = "Add";
  CalMethod2["Cancel"] = "Cancel";
  CalMethod2["Counter"] = "Counter";
  CalMethod2["DeclineCounter"] = "DeclineCounter";
  CalMethod2["Publish"] = "Publish";
  CalMethod2["Refresh"] = "Refresh";
  CalMethod2["Reply"] = "Reply";
  CalMethod2["Request"] = "Request";
})(CalMethod || (CalMethod = {}));
var CalReplyStatus;
(function (CalReplyStatus2) {
  CalReplyStatus2["Unknown"] = "Unknown";
  CalReplyStatus2["Accepted"] = "Accepted";
  CalReplyStatus2["Declined"] = "Declined";
  CalReplyStatus2["Tentative"] = "Tentative";
})(CalReplyStatus || (CalReplyStatus = {}));
var SenderMailMode;
(function (SenderMailMode2) {
  SenderMailMode2["UseDefaultSender"] = "UseDefaultSender";
  SenderMailMode2["UseOurContact"] = "UseOurContact";
  SenderMailMode2["UseSupportContact"] = "UseSupportContact";
  SenderMailMode2["UseLoggedInUser"] = "UseLoggedInUser";
})(SenderMailMode || (SenderMailMode = {}));
var FormsRecaptchaMode;
(function (FormsRecaptchaMode2) {
  FormsRecaptchaMode2["NotAvailable"] = "NotAvailable";
  FormsRecaptchaMode2["GlobalKeysExist"] = "GlobalKeysExist";
  FormsRecaptchaMode2["KeysNeeded"] = "KeysNeeded";
})(FormsRecaptchaMode || (FormsRecaptchaMode = {}));
var AppointmentCautionWarning;
(function (AppointmentCautionWarning2) {
  AppointmentCautionWarning2["OK"] = "OK";
  AppointmentCautionWarning2["NotInSync"] = "NotInSync";
  AppointmentCautionWarning2["NotNotifiedByEmail"] = "NotNotifiedByEmail";
  AppointmentCautionWarning2["RecurrencePatternNotSupported"] = "RecurrencePatternNotSupported";
  AppointmentCautionWarning2["IncomingRecurrenceChangeNotSupported"] = "IncomingRecurrenceChangeNotSupported";
  AppointmentCautionWarning2["ExternalParticipantsDateTimeMismatch"] = "ExternalParticipantsDateTimeMismatch";
})(AppointmentCautionWarning || (AppointmentCautionWarning = {}));
var DocTmplInvitationType;
(function (DocTmplInvitationType2) {
  DocTmplInvitationType2["None"] = "None";
  DocTmplInvitationType2["New"] = "New";
  DocTmplInvitationType2["Changed"] = "Changed";
  DocTmplInvitationType2["Cancelled"] = "Cancelled";
})(DocTmplInvitationType || (DocTmplInvitationType = {}));
var VideoMeetingStatus;
(function (VideoMeetingStatus2) {
  VideoMeetingStatus2["NoChange"] = "NoChange";
  VideoMeetingStatus2["VideoMeetingOn"] = "VideoMeetingOn";
  VideoMeetingStatus2["VideoMeetingOff"] = "VideoMeetingOff";
})(VideoMeetingStatus || (VideoMeetingStatus = {}));
var UpsertNomatchAction;
(function (UpsertNomatchAction2) {
  UpsertNomatchAction2["NoChange"] = "NoChange";
  UpsertNomatchAction2["ZeroColumns"] = "ZeroColumns";
  UpsertNomatchAction2["DeleteRow"] = "DeleteRow";
})(UpsertNomatchAction || (UpsertNomatchAction = {}));
var UpsertRowActionStatus;
(function (UpsertRowActionStatus2) {
  UpsertRowActionStatus2["Inserted"] = "Inserted";
  UpsertRowActionStatus2["Updated"] = "Updated";
  UpsertRowActionStatus2["NoUpdateNeeded"] = "NoUpdateNeeded";
  UpsertRowActionStatus2["Deleted"] = "Deleted";
  UpsertRowActionStatus2["ColumnsZeroed"] = "ColumnsZeroed";
})(UpsertRowActionStatus || (UpsertRowActionStatus = {}));
var MailboxType;
(function (MailboxType2) {
  MailboxType2["Unknown"] = "Unknown";
  MailboxType2["Pop"] = "Pop";
  MailboxType2["Imap"] = "Imap";
  MailboxType2["Mapi"] = "Mapi";
  MailboxType2["Facebook"] = "Facebook";
  MailboxType2["Pops"] = "Pops";
  MailboxType2["Imaps"] = "Imaps";
  MailboxType2["SmsPlugin"] = "SmsPlugin";
  MailboxType2["Mailgun"] = "Mailgun";
  MailboxType2["ImapOAuth"] = "ImapOAuth";
})(MailboxType || (MailboxType = {}));
var DeltaType;
(function (DeltaType2) {
  DeltaType2["Unknown"] = "Unknown";
  DeltaType2["System"] = "System";
  DeltaType2["WebPanel"] = "WebPanel";
  DeltaType2["CustomFields"] = "CustomFields";
  DeltaType2["Customized"] = "Customized";
})(DeltaType || (DeltaType = {}));
var DeltaState;
(function (DeltaState2) {
  DeltaState2["Unknown"] = "Unknown";
  DeltaState2["Draft"] = "Draft";
  DeltaState2["Published"] = "Published";
})(DeltaState || (DeltaState = {}));
var NotificationEventType;
(function (NotificationEventType2) {
  NotificationEventType2["Unknown"] = "Unknown";
  NotificationEventType2["NewTicket"] = "NewTicket";
  NotificationEventType2["AppointmentInvitation"] = "AppointmentInvitation";
  NotificationEventType2["AppointmentMoved"] = "AppointmentMoved";
  NotificationEventType2["AppointmentCancelled"] = "AppointmentCancelled";
  NotificationEventType2["NewTicketMessage"] = "NewTicketMessage";
  NotificationEventType2["TicketActivated"] = "TicketActivated";
  NotificationEventType2["TicketEscalated"] = "TicketEscalated";
  NotificationEventType2["QuoteApprovalRequest"] = "QuoteApprovalRequest";
  NotificationEventType2["QuoteApprovalApproved"] = "QuoteApprovalApproved";
  NotificationEventType2["QuoteApprovalDenied"] = "QuoteApprovalDenied";
  NotificationEventType2["AppointmentDeclined"] = "AppointmentDeclined";
})(NotificationEventType || (NotificationEventType = {}));
var ChangePasswordType;
(function (ChangePasswordType2) {
  ChangePasswordType2["Email"] = "Email";
  ChangePasswordType2["Password"] = "Password";
})(ChangePasswordType || (ChangePasswordType = {}));
var MessageHeaderStdItem;
(function (MessageHeaderStdItem2) {
  MessageHeaderStdItem2["None"] = "None";
  MessageHeaderStdItem2["Forward"] = "Forward";
  MessageHeaderStdItem2["UnnamedAttachmentBlocked"] = "UnnamedAttachmentBlocked";
  MessageHeaderStdItem2["NoAutoReply"] = "NoAutoReply";
  MessageHeaderStdItem2["SentAutoReplyToCustomersA"] = "SentAutoReplyToCustomersA";
  MessageHeaderStdItem2["SentAutoReplyToCustomersB"] = "SentAutoReplyToCustomersB";
  MessageHeaderStdItem2["CustomerReadFAQ"] = "CustomerReadFAQ";
  MessageHeaderStdItem2["ReplyTemplate"] = "ReplyTemplate";
})(MessageHeaderStdItem || (MessageHeaderStdItem = {}));
var MessageHeaderStdItemCol;
(function (MessageHeaderStdItemCol2) {
  MessageHeaderStdItemCol2["None"] = "None";
  MessageHeaderStdItemCol2["Name"] = "Name";
  MessageHeaderStdItemCol2["Value"] = "Value";
})(MessageHeaderStdItemCol || (MessageHeaderStdItemCol = {}));
var MessageActionType;
(function (MessageActionType2) {
  MessageActionType2["None"] = "None";
  MessageActionType2["Reply"] = "Reply";
  MessageActionType2["ReplyAll"] = "ReplyAll";
  MessageActionType2["Forward"] = "Forward";
  MessageActionType2["InternalComment"] = "InternalComment";
})(MessageActionType || (MessageActionType = {}));
var RecipientType;
(function (RecipientType2) {
  RecipientType2["To"] = "To";
  RecipientType2["CC"] = "CC";
  RecipientType2["BCC"] = "BCC";
})(RecipientType || (RecipientType = {}));
var ImageEmbedType;
(function (ImageEmbedType2) {
  ImageEmbedType2["Link"] = "Link";
  ImageEmbedType2["Inline"] = "Inline";
})(ImageEmbedType || (ImageEmbedType = {}));
var TaskListItemType;
(function (TaskListItemType2) {
  TaskListItemType2["None"] = "None";
  TaskListItemType2["Url"] = "Url";
  TaskListItemType2["CrmScript"] = "CrmScript";
  TaskListItemType2["SoProtocol"] = "SoProtocol";
})(TaskListItemType || (TaskListItemType = {}));
var ShowTaskItemInClient;
(function (ShowTaskItemInClient2) {
  ShowTaskItemInClient2[ShowTaskItemInClient2["None"] = 0] = "None";
  ShowTaskItemInClient2[ShowTaskItemInClient2["Web"] = 1] = "Web";
  ShowTaskItemInClient2[ShowTaskItemInClient2["Mobile"] = 2] = "Mobile";
})(ShowTaskItemInClient || (ShowTaskItemInClient = {}));
var ArchiveBehaviour;
(function (ArchiveBehaviour2) {
  ArchiveBehaviour2[ArchiveBehaviour2["None"] = 0] = "None";
  ArchiveBehaviour2[ArchiveBehaviour2["InArchives"] = 1] = "InArchives";
  ArchiveBehaviour2[ArchiveBehaviour2["MultiSelectInArchives"] = 2] = "MultiSelectInArchives";
})(ArchiveBehaviour || (ArchiveBehaviour = {}));
var AiTextStyle;
(function (AiTextStyle2) {
  AiTextStyle2["None"] = "None";
  AiTextStyle2["Rephrase"] = "Rephrase";
  AiTextStyle2["Correct"] = "Correct";
  AiTextStyle2["Casual"] = "Casual";
  AiTextStyle2["Formal"] = "Formal";
})(AiTextStyle || (AiTextStyle = {}));
var EventHandlerType;
(function (EventHandlerType2) {
  EventHandlerType2["Unknown"] = "Unknown";
  EventHandlerType2["NewTicket"] = "NewTicket";
  EventHandlerType2["NewTicketFromCustomerCenter"] = "NewTicketFromCustomerCenter";
  EventHandlerType2["NewTicketFromEmail"] = "NewTicketFromEmail";
  EventHandlerType2["NewTicketFromCustomerCenterBeforeSave"] = "NewTicketFromCustomerCenterBeforeSave";
  EventHandlerType2["NewTicketFromSpmLink"] = "NewTicketFromSpmLink";
  EventHandlerType2["NewNotifyTicketFromForm"] = "NewNotifyTicketFromForm";
  EventHandlerType2["NewTicketFromForm"] = "NewTicketFromForm";
  EventHandlerType2["TicketSave"] = "TicketSave";
  EventHandlerType2["TicketClosed"] = "TicketClosed";
  EventHandlerType2["TicketPostponed"] = "TicketPostponed";
  EventHandlerType2["TicketDeleted"] = "TicketDeleted";
  EventHandlerType2["TicketActivated"] = "TicketActivated";
  EventHandlerType2["TicketReopened"] = "TicketReopened";
  EventHandlerType2["TicketReopenedFromCustomerCenter"] = "TicketReopenedFromCustomerCenter";
  EventHandlerType2["TicketReopenedFromEmail"] = "TicketReopenedFromEmail";
  EventHandlerType2["TicketChangedPriority"] = "TicketChangedPriority";
  EventHandlerType2["TicketChangedCategory"] = "TicketChangedCategory";
  EventHandlerType2["TicketChangedOwnedBy"] = "TicketChangedOwnedBy";
  EventHandlerType2["TicketChangedPrimaryCustomer"] = "TicketChangedPrimaryCustomer";
  EventHandlerType2["TicketChangedTicketStatus"] = "TicketChangedTicketStatus";
  EventHandlerType2["TicketChangedSlevel"] = "TicketChangedSlevel";
  EventHandlerType2["TicketMessageAdded"] = "TicketMessageAdded";
  EventHandlerType2["TicketInternalMessageAdded"] = "TicketInternalMessageAdded";
  EventHandlerType2["TicketExternalMessageAdded"] = "TicketExternalMessageAdded";
  EventHandlerType2["TicketMessageSentimentCalculated"] = "TicketMessageSentimentCalculated";
  EventHandlerType2["CompactModeInjection"] = "CompactModeInjection";
  EventHandlerType2["CustomerCenterAuthentication"] = "CustomerCenterAuthentication";
  EventHandlerType2["ScheduledTaskFailed"] = "ScheduledTaskFailed";
  EventHandlerType2["DbiTaskFailed"] = "DbiTaskFailed";
  EventHandlerType2["CustomerSetSubscriptions"] = "CustomerSetSubscriptions";
  EventHandlerType2["ImportMailBeforeProcessing"] = "ImportMailBeforeProcessing";
  EventHandlerType2["ImportMailAfterProcessing"] = "ImportMailAfterProcessing";
  EventHandlerType2["MainMenu"] = "MainMenu";
  EventHandlerType2["ChatNewSession"] = "ChatNewSession";
  EventHandlerType2["ChatSessionChangedStatus"] = "ChatSessionChangedStatus";
  EventHandlerType2["ChatBeforeSaveNewMessage"] = "ChatBeforeSaveNewMessage";
  EventHandlerType2["ChatAfterSaveNewMessage"] = "ChatAfterSaveNewMessage";
  EventHandlerType2["ServiceScreenNewTicketLoad"] = "ServiceScreenNewTicketLoad";
  EventHandlerType2["ServiceScreenNewQuickTicketLoad"] = "ServiceScreenNewQuickTicketLoad";
  EventHandlerType2["ServiceScreenListTicketMessagesLoad"] = "ServiceScreenListTicketMessagesLoad";
  EventHandlerType2["ServiceScreenAddMessageLoad"] = "ServiceScreenAddMessageLoad";
  EventHandlerType2["ServiceScreenEditTicketLoad"] = "ServiceScreenEditTicketLoad";
  EventHandlerType2["ServiceScreenViewCustomerLoad"] = "ServiceScreenViewCustomerLoad";
  EventHandlerType2["ServiceScreenEditCustomerLoad"] = "ServiceScreenEditCustomerLoad";
  EventHandlerType2["ServiceScreenViewCompanyLoad"] = "ServiceScreenViewCompanyLoad";
  EventHandlerType2["ServiceScreenEditCompanyLoad"] = "ServiceScreenEditCompanyLoad";
  EventHandlerType2["ServiceScreenForwardLoad"] = "ServiceScreenForwardLoad";
  EventHandlerType2["ServiceScreenEditExtraTableLoad"] = "ServiceScreenEditExtraTableLoad";
  EventHandlerType2["ServiceScreenNewTicketBeforeSubmit"] = "ServiceScreenNewTicketBeforeSubmit";
  EventHandlerType2["ServiceScreenNewQuickTicketBeforeSubmit"] = "ServiceScreenNewQuickTicketBeforeSubmit";
  EventHandlerType2["ServiceScreenListTicketMessagesBeforeSubmit"] = "ServiceScreenListTicketMessagesBeforeSubmit";
  EventHandlerType2["ServiceScreenAddMessageBeforeSubmit"] = "ServiceScreenAddMessageBeforeSubmit";
  EventHandlerType2["ServiceScreenEditTicketBeforeSubmit"] = "ServiceScreenEditTicketBeforeSubmit";
  EventHandlerType2["ServiceScreenViewCustomerBeforeSubmit"] = "ServiceScreenViewCustomerBeforeSubmit";
  EventHandlerType2["ServiceScreenEditCustomerBeforeSubmit"] = "ServiceScreenEditCustomerBeforeSubmit";
  EventHandlerType2["ServiceScreenViewCompanyBeforeSubmit"] = "ServiceScreenViewCompanyBeforeSubmit";
  EventHandlerType2["ServiceScreenEditCompanyBeforeSubmit"] = "ServiceScreenEditCompanyBeforeSubmit";
  EventHandlerType2["ServiceScreenForwardBeforeSubmit"] = "ServiceScreenForwardBeforeSubmit";
  EventHandlerType2["ServiceScreenEditExtraTableBeforeSubmit"] = "ServiceScreenEditExtraTableBeforeSubmit";
  EventHandlerType2["ServiceScreenNewTicketAfterSubmit"] = "ServiceScreenNewTicketAfterSubmit";
  EventHandlerType2["ServiceScreenNewQuickTicketAfterSubmit"] = "ServiceScreenNewQuickTicketAfterSubmit";
  EventHandlerType2["ServiceScreenListTicketMessagesAfterSubmit"] = "ServiceScreenListTicketMessagesAfterSubmit";
  EventHandlerType2["ServiceScreenAddMessageAfterSubmit"] = "ServiceScreenAddMessageAfterSubmit";
  EventHandlerType2["ServiceScreenEditTicketAfterSubmit"] = "ServiceScreenEditTicketAfterSubmit";
  EventHandlerType2["ServiceScreenViewCustomerAfterSubmit"] = "ServiceScreenViewCustomerAfterSubmit";
  EventHandlerType2["ServiceScreenEditCustomerAfterSubmit"] = "ServiceScreenEditCustomerAfterSubmit";
  EventHandlerType2["ServiceScreenViewCompanyAfterSubmit"] = "ServiceScreenViewCompanyAfterSubmit";
  EventHandlerType2["ServiceScreenEditCompanyAfterSubmit"] = "ServiceScreenEditCompanyAfterSubmit";
  EventHandlerType2["ServiceScreenForwardAfterSubmit"] = "ServiceScreenForwardAfterSubmit";
  EventHandlerType2["ServiceScreenEditExtraTableAfterSubmit"] = "ServiceScreenEditExtraTableAfterSubmit";
  EventHandlerType2["SalesBeforeSaveAppointment"] = "SalesBeforeSaveAppointment";
  EventHandlerType2["SalesBeforeSaveStakeholder"] = "SalesBeforeSaveStakeholder";
  EventHandlerType2["SalesBeforeSaveQuote"] = "SalesBeforeSaveQuote";
  EventHandlerType2["SalesBeforeSaveDocument"] = "SalesBeforeSaveDocument";
  EventHandlerType2["SalesBeforeSaveContact"] = "SalesBeforeSaveContact";
  EventHandlerType2["SalesBeforeSavePerson"] = "SalesBeforeSavePerson";
  EventHandlerType2["SalesBeforeSaveRelation"] = "SalesBeforeSaveRelation";
  EventHandlerType2["SalesBeforeSaveSale"] = "SalesBeforeSaveSale";
  EventHandlerType2["SalesBeforeSaveProject"] = "SalesBeforeSaveProject";
  EventHandlerType2["SalesBeforeSaveSelection"] = "SalesBeforeSaveSelection";
  EventHandlerType2["SalesBeforeSaveProjectMember"] = "SalesBeforeSaveProjectMember";
  EventHandlerType2["SalesBeforeSaveSelectionMember"] = "SalesBeforeSaveSelectionMember";
  EventHandlerType2["SalesBeforeSaveQuoteLine"] = "SalesBeforeSaveQuoteLine";
  EventHandlerType2["SalesBeforeSaveApproveQuote"] = "SalesBeforeSaveApproveQuote";
  EventHandlerType2["SalesBeforeSaveRejectQuote"] = "SalesBeforeSaveRejectQuote";
  EventHandlerType2["SalesBeforeSaveTicket"] = "SalesBeforeSaveTicket";
  EventHandlerType2["SalesAfterSaveAppointment"] = "SalesAfterSaveAppointment";
  EventHandlerType2["SalesAfterSaveStakeholder"] = "SalesAfterSaveStakeholder";
  EventHandlerType2["SalesAfterSaveQuote"] = "SalesAfterSaveQuote";
  EventHandlerType2["SalesAfterSaveDocument"] = "SalesAfterSaveDocument";
  EventHandlerType2["SalesAfterSaveContact"] = "SalesAfterSaveContact";
  EventHandlerType2["SalesAfterSavePerson"] = "SalesAfterSavePerson";
  EventHandlerType2["SalesAfterSaveRelation"] = "SalesAfterSaveRelation";
  EventHandlerType2["SalesAfterSaveSale"] = "SalesAfterSaveSale";
  EventHandlerType2["SalesAfterSaveProject"] = "SalesAfterSaveProject";
  EventHandlerType2["SalesAfterSaveSelection"] = "SalesAfterSaveSelection";
  EventHandlerType2["SalesAfterSaveProjectMember"] = "SalesAfterSaveProjectMember";
  EventHandlerType2["SalesAfterSaveSelectionMember"] = "SalesAfterSaveSelectionMember";
  EventHandlerType2["SalesAfterSaveQuoteLine"] = "SalesAfterSaveQuoteLine";
  EventHandlerType2["SalesAfterSaveApproveQuote"] = "SalesAfterSaveApproveQuote";
  EventHandlerType2["SalesAfterSaveRejectQuote"] = "SalesAfterSaveRejectQuote";
  EventHandlerType2["SalesAfterSaveTicket"] = "SalesAfterSaveTicket";
})(EventHandlerType || (EventHandlerType = {}));
var Domain;
(function (Domain2) {
  Domain2["Unknown"] = "Unknown";
  Domain2["ExtraTables"] = "ExtraTables";
  Domain2["ScreenDefinitions"] = "ScreenDefinitions";
  Domain2["Scripts"] = "Scripts";
  Domain2["Selections"] = "Selections";
  Domain2["ExternalDocuments"] = "ExternalDocuments";
  Domain2["UserGroups"] = "UserGroups";
  Domain2["ExternalDocumentRelatedToSpmMessage"] = "ExternalDocumentRelatedToSpmMessage";
  Domain2["Dashboards"] = "Dashboards";
  Domain2["EmailFlows"] = "EmailFlows";
})(Domain || (Domain = {}));
var FormSubmissionStatus;
(function (FormSubmissionStatus2) {
  FormSubmissionStatus2["Unknown"] = "Unknown";
  FormSubmissionStatus2["InProgress"] = "InProgress";
  FormSubmissionStatus2["EmailVerification"] = "EmailVerification";
  FormSubmissionStatus2["Submitted"] = "Submitted";
  FormSubmissionStatus2["Processed"] = "Processed";
  FormSubmissionStatus2["Failed"] = "Failed";
})(FormSubmissionStatus || (FormSubmissionStatus = {}));
var TicketPriorityStatus;
(function (TicketPriorityStatus2) {
  TicketPriorityStatus2["Unknown"] = "Unknown";
  TicketPriorityStatus2["Normal"] = "Normal";
  TicketPriorityStatus2["Deleted"] = "Deleted";
})(TicketPriorityStatus || (TicketPriorityStatus = {}));
var TicketCategoryDelegateMethod;
(function (TicketCategoryDelegateMethod2) {
  TicketCategoryDelegateMethod2["Unknown"] = "Unknown";
  TicketCategoryDelegateMethod2["Even"] = "Even";
  TicketCategoryDelegateMethod2["Weighted"] = "Weighted";
  TicketCategoryDelegateMethod2["Unfair"] = "Unfair";
  TicketCategoryDelegateMethod2["Not"] = "Not";
})(TicketCategoryDelegateMethod || (TicketCategoryDelegateMethod = {}));
var TicketCategoryClosingStatus;
(function (TicketCategoryClosingStatus2) {
  TicketCategoryClosingStatus2["UserDefined"] = "UserDefined";
  TicketCategoryClosingStatus2["Active"] = "Active";
  TicketCategoryClosingStatus2["Closed"] = "Closed";
  TicketCategoryClosingStatus2["Postponed"] = "Postponed";
})(TicketCategoryClosingStatus || (TicketCategoryClosingStatus = {}));
var TicketCategoryFlags;
(function (TicketCategoryFlags2) {
  TicketCategoryFlags2[TicketCategoryFlags2["Unknown"] = 0] = "Unknown";
  TicketCategoryFlags2[TicketCategoryFlags2["Internal"] = 1] = "Internal";
  TicketCategoryFlags2[TicketCategoryFlags2["OnlyLoggedInUsers"] = 2] = "OnlyLoggedInUsers";
  TicketCategoryFlags2[TicketCategoryFlags2["DefaultToCategoryMaster"] = 4] = "DefaultToCategoryMaster";
  TicketCategoryFlags2[TicketCategoryFlags2["ListInMain"] = 8] = "ListInMain";
  TicketCategoryFlags2[TicketCategoryFlags2["RedelegateNewMsg"] = 16] = "RedelegateNewMsg";
  TicketCategoryFlags2[TicketCategoryFlags2["DelegateToOurContact"] = 32] = "DelegateToOurContact";
  TicketCategoryFlags2[TicketCategoryFlags2["PropagateReplyTemplate"] = 64] = "PropagateReplyTemplate";
  TicketCategoryFlags2[TicketCategoryFlags2["MembersOnly"] = 128] = "MembersOnly";
  TicketCategoryFlags2[TicketCategoryFlags2["NotifyMembers"] = 256] = "NotifyMembers";
  TicketCategoryFlags2[TicketCategoryFlags2["AcceptWhenReplying"] = 512] = "AcceptWhenReplying";
})(TicketCategoryFlags || (TicketCategoryFlags = {}));
var TicketPriorityFlags;
(function (TicketPriorityFlags2) {
  TicketPriorityFlags2[TicketPriorityFlags2["Unknown"] = 0] = "Unknown";
  TicketPriorityFlags2[TicketPriorityFlags2["External"] = 1] = "External";
  TicketPriorityFlags2[TicketPriorityFlags2["Default"] = 2] = "Default";
  TicketPriorityFlags2[TicketPriorityFlags2["AlertSchedule"] = 4] = "AlertSchedule";
})(TicketPriorityFlags || (TicketPriorityFlags = {}));
var TicketPriorityEscalateEvent;
(function (TicketPriorityEscalateEvent2) {
  TicketPriorityEscalateEvent2["None"] = "None";
  TicketPriorityEscalateEvent2["Stop"] = "Stop";
  TicketPriorityEscalateEvent2["Continue"] = "Continue";
  TicketPriorityEscalateEvent2["Restart"] = "Restart";
})(TicketPriorityEscalateEvent || (TicketPriorityEscalateEvent = {}));
var TicketSecurityLevel;
(function (TicketSecurityLevel2) {
  TicketSecurityLevel2["Unknown"] = "Unknown";
  TicketSecurityLevel2["Internal"] = "Internal";
  TicketSecurityLevel2["External"] = "External";
})(TicketSecurityLevel || (TicketSecurityLevel = {}));
var TicketReadStatus;
(function (TicketReadStatus2) {
  TicketReadStatus2["Unknown"] = "Unknown";
  TicketReadStatus2["Green"] = "Green";
  TicketReadStatus2["Yellow"] = "Yellow";
  TicketReadStatus2["Red"] = "Red";
})(TicketReadStatus || (TicketReadStatus = {}));
var TicketMessageType;
(function (TicketMessageType2) {
  TicketMessageType2["Unknown"] = "Unknown";
  TicketMessageType2["Plain"] = "Plain";
  TicketMessageType2["Html"] = "Html";
})(TicketMessageType || (TicketMessageType = {}));
var TicketMessageCategory;
(function (TicketMessageCategory2) {
  TicketMessageCategory2["Message"] = "Message";
  TicketMessageCategory2["Bounce"] = "Bounce";
  TicketMessageCategory2["OutboxFailed"] = "OutboxFailed";
})(TicketMessageCategory || (TicketMessageCategory = {}));
var DesignType;
(function (DesignType2) {
  DesignType2["Unknown"] = "Unknown";
  DesignType2["SOEditor"] = "SOEditor";
  DesignType2["Unlayer"] = "Unlayer";
})(DesignType || (DesignType = {}));
var ShipmentMessageType;
(function (ShipmentMessageType2) {
  ShipmentMessageType2[ShipmentMessageType2["Plain"] = 1] = "Plain";
  ShipmentMessageType2[ShipmentMessageType2["Html"] = 2] = "Html";
  ShipmentMessageType2[ShipmentMessageType2["SourceView"] = 4] = "SourceView";
  ShipmentMessageType2[ShipmentMessageType2["Sms"] = 8] = "Sms";
  ShipmentMessageType2[ShipmentMessageType2["Document"] = 16] = "Document";
})(ShipmentMessageType || (ShipmentMessageType = {}));
var TicketAlertAction;
(function (TicketAlertAction2) {
  TicketAlertAction2[TicketAlertAction2["ActionDelegate"] = 1] = "ActionDelegate";
  TicketAlertAction2[TicketAlertAction2["UndefinedValue2"] = 2] = "UndefinedValue2";
  TicketAlertAction2[TicketAlertAction2["ActionEmail"] = 4] = "ActionEmail";
  TicketAlertAction2[TicketAlertAction2["ActionEmailCustomer"] = 8] = "ActionEmailCustomer";
  TicketAlertAction2[TicketAlertAction2["ActionEmailUser"] = 16] = "ActionEmailUser";
  TicketAlertAction2[TicketAlertAction2["ActionEmailCategoryMaster"] = 32] = "ActionEmailCategoryMaster";
  TicketAlertAction2[TicketAlertAction2["ActionSms"] = 64] = "ActionSms";
  TicketAlertAction2[TicketAlertAction2["ActionSmsCustomer"] = 128] = "ActionSmsCustomer";
  TicketAlertAction2[TicketAlertAction2["ActionSmsUser"] = 256] = "ActionSmsUser";
  TicketAlertAction2[TicketAlertAction2["ActionSmsCategoryMaster"] = 512] = "ActionSmsCategoryMaster";
  TicketAlertAction2[TicketAlertAction2["ActionScript"] = 1024] = "ActionScript";
})(TicketAlertAction || (TicketAlertAction = {}));
var BadgeType;
(function (BadgeType2) {
  BadgeType2["Unknown"] = "Unknown";
  BadgeType2["Reply"] = "Reply";
  BadgeType2["Forward"] = "Forward";
  BadgeType2["Comment"] = "Comment";
  BadgeType2["Incoming"] = "Incoming";
  BadgeType2["Outgoing"] = "Outgoing";
})(BadgeType || (BadgeType = {}));
var WidgetTheme;
(function (WidgetTheme2) {
  WidgetTheme2["Classic"] = "Classic";
  WidgetTheme2["Modern"] = "Modern";
})(WidgetTheme || (WidgetTheme = {}));
var WidgetRequiredFields;
(function (WidgetRequiredFields2) {
  WidgetRequiredFields2[WidgetRequiredFields2["None"] = 0] = "None";
  WidgetRequiredFields2[WidgetRequiredFields2["Email"] = 1] = "Email";
  WidgetRequiredFields2[WidgetRequiredFields2["Name"] = 2] = "Name";
  WidgetRequiredFields2[WidgetRequiredFields2["Company"] = 4] = "Company";
  WidgetRequiredFields2[WidgetRequiredFields2["Phone"] = 8] = "Phone";
  WidgetRequiredFields2[WidgetRequiredFields2["Country"] = 16] = "Country";
})(WidgetRequiredFields || (WidgetRequiredFields = {}));
var ChatSessionFlags;
(function (ChatSessionFlags2) {
  ChatSessionFlags2[ChatSessionFlags2["CustomerIsTyping"] = 0] = "CustomerIsTyping";
  ChatSessionFlags2[ChatSessionFlags2["UserIsTyping"] = 1] = "UserIsTyping";
})(ChatSessionFlags || (ChatSessionFlags = {}));
var ConfigType;
(function (ConfigType2) {
  ConfigType2["Style"] = "Style";
  ConfigType2["Options"] = "Options";
})(ConfigType || (ConfigType = {}));
var FormType;
(function (FormType2) {
  FormType2["Normal"] = "Normal";
  FormType2["Template"] = "Template";
})(FormType || (FormType = {}));
var ChatSessionStatus;
(function (ChatSessionStatus2) {
  ChatSessionStatus2["Invalid"] = "Invalid";
  ChatSessionStatus2["PreChatForm"] = "PreChatForm";
  ChatSessionStatus2["Faq"] = "Faq";
  ChatSessionStatus2["OfflineForm"] = "OfflineForm";
  ChatSessionStatus2["InQueue"] = "InQueue";
  ChatSessionStatus2["CustomerLast"] = "CustomerLast";
  ChatSessionStatus2["UserLast"] = "UserLast";
  ChatSessionStatus2["Finished"] = "Finished";
  ChatSessionStatus2["Deleted"] = "Deleted";
  ChatSessionStatus2["Closed"] = "Closed";
  ChatSessionStatus2["RequestPosted"] = "RequestPosted";
  ChatSessionStatus2["ClosedFromQueue"] = "ClosedFromQueue";
})(ChatSessionStatus || (ChatSessionStatus = {}));
var ChatMessageType;
(function (ChatMessageType2) {
  ChatMessageType2["Invalid"] = "Invalid";
  ChatMessageType2["ToCustomer"] = "ToCustomer";
  ChatMessageType2["ToUser"] = "ToUser";
  ChatMessageType2["Special"] = "Special";
})(ChatMessageType || (ChatMessageType = {}));
var ChatMessageSpecialType;
(function (ChatMessageSpecialType2) {
  ChatMessageSpecialType2["None"] = "None";
  ChatMessageSpecialType2["Welcome"] = "Welcome";
  ChatMessageSpecialType2["Url"] = "Url";
  ChatMessageSpecialType2["Block"] = "Block";
  ChatMessageSpecialType2["NewSession"] = "NewSession";
  ChatMessageSpecialType2["TransferedSession"] = "TransferedSession";
  ChatMessageSpecialType2["Error"] = "Error";
  ChatMessageSpecialType2["SessionDeleted"] = "SessionDeleted";
  ChatMessageSpecialType2["FaqSuccessQuestion"] = "FaqSuccessQuestion";
  ChatMessageSpecialType2["ClosedByUser"] = "ClosedByUser";
  ChatMessageSpecialType2["ClosedByCustomer"] = "ClosedByCustomer";
  ChatMessageSpecialType2["ClosedByIdle"] = "ClosedByIdle";
  ChatMessageSpecialType2["TransferRejected"] = "TransferRejected";
  ChatMessageSpecialType2["ReopenedByCustomer"] = "ReopenedByCustomer";
  ChatMessageSpecialType2["ClickedOption"] = "ClickedOption";
  ChatMessageSpecialType2["BotMessage"] = "BotMessage";
  ChatMessageSpecialType2["Options"] = "Options";
  ChatMessageSpecialType2["IllegalFileType"] = "IllegalFileType";
})(ChatMessageSpecialType || (ChatMessageSpecialType = {}));
var ChatWidgetSize;
(function (ChatWidgetSize2) {
  ChatWidgetSize2["Normal"] = "Normal";
  ChatWidgetSize2["Large"] = "Large";
})(ChatWidgetSize || (ChatWidgetSize = {}));

// server/node_modules/@superoffice/webapi/dist/esm/Converters.js
function Create_Address_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.wgs84Latitude = src.Wgs84Latitude;
  res.wgs84Longitude = src.Wgs84Longitude;
  res.localizedAddress = Create_LocalizedFieldArrayArray_From(src.LocalizedAddress);
  res.street = Create_StructuredAddress_From(src.Street);
  res.postal = Create_StructuredAddress_From(src.Postal);
  res.formatted = src.Formatted;
  return res;
}
function Create_AddressArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_Address_From(src[i]);
    }
  }
  return res;
}
function Create_Carrier_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = {};
  res.tableRight = Create_TableRight_From(src.TableRight);
  res.fieldProperties = Create_FieldPropertyDictionary_From(src.FieldProperties);
  return res;
}
function Create_ColumnDataDictionary_From(src) {
  let res = src;
  if (res) {
    for (let i in res) {
      res[i] = Create_ArchiveColumnData_From(src[i]);
    }
  }
  return res;
}
function Create_CommandResult_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.success = src.Success;
  res.message = src.Message;
  res.result = CommandActionResult[src.Result];
  return res;
}
function Create_CustomCommand_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.name = src.Name;
  res.displayName = src.DisplayName;
  res.description = src.Description;
  res.toolTip = src.ToolTip;
  res.actions = CommandAction[src.Actions];
  res.actionData = src.ActionData;
  return res;
}
function Create_CustomCommandArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_CustomCommand_From(src[i]);
    }
  }
  return res;
}
function Create_DuplicateEntry_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.ruleName = src.RuleName;
  res.soPrimaryKey = src.SoPrimaryKey;
  res.entryName = src.EntryName;
  res.entryIdentifier = src.EntryIdentifier;
  res.ruleDisplayName = src.RuleDisplayName;
  return res;
}
function Create_DuplicateEntryArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_DuplicateEntry_From(src[i]);
    }
  }
  return res;
}
function Create_DuplicateRule_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.name = src.Name;
  res.displayName = src.DisplayName;
  res.displayTooltip = src.DisplayTooltip;
  res.isActive = src.IsActive;
  return res;
}
function Create_DuplicateRuleArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_DuplicateRule_From(src[i]);
    }
  }
  return res;
}
function Create_EntityElement_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.value = src.Value;
  res.strippedValue = src.StrippedValue;
  res.description = src.Description;
  return res;
}
function Create_EntityElementArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_EntityElement_From(src[i]);
    }
  }
  return res;
}
function Create_FieldProperty_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = {};
  res.fieldRight = Create_FieldRight_From(src.FieldRight);
  res.fieldType = src.FieldType;
  res.fieldLength = src.FieldLength;
  return res;
}
function Create_FieldPropertyDictionary_From(src) {
  let res = src;
  if (res) {
    for (let i in res) {
      res[i] = Create_FieldProperty_From(src[i]);
    }
  }
  return res;
}
function Create_FieldRight_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = {};
  res.mask = Create_EFieldRight_From(src.Mask);
  res.reason = src.Reason;
  return res;
}
function Create_IntStringDictionary_From(src) {
  let res = src;
  if (res) {
    for (let i in res) {
      res[i] = src[i];
    }
  }
  return res;
}
function Create_LocalizedField_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.name = src.Name;
  res.value = src.Value;
  res.tooltip = src.Tooltip;
  res.label = src.Label;
  res.valueLength = src.ValueLength;
  res.addressType = src.AddressType;
  return res;
}
function Create_LocalizedFieldArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_LocalizedField_From(src[i]);
    }
  }
  return res;
}
function Create_LocalizedFieldArrayArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_LocalizedFieldArray_From(src[i]);
    }
  }
  return res;
}
function Create_OperationResult_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = {};
  res.success = src.Success;
  res.message = src.Message;
  return res;
}
function Create_ProjectTypeStatusLink_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.projectTypeStatusLinkId = src.ProjectTypeStatusLinkId;
  res.projTypeId = src.ProjTypeId;
  res.projTypeName = src.ProjTypeName;
  res.projTypeTooltip = src.ProjTypeTooltip;
  res.projStatusId = src.ProjStatusId;
  res.projStatusName = src.ProjStatusName;
  res.projStatusTooltip = src.ProjStatusTooltip;
  return res;
}
function Create_Recipient_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = {};
  res.type = RecipientType[src.Type];
  res.value = src.Value;
  res.displayValue = src.DisplayValue;
  return res;
}
function Create_RecipientArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_Recipient_From(src[i]);
    }
  }
  return res;
}
function Create_RecipientStatistics_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.total = src.Total;
  res.validPostalAddresses = src.ValidPostalAddresses;
  res.validEmailAddresses = src.ValidEmailAddresses;
  res.validFaxNumbers = src.ValidFaxNumbers;
  res.noAddresses = src.NoAddresses;
  res.noFaxOrEmails = src.NoFaxOrEmails;
  return res;
}
function Create_RecurrenceDate_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = {};
  res.date = Create_Date_From(src.Date);
  res.isConflict = src.IsConflict;
  res.description = src.Description;
  res.descriptionStyleHint = src.DescriptionStyleHint;
  res.tooltip = src.Tooltip;
  return res;
}
function Create_RecurrenceDateArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_RecurrenceDate_From(src[i]);
    }
  }
  return res;
}
function Create_RecurrenceDayPattern_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = {};
  res.cycle = src.Cycle;
  res.pattern = RecurrenceDailyPattern[src.Pattern];
  return res;
}
function Create_RecurrenceInfo_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = {};
  res.recurrenceId = src.RecurrenceId;
  res.startDate = Create_Date_From(src.StartDate);
  res.endDate = Create_Date_From(src.EndDate);
  res.recurrenceEndType = RecurrenceEndType[src.RecurrenceEndType];
  res.pattern = RecurrencePattern[src.Pattern];
  res.dayPattern = Create_RecurrenceDayPattern_From(src.DayPattern);
  res.weekPattern = Create_RecurrenceWeekPattern_From(src.WeekPattern);
  res.monthPattern = Create_RecurrenceMonthPattern_From(src.MonthPattern);
  res.yearPattern = Create_RecurrenceYearPattern_From(src.YearPattern);
  res.dates = Create_RecurrenceDateArray_From(src.Dates);
  res.recurrenceCounter = src.RecurrenceCounter;
  res.isRecurrence = src.IsRecurrence;
  return res;
}
function Create_RecurrenceMonthPattern_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = {};
  res.cycle = src.Cycle;
  res.day = src.Day;
  res.weekday = Create_Weekday_From(src.Weekday);
  res.weekOfMonth = WeekOfMonth[src.WeekOfMonth];
  res.pattern = RecurrenceMonthlyPattern[src.Pattern];
  return res;
}
function Create_RecurrenceWeekPattern_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = {};
  res.cycle = src.Cycle;
  res.weekdays = Create_Weekday_From(src.Weekdays);
  return res;
}
function Create_RecurrenceYearPattern_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = {};
  res.cycle = src.Cycle;
  res.day = src.Day;
  res.weekday = Create_Weekday_From(src.Weekday);
  res.weekOfMonth = WeekOfMonth[src.WeekOfMonth];
  res.pattern = RecurrenceYearlyPattern[src.Pattern];
  return res;
}
function Create_SaleTypeStageLink_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.saleTypeStageLinkId = src.SaleTypeStageLinkId;
  res.saleTypeId = src.SaleTypeId;
  res.saleTypeName = src.SaleTypeName;
  res.saleTypeTooltip = src.SaleTypeTooltip;
  res.probId = src.ProbId;
  res.probName = src.ProbName;
  res.probTooltip = src.ProbTooltip;
  res.probability = src.Probability;
  return res;
}
function Create_StringDictionary_From(src) {
  let res = src;
  if (res) {
    for (let i in res) {
      res[i] = src[i];
    }
  }
  return res;
}
function Create_StringObjectDictionary_From(src) {
  let res = src;
  if (res) {
    for (let i in res) {
      res[i] = Create_Object_From(src[i]);
    }
  }
  return res;
}
function Create_StructuredAddress_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = {};
  res.atypeIdx = AddressType[src.AtypeIdx];
  res.address1 = src.Address1;
  res.address2 = src.Address2;
  res.address3 = src.Address3;
  res.city = src.City;
  res.county = src.County;
  res.state = src.State;
  res.zipcode = src.Zipcode;
  res.formatted = src.Formatted;
  return res;
}
function Create_TableRight_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = {};
  res.mask = Create_ETableRight_From(src.Mask);
  res.reason = src.Reason;
  return res;
}
function Create_TicketFormSubmission_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = {};
  res.formSubmissionId = src.FormSubmissionId;
  res.emailAddress = src.EmailAddress;
  res.status = FormSubmissionStatus[src.Status];
  return res;
}
function Create_TicketMessageHeader_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.id = src.Id;
  res.name = src.Name;
  res.value = src.Value;
  res.stdItem = MessageHeaderStdItem[src.StdItem];
  res.stdItemCol = MessageHeaderStdItemCol[src.StdItemCol];
  return res;
}
function Create_TicketMessageHeaderArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_TicketMessageHeader_From(src[i]);
    }
  }
  return res;
}
function Create_UserCandidate_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.userCandidateId = src.UserCandidateId;
  res.personId = src.PersonId;
  res.secretKey = src.SecretKey;
  res.secretValue = src.SecretValue;
  return res;
}
function Create_ApproveRejectResponse_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.pluginResponse = Create_PluginResponse_From(src.PluginResponse);
  res.createdAppointmentId = src.CreatedAppointmentId;
  return res;
}
function Create_ChangedData_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.addedRecords = Create_ChangedDataItemArray_From(src.AddedRecords);
  res.updatedRecords = Create_ChangedDataItemArray_From(src.UpdatedRecords);
  res.deletedRecords = Create_ChangedDataItemArray_From(src.DeletedRecords);
  return res;
}
function Create_ChangedDataItem_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.tablename = src.Tablename;
  res.recordId = src.RecordId;
  return res;
}
function Create_ChangedDataItemArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_ChangedDataItem_From(src[i]);
    }
  }
  return res;
}
function Create_FieldMetadata_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.fieldKey = src.FieldKey;
  res.rank = src.Rank;
  res.displayName = src.DisplayName;
  res.displayDescription = src.DisplayDescription;
  res.fieldType = FieldMetadataType[src.FieldType];
  res.listName = src.ListName;
  res.defaultValue = src.DefaultValue;
  res.maxLength = src.MaxLength;
  res.access = FieldAccess[src.Access];
  res.showInSearch = src.ShowInSearch;
  return res;
}
function Create_FieldMetadataArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_FieldMetadata_From(src[i]);
    }
  }
  return res;
}
function Create_FieldMetadataDictionary_From(src) {
  let res = src;
  if (res) {
    for (let i in res) {
      res[i] = Create_FieldMetadata_From(src[i]);
    }
  }
  return res;
}
function Create_PluginResponse_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.isOk = src.IsOk;
  res.userExplanation = src.UserExplanation;
  res.techExplanation = src.TechExplanation;
  res.errorCode = src.ErrorCode;
  res.changes = Create_ChangedData_From(src.Changes);
  res.status = QuoteStatus[src.Status];
  return res;
}
function Create_PluginResponseArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_PluginResponse_From(src[i]);
    }
  }
  return res;
}
function Create_PluginUrlResponse_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.isOk = src.IsOk;
  res.userExplanation = src.UserExplanation;
  res.techExplanation = src.TechExplanation;
  res.errorCode = src.ErrorCode;
  res.changes = Create_ChangedData_From(src.Changes);
  res.url = src.Url;
  res.status = QuoteStatus[src.Status];
  return res;
}
function Create_PriceList_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.priceListId = src.PriceListId;
  res.erpPriceListKey = src.ERPPriceListKey;
  res.quoteConnectionId = src.QuoteConnectionId;
  res.name = src.Name;
  res.description = src.Description;
  res.currency = src.Currency;
  res.currencyName = src.CurrencyName;
  res.validFrom = Create_Date_From(src.ValidFrom);
  res.validTo = Create_Date_From(src.ValidTo);
  res.isActive = src.IsActive;
  return res;
}
function Create_PriceListArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_PriceList_From(src[i]);
    }
  }
  return res;
}
function Create_Product_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.productId = src.ProductId;
  res.erpProductKey = src.ERPProductKey;
  res.erpPriceListKey = src.ERPPriceListKey;
  res.name = src.Name;
  res.description = src.Description;
  res.code = src.Code;
  res.priceUnit = src.PriceUnit;
  res.quantityUnit = src.QuantityUnit;
  res.isSubscription = src.IsSubscription;
  res.subscriptionUnit = src.SubscriptionUnit;
  res.defaultSubscriptionQuantity = src.DefaultSubscriptionQuantity;
  res.itemNumber = src.ItemNumber;
  res.url = src.Url;
  res.productCategoryKey = src.ProductCategoryKey;
  res.productFamilyKey = src.ProductFamilyKey;
  res.productTypeKey = src.ProductTypeKey;
  res.vAT = src.VAT;
  res.vATInfo = src.VATInfo;
  res.unitCost = src.UnitCost;
  res.unitMinimumPrice = src.UnitMinimumPrice;
  res.unitListPrice = src.UnitListPrice;
  res.inAssortment = src.InAssortment;
  res.supplier = src.Supplier;
  res.supplierCode = src.SupplierCode;
  res.rights = src.Rights;
  res.rule = src.Rule;
  res.extraInfo = Create_ProductExtraDataFieldArray_From(src.ExtraInfo);
  res.rawExtraInfo = src.RawExtraInfo;
  res.extraField1 = src.ExtraField1;
  res.extraField2 = src.ExtraField2;
  res.extraField3 = src.ExtraField3;
  res.extraField4 = src.ExtraField4;
  res.extraField5 = src.ExtraField5;
  res.inStock = src.InStock;
  return res;
}
function Create_ProductArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_Product_From(src[i]);
    }
  }
  return res;
}
function Create_ProductExtraDataField_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.name = src.Name;
  res.value = src.Value;
  res.type = ExtraDataFieldType[src.Type];
  return res;
}
function Create_ProductExtraDataFieldArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_ProductExtraDataField_From(src[i]);
    }
  }
  return res;
}
function Create_Quote_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.quoteId = src.QuoteId;
  res.saleId = src.SaleId;
  res.quoteConnectionId = src.QuoteConnectionId;
  res.erpQuoteKey = src.ERPQuoteKey;
  res.erpOrderKey = src.ERPOrderKey;
  res.activeQuoteVersionId = src.ActiveQuoteVersionId;
  res.acceptedQuoteAlternativeId = src.AcceptedQuoteAlternativeId;
  res.useValuesFromQuote = src.UseValuesFromQuote;
  res.documentId = src.DocumentId;
  res.poNumber = src.PoNumber;
  res.orderComment = src.OrderComment;
  res.preferredEmailCulture = src.PreferredEmailCulture;
  res.activeQuoteVersion = Create_QuoteVersion_From(src.ActiveQuoteVersion);
  res.favoriteQuoteAlternative = Create_QuoteAlternative_From(src.FavoriteQuoteAlternative);
  return res;
}
function Create_QuoteAlternative_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.quoteAlternativeId = src.QuoteAlternativeId;
  res.erpQuoteAlternativeKey = src.ERPQuoteAlternativeKey;
  res.quoteVersionId = src.QuoteVersionId;
  res.name = src.Name;
  res.description = src.Description;
  res.status = QuoteStatus[src.Status];
  res.reason = src.Reason;
  res.erpDiscountPercent = src.ERPDiscountPercent;
  res.erpDiscountAmount = src.ERPDiscountAmount;
  res.discountPercent = src.DiscountPercent;
  res.discountAmount = src.DiscountAmount;
  res.userValueOverride = ValueOverride[src.UserValueOverride];
  res.vATInfo = src.VATInfo;
  res.vAT = src.VAT;
  res.earningPercent = src.EarningPercent;
  res.earningAmount = src.EarningAmount;
  res.subTotal = src.SubTotal;
  res.totalPrice = src.TotalPrice;
  res.extraField1 = src.ExtraField1;
  res.extraField2 = src.ExtraField2;
  res.extraField3 = src.ExtraField3;
  res.extraField4 = src.ExtraField4;
  res.extraField5 = src.ExtraField5;
  return res;
}
function Create_QuoteAlternativeArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_QuoteAlternative_From(src[i]);
    }
  }
  return res;
}
function Create_QuoteAlternativeRecalculated_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.quoteLinesHasChanged = src.QuoteLinesHasChanged;
  res.changedQuoteAlternative = Create_QuoteAlternative_From(src.ChangedQuoteAlternative);
  res.changes = Create_ChangedData_From(src.Changes);
  return res;
}
function Create_QuoteAlternativeRecalculatedArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_QuoteAlternativeRecalculated_From(src[i]);
    }
  }
  return res;
}
function Create_QuoteConnection_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.quoteConnectionId = src.QuoteConnectionId;
  res.erpName = src.ERPName;
  res.displayName = src.DisplayName;
  res.displayDescription = src.DisplayDescription;
  res.rank = src.Rank;
  res.connectorName = src.ConnectorName;
  res.erpConnectionId = src.ErpConnectionId;
  res.extraData = src.ExtraData;
  res.isAvailable = src.IsAvailable;
  res.initializeResponse = Create_PluginResponse_From(src.InitializeResponse);
  res.priceLists = Create_PriceListArray_From(src.PriceLists);
  res.allAccess = src.AllAccess;
  res.deleted = src.Deleted;
  res.userGroupAccessIds = src.UserGroupAccessIds;
  res.associateAccessIds = src.AssociateAccessIds;
  return res;
}
function Create_QuoteConnectionArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_QuoteConnection_From(src[i]);
    }
  }
  return res;
}
function Create_QuoteEntity_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.quoteId = src.QuoteId;
  res.saleId = src.SaleId;
  res.quoteConnectionId = src.QuoteConnectionId;
  res.erpQuoteKey = src.ERPQuoteKey;
  res.erpOrderKey = src.ERPOrderKey;
  res.activeQuoteVersionId = src.ActiveQuoteVersionId;
  res.acceptedQuoteAlternativeId = src.AcceptedQuoteAlternativeId;
  res.useValuesFromQuote = src.UseValuesFromQuote;
  res.documentId = src.DocumentId;
  res.poNumber = src.PoNumber;
  res.orderComment = src.OrderComment;
  res.preferredEmailCulture = src.PreferredEmailCulture;
  res.quoteVersions = Create_QuoteVersionArray_From(src.QuoteVersions);
  return res;
}
function Create_QuoteLine_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.quoteLineId = src.QuoteLineId;
  res.erpQuoteLineKey = src.ERPQuoteLineKey;
  res.quoteAlternativeId = src.QuoteAlternativeId;
  res.erpProductKey = src.ERPProductKey;
  res.status = QuoteStatus[src.Status];
  res.reason = src.Reason;
  res.quantity = src.Quantity;
  res.deliveredQuantity = src.DeliveredQuantity;
  res.rank = src.Rank;
  res.name = src.Name;
  res.description = src.Description;
  res.code = src.Code;
  res.quantityUnit = src.QuantityUnit;
  res.priceUnit = src.PriceUnit;
  res.itemNumber = src.ItemNumber;
  res.url = src.Url;
  res.productCategoryKey = src.ProductCategoryKey;
  res.productFamilyKey = src.ProductFamilyKey;
  res.productTypeKey = src.ProductTypeKey;
  res.supplier = src.Supplier;
  res.supplierCode = src.SupplierCode;
  res.thumbnail = src.Thumbnail;
  res.vATInfo = src.VATInfo;
  res.vAT = src.VAT;
  res.unitCost = src.UnitCost;
  res.unitMinimumPrice = src.UnitMinimumPrice;
  res.unitListPrice = src.UnitListPrice;
  res.extraInfo = Create_ProductExtraDataFieldArray_From(src.ExtraInfo);
  res.rawExtraInfo = src.RawExtraInfo;
  res.isSubscription = src.IsSubscription;
  res.subscriptionUnit = src.SubscriptionUnit;
  res.subscriptionQuantity = src.SubscriptionQuantity;
  res.subscriptionStart = Create_Date_From(src.SubscriptionStart);
  res.erpDiscountPercent = src.ERPDiscountPercent;
  res.erpDiscountAmount = src.ERPDiscountAmount;
  res.discountPercent = src.DiscountPercent;
  res.discountAmount = src.DiscountAmount;
  res.userValueOverride = ValueOverride[src.UserValueOverride];
  res.earningPercent = src.EarningPercent;
  res.earningAmount = src.EarningAmount;
  res.subTotal = src.SubTotal;
  res.totalPrice = src.TotalPrice;
  res.rights = src.Rights;
  res.rule = src.Rule;
  res.extraField1 = src.ExtraField1;
  res.extraField2 = src.ExtraField2;
  res.extraField3 = src.ExtraField3;
  res.extraField4 = src.ExtraField4;
  res.extraField5 = src.ExtraField5;
  return res;
}
function Create_QuoteLineArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_QuoteLine_From(src[i]);
    }
  }
  return res;
}
function Create_QuoteLineConfiguration_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.quoteLineConfigurationId = src.QuoteLineConfigurationId;
  res.fieldName = src.FieldName;
  res.label = src.Label;
  res.tooltip = src.Tooltip;
  res.editable = src.Editable;
  res.inUse = src.InUse;
  res.mandatory = src.Mandatory;
  res.rank = src.Rank;
  res.restrictEdit = src.RestrictEdit;
  return res;
}
function Create_QuoteLineConfigurationArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_QuoteLineConfiguration_From(src[i]);
    }
  }
  return res;
}
function Create_QuoteListItem_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.erpQuoteListItemKey = src.ERPQuoteListItemKey;
  res.displayValue = src.DisplayValue;
  res.displayDescription = src.DisplayDescription;
  return res;
}
function Create_QuoteListItemArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_QuoteListItem_From(src[i]);
    }
  }
  return res;
}
function Create_QuotePublishDocuments_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.quoteDocumentId = src.QuoteDocumentId;
  res.quotedProductsId = src.QuotedProductsId;
  res.quoteAttachmentIds = src.QuoteAttachmentIds;
  res.mailBody = src.MailBody;
  res.mailSubject = src.MailSubject;
  res.toEmail = src.ToEmail;
  res.toFullName = src.ToFullName;
  res.errorMessage = src.ErrorMessage;
  return res;
}
function Create_QuoteVersion_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.quoteVersionId = src.QuoteVersionId;
  res.erpQuoteVersionKey = src.ERPQuoteVersionKey;
  res.quoteId = src.QuoteId;
  res.description = src.Description;
  res.number = src.Number;
  res.state = QuoteVersionState[src.State];
  res.archivedState = QuoteVersionState[src.ArchivedState];
  res.status = QuoteStatus[src.Status];
  res.reason = src.Reason;
  res.likelyQuoteAlternativeId = src.LikelyQuoteAlternativeId;
  res.sentDate = Create_Date_From(src.SentDate);
  res.followupId = src.FollowupId;
  res.expirationDate = Create_Date_From(src.ExpirationDate);
  res.deliveryCountryId = src.DeliveryCountryId;
  res.hasOwnDeliveryAddress = src.HasOwnDeliveryAddress;
  res.invoiceCountryId = src.InvoiceCountryId;
  res.hasOwnInvoiceAddress = src.HasOwnInvoiceAddress;
  res.erpPaymentTermsKey = src.ERPPaymentTermsKey;
  res.erpPaymentTypeKey = src.ERPPaymentTypeKey;
  res.erpDeliveryTermsKey = src.ERPDeliveryTermsKey;
  res.erpDeliveryTypeKey = src.ERPDeliveryTypeKey;
  res.rank = src.Rank;
  res.approvedBy = src.ApprovedBy;
  res.approvedText = src.ApprovedText;
  res.approvedRegisteredBy = src.ApprovedRegisteredBy;
  res.approvedRegisteredDate = Create_Date_From(src.ApprovedRegisteredDate);
  res.extraField1 = src.ExtraField1;
  res.extraField2 = src.ExtraField2;
  res.extraField3 = src.ExtraField3;
  res.extraField4 = src.ExtraField4;
  res.extraField5 = src.ExtraField5;
  res.lastRecalculated = Create_Date_From(src.LastRecalculated);
  res.updated = Create_Date_From(src.Updated);
  res.updatedAssociateId = src.UpdatedAssociateId;
  res.registered = Create_Date_From(src.Registered);
  res.registeredAssociateId = src.RegisteredAssociateId;
  res.requestAssociateId = src.RequestAssociateId;
  res.requestComment = src.RequestComment;
  res.quoteAlternatives = Create_QuoteAlternativeArray_From(src.QuoteAlternatives);
  return res;
}
function Create_QuoteVersionArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_QuoteVersion_From(src[i]);
    }
  }
  return res;
}
function Create_QuoteVersionAttachment_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.documentId = src.DocumentId;
  res.included = src.Included;
  return res;
}
function Create_QuoteVersionAttachmentArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_QuoteVersionAttachment_From(src[i]);
    }
  }
  return res;
}
function Create_QuoteVersionButtonState_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.action = QuoteVersionButtonAction[src.Action];
  res.imageHint = src.ImageHint;
  res.displayText = src.DisplayText;
  res.tooltipText = src.TooltipText;
  res.enabled = src.Enabled;
  return res;
}
function Create_QuoteVersionButtonStateArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_QuoteVersionButtonState_From(src[i]);
    }
  }
  return res;
}
function Create_QuoteVersionStatusInformation_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.status = QuoteStatus[src.Status];
  res.iconHint = src.IconHint;
  res.displayMessage = src.DisplayMessage;
  res.displayTooltip = src.DisplayTooltip;
  return res;
}
function Create_QuoteVersionValidated_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.isOk = src.IsOk;
  res.userExplanation = src.UserExplanation;
  res.techExplanation = src.TechExplanation;
  res.errorCode = src.ErrorCode;
  res.changedSale = Create_Sale_From(src.ChangedSale);
  res.changedQuote = Create_Quote_From(src.ChangedQuote);
  res.changedQuoteVersion = Create_QuoteVersion_From(src.ChangedQuoteVersion);
  res.changedQuoteAlternatives = Create_QuoteAlternativeRecalculatedArray_From(src.ChangedQuoteAlternatives);
  res.status = QuoteStatus[src.Status];
  return res;
}
function Create_QuoteVersionWorkflowState_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.actionButtons = Create_QuoteVersionButtonStateArray_From(src.ActionButtons);
  res.stateImage = Create_QuoteVersionButtonState_From(src.StateImage);
  res.updatePricesButton = Create_QuoteVersionButtonState_From(src.UpdatePricesButton);
  res.status = Create_QuoteVersionStatusInformation_From(src.Status);
  return res;
}
function Create_ErpConnection_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.erpConnectionId = src.ErpConnectionId;
  res.erpConnectorId = src.ErpConnectorId;
  res.displayName = src.DisplayName;
  res.displayDescription = src.DisplayDescription;
  res.active = src.Active;
  res.connectionId = src.ConnectionId;
  res.mostRecentTimestamp = src.MostRecentTimestamp;
  res.configFields = Create_StringDictionary_From(src.ConfigFields);
  res.deleted = src.Deleted;
  res.allAccess = src.AllAccess;
  res.userGroupAccessIds = src.UserGroupAccessIds;
  res.associateAccessIds = src.AssociateAccessIds;
  return res;
}
function Create_ErpConnectionArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_ErpConnection_From(src[i]);
    }
  }
  return res;
}
function Create_ErpConnectionData_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.erpConnectionId = src.ErpConnectionId;
  res.connectionName = src.ConnectionName;
  res.connected = src.Connected;
  res.erpFields = Create_FieldMetadataArray_From(src.ErpFields);
  res.crmActorType = CrmActorType[src.CrmActorType];
  res.erpActorType = ErpActorType[src.ErpActorType];
  res.erpActorTypes = Create_ErpActorType_From(src.ErpActorTypes);
  return res;
}
function Create_ErpConnectionDataArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_ErpConnectionData_From(src[i]);
    }
  }
  return res;
}
function Create_ErpConnectionListMapping_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.crmList = Create_MDOListItem_From(src.CrmList);
  res.erpListName = src.ErpListName;
  res.erpCrmListItemMappings = Create_ErpCrmListItemMappingArray_From(src.ErpCrmListItemMappings);
  res.erpActorTypeName = src.ErpActorTypeName;
  res.erpFieldId = src.ErpFieldId;
  return res;
}
function Create_ErpConnectionListMappingArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_ErpConnectionListMapping_From(src[i]);
    }
  }
  return res;
}
function Create_ErpConnectionListMappingContainer_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.erpListItemMappings = Create_ErpConnectionListMappingArray_From(src.ErpListItemMappings);
  res.erpConnectionId = src.ErpConnectionId;
  res.erpConnectionName = src.ErpConnectionName;
  return res;
}
function Create_ErpCrmListItemMapping_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.erpListItemId = src.ErpListItemId;
  res.erpListItemName = src.ErpListItemName;
  res.crmListItem = Create_MDOListItem_From(src.CrmListItem);
  return res;
}
function Create_ErpCrmListItemMappingArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_ErpCrmListItemMapping_From(src[i]);
    }
  }
  return res;
}
function Create_ErpSyncFieldValue_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.displayName = src.DisplayName;
  res.crmFieldKey = src.CrmFieldKey;
  res.value = src.Value;
  res.displayValue = src.DisplayValue;
  res.syncToCrm = src.SyncToCrm;
  res.syncToErp = src.SyncToErp;
  return res;
}
function Create_ErpSyncFieldValueArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_ErpSyncFieldValue_From(src[i]);
    }
  }
  return res;
}
function Create_ErpSyncActorTypeMapping_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.erpConnectionId = src.ErpConnectionId;
  res.isActive = src.IsActive;
  res.fieldMappings = Create_ErpSyncFieldMappingArray_From(src.FieldMappings);
  res.actorTypeErp = ErpActorType[src.ActorTypeErp];
  res.actorTypeCrm = CrmActorType[src.ActorTypeCrm];
  return res;
}
function Create_ErpSyncConnectionSummary_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.displayName = src.DisplayName;
  res.displayDescription = src.DisplayDescription;
  res.active = src.Active;
  res.deleted = src.Deleted;
  res.lastSync = Create_Date_From(src.LastSync);
  res.actors = Create_ErpSyncActorSummaryArray_From(src.Actors);
  return res;
}
function Create_ErpSyncConnectorEntity_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.erpConnectorId = src.ErpConnectorId;
  res.displayName = src.DisplayName;
  res.uRL = src.URL;
  res.deleted = src.Deleted;
  return res;
}
function Create_ErpSyncDefaultValue_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.erpFieldId = src.ErpFieldId;
  res.defaultValue = src.DefaultValue;
  res.hasFirstSyncDefaultValue = src.HasFirstSyncDefaultValue;
  res.firstSyncDefaultValue = src.FirstSyncDefaultValue;
  res.promptUser = src.PromptUser;
  res.mandatory = src.Mandatory;
  res.erpFieldKey = src.ErpFieldKey;
  res.fieldType = FieldMetadataType[src.FieldType];
  res.listName = src.ListName;
  res.access = FieldAccess[src.Access];
  return res;
}
function Create_ErpSyncEngineStatus_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.isRunning = src.IsRunning;
  res.statusMessage = src.StatusMessage;
  res.interval = Create_Duration_From(src.Interval);
  return res;
}
function Create_ErpSyncFieldMapping_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.erpFieldId = src.ErpFieldId;
  res.crmFieldKey = src.CrmFieldKey;
  res.crmDisplayName = src.CrmDisplayName;
  res.crmDisplayTooltip = src.CrmDisplayTooltip;
  res.erpFieldKey = src.ErpFieldKey;
  res.fieldType = FieldMetadataType[src.FieldType];
  res.erpDisplayName = src.ErpDisplayName;
  res.erpDisplayTooltip = src.ErpDisplayTooltip;
  res.syncToCrm = src.SyncToCrm;
  res.syncToErp = src.SyncToErp;
  res.showInGui = src.ShowInGui;
  res.showInSearch = src.ShowInSearch;
  res.alreadyMapped = src.AlreadyMapped;
  res.missingInERP = src.MissingInERP;
  res.missingInCRM = src.MissingInCRM;
  res.access = FieldAccess[src.Access];
  res.listReference = src.ListReference;
  return res;
}
function Create_ErpSyncFieldMappingArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_ErpSyncFieldMapping_From(src[i]);
    }
  }
  return res;
}
function Create_ErpSyncActorSummary_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.actorType = ErpActorType[src.ActorType];
  res.hasMappings = src.HasMappings;
  res.defaults = src.Defaults;
  res.mappings = src.Mappings;
  return res;
}
function Create_ErpSyncActorSummaryArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_ErpSyncActorSummary_From(src[i]);
    }
  }
  return res;
}
function Create_ResourceOverride_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.resourceName = src.ResourceName;
  res.resourceValue = src.ResourceValue;
  res.culture = src.Culture;
  res.isActive = src.IsActive;
  return res;
}
function Create_ResourceOverrideArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_ResourceOverride_From(src[i]);
    }
  }
  return res;
}
function Create_Contact_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.contactId = src.ContactId;
  res.name = src.Name;
  res.orgNr = src.OrgNr;
  res.department = src.Department;
  res.uRL = src.URL;
  res.city = src.City;
  res.directPhone = src.DirectPhone;
  res.associateId = src.AssociateId;
  res.countryId = src.CountryId;
  res.emailAddress = src.EmailAddress;
  res.kananame = src.Kananame;
  res.emailAddressName = src.EmailAddressName;
  res.uRLName = src.URLName;
  res.associateFullName = src.AssociateFullName;
  res.businessName = src.BusinessName;
  res.categoryName = src.CategoryName;
  res.countryName = src.CountryName;
  res.address = Create_Address_From(src.Address);
  res.formattedAddress = src.FormattedAddress;
  res.fullName = src.FullName;
  res.isOwnerContact = src.IsOwnerContact;
  res.activeErpLinks = src.ActiveErpLinks;
  res.number1 = src.Number1;
  res.number2 = src.Number2;
  return res;
}
function Create_ContactArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_Contact_From(src[i]);
    }
  }
  return res;
}
function Create_ContactActivity_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.contactId = src.ContactId;
  res.department = src.Department;
  res.orgNr = src.OrgNr;
  res.name = src.Name;
  res.uRL = src.URL;
  res.associateFullName = src.AssociateFullName;
  res.action = Create_ContactAction_From(src.Action);
  res.actionTime = Create_Date_From(src.ActionTime);
  res.category = src.Category;
  res.activityPersonName = src.ActivityPersonName;
  res.actionId = src.ActionId;
  res.personId = src.PersonId;
  res.activityPersonId = src.ActivityPersonId;
  res.associateId = src.AssociateId;
  return res;
}
function Create_ContactActivityArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_ContactActivity_From(src[i]);
    }
  }
  return res;
}
function Create_ContactEntity_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.contactId = src.ContactId;
  res.name = src.Name;
  res.department = src.Department;
  res.orgNr = src.OrgNr;
  res.number1 = src.Number1;
  res.number2 = src.Number2;
  res.updatedDate = Create_Date_From(src.UpdatedDate);
  res.createdDate = Create_Date_From(src.CreatedDate);
  res.emails = Create_EntityElementArray_From(src.Emails);
  res.interests = Create_SelectableMDOListItemArray_From(src.Interests);
  res.urls = Create_EntityElementArray_From(src.Urls);
  res.phones = Create_EntityElementArray_From(src.Phones);
  res.faxes = Create_EntityElementArray_From(src.Faxes);
  res.description = src.Description;
  res.updatedBy = Create_Associate_From(src.UpdatedBy);
  res.createdBy = Create_Associate_From(src.CreatedBy);
  res.associate = Create_Associate_From(src.Associate);
  res.business = Create_Business_From(src.Business);
  res.category = Create_Category_From(src.Category);
  res.country = Create_Country_From(src.Country);
  res.persons = Create_PersonArray_From(src.Persons);
  res.noMailing = src.NoMailing;
  res.kananame = src.Kananame;
  res.xstop = src.Xstop;
  res.activeInterests = src.ActiveInterests;
  res.groupId = src.GroupId;
  res.activeStatusMonitorId = src.ActiveStatusMonitorId;
  res.supportAssociate = Create_Associate_From(src.SupportAssociate);
  res.ticketPriority = Create_TicketPriority_From(src.TicketPriority);
  res.customerLanguage = Create_CustomerLanguage_From(src.CustomerLanguage);
  res.deleted = src.Deleted;
  res.dbiAgentId = src.DbiAgentId;
  res.dbiLastSyncronized = Create_Date_From(src.DbiLastSyncronized);
  res.dbiKey = src.DbiKey;
  res.dbiLastModified = Create_Date_From(src.DbiLastModified);
  res.supportPerson = Create_Person_From(src.SupportPerson);
  res.address = Create_Address_From(src.Address);
  res.source = src.Source;
  res.activeErpLinks = src.ActiveErpLinks;
  res.bounceEmails = src.BounceEmails;
  res.domains = src.Domains;
  res.userDefinedFields = src.UserDefinedFields;
  res.extraFields = src.ExtraFields;
  res.customFields = src.CustomFields;
  return res;
}
function Create_ContactSummary_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = {};
  res.contact = Create_Contact_From(src.Contact);
  res.tickets = Create_TicketSummaryItemArray_From(src.Tickets);
  res.followups = Create_ActivitySummaryItemArray_From(src.Followups);
  res.documents = Create_ActivitySummaryItemArray_From(src.Documents);
  res.sales = Create_SaleSummaryItemArray_From(src.Sales);
  res.chats = Create_ChatSummaryItemArray_From(src.Chats);
  return res;
}
function Create_PreviewContact_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = {};
  res.contactId = src.ContactId;
  res.name = src.Name;
  res.department = src.Department;
  res.countryId = src.CountryId;
  res.number2 = src.Number2;
  res.directPhone = src.DirectPhone;
  res.uRL = src.URL;
  res.emailAddress = src.EmailAddress;
  res.businessName = src.BusinessName;
  res.categoryName = src.CategoryName;
  res.associateFullName = src.AssociateFullName;
  res.address = Create_Address_From(src.Address);
  return res;
}
function Create_ConsentInfo_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.consentPersonId = src.ConsentPersonId;
  res.comment = src.Comment;
  res.registered = Create_Date_From(src.Registered);
  res.registeredAssociateId = src.RegisteredAssociateId;
  res.updated = Create_Date_From(src.Updated);
  res.updatedAssociateId = src.UpdatedAssociateId;
  res.legalBaseId = src.LegalBaseId;
  res.legalBaseKey = src.LegalBaseKey;
  res.legalBaseName = src.LegalBaseName;
  res.consentPurposeId = src.ConsentPurposeId;
  res.consentPurposeKey = src.ConsentPurposeKey;
  res.consentPurposeName = src.ConsentPurposeName;
  res.consentSourceId = src.ConsentSourceId;
  res.consentSourceKey = src.ConsentSourceKey;
  res.consentSourceName = src.ConsentSourceName;
  return res;
}
function Create_ConsentInfoArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_ConsentInfo_From(src[i]);
    }
  }
  return res;
}
function Create_ConsentPerson_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.consentPersonId = src.ConsentPersonId;
  res.consentSource = Create_ConsentSource_From(src.ConsentSource);
  res.legalBase = Create_LegalBase_From(src.LegalBase);
  res.personId = src.PersonId;
  res.consentPurpose = Create_ConsentPurpose_From(src.ConsentPurpose);
  res.comment = src.Comment;
  return res;
}
function Create_Person_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.position = src.Position;
  res.personId = src.PersonId;
  res.mrmrs = src.Mrmrs;
  res.firstname = src.Firstname;
  res.lastname = src.Lastname;
  res.middleName = src.MiddleName;
  res.title = src.Title;
  res.description = src.Description;
  res.email = src.Email;
  res.fullName = src.FullName;
  res.directPhone = src.DirectPhone;
  res.formalName = src.FormalName;
  res.countryId = src.CountryId;
  res.contactId = src.ContactId;
  res.contactName = src.ContactName;
  res.retired = src.Retired;
  res.rank = src.Rank;
  res.activeInterests = src.ActiveInterests;
  res.contactDepartment = src.ContactDepartment;
  res.contactCountryId = src.ContactCountryId;
  res.contactOrgNr = src.ContactOrgNr;
  res.faxPhone = src.FaxPhone;
  res.mobilePhone = src.MobilePhone;
  res.contactPhone = src.ContactPhone;
  res.associateName = src.AssociateName;
  res.associateId = src.AssociateId;
  res.usePersonAddress = src.UsePersonAddress;
  res.contactFax = src.ContactFax;
  res.kanafname = src.Kanafname;
  res.kanalname = src.Kanalname;
  res.post1 = src.Post1;
  res.post2 = src.Post2;
  res.post3 = src.Post3;
  res.emailName = src.EmailName;
  res.contactFullName = src.ContactFullName;
  res.activeErpLinks = src.ActiveErpLinks;
  res.ticketPriorityId = src.TicketPriorityId;
  res.supportLanguageId = src.SupportLanguageId;
  res.supportAssociateId = src.SupportAssociateId;
  res.categoryName = src.CategoryName;
  return res;
}
function Create_PersonArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_Person_From(src[i]);
    }
  }
  return res;
}
function Create_PersonEntity_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.personId = src.PersonId;
  res.firstname = src.Firstname;
  res.middleName = src.MiddleName;
  res.lastname = src.Lastname;
  res.mrmrs = src.Mrmrs;
  res.title = src.Title;
  res.updatedDate = Create_Date_From(src.UpdatedDate);
  res.createdDate = Create_Date_From(src.CreatedDate);
  res.birthDate = Create_BirthDate_From(src.BirthDate);
  res.createdBy = Create_Associate_From(src.CreatedBy);
  res.emails = Create_EntityElementArray_From(src.Emails);
  res.description = src.Description;
  res.isAssociate = src.IsAssociate;
  res.privatePhones = Create_EntityElementArray_From(src.PrivatePhones);
  res.faxes = Create_EntityElementArray_From(src.Faxes);
  res.mobilePhones = Create_EntityElementArray_From(src.MobilePhones);
  res.officePhones = Create_EntityElementArray_From(src.OfficePhones);
  res.otherPhones = Create_EntityElementArray_From(src.OtherPhones);
  res.position = Create_Position_From(src.Position);
  res.updatedBy = Create_Associate_From(src.UpdatedBy);
  res.contact = Create_Contact_From(src.Contact);
  res.country = Create_Country_From(src.Country);
  res.interests = Create_SelectableMDOListItemArray_From(src.Interests);
  res.personNumber = src.PersonNumber;
  res.fullName = src.FullName;
  res.noMailing = src.NoMailing;
  res.usePersonAddress = src.UsePersonAddress;
  res.retired = src.Retired;
  res.urls = Create_EntityElementArray_From(src.Urls);
  res.formalName = src.FormalName;
  res.address = Create_Address_From(src.Address);
  res.post3 = src.Post3;
  res.post2 = src.Post2;
  res.post1 = src.Post1;
  res.kanalname = src.Kanalname;
  res.kanafname = src.Kanafname;
  res.correspondingAssociate = Create_Associate_From(src.CorrespondingAssociate);
  res.category = Create_Category_From(src.Category);
  res.business = Create_Business_From(src.Business);
  res.associate = Create_Associate_From(src.Associate);
  res.salutation = src.Salutation;
  res.activeInterests = src.ActiveInterests;
  res.supportAssociate = Create_Associate_From(src.SupportAssociate);
  res.ticketPriority = Create_TicketPriority_From(src.TicketPriority);
  res.customerLanguage = Create_CustomerLanguage_From(src.CustomerLanguage);
  res.dbiAgentId = src.DbiAgentId;
  res.dbiKey = src.DbiKey;
  res.dbiLastModified = Create_Date_From(src.DbiLastModified);
  res.dbiLastSyncronized = Create_Date_From(src.DbiLastSyncronized);
  res.sentInfo = src.SentInfo;
  res.showContactTickets = src.ShowContactTickets;
  res.userInfo = Create_UserInfo_From(src.UserInfo);
  res.chatEmails = Create_EntityElementArray_From(src.ChatEmails);
  res.internetPhones = Create_EntityElementArray_From(src.InternetPhones);
  res.source = src.Source;
  res.activeErpLinks = src.ActiveErpLinks;
  res.shipmentTypes = Create_SelectableMDOListItemArray_From(src.ShipmentTypes);
  res.consents = Create_ConsentInfoArray_From(src.Consents);
  res.bounceEmails = src.BounceEmails;
  res.activeStatusMonitorId = src.ActiveStatusMonitorId;
  res.userDefinedFields = src.UserDefinedFields;
  res.extraFields = src.ExtraFields;
  res.customFields = src.CustomFields;
  return res;
}
function Create_PersonEntityArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_PersonEntity_From(src[i]);
    }
  }
  return res;
}
function Create_PersonImage_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = {};
  res.personId = src.PersonId;
  res.imageData = Create_ArrayBuffer_From(src.ImageData);
  return res;
}
function Create_PersonImageArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_PersonImage_From(src[i]);
    }
  }
  return res;
}
function Create_PersonSummary_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = {};
  res.person = Create_Person_From(src.Person);
  res.tickets = Create_TicketSummaryItemArray_From(src.Tickets);
  res.followups = Create_ActivitySummaryItemArray_From(src.Followups);
  res.documents = Create_ActivitySummaryItemArray_From(src.Documents);
  res.sales = Create_SaleSummaryItemArray_From(src.Sales);
  res.chats = Create_ChatSummaryItemArray_From(src.Chats);
  return res;
}
function Create_ResolvedPerson_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.person = Create_PersonEntity_From(src.Person);
  res.personCreated = src.PersonCreated;
  return res;
}
function Create_TemporaryKeyInfo_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.domain = TemporaryKeyDomain[src.Domain];
  res.targetId = src.TargetId;
  res.personId = src.PersonId;
  res.isExpired = src.IsExpired;
  return res;
}
function Create_Sale_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.contactName = src.ContactName;
  res.saleDate = Create_Date_From(src.SaleDate);
  res.saleId = src.SaleId;
  res.probability = src.Probability;
  res.title = src.Title;
  res.amount = src.Amount;
  res.currency = src.Currency;
  res.projectName = src.ProjectName;
  res.associateFullName = src.AssociateFullName;
  res.description = src.Description;
  res.status = SaleStatus[src.Status];
  res.weightedAmount = src.WeightedAmount;
  res.projectId = src.ProjectId;
  res.earningPercent = src.EarningPercent;
  res.earning = src.Earning;
  res.contactId = src.ContactId;
  res.associateId = src.AssociateId;
  res.personId = src.PersonId;
  res.saleTypeId = src.SaleTypeId;
  res.saleTypeName = src.SaleTypeName;
  res.personFullName = src.PersonFullName;
  res.completed = ActivityStatus[src.Completed];
  res.activeErpLinks = src.ActiveErpLinks;
  res.nextDueDate = Create_Date_From(src.NextDueDate);
  res.number = src.Number;
  return res;
}
function Create_SaleArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_Sale_From(src[i]);
    }
  }
  return res;
}
function Create_SaleEntity_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.appointment = Create_Appointment_From(src.Appointment);
  res.associate = Create_Associate_From(src.Associate);
  res.updatedBy = Create_Associate_From(src.UpdatedBy);
  res.createdBy = Create_Associate_From(src.CreatedBy);
  res.contact = Create_Contact_From(src.Contact);
  res.project = Create_Project_From(src.Project);
  res.saleText = src.SaleText;
  res.person = Create_Person_From(src.Person);
  res.currency = Create_Currency_From(src.Currency);
  res.competitor = Create_Competitor_From(src.Competitor);
  res.credited = Create_Credited_From(src.Credited);
  res.rating = Create_Rating_From(src.Rating);
  res.reason = Create_Reason_From(src.Reason);
  res.source = Create_Source_From(src.Source);
  res.status = SaleStatus[src.Status];
  res.saledate = Create_Date_From(src.Saledate);
  res.amount = src.Amount;
  res.saleId = src.SaleId;
  res.earning = src.Earning;
  res.earningPercent = src.EarningPercent;
  res.heading = src.Heading;
  res.number = src.Number;
  res.probability = src.Probability;
  res.createdDate = Create_Date_From(src.CreatedDate);
  res.updatedDate = Create_Date_From(src.UpdatedDate);
  res.completed = ActivityStatus[src.Completed];
  res.activeLinks = src.ActiveLinks;
  res.links = Create_LinkArray_From(src.Links);
  res.nextDueDate = Create_Date_From(src.NextDueDate);
  res.postit = src.Postit;
  res.saleType = Create_SaleType_From(src.SaleType);
  res.reasonSold = Create_ReasonSold_From(src.ReasonSold);
  res.reasonStalled = Create_ReasonStalled_From(src.ReasonStalled);
  res.reopenDate = Create_Date_From(src.ReopenDate);
  res.saleStakeholders = Create_SaleStakeholderArray_From(src.SaleStakeholders);
  res.activeErpLinks = src.ActiveErpLinks;
  res.userDefinedFields = src.UserDefinedFields;
  res.extraFields = src.ExtraFields;
  res.customFields = src.CustomFields;
  res.publishEventDate = Create_Date_From(src.PublishEventDate);
  res.publishTo = Create_Date_From(src.PublishTo);
  res.publishFrom = Create_Date_From(src.PublishFrom);
  res.isPublished = src.IsPublished;
  res.visibleFor = Create_VisibleForArray_From(src.VisibleFor);
  return res;
}
function Create_SaleStakeholder_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.stakeholderRoleName = src.StakeholderRoleName;
  res.comment = src.Comment;
  res.stakeholderRoleId = src.StakeholderRoleId;
  res.countryId = src.CountryId;
  res.personId = src.PersonId;
  res.emailDescription = src.EmailDescription;
  res.emailId = src.EmailId;
  res.emailAddress = src.EmailAddress;
  res.phoneId = src.PhoneId;
  res.contactName = src.ContactName;
  res.contactId = src.ContactId;
  res.saleId = src.SaleId;
  res.mrmrs = src.Mrmrs;
  res.firstname = src.Firstname;
  res.middleName = src.MiddleName;
  res.lastname = src.Lastname;
  res.saleStakeholderId = src.SaleStakeholderId;
  res.rank = src.Rank;
  res.phone = src.Phone;
  return res;
}
function Create_SaleStakeholderArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_SaleStakeholder_From(src[i]);
    }
  }
  return res;
}
function Create_SaleSummary_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.baseCurrency = src.BaseCurrency;
  res.ownCurrency = src.OwnCurrency;
  res.soldTotalBaseCurrency = src.SoldTotalBaseCurrency;
  res.sold = src.Sold;
  res.soldTotalOwnCurrency = src.SoldTotalOwnCurrency;
  res.lost = src.Lost;
  res.lostTotalBaseCurrency = src.LostTotalBaseCurrency;
  res.lostTotalOwnCurrency = src.LostTotalOwnCurrency;
  res.open = src.Open;
  res.openTotalBaseCurrency = src.OpenTotalBaseCurrency;
  res.openTotalOwnCurrency = src.OpenTotalOwnCurrency;
  res.openWeightedBaseCurrency = src.OpenWeightedBaseCurrency;
  res.openWeightedOwnCurrency = src.OpenWeightedOwnCurrency;
  res.previousOverdue = src.PreviousOverdue;
  res.previousOverdueTotalBaseCurrency = src.PreviousOverdueTotalBaseCurrency;
  res.previousOverdueTotalOwnCurrency = src.PreviousOverdueTotalOwnCurrency;
  res.previousOverdueWeightedBaseCurrency = src.PreviousOverdueWeightedBaseCurrency;
  res.previousOverdueWeightedOwnCurrency = src.PreviousOverdueWeightedOwnCurrency;
  res.currentOverdue = src.CurrentOverdue;
  res.currentOverdueTotalBaseCurrency = src.CurrentOverdueTotalBaseCurrency;
  res.currentOverdueTotalOwnCurrency = src.CurrentOverdueTotalOwnCurrency;
  res.currentOverdueWeightedBaseCurrency = src.CurrentOverdueWeightedBaseCurrency;
  res.currentOverdueWeightedOwnCurrency = src.CurrentOverdueWeightedOwnCurrency;
  res.futureOpen = src.FutureOpen;
  res.futureOpenTotalBaseCurrency = src.FutureOpenTotalBaseCurrency;
  res.futureOpenTotalOwnCurrency = src.FutureOpenTotalOwnCurrency;
  res.futureOpenWeightedBaseCurrency = src.FutureOpenWeightedBaseCurrency;
  res.futureOpenWeightedOwnCurrency = src.FutureOpenWeightedOwnCurrency;
  return res;
}
function Create_SaleSummaryItem_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = {};
  res.saleId = src.SaleId;
  res.saleDate = Create_Date_From(src.SaleDate);
  res.probability = src.Probability;
  res.heading = src.Heading;
  res.amount = src.Amount;
  res.currency = src.Currency;
  res.amountInBaseCurrency = src.AmountInBaseCurrency;
  res.status = SaleStatus[src.Status];
  res.completed = ActivityStatus[src.Completed];
  res.registered = Create_Date_From(src.Registered);
  return res;
}
function Create_SaleSummaryItemArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_SaleSummaryItem_From(src[i]);
    }
  }
  return res;
}
function Create_PhoneListItem_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.personDirectPhone = src.PersonDirectPhone;
  res.personCellPhone = src.PersonCellPhone;
  res.personPrivatePhone = src.PersonPrivatePhone;
  res.personFaxNumber = src.PersonFaxNumber;
  res.personPagerNumber = src.PersonPagerNumber;
  res.personEmail = src.PersonEmail;
  res.id = src.Id;
  res.name = src.Name;
  res.tooltip = src.Tooltip;
  res.uniqueId = src.UniqueId;
  return res;
}
function Create_PhoneListItemArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_PhoneListItem_From(src[i]);
    }
  }
  return res;
}
function Create_PhoneListPreferences_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.searchCompany = src.SearchCompany;
  res.searchFirstname = src.SearchFirstname;
  res.searchLastname = src.SearchLastname;
  res.searchDepartment = src.SearchDepartment;
  res.searchModeCompany = StringSearchType[src.SearchModeCompany];
  res.searchModeDepartment = StringSearchType[src.SearchModeDepartment];
  res.searchModeFirstname = StringSearchType[src.SearchModeFirstname];
  res.searchModeLastname = StringSearchType[src.SearchModeLastname];
  return res;
}
function Create_Project_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.projectId = src.ProjectId;
  res.name = src.Name;
  res.description = src.Description;
  res.uRL = src.URL;
  res.type = src.Type;
  res.associateId = src.AssociateId;
  res.associateFullName = src.AssociateFullName;
  res.typeId = src.TypeId;
  res.updated = Create_Date_From(src.Updated);
  res.statusId = src.StatusId;
  res.status = src.Status;
  res.textId = src.TextId;
  res.publishTo = Create_Date_From(src.PublishTo);
  res.publishFrom = Create_Date_From(src.PublishFrom);
  res.isPublished = src.IsPublished;
  res.uRLName = src.URLName;
  res.projectNumber = src.ProjectNumber;
  res.activeErpLinks = src.ActiveErpLinks;
  return res;
}
function Create_ProjectArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_Project_From(src[i]);
    }
  }
  return res;
}
function Create_ProjectEntity_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.projectId = src.ProjectId;
  res.name = src.Name;
  res.projectNumber = src.ProjectNumber;
  res.projectMembers = Create_ProjectMemberArray_From(src.ProjectMembers);
  res.urls = Create_EntityElementArray_From(src.Urls);
  res.createdDate = Create_Date_From(src.CreatedDate);
  res.updatedDate = Create_Date_From(src.UpdatedDate);
  res.description = src.Description;
  res.postit = src.Postit;
  res.createdBy = Create_Associate_From(src.CreatedBy);
  res.updatedBy = Create_Associate_From(src.UpdatedBy);
  res.associate = Create_Associate_From(src.Associate);
  res.projectStatus = Create_ProjectStatus_From(src.ProjectStatus);
  res.projectType = Create_ProjectType_From(src.ProjectType);
  res.hasImage = src.HasImage;
  res.imageDescription = src.ImageDescription;
  res.activeStatusMonitorId = src.ActiveStatusMonitorId;
  res.links = Create_LinkArray_From(src.Links);
  res.activeLinks = src.ActiveLinks;
  res.completed = src.Completed;
  res.nextMilestoneDate = Create_Date_From(src.NextMilestoneDate);
  res.nmdAppointmentId = src.NmdAppointmentId;
  res.endDate = Create_Date_From(src.EndDate);
  res.activeErpLinks = src.ActiveErpLinks;
  res.userDefinedFields = src.UserDefinedFields;
  res.extraFields = src.ExtraFields;
  res.customFields = src.CustomFields;
  res.publishEventDate = Create_Date_From(src.PublishEventDate);
  res.publishTo = Create_Date_From(src.PublishTo);
  res.publishFrom = Create_Date_From(src.PublishFrom);
  res.isPublished = src.IsPublished;
  return res;
}
function Create_ProjectEvent_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.associateFullName = src.AssociateFullName;
  res.description = src.Description;
  res.projectId = src.ProjectId;
  res.eventName = src.EventName;
  res.associateId = src.AssociateId;
  res.isSignedOn = src.IsSignedOn;
  res.signOffConfirmationText = src.SignOffConfirmationText;
  res.signOffText = src.SignOffText;
  res.signOnConfirmationText = src.SignOnConfirmationText;
  res.signOnText = src.SignOnText;
  res.eventDate = Create_Date_From(src.EventDate);
  res.enabled = src.Enabled;
  res.signOff = src.SignOff;
  res.signOffTaskEnable = src.SignOffTaskEnable;
  res.signOnTaskEnable = src.SignOnTaskEnable;
  res.signOn = src.SignOn;
  res.signOffTaskId = src.SignOffTaskId;
  res.signOnTaskId = src.SignOnTaskId;
  res.signOffTriggersAssign = src.SignOffTriggersAssign;
  res.signOnTriggersAssign = src.SignOnTriggersAssign;
  res.signOnPersonId = src.SignOnPersonId;
  res.signOffPersonId = src.SignOffPersonId;
  return res;
}
function Create_ProjectEventArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_ProjectEvent_From(src[i]);
    }
  }
  return res;
}
function Create_ProjectEventEntity_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.signOffConfirmationText = src.SignOffConfirmationText;
  res.signOffText = src.SignOffText;
  res.signOnConfirmationText = src.SignOnConfirmationText;
  res.signOnText = src.SignOnText;
  res.eventDate = Create_Date_From(src.EventDate);
  res.enabled = src.Enabled;
  res.createdDate = Create_Date_From(src.CreatedDate);
  res.signOff = src.SignOff;
  res.signOffTaskEnable = src.SignOffTaskEnable;
  res.signOffTaskId = src.SignOffTaskId;
  res.signOffTriggersAssign = src.SignOffTriggersAssign;
  res.signOn = src.SignOn;
  res.signOnTaskEnable = src.SignOnTaskEnable;
  res.signOnTaskId = src.SignOnTaskId;
  res.signOnTriggersAssign = src.SignOnTriggersAssign;
  res.updatedDate = Create_Date_From(src.UpdatedDate);
  res.createdBy = Create_Associate_From(src.CreatedBy);
  res.updatedBy = Create_Associate_From(src.UpdatedBy);
  res.projectId = src.ProjectId;
  res.id = src.Id;
  res.publishFrom = Create_Date_From(src.PublishFrom);
  res.publishType = PublishType[src.PublishType];
  res.publishTo = Create_Date_From(src.PublishTo);
  res.visibleForCategories = Create_MDOListItemArray_From(src.VisibleForCategories);
  res.visibleForPersonInterests = Create_MDOListItemArray_From(src.VisibleForPersonInterests);
  res.isPublished = src.IsPublished;
  res.isVisibleForMembers = src.IsVisibleForMembers;
  res.isVisibleForCategories = src.IsVisibleForCategories;
  res.isVisibleForPersonInterests = src.IsVisibleForPersonInterests;
  res.projectEventId = src.ProjectEventId;
  return res;
}
function Create_ProjectMember_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.projectmemberId = src.ProjectmemberId;
  res.contactId = src.ContactId;
  res.projectId = src.ProjectId;
  res.contactName = src.ContactName;
  res.contactDepartment = src.ContactDepartment;
  res.projectName = src.ProjectName;
  res.emailId = src.EmailId;
  res.emailAddress = src.EmailAddress;
  res.countryId = src.CountryId;
  res.firstname = src.Firstname;
  res.middleName = src.MiddleName;
  res.lastname = src.Lastname;
  res.personId = src.PersonId;
  res.mrmrs = src.Mrmrs;
  res.projectMemberTypeName = src.ProjectMemberTypeName;
  res.phone = src.Phone;
  res.phoneId = src.PhoneId;
  res.projectMemberTypeId = src.ProjectMemberTypeId;
  res.emailAddressName = src.EmailAddressName;
  res.comment = src.Comment;
  res.fullName = src.FullName;
  return res;
}
function Create_ProjectMemberArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_ProjectMember_From(src[i]);
    }
  }
  return res;
}
function Create_ActivityInformationListItem_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.date = Create_Date_From(src.Date);
  res.activityInformation = Create_ActivitySummary_From(src.ActivityInformation);
  return res;
}
function Create_ActivityInformationListItemArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_ActivityInformationListItem_From(src[i]);
    }
  }
  return res;
}
function Create_ActivitySummary_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.numBusyActivities = src.NumBusyActivities;
  res.numFreeActivities = src.NumFreeActivities;
  res.percentageBusy = src.PercentageBusy;
  return res;
}
function Create_ActivitySummaryItem_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = {};
  res.appointmentId = src.AppointmentId;
  res.documentId = src.DocumentId;
  res.date = Create_Date_From(src.Date);
  res.description = src.Description;
  res.completed = ActivityStatus[src.Completed];
  res.registered = Create_Date_From(src.Registered);
  return res;
}
function Create_ActivitySummaryItemArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_ActivitySummaryItem_From(src[i]);
    }
  }
  return res;
}
function Create_AddressSyncData_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.addressId = src.AddressId;
  res.addressType = AddressType[src.AddressType];
  res.address1 = src.Address1;
  res.address2 = src.Address2;
  res.address3 = src.Address3;
  res.city = src.City;
  res.county = src.County;
  res.zipCode = src.ZipCode;
  res.state = src.State;
  res.latitude = src.Latitude;
  res.longitude = src.Longitude;
  res.formattedAddress = src.FormattedAddress;
  return res;
}
function Create_AlarmData_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.appointmentId = src.AppointmentId;
  res.startTime = Create_Date_From(src.StartTime);
  res.endDate = Create_Date_From(src.EndDate);
  res.alarmTime = Create_Date_From(src.AlarmTime);
  res.personId = src.PersonId;
  res.personFullName = src.PersonFullName;
  res.contactName = src.ContactName;
  res.projectId = src.ProjectId;
  res.projectName = src.ProjectName;
  res.appointmentText = src.AppointmentText;
  res.saleId = src.SaleId;
  res.saleName = src.SaleName;
  res.location = src.Location;
  res.appointmentType = AppointmentType[src.AppointmentType];
  res.contactId = src.ContactId;
  res.assignmentStatus = AssignmentStatus[src.AssignmentStatus];
  res.invitationStatus = InvitationStatus[src.InvitationStatus];
  res.bookingType = BookingType[src.BookingType];
  res.formalName = src.FormalName;
  res.taskName = src.TaskName;
  res.contactDepartment = src.ContactDepartment;
  res.contactFullName = src.ContactFullName;
  res.joinVideomeetUrl = src.JoinVideomeetUrl;
  return res;
}
function Create_AlarmDataArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_AlarmData_From(src[i]);
    }
  }
  return res;
}
function Create_Appointment_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.appointmentId = src.AppointmentId;
  res.startDate = Create_Date_From(src.StartDate);
  res.endDate = Create_Date_From(src.EndDate);
  res.type = AppointmentType[src.Type];
  res.task = src.Task;
  res.associateFullName = src.AssociateFullName;
  res.contactName = src.ContactName;
  res.description = src.Description;
  res.personFullName = src.PersonFullName;
  res.personId = src.PersonId;
  res.contactId = src.ContactId;
  res.projectId = src.ProjectId;
  res.projectName = src.ProjectName;
  res.isPublished = src.IsPublished;
  res.associateId = src.AssociateId;
  res.colorIndex = src.ColorIndex;
  res.isFree = src.IsFree;
  res.hasAlarm = src.HasAlarm;
  res.isAlldayEvent = src.IsAlldayEvent;
  res.private = AppointmentPrivate[src.Private];
  res.priorityId = src.PriorityId;
  res.priorityName = src.PriorityName;
  res.taskType = TaskType[src.TaskType];
  res.isBookingMain = src.IsBookingMain;
  res.isRecurrence = src.IsRecurrence;
  res.isBooking = src.IsBooking;
  res.activeDate = Create_Date_From(src.ActiveDate);
  res.assignmentStatus = AssignmentStatus[src.AssignmentStatus];
  res.invitationStatus = InvitationStatus[src.InvitationStatus];
  res.bookingType = BookingType[src.BookingType];
  res.completed = ActivityStatus[src.Completed];
  res.recurringPattern = RecurrencePattern[src.RecurringPattern];
  res.recurringStartDate = Create_Date_From(src.RecurringStartDate);
  res.recurringEndDate = Create_Date_From(src.RecurringEndDate);
  res.motherId = src.MotherId;
  res.assignedBy = src.AssignedBy;
  res.assignedByFullName = src.AssignedByFullName;
  res.rejectReason = src.RejectReason;
  res.location = src.Location;
  res.alarmLeadTime = Create_Duration_From(src.AlarmLeadTime);
  res.saleId = src.SaleId;
  res.saleName = src.SaleName;
  res.associateName = src.AssociateName;
  res.createdDate = Create_Date_From(src.CreatedDate);
  res.createdBy = src.CreatedBy;
  res.createdByFullName = src.CreatedByFullName;
  res.createdByAssociateId = src.CreatedByAssociateId;
  res.cautionWarning = AppointmentCautionWarning[src.CautionWarning];
  res.joinVideomeetUrl = src.JoinVideomeetUrl;
  res.title = src.Title;
  res.agenda = src.Agenda;
  res.internalNotes = src.InternalNotes;
  return res;
}
function Create_AppointmentArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_Appointment_From(src[i]);
    }
  }
  return res;
}
function Create_AppointmentEntity_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.associate = Create_Associate_From(src.Associate);
  res.contact = Create_Contact_From(src.Contact);
  res.createdBy = Create_Associate_From(src.CreatedBy);
  res.updatedBy = Create_Associate_From(src.UpdatedBy);
  res.createdDate = Create_Date_From(src.CreatedDate);
  res.appointmentId = src.AppointmentId;
  res.description = src.Description;
  res.startDate = Create_Date_From(src.StartDate);
  res.endDate = Create_Date_From(src.EndDate);
  res.invitedPerson = Create_Person_From(src.InvitedPerson);
  res.person = Create_Person_From(src.Person);
  res.motherId = src.MotherId;
  res.priority = Create_Priority_From(src.Priority);
  res.private = AppointmentPrivate[src.Private];
  res.project = Create_Project_From(src.Project);
  res.type = AppointmentType[src.Type];
  res.updatedDate = Create_Date_From(src.UpdatedDate);
  res.completed = ActivityStatus[src.Completed];
  res.activeLinks = src.ActiveLinks;
  res.links = Create_LinkArray_From(src.Links);
  res.alarmLeadTime = Create_Duration_From(src.AlarmLeadTime);
  res.hasAlarm = src.HasAlarm;
  res.colorIndex = src.ColorIndex;
  res.isFree = src.IsFree;
  res.isAlldayEvent = src.IsAlldayEvent;
  res.lagTime = Create_Duration_From(src.LagTime);
  res.leadTime = Create_Duration_From(src.LeadTime);
  res.location = src.Location;
  res.rejectCounter = src.RejectCounter;
  res.rejectReason = src.RejectReason;
  res.recurrence = Create_RecurrenceInfo_From(src.Recurrence);
  res.participants = Create_ParticipantInfoArray_From(src.Participants);
  res.assignmentStatus = AssignmentStatus[src.AssignmentStatus];
  res.invitationStatus = InvitationStatus[src.InvitationStatus];
  res.bookingType = BookingType[src.BookingType];
  res.activeDate = Create_Date_From(src.ActiveDate);
  res.hasConflict = src.HasConflict;
  res.assignedBy = Create_Associate_From(src.AssignedBy);
  res.motherAssociate = Create_Associate_From(src.MotherAssociate);
  res.task = Create_TaskListItem_From(src.Task);
  res.preferredTZLocation = src.PreferredTZLocation;
  res.sale = Create_Sale_From(src.Sale);
  res.suggestedAppointmentId = src.SuggestedAppointmentId;
  res.isMileStone = src.IsMileStone;
  res.cautionWarning = AppointmentCautionWarning[src.CautionWarning];
  res.joinVideomeetUrl = src.JoinVideomeetUrl;
  res.centralserviceVideomeetId = src.CentralserviceVideomeetId;
  res.title = src.Title;
  res.agenda = src.Agenda;
  res.internalNotes = src.InternalNotes;
  res.userDefinedFields = src.UserDefinedFields;
  res.extraFields = src.ExtraFields;
  res.customFields = src.CustomFields;
  res.publishEventDate = Create_Date_From(src.PublishEventDate);
  res.publishTo = Create_Date_From(src.PublishTo);
  res.publishFrom = Create_Date_From(src.PublishFrom);
  res.isPublished = src.IsPublished;
  res.visibleFor = Create_VisibleForArray_From(src.VisibleFor);
  return res;
}
function Create_AppointmentSyncData_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.alarmTime = Create_Date_From(src.AlarmTime);
  res.appointmentId = src.AppointmentId;
  res.appointmentText = src.AppointmentText;
  res.contactDepartment = src.ContactDepartment;
  res.contactFullName = src.ContactFullName;
  res.contactName = src.ContactName;
  res.contactId = src.ContactId;
  res.endDate = Create_Date_From(src.EndDate);
  res.hasAlarm = src.HasAlarm;
  res.isAllDay = src.IsAllDay;
  res.isAssignment = src.IsAssignment;
  res.isBusy = src.IsBusy;
  res.isCompleted = src.IsCompleted;
  res.isInvitation = src.IsInvitation;
  res.isTentative = src.IsTentative;
  res.location = src.Location;
  res.participants = Create_ParticipantSyncDataArray_From(src.Participants);
  res.personFormalName = src.PersonFormalName;
  res.personFullName = src.PersonFullName;
  res.personId = src.PersonId;
  res.projectId = src.ProjectId;
  res.projectName = src.ProjectName;
  res.saleId = src.SaleId;
  res.saleName = src.SaleName;
  res.startDate = Create_Date_From(src.StartDate);
  res.taskName = src.TaskName;
  return res;
}
function Create_AppointmentSyncDataArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_AppointmentSyncData_From(src[i]);
    }
  }
  return res;
}
function Create_DayInformationListItem_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.activityInformation = Create_ActivitySummary_From(src.ActivityInformation);
  res.redLetterInformation = Create_RedLetterSummary_From(src.RedLetterInformation);
  res.date = Create_Date_From(src.Date);
  return res;
}
function Create_DayInformationListItemArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_DayInformationListItem_From(src[i]);
    }
  }
  return res;
}
function Create_MultiAlarmData_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.alarms = Create_AlarmDataArray_From(src.Alarms);
  res.pollingInterval = src.PollingInterval;
  res.silentAfter = src.SilentAfter;
  return res;
}
function Create_ParticipantInfo_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = {};
  res.associateId = src.AssociateId;
  res.personId = src.PersonId;
  res.contactId = src.ContactId;
  res.emailId = src.EmailId;
  res.sendEmail = src.SendEmail;
  res.invitationStatus = InvitationStatus[src.InvitationStatus];
  return res;
}
function Create_ParticipantInfoArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_ParticipantInfo_From(src[i]);
    }
  }
  return res;
}
function Create_ParticipantSyncData_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.personId = src.PersonId;
  res.personFirstName = src.PersonFirstName;
  res.personMiddleName = src.PersonMiddleName;
  res.personLastname = src.PersonLastname;
  res.personMrmrs = src.PersonMrmrs;
  res.personTitle = src.PersonTitle;
  res.personPosition = src.PersonPosition;
  res.personAcademicTitle = src.PersonAcademicTitle;
  res.personFormalName = src.PersonFormalName;
  res.personFullName = src.PersonFullName;
  res.contactId = src.ContactId;
  res.contactName = src.ContactName;
  res.contactDepartment = src.ContactDepartment;
  res.contactBusiness = src.ContactBusiness;
  res.contactCountry = src.ContactCountry;
  res.contactCategory = src.ContactCategory;
  res.contactFullName = src.ContactFullName;
  res.eMail = src.EMail;
  res.phonePrivate = src.PhonePrivate;
  res.phoneFax = src.PhoneFax;
  res.phoneMobile = src.PhoneMobile;
  res.phoneDirect = src.PhoneDirect;
  res.phoneContact = src.PhoneContact;
  res.messenger = src.Messenger;
  res.voip = src.Voip;
  res.contactUrl = src.ContactUrl;
  res.url = src.Url;
  res.streetAddress = Create_AddressSyncData_From(src.StreetAddress);
  res.postalAddress = Create_AddressSyncData_From(src.PostalAddress);
  res.country = src.Country;
  res.personAddress = Create_AddressSyncData_From(src.PersonAddress);
  res.personCountry = src.PersonCountry;
  res.participantStatus = AppointmentStatus[src.ParticipantStatus];
  return res;
}
function Create_ParticipantSyncDataArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_ParticipantSyncData_From(src[i]);
    }
  }
  return res;
}
function Create_RedLetterDetails_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.ownCountryDayTexts = src.OwnCountryDayTexts;
  res.otherCountryDayTexts = src.OtherCountryDayTexts;
  return res;
}
function Create_RedLetterInformationListItem_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.date = Create_Date_From(src.Date);
  res.redLetterInformation = Create_RedLetterSummary_From(src.RedLetterInformation);
  res.redLetterDetails = Create_RedLetterDetails_From(src.RedLetterDetails);
  return res;
}
function Create_RedLetterInformationListItemArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_RedLetterInformationListItem_From(src[i]);
    }
  }
  return res;
}
function Create_RedLetterSummary_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.isOwnCountryHoliday = src.IsOwnCountryHoliday;
  res.isOtherCountryHoliday = src.IsOtherCountryHoliday;
  return res;
}
function Create_SalesActivity_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.requestedContacts = Create_ContactArray_From(src.RequestedContacts);
  res.requestedPerson = Create_Person_From(src.RequestedPerson);
  res.salesRep = Create_Person_From(src.SalesRep);
  return res;
}
function Create_SuggestedAppointment_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.autoSuggest = src.AutoSuggest;
  res.deleted = src.Deleted;
  res.daysFuture = src.DaysFuture;
  res.tooltip = src.Tooltip;
  res.text = src.Text;
  res.taskId = src.TaskId;
  res.suggestedAppointmentId = src.SuggestedAppointmentId;
  res.saleTypeStageLinkId = src.SaleTypeStageLinkId;
  res.registeredAssociateId = src.RegisteredAssociateId;
  res.rank = src.Rank;
  res.projectTypeStatusLinkId = src.ProjectTypeStatusLinkId;
  res.name = src.Name;
  res.duration = src.Duration;
  res.associate = Create_Associate_From(src.Associate);
  return res;
}
function Create_SuggestedAppointmentEntity_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.suggestedAppointmentId = src.SuggestedAppointmentId;
  res.name = src.Name;
  res.tooltip = src.Tooltip;
  res.rank = src.Rank;
  res.deleted = src.Deleted;
  res.daysFuture = src.DaysFuture;
  res.duration = Create_Duration_From(src.Duration);
  res.autoSuggest = src.AutoSuggest;
  res.isMilestone = src.IsMilestone;
  res.assignToMember = src.AssignToMember;
  res.text = src.Text;
  res.projectTypeStatusLink = Create_ProjectTypeStatusLink_From(src.ProjectTypeStatusLink);
  res.saleTypeStageLink = Create_SaleTypeStageLink_From(src.SaleTypeStageLink);
  res.type = Create_Task_From(src.Type);
  return res;
}
function Create_TaskListItem_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.taskListItemId = src.TaskListItemId;
  res.value = src.Value;
  res.direction = TaskDirection[src.Direction];
  res.type = TaskType[src.Type];
  res.tooltip = src.Tooltip;
  res.deleted = src.Deleted;
  res.intentId = src.IntentId;
  res.rank = src.Rank;
  res.isDefaultAlldayEvent = src.IsDefaultAlldayEvent;
  res.isDefaultFree = src.IsDefaultFree;
  res.isDefaultPublished = src.IsDefaultPublished;
  res.colorIndex = ColorIndex[src.ColorIndex];
  res.defaultVideomeetingStatus = VideoMeetingStatus[src.DefaultVideomeetingStatus];
  return res;
}
function Create_TaskListItemArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_TaskListItem_From(src[i]);
    }
  }
  return res;
}
function Create_ForeignAppEntity_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.foreignAppId = src.ForeignAppId;
  res.name = src.Name;
  res.createdDate = Create_Date_From(src.CreatedDate);
  res.updatedDate = Create_Date_From(src.UpdatedDate);
  res.createdBy = Create_Associate_From(src.CreatedBy);
  res.updatedBy = Create_Associate_From(src.UpdatedBy);
  res.devices = Create_ForeignDeviceArray_From(src.Devices);
  return res;
}
function Create_ForeignDevice_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.foreignDeviceId = src.ForeignDeviceId;
  res.name = src.Name;
  res.createdDate = Create_Date_From(src.CreatedDate);
  res.updatedDate = Create_Date_From(src.UpdatedDate);
  res.associateFullName = src.AssociateFullName;
  res.createdBy = src.CreatedBy;
  res.updatedBy = src.UpdatedBy;
  res.deviceIdentifier = src.DeviceIdentifier;
  res.foreignAppId = src.ForeignAppId;
  return res;
}
function Create_ForeignDeviceArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_ForeignDevice_From(src[i]);
    }
  }
  return res;
}
function Create_ForeignKey_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.key = src.Key;
  res.value = src.Value;
  res.recordId = src.RecordId;
  res.createdDate = Create_Date_From(src.CreatedDate);
  res.updatedDate = Create_Date_From(src.UpdatedDate);
  res.updatedBy = src.UpdatedBy;
  res.createdBy = src.CreatedBy;
  res.tableName = src.TableName;
  return res;
}
function Create_ForeignKeyArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_ForeignKey_From(src[i]);
    }
  }
  return res;
}
function Create_CheckoutInfo_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = {};
  res.state = CheckoutState[src.State];
  res.associateId = src.AssociateId;
  res.name = src.Name;
  return res;
}
function Create_CommandInfo_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = {};
  res.name = src.Name;
  res.displayName = src.DisplayName;
  res.displayTooltip = src.DisplayTooltip;
  res.iconHint = src.IconHint;
  res.returnType = ReturnType[src.ReturnType];
  return res;
}
function Create_CommandInfoArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_CommandInfo_From(src[i]);
    }
  }
  return res;
}
function Create_Document_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.documentId = src.DocumentId;
  res.attention = src.Attention;
  res.header = src.Header;
  res.name = src.Name;
  res.ourRef = src.OurRef;
  res.yourRef = src.YourRef;
  res.description = src.Description;
  res.documentTemplate = src.DocumentTemplate;
  res.isPublished = src.IsPublished;
  res.personId = src.PersonId;
  res.personFullName = src.PersonFullName;
  res.associateFullName = src.AssociateFullName;
  res.contactId = src.ContactId;
  res.contactName = src.ContactName;
  res.projectId = src.ProjectId;
  res.projectName = src.ProjectName;
  res.associateId = src.AssociateId;
  res.snum = src.Snum;
  res.saleId = src.SaleId;
  res.saleName = src.SaleName;
  return res;
}
function Create_DocumentArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_Document_From(src[i]);
    }
  }
  return res;
}
function Create_DocumentEntity_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.documentId = src.DocumentId;
  res.updatedBy = Create_Associate_From(src.UpdatedBy);
  res.createdBy = Create_Associate_From(src.CreatedBy);
  res.attention = src.Attention;
  res.header = src.Header;
  res.name = src.Name;
  res.ourRef = src.OurRef;
  res.yourRef = src.YourRef;
  res.createdDate = Create_Date_From(src.CreatedDate);
  res.updatedDate = Create_Date_From(src.UpdatedDate);
  res.description = src.Description;
  res.documentTemplate = Create_DocumentTemplate_From(src.DocumentTemplate);
  res.person = Create_Person_From(src.Person);
  res.associate = Create_Associate_From(src.Associate);
  res.contact = Create_Contact_From(src.Contact);
  res.project = Create_Project_From(src.Project);
  res.date = Create_Date_From(src.Date);
  res.externalRef = src.ExternalRef;
  res.completed = ActivityStatus[src.Completed];
  res.activeLinks = src.ActiveLinks;
  res.type = AppointmentType[src.Type];
  res.links = Create_LinkArray_From(src.Links);
  res.lockSemantics = DocumentLockSemantics[src.LockSemantics];
  res.sale = Create_Sale_From(src.Sale);
  res.suggestedDocumentId = src.SuggestedDocumentId;
  res.snum = src.Snum;
  res.userDefinedFields = src.UserDefinedFields;
  res.extraFields = src.ExtraFields;
  res.customFields = src.CustomFields;
  res.publishEventDate = Create_Date_From(src.PublishEventDate);
  res.publishTo = Create_Date_From(src.PublishTo);
  res.publishFrom = Create_Date_From(src.PublishFrom);
  res.isPublished = src.IsPublished;
  res.visibleFor = Create_VisibleForArray_From(src.VisibleFor);
  return res;
}
function Create_DocumentPreview_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.name = src.Name;
  res.type = src.Type;
  res.size = src.Size;
  res.stream = Create_ArrayBuffer_From(src.Stream);
  return res;
}
function Create_ReturnInfo_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = {};
  res.externalReference = src.ExternalReference;
  res.versionId = src.VersionId;
  res.success = src.Success;
  res.type = ReturnType[src.Type];
  res.value = src.Value;
  res.additionalInfo = src.AdditionalInfo;
  return res;
}
function Create_SuggestedDocumentEntity_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.suggestedDocumentId = src.SuggestedDocumentId;
  res.name = src.Name;
  res.tooltip = src.Tooltip;
  res.rank = src.Rank;
  res.doctmplId = src.DoctmplId;
  res.header = src.Header;
  res.ourRef = src.OurRef;
  res.deleted = src.Deleted;
  res.docTmpl = Create_DocumentTemplate_From(src.DocTmpl);
  res.projectTypeStatusLink = Create_ProjectTypeStatusLink_From(src.ProjectTypeStatusLink);
  res.saleTypeStageLink = Create_SaleTypeStageLink_From(src.SaleTypeStageLink);
  return res;
}
function Create_TemplateInfo_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = {};
  res.name = src.Name;
  res.description = src.Description;
  res.externalReference = src.ExternalReference;
  res.pluginId = src.PluginId;
  return res;
}
function Create_TemplateVariablesParameters_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.sourceInput = src.SourceInput;
  res.encoding = GeneratorEncoding[src.Encoding];
  res.cultureName = src.CultureName;
  res.contactId = src.ContactId;
  res.personId = src.PersonId;
  res.projectId = src.ProjectId;
  res.selectionId = src.SelectionId;
  res.appointmentId = src.AppointmentId;
  res.documentId = src.DocumentId;
  res.saleId = src.SaleId;
  res.quoteLineId = src.QuoteLineId;
  res.quoteAlternativeId = src.QuoteAlternativeId;
  res.productKey = src.ProductKey;
  res.customTags = src.CustomTags;
  res.ticketId = src.TicketId;
  res.documentEntity = Create_DocumentEntity_From(src.DocumentEntity);
  return res;
}
function Create_VersionInfo_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = {};
  res.externalReference = src.ExternalReference;
  res.documentId = src.DocumentId;
  res.versionId = src.VersionId;
  res.checkedInDate = Create_Date_From(src.CheckedInDate);
  res.checkedInByName = src.CheckedInByName;
  res.checkedInByAssociateId = src.CheckedInByAssociateId;
  res.description = src.Description;
  res.displayText = src.DisplayText;
  res.extraFields = src.ExtraFields;
  return res;
}
function Create_VersionInfoArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_VersionInfo_From(src[i]);
    }
  }
  return res;
}
function Create_AmountClassEntity_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.amountClassId = src.AmountClassId;
  res.name = src.Name;
  res.tooltip = src.Tooltip;
  res.rank = src.Rank;
  res.amountFrom = src.AmountFrom;
  res.amountTo = src.AmountTo;
  res.deleted = src.Deleted;
  res.currencyId = src.CurrencyId;
  return res;
}
function Create_Business_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.id = src.Id;
  res.value = src.Value;
  res.tooltip = src.Tooltip;
  return res;
}
function Create_BusinessArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_Business_From(src[i]);
    }
  }
  return res;
}
function Create_Category_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.id = src.Id;
  res.value = src.Value;
  res.tooltip = src.Tooltip;
  return res;
}
function Create_CategoryArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_Category_From(src[i]);
    }
  }
  return res;
}
function Create_Competitor_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.id = src.Id;
  res.value = src.Value;
  res.tooltip = src.Tooltip;
  return res;
}
function Create_CompetitorArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_Competitor_From(src[i]);
    }
  }
  return res;
}
function Create_TaskMenu_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.taskMenuId = src.TaskMenuId;
  res.name = src.Name;
  res.tooltip = src.Tooltip;
  res.tableName = src.TableName;
  res.area = src.Area;
  res.urlOrSoprotocol = src.UrlOrSoprotocol;
  res.taskType = TaskListItemType[src.TaskType];
  res.crmScriptId = src.CrmScriptId;
  res.showInClient = Create_ShowTaskItemInClient_From(src.ShowInClient);
  res.archiveBehaviour = Create_ArchiveBehaviour_From(src.ArchiveBehaviour);
  res.rank = src.Rank;
  res.encoding = UrlEncoding[src.Encoding];
  res.progId = src.ProgId;
  res.deleted = src.Deleted;
  return res;
}
function Create_TaskMenuArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_TaskMenu_From(src[i]);
    }
  }
  return res;
}
function Create_ConsentPurpose_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.consentPurposeId = src.ConsentPurposeId;
  res.name = src.Name;
  res.consentText = src.ConsentText;
  res.formText = src.FormText;
  res.key = src.Key;
  res.tooltip = src.Tooltip;
  res.active = src.Active;
  res.updatedDate = Create_Date_From(src.UpdatedDate);
  res.updatedBy = Create_Associate_From(src.UpdatedBy);
  res.deleted = src.Deleted;
  res.rank = src.Rank;
  res.privacyStatementDesc = src.PrivacyStatementDesc;
  res.privacyStatementUrl = src.PrivacyStatementUrl;
  return res;
}
function Create_ConsentPurposeArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_ConsentPurpose_From(src[i]);
    }
  }
  return res;
}
function Create_ConsentSource_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.consentSourceId = src.ConsentSourceId;
  res.name = src.Name;
  res.tooltip = src.Tooltip;
  res.rank = src.Rank;
  res.key = src.Key;
  res.mailTemplateId = src.MailTemplateId;
  res.deleted = src.Deleted;
  return res;
}
function Create_ConsentSourceArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_ConsentSource_From(src[i]);
    }
  }
  return res;
}
function Create_Country_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.countryId = src.CountryId;
  res.name = src.Name;
  res.currencyId = src.CurrencyId;
  res.englishName = src.EnglishName;
  res.twoLetterISOCountry = src.TwoLetterISOCountry;
  res.threeLetterISOCountry = src.ThreeLetterISOCountry;
  res.imageDescription = src.ImageDescription;
  res.orgNrText = src.OrgNrText;
  res.interAreaPrefix = src.InterAreaPrefix;
  res.dialInPrefix = src.DialInPrefix;
  res.zipPrefix = src.ZipPrefix;
  res.domainName = src.DomainName;
  res.addressLayoutId = src.AddressLayoutId;
  res.domesticAddressLayoutId = src.DomesticAddressLayoutId;
  res.foreignAddressLayoutId = src.ForeignAddressLayoutId;
  res.rank = src.Rank;
  res.tooltip = src.Tooltip;
  res.deleted = src.Deleted;
  return res;
}
function Create_CountryArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_Country_From(src[i]);
    }
  }
  return res;
}
function Create_Credited_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.id = src.Id;
  res.value = src.Value;
  res.tooltip = src.Tooltip;
  return res;
}
function Create_CreditedArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_Credited_From(src[i]);
    }
  }
  return res;
}
function Create_Currency_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.id = src.Id;
  res.value = src.Value;
  res.tooltip = src.Tooltip;
  return res;
}
function Create_CurrencyArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_Currency_From(src[i]);
    }
  }
  return res;
}
function Create_CurrencyEntity_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.currencyId = src.CurrencyId;
  res.name = src.Name;
  res.tooltip = src.Tooltip;
  res.rank = src.Rank;
  res.rate = src.Rate;
  res.units = src.Units;
  res.deleted = src.Deleted;
  return res;
}
function Create_CurrencyEntityArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_CurrencyEntity_From(src[i]);
    }
  }
  return res;
}
function Create_CustomerLanguage_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.id = src.Id;
  res.value = src.Value;
  res.tooltip = src.Tooltip;
  return res;
}
function Create_CustomerLanguageArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_CustomerLanguage_From(src[i]);
    }
  }
  return res;
}
function Create_DeliveryTerm_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.id = src.Id;
  res.value = src.Value;
  res.tooltip = src.Tooltip;
  return res;
}
function Create_DeliveryTermArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_DeliveryTerm_From(src[i]);
    }
  }
  return res;
}
function Create_DeliveryType_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.id = src.Id;
  res.value = src.Value;
  res.tooltip = src.Tooltip;
  return res;
}
function Create_DeliveryTypeArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_DeliveryType_From(src[i]);
    }
  }
  return res;
}
function Create_Department_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.id = src.Id;
  res.value = src.Value;
  res.tooltip = src.Tooltip;
  return res;
}
function Create_DepartmentArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_Department_From(src[i]);
    }
  }
  return res;
}
function Create_DocumentTemplate_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.documentTemplateId = src.DocumentTemplateId;
  res.name = src.Name;
  res.tooltip = src.Tooltip;
  res.saveInDb = src.SaveInDb;
  res.filename = src.Filename;
  res.defaultOref = src.DefaultOref;
  res.recordType = DocTmplType[src.RecordType];
  res.deleted = src.Deleted;
  res.direction = DocTmplDirection[src.Direction];
  res.autoeventId = src.AutoeventId;
  res.quoteDocType = DocTmplQuoteType[src.QuoteDocType];
  return res;
}
function Create_DocumentTemplateArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_DocumentTemplate_From(src[i]);
    }
  }
  return res;
}
function Create_DocumentTemplateEntity_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.documentTemplateId = src.DocumentTemplateId;
  res.name = src.Name;
  res.tooltip = src.Tooltip;
  res.saveInDb = src.SaveInDb;
  res.filename = src.Filename;
  res.defaultOref = src.DefaultOref;
  res.recordType = DocTmplType[src.RecordType];
  res.deleted = src.Deleted;
  res.direction = DocTmplDirection[src.Direction];
  res.autoeventId = src.AutoeventId;
  res.intentId = src.IntentId;
  res.isDefaultPublished = src.IsDefaultPublished;
  res.rank = src.Rank;
  res.loadTemplateFromPlugin = src.LoadTemplateFromPlugin;
  res.mimeType = src.MimeType;
  res.isInUseInGuides = src.IsInUseInGuides;
  res.documentTypeKey = src.DocumentTypeKey;
  res.quoteDocType = DocTmplQuoteType[src.QuoteDocType];
  res.privacyDocType = DocTmplPrivacyType[src.PrivacyDocType];
  res.emailSubject = src.EmailSubject;
  res.includeSignature = src.IncludeSignature;
  res.showCurrents = src.ShowCurrents;
  res.senderEmailMode = SenderMailMode[src.SenderEmailMode];
  res.senderEmailAddress = src.SenderEmailAddress;
  res.invitationDocType = DocTmplInvitationType[src.InvitationDocType];
  return res;
}
function Create_DocumentTemplateEntityArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_DocumentTemplateEntity_From(src[i]);
    }
  }
  return res;
}
function Create_ExtAppEntity_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.extAppId = src.ExtAppId;
  res.name = src.Name;
  res.tooltip = src.Tooltip;
  res.deleted = src.Deleted;
  res.rank = src.Rank;
  res.filename = src.Filename;
  res.parameters = src.Parameters;
  res.workdir = src.Workdir;
  res.showState = Create_ShowState_From(src.ShowState);
  res.visibleIn = Navigation[src.VisibleIn];
  res.onCentral = src.OnCentral;
  res.onSatellite = src.OnSatellite;
  res.onTravel = src.OnTravel;
  res.onSalesMarketingPocket = src.OnSalesMarketingPocket;
  res.showInMenuBar = src.ShowInMenuBar;
  res.showInToolBar = src.ShowInToolBar;
  res.showInAddressBar = src.ShowInAddressBar;
  res.showInStatusBar = src.ShowInStatusBar;
  res.icon = src.Icon;
  res.waitToFinish = src.WaitToFinish;
  res.executeOnEvent = ExecuteOnEvent[src.ExecuteOnEvent];
  res.path = src.Path;
  return res;
}
function Create_HeadingEntity_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.headingId = src.HeadingId;
  res.name = src.Name;
  res.tooltip = src.Tooltip;
  res.deleted = src.Deleted;
  res.rank = src.Rank;
  res.udListDefinitionId = src.UdListDefinitionId;
  return res;
}
function Create_HeadingEntityArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_HeadingEntity_From(src[i]);
    }
  }
  return res;
}
function Create_HierarchyEntity_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.hierarchyId = src.HierarchyId;
  res.domain = Domain[src.Domain];
  res.name = src.Name;
  res.fullname = src.Fullname;
  res.parentId = src.ParentId;
  res.children = Create_HierarchyEntityArray_From(src.Children);
  res.registered = Create_Date_From(src.Registered);
  res.registeredAssociateId = src.RegisteredAssociateId;
  res.updated = Create_Date_From(src.Updated);
  res.updatedAssociateId = src.UpdatedAssociateId;
  return res;
}
function Create_HierarchyEntityArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_HierarchyEntity_From(src[i]);
    }
  }
  return res;
}
function Create_LanguageInfo_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.languageInfoId = src.LanguageInfoId;
  res.lCID = src.LCID;
  res.englishName = src.EnglishName;
  res.nativeName = src.NativeName;
  res.threeLetterISOLanguageName = src.ThreeLetterISOLanguageName;
  res.twoLetterISOLanguageName = src.TwoLetterISOLanguageName;
  res.isBuiltIn = src.IsBuiltIn;
  return res;
}
function Create_LanguageInfoArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_LanguageInfo_From(src[i]);
    }
  }
  return res;
}
function Create_LegalBase_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.legalBaseId = src.LegalBaseId;
  res.name = src.Name;
  res.tooltip = src.Tooltip;
  res.rank = src.Rank;
  res.key = src.Key;
  res.deleted = src.Deleted;
  return res;
}
function Create_LegalBaseArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_LegalBase_From(src[i]);
    }
  }
  return res;
}
function Create_Link_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.entityName = src.EntityName;
  res.id = src.Id;
  res.description = src.Description;
  res.extraInfo = src.ExtraInfo;
  res.linkId = src.LinkId;
  return res;
}
function Create_LinkArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_Link_From(src[i]);
    }
  }
  return res;
}
function Create_ListEntity_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.id = src.Id;
  res.name = src.Name;
  res.tooltip = src.Tooltip;
  res.deleted = src.Deleted;
  res.rank = src.Rank;
  res.isCustomList = src.IsCustomList;
  res.isMDOList = src.IsMDOList;
  res.useGroupsAndHeadings = src.UseGroupsAndHeadings;
  res.listType = src.ListType;
  res.inUseByUserDefinedFields = src.InUseByUserDefinedFields;
  return res;
}
function Create_ListEntityArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_ListEntity_From(src[i]);
    }
  }
  return res;
}
function Create_ListItem_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = {};
  res.id = src.Id;
  res.name = src.Name;
  res.toolTip = src.ToolTip;
  return res;
}
function Create_ListItemArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_ListItem_From(src[i]);
    }
  }
  return res;
}
function Create_ListItemEntity_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.id = src.Id;
  res.name = src.Name;
  res.tooltip = src.Tooltip;
  res.deleted = src.Deleted;
  res.udListDefinitionId = src.UdListDefinitionId;
  res.rank = src.Rank;
  return res;
}
function Create_ListItemEntityArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_ListItemEntity_From(src[i]);
    }
  }
  return res;
}
function Create_LocalizedText_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.languageId = src.LanguageId;
  res.resourceId = src.ResourceId;
  res.text = src.Text;
  res.type = LocalizedTextType[src.Type];
  res.localizedTextId = src.LocalizedTextId;
  res.isBuiltIn = src.IsBuiltIn;
  return res;
}
function Create_LocalizedTextArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_LocalizedText_From(src[i]);
    }
  }
  return res;
}
function Create_MrMrs_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.id = src.Id;
  res.value = src.Value;
  res.tooltip = src.Tooltip;
  return res;
}
function Create_MrMrsArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_MrMrs_From(src[i]);
    }
  }
  return res;
}
function Create_PaymentTerm_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.id = src.Id;
  res.value = src.Value;
  res.tooltip = src.Tooltip;
  return res;
}
function Create_PaymentTermArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_PaymentTerm_From(src[i]);
    }
  }
  return res;
}
function Create_PaymentType_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.id = src.Id;
  res.value = src.Value;
  res.tooltip = src.Tooltip;
  return res;
}
function Create_PaymentTypeArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_PaymentType_From(src[i]);
    }
  }
  return res;
}
function Create_Position_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.id = src.Id;
  res.value = src.Value;
  res.tooltip = src.Tooltip;
  return res;
}
function Create_PositionArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_Position_From(src[i]);
    }
  }
  return res;
}
function Create_Priority_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.id = src.Id;
  res.value = src.Value;
  res.tooltip = src.Tooltip;
  return res;
}
function Create_PriorityArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_Priority_From(src[i]);
    }
  }
  return res;
}
function Create_ProductCategory_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.id = src.Id;
  res.value = src.Value;
  res.tooltip = src.Tooltip;
  return res;
}
function Create_ProductCategoryArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_ProductCategory_From(src[i]);
    }
  }
  return res;
}
function Create_ProductFamily_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.id = src.Id;
  res.value = src.Value;
  res.tooltip = src.Tooltip;
  return res;
}
function Create_ProductFamilyArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_ProductFamily_From(src[i]);
    }
  }
  return res;
}
function Create_ProductType_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.id = src.Id;
  res.value = src.Value;
  res.tooltip = src.Tooltip;
  return res;
}
function Create_ProductTypeArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_ProductType_From(src[i]);
    }
  }
  return res;
}
function Create_ProjectStatus_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.id = src.Id;
  res.value = src.Value;
  res.tooltip = src.Tooltip;
  return res;
}
function Create_ProjectStatusArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_ProjectStatus_From(src[i]);
    }
  }
  return res;
}
function Create_ProjectType_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.id = src.Id;
  res.value = src.Value;
  res.tooltip = src.Tooltip;
  return res;
}
function Create_ProjectTypeArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_ProjectType_From(src[i]);
    }
  }
  return res;
}
function Create_ProjectTypeEntity_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.projTypeId = src.ProjTypeId;
  res.name = src.Name;
  res.tooltip = src.Tooltip;
  res.rank = src.Rank;
  res.durationUnit = DurationUnit[src.DurationUnit];
  res.projectDuration = src.ProjectDuration;
  res.deleted = src.Deleted;
  res.hasGuide = src.HasGuide;
  res.isAutoAdvance = src.IsAutoAdvance;
  res.stages = Create_SelectableMDOListItemArray_From(src.Stages);
  return res;
}
function Create_QuickReply_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.quickReplyId = src.QuickReplyId;
  res.name = src.Name;
  res.htmlBody = src.HtmlBody;
  return res;
}
function Create_QuickReplyArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_QuickReply_From(src[i]);
    }
  }
  return res;
}
function Create_Rating_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.id = src.Id;
  res.value = src.Value;
  res.tooltip = src.Tooltip;
  return res;
}
function Create_RatingArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_Rating_From(src[i]);
    }
  }
  return res;
}
function Create_Reason_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.id = src.Id;
  res.value = src.Value;
  res.tooltip = src.Tooltip;
  return res;
}
function Create_ReasonArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_Reason_From(src[i]);
    }
  }
  return res;
}
function Create_QuoteApproveReason_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.id = src.Id;
  res.value = src.Value;
  res.tooltip = src.Tooltip;
  return res;
}
function Create_QuoteApproveReasonArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_QuoteApproveReason_From(src[i]);
    }
  }
  return res;
}
function Create_QuoteDenyReason_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.id = src.Id;
  res.value = src.Value;
  res.tooltip = src.Tooltip;
  return res;
}
function Create_QuoteDenyReasonArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_QuoteDenyReason_From(src[i]);
    }
  }
  return res;
}
function Create_ReasonSold_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.id = src.Id;
  res.value = src.Value;
  res.tooltip = src.Tooltip;
  return res;
}
function Create_ReasonSoldArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_ReasonSold_From(src[i]);
    }
  }
  return res;
}
function Create_ReasonStalled_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.id = src.Id;
  res.value = src.Value;
  res.tooltip = src.Tooltip;
  return res;
}
function Create_ReasonStalledArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_ReasonStalled_From(src[i]);
    }
  }
  return res;
}
function Create_RelationDefinitionEntity_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.reldefId = src.ReldefId;
  res.name = src.Name;
  res.tooltip = src.Tooltip;
  res.passiveText = src.PassiveText;
  res.deleted = src.Deleted;
  res.rank = src.Rank;
  res.source = RelationTarget[src.Source];
  res.destination = RelationTarget[src.Destination];
  return res;
}
function Create_ResourceEntity_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.resourceId = src.ResourceId;
  res.name = src.Name;
  res.rank = src.Rank;
  res.tooltip = src.Tooltip;
  res.deleted = src.Deleted;
  res.isLocation = src.IsLocation;
  res.locationAddress = src.LocationAddress;
  return res;
}
function Create_SaleStageEntity_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.saleStageId = src.SaleStageId;
  res.value = src.Value;
  res.tooltip = src.Tooltip;
  res.probability = src.Probability;
  res.deleted = src.Deleted;
  res.rank = src.Rank;
  return res;
}
function Create_SaleStageEntityArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_SaleStageEntity_From(src[i]);
    }
  }
  return res;
}
function Create_SaleType_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.id = src.Id;
  res.value = src.Value;
  res.tooltip = src.Tooltip;
  return res;
}
function Create_SaleTypeArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_SaleType_From(src[i]);
    }
  }
  return res;
}
function Create_SaleTypeEntity_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.saleTypeId = src.SaleTypeId;
  res.name = src.Name;
  res.tooltip = src.Tooltip;
  res.rank = src.Rank;
  res.durationUnit = DurationUnit[src.DurationUnit];
  res.saleDuration = src.SaleDuration;
  res.saleTypeCatId = src.SaleTypeCatId;
  res.deleted = src.Deleted;
  res.hasGuide = src.HasGuide;
  res.hasStakeholders = src.HasStakeholders;
  res.isAutoAdvance = src.IsAutoAdvance;
  res.allowQuoteAlternatives = src.AllowQuoteAlternatives;
  res.defaultQuoteValidity = src.DefaultQuoteValidity;
  res.quoteLinesTemplate = src.QuoteLinesTemplate;
  res.confirmationLinesTemplate = src.ConfirmationLinesTemplate;
  res.maxDiscountPercentSet = src.MaxDiscountPercentSet;
  res.minEarningPercentSet = src.MinEarningPercentSet;
  res.maxDiscountPercent = src.MaxDiscountPercent;
  res.minEarningPercent = src.MinEarningPercent;
  res.groupQuoteLinesBy = src.GroupQuoteLinesBy;
  res.sortGroupLinesBy = src.SortGroupLinesBy;
  res.stages = Create_SelectableMDOListItemArray_From(src.Stages);
  return res;
}
function Create_SaleTypeEntityArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_SaleTypeEntity_From(src[i]);
    }
  }
  return res;
}
function Create_SelectionCategory_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.id = src.Id;
  res.value = src.Value;
  res.tooltip = src.Tooltip;
  return res;
}
function Create_SelectionCategoryArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_SelectionCategory_From(src[i]);
    }
  }
  return res;
}
function Create_Source_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.id = src.Id;
  res.value = src.Value;
  res.tooltip = src.Tooltip;
  return res;
}
function Create_SourceArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_Source_From(src[i]);
    }
  }
  return res;
}
function Create_Tag_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.id = src.Id;
  res.name = src.Name;
  res.toolTip = src.ToolTip;
  return res;
}
function Create_TagArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_Tag_From(src[i]);
    }
  }
  return res;
}
function Create_Task_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.id = src.Id;
  res.value = src.Value;
  res.tooltip = src.Tooltip;
  return res;
}
function Create_TaskArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_Task_From(src[i]);
    }
  }
  return res;
}
function Create_TicketCategory_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.id = src.Id;
  res.value = src.Value;
  res.tooltip = src.Tooltip;
  return res;
}
function Create_TicketCategoryEntity_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.ticketCategoryId = src.TicketCategoryId;
  res.parentId = src.ParentId;
  res.name = src.Name;
  res.fullname = src.Fullname;
  res.categoryMaster = src.CategoryMaster;
  res.flags = Create_TicketCategoryFlags_From(src.Flags);
  res.delegateMethod = TicketCategoryDelegateMethod[src.DelegateMethod];
  res.externalName = src.ExternalName;
  res.closingStatus = TicketCategoryClosingStatus[src.ClosingStatus];
  res.msgClosingStatus = TicketCategoryClosingStatus[src.MsgClosingStatus];
  res.assignmentLag = src.AssignmentLag;
  res.replyTemplate = src.ReplyTemplate;
  res.notificationEmail = src.NotificationEmail;
  res.defaultTicketStatus = Create_TicketStatusEntity_From(src.DefaultTicketStatus);
  res.defaultMessageStatus = Create_TicketStatusEntity_From(src.DefaultMessageStatus);
  res.effectiveReplyTemplateId = src.EffectiveReplyTemplateId;
  res.extraFields = src.ExtraFields;
  res.customFields = src.CustomFields;
  return res;
}
function Create_TicketCategoryEntityArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_TicketCategoryEntity_From(src[i]);
    }
  }
  return res;
}
function Create_TicketPriority_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.id = src.Id;
  res.value = src.Value;
  res.tooltip = src.Tooltip;
  return res;
}
function Create_TicketPriorityArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_TicketPriority_From(src[i]);
    }
  }
  return res;
}
function Create_TicketPriorityEntity_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.ticketPriorityId = src.TicketPriorityId;
  res.name = src.Name;
  res.status = TicketPriorityStatus[src.Status];
  res.flags = Create_TicketPriorityFlags_From(src.Flags);
  res.sortOrder = src.SortOrder;
  res.ticketRead = TicketPriorityEscalateEvent[src.TicketRead];
  res.changedOwner = TicketPriorityEscalateEvent[src.ChangedOwner];
  res.ticketNewinfo = TicketPriorityEscalateEvent[src.TicketNewinfo];
  res.ticketClosed = TicketPriorityEscalateEvent[src.TicketClosed];
  res.ticketChangedPriority = TicketPriorityEscalateEvent[src.TicketChangedPriority];
  res.ticketNew = TicketPriorityEscalateEvent[src.TicketNew];
  res.deadline = src.Deadline;
  res.monStart = Create_Date_From(src.MonStart);
  res.monStop = Create_Date_From(src.MonStop);
  res.tueStart = Create_Date_From(src.TueStart);
  res.tueStop = Create_Date_From(src.TueStop);
  res.wedStart = Create_Date_From(src.WedStart);
  res.wedStop = Create_Date_From(src.WedStop);
  res.thuStart = Create_Date_From(src.ThuStart);
  res.thuStop = Create_Date_From(src.ThuStop);
  res.friStart = Create_Date_From(src.FriStart);
  res.friStop = Create_Date_From(src.FriStop);
  res.satStart = Create_Date_From(src.SatStart);
  res.satStop = Create_Date_From(src.SatStop);
  res.sunStart = Create_Date_From(src.SunStart);
  res.sunStop = Create_Date_From(src.SunStop);
  res.nonDates = Create_DateArray_From(src.NonDates);
  res.escalationLevels = Create_TicketPriorityEscalationLevelEntityArray_From(src.EscalationLevels);
  return res;
}
function Create_TicketPriorityEntityArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_TicketPriorityEntity_From(src[i]);
    }
  }
  return res;
}
function Create_TicketPriorityEscalationLevelEntity_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.ticketAlertId = src.TicketAlertId;
  res.alertLevel = src.AlertLevel;
  res.alertTimeout = src.AlertTimeout;
  res.action = src.Action;
  res.delegateTo = src.DelegateTo;
  res.scriptId = src.ScriptId;
  res.emailTo = src.EmailTo;
  res.smsTo = src.SmsTo;
  res.replyTemplateIdCustomer = src.ReplyTemplateIdCustomer;
  res.replyTemplateIdUser = src.ReplyTemplateIdUser;
  res.replyTemplateIdCatmast = src.ReplyTemplateIdCatmast;
  res.replyTemplateIdEmail = src.ReplyTemplateIdEmail;
  res.rtiCustomerSms = src.RtiCustomerSms;
  res.replyTemplateIdUserSms = src.ReplyTemplateIdUserSms;
  res.replyTemplateIdCatmastSms = src.ReplyTemplateIdCatmastSms;
  res.replyTemplateIdSms = src.ReplyTemplateIdSms;
  return res;
}
function Create_TicketPriorityEscalationLevelEntityArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_TicketPriorityEscalationLevelEntity_From(src[i]);
    }
  }
  return res;
}
function Create_TicketStatusEntity_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.ticketStatusId = src.TicketStatusId;
  res.name = src.Name;
  res.status = TicketBaseStatus[src.Status];
  res.timeCounter = TicketStatusTimeCounter[src.TimeCounter];
  res.noEmailReopen = src.NoEmailReopen;
  res.isDefault = src.IsDefault;
  res.usedInQueue = src.UsedInQueue;
  return res;
}
function Create_TicketStatusEntityArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_TicketStatusEntity_From(src[i]);
    }
  }
  return res;
}
function Create_TicketType_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.id = src.Id;
  res.value = src.Value;
  res.tooltip = src.Tooltip;
  return res;
}
function Create_TicketTypeArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_TicketType_From(src[i]);
    }
  }
  return res;
}
function Create_TicketTypeEntity_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.ticketTypeId = src.TicketTypeId;
  res.name = src.Name;
  res.rank = src.Rank;
  res.tooltip = src.Tooltip;
  res.icon = src.Icon;
  res.defaultTicketStatus = src.DefaultTicketStatus;
  res.ticketStatuses = src.TicketStatuses;
  res.defaultTicketPriority = src.DefaultTicketPriority;
  res.ticketPriorities = src.TicketPriorities;
  res.replyTemplate = src.ReplyTemplate;
  res.isExternalVisible = src.IsExternalVisible;
  return res;
}
function Create_TicketTypeEntityArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_TicketTypeEntity_From(src[i]);
    }
  }
  return res;
}
function Create_WebPanelEntity_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.webPanelId = src.WebPanelId;
  res.name = src.Name;
  res.tooltip = src.Tooltip;
  res.deleted = src.Deleted;
  res.rank = src.Rank;
  res.urlEncoding = UrlEncoding[src.UrlEncoding];
  res.visibleIn = Navigation[src.VisibleIn];
  res.onCentral = src.OnCentral;
  res.onSatellite = src.OnSatellite;
  res.onTravel = src.OnTravel;
  res.onSalesMarketingWeb = src.OnSalesMarketingWeb;
  res.onSalesMarketingPocket = src.OnSalesMarketingPocket;
  res.showInMenuBar = src.ShowInMenuBar;
  res.showInToolBar = src.ShowInToolBar;
  res.showInAddressBar = src.ShowInAddressBar;
  res.showInStatusBar = src.ShowInStatusBar;
  res.windowName = src.WindowName;
  res.url = src.Url;
  res.progId = src.ProgId;
  res.icon = src.Icon;
  res.alwaysReloadOnShow = src.AlwaysReloadOnShow;
  return res;
}
function Create_WebPanelEntityArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_WebPanelEntity_From(src[i]);
    }
  }
  return res;
}
function Create_BlobEntity_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.blobId = src.BlobId;
  res.blobSize = src.BlobSize;
  res.description = src.Description;
  res.extraInfo = src.ExtraInfo;
  res.isEncrypted = src.IsEncrypted;
  res.isZipped = src.IsZipped;
  res.mimeType = src.MimeType;
  res.originalSize = src.OriginalSize;
  res.createdDate = Create_Date_From(src.CreatedDate);
  res.updatedDate = Create_Date_From(src.UpdatedDate);
  res.createdBy = Create_Associate_From(src.CreatedBy);
  res.updatedBy = Create_Associate_From(src.UpdatedBy);
  res.conceptualType = src.ConceptualType;
  return res;
}
function Create_NavigatorCompany_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.id = src.Id;
  res.value = src.Value;
  res.tooltip = src.Tooltip;
  return res;
}
function Create_NavigatorCompanyArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_NavigatorCompany_From(src[i]);
    }
  }
  return res;
}
function Create_MDOListItem_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.id = src.Id;
  res.name = src.Name;
  res.toolTip = src.ToolTip;
  res.deleted = src.Deleted;
  res.rank = src.Rank;
  res.type = src.Type;
  res.childItems = Create_MDOListItemArray_From(src.ChildItems);
  res.iconHint = src.IconHint;
  res.colorBlock = src.ColorBlock;
  res.extraInfo = src.ExtraInfo;
  res.styleHint = src.StyleHint;
  res.fullName = src.FullName;
  return res;
}
function Create_MDOListItemArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_MDOListItem_From(src[i]);
    }
  }
  return res;
}
function Create_SelectableMDOListItem_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.id = src.Id;
  res.name = src.Name;
  res.toolTip = src.ToolTip;
  res.deleted = src.Deleted;
  res.rank = src.Rank;
  res.type = src.Type;
  res.colorBlock = src.ColorBlock;
  res.iconHint = src.IconHint;
  res.selected = src.Selected;
  res.lastChanged = Create_Date_From(src.LastChanged);
  res.childItems = Create_SelectableMDOListItemArray_From(src.ChildItems);
  res.extraInfo = src.ExtraInfo;
  res.styleHint = src.StyleHint;
  res.hidden = src.Hidden;
  res.fullName = src.FullName;
  return res;
}
function Create_SelectableMDOListItemArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_SelectableMDOListItem_From(src[i]);
    }
  }
  return res;
}
function Create_ConfigurableScreenDelta_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.configurableScreenDeltaId = src.ConfigurableScreenDeltaId;
  res.name = src.Name;
  res.description = src.Description;
  res.deltaJson = src.DeltaJson;
  res.deltaType = DeltaType[src.DeltaType];
  res.deltaState = DeltaState[src.DeltaState];
  res.recipeId = src.RecipeId;
  res.updatedDate = Create_Date_From(src.UpdatedDate);
  res.createdDate = Create_Date_From(src.CreatedDate);
  res.updatedBy = Create_Associate_From(src.UpdatedBy);
  res.createdBy = Create_Associate_From(src.CreatedBy);
  res.appliesToIds = src.AppliesToIds;
  res.appliesToKey = src.AppliesToKey;
  return res;
}
function Create_ConfigurableScreenDeltaArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_ConfigurableScreenDelta_From(src[i]);
    }
  }
  return res;
}
function Create_DiaryViewEntity_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.diaryViewId = src.DiaryViewId;
  res.name = src.Name;
  res.tooltip = src.Tooltip;
  res.visibleColumns = src.VisibleColumns;
  res.rank = src.Rank;
  res.assocId = src.AssocId;
  res.associateList = Create_SelectableMDOListItemArray_From(src.AssociateList);
  res.tzLocationId = src.TzLocationId;
  return res;
}
function Create_SystemEventEntity_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.systemEventId = src.SystemEventId;
  res.scope = SystemEventScope[src.Scope];
  res.eta = Create_Date_From(src.Eta);
  res.eventkey = src.Eventkey;
  res.eventmess = src.Eventmess;
  res.extraInfo = src.ExtraInfo;
  res.owner = src.Owner;
  res.updatedCount = src.UpdatedCount;
  res.registered = Create_Date_From(src.Registered);
  res.activatedBy = Create_Associate_From(src.ActivatedBy);
  return res;
}
function Create_WindowPosSize_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.ownerWindow = src.OwnerWindow;
  res.personId = src.PersonId;
  res.associateId = src.AssociateId;
  res.extraId = src.ExtraId;
  res.extraInfo = src.ExtraInfo;
  res.height = src.Height;
  res.leftX = src.LeftX;
  res.state = ShowWindowState[src.State];
  res.upperY = src.UpperY;
  res.width = src.Width;
  res.windowPosSizeId = src.WindowPosSizeId;
  return res;
}
function Create_WindowPosSizeArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_WindowPosSize_From(src[i]);
    }
  }
  return res;
}
function Create_LiveUiConfig_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.isEnabled = src.IsEnabled;
  res.pollingInterval = src.PollingInterval;
  return res;
}
function Create_History_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.rank = src.Rank;
  res.id = src.Id;
  res.historyName = src.HistoryName;
  res.historyId = src.HistoryId;
  res.associateId = src.AssociateId;
  res.name = src.Name;
  res.itemInfo = src.ItemInfo;
  return res;
}
function Create_HistoryArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_History_From(src[i]);
    }
  }
  return res;
}
function Create_UiEvent_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.eventId = src.EventId;
  res.eventName = src.EventName;
  res.entityType = src.EntityType;
  res.entityKey = src.EntityKey;
  res.associateId = src.AssociateId;
  res.associateName = src.AssociateName;
  res.eventDateTime = Create_Date_From(src.EventDateTime);
  return res;
}
function Create_UiEventArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_UiEvent_From(src[i]);
    }
  }
  return res;
}
function Create_Associate_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.associateId = src.AssociateId;
  res.name = src.Name;
  res.personId = src.PersonId;
  res.rank = src.Rank;
  res.tooltip = src.Tooltip;
  res.type = UserType[src.Type];
  res.groupIdx = src.GroupIdx;
  res.fullName = src.FullName;
  res.formalName = src.FormalName;
  res.deleted = src.Deleted;
  res.ejUserId = src.EjUserId;
  res.userName = src.UserName;
  return res;
}
function Create_AssociateArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_Associate_From(src[i]);
    }
  }
  return res;
}
function Create_EntityCounts_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.entityName = src.EntityName;
  res.records = src.Records;
  return res;
}
function Create_EntityCountsArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_EntityCounts_From(src[i]);
    }
  }
  return res;
}
function Create_WebAppUsage_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.webAppUsageId = src.WebAppUsageId;
  res.assocId = src.AssocId;
  res.timestamp = Create_Date_From(src.Timestamp);
  res.viewState = src.ViewState;
  res.aggregateCount = src.AggregateCount;
  res.aggregateBin = src.AggregateBin;
  res.version = src.Version;
  return res;
}
function Create_WebAppUsageArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_WebAppUsage_From(src[i]);
    }
  }
  return res;
}
function Create_MailMergeSettings_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.selectionId = src.SelectionId;
  res.documentId = src.DocumentId;
  res.mailMergeDeliveryType = EMailMergeTargetType[src.MailMergeDeliveryType];
  res.customAttention = src.CustomAttention;
  res.alwaysUseCustomAttention = src.AlwaysUseCustomAttention;
  res.saveDocument = src.SaveDocument;
  res.customMailBody = src.CustomMailBody;
  res.taskEntity = Create_MailMergeTask_From(src.TaskEntity);
  res.addCompanyInterest = src.AddCompanyInterest;
  res.addPersonInterest = src.AddPersonInterest;
  res.removeCompanyInterest = src.RemoveCompanyInterest;
  res.removePersonInterest = src.RemovePersonInterest;
  res.includeNoMailingsRecipient = src.IncludeNoMailingsRecipient;
  res.testOnly = src.TestOnly;
  res.projectId = src.ProjectId;
  res.includeRetiredRecipients = src.IncludeRetiredRecipients;
  res.includeStoppedRecipients = src.IncludeStoppedRecipients;
  res.customMailSubject = src.CustomMailSubject;
  res.extraInfo = src.ExtraInfo;
  res.synchronous = src.Synchronous;
  res.isTemporarySelection = src.IsTemporarySelection;
  return res;
}
function Create_MailMergeTask_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.projectId = src.ProjectId;
  res.typeId = src.TypeId;
  res.startDate = Create_Date_From(src.StartDate);
  res.duration = src.Duration;
  res.description = src.Description;
  res.priorityId = src.PriorityId;
  res.visibleFor = Create_VisibleFor_From(src.VisibleFor);
  res.completed = ActivityStatus[src.Completed];
  res.ownerAssociateId = src.OwnerAssociateId;
  res.singleEntryOnEachCompany = src.SingleEntryOnEachCompany;
  res.saleId = src.SaleId;
  return res;
}
function Create_SelectionEntity_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.description = src.Description;
  res.postit = src.Postit;
  res.associate = Create_Associate_From(src.Associate);
  res.createdBy = Create_Associate_From(src.CreatedBy);
  res.updatedBy = Create_Associate_From(src.UpdatedBy);
  res.selectionCategory = Create_SelectionCategory_From(src.SelectionCategory);
  res.groupIdx = src.GroupIdx;
  res.includePerson = src.IncludePerson;
  res.memberCount = src.MemberCount;
  res.name = src.Name;
  res.postitTextId = src.PostitTextId;
  res.createdDate = Create_Date_From(src.CreatedDate);
  res.selectionId = src.SelectionId;
  res.soundEx = src.SoundEx;
  res.source = src.Source;
  res.textId = src.TextId;
  res.updatedDate = Create_Date_From(src.UpdatedDate);
  res.updatedCount = src.UpdatedCount;
  res.visibility = src.Visibility;
  res.selectionType = SelectionType[src.SelectionType];
  res.companyUnique = src.CompanyUnique;
  res.targetTableNumber = src.TargetTableNumber;
  res.targetTableName = src.TargetTableName;
  res.completed = src.Completed;
  res.leftSelectionId = src.LeftSelectionId;
  res.rightSelectionId = src.RightSelectionId;
  res.selectionUnionType = SelectionUnionType[src.SelectionUnionType];
  res.mainProviderName = src.MainProviderName;
  res.shadowProviderName = src.ShadowProviderName;
  res.chartKey = src.ChartKey;
  res.lastLoaded = Create_Date_From(src.LastLoaded);
  res.lastLoadedBy = src.LastLoadedBy;
  res.lastLoadedByAssociate = Create_Associate_From(src.LastLoadedByAssociate);
  res.lastMembershipChange = Create_Date_From(src.LastMembershipChange);
  res.lastMembershipChangeBy = src.LastMembershipChangeBy;
  res.lastMembershipChangeByAssociate = Create_Associate_From(src.LastMembershipChangeByAssociate);
  res.mainHeading = src.MainHeading;
  res.memberTabHeading = src.MemberTabHeading;
  res.mailingsProviderName = src.MailingsProviderName;
  res.dashboardTileDefinitionId = src.DashboardTileDefinitionId;
  res.visibleFor = Create_VisibleForArray_From(src.VisibleFor);
  return res;
}
function Create_SelectionForFind_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.providerName = src.ProviderName;
  res.selectionId = src.SelectionId;
  res.canSaveAsSelection = src.CanSaveAsSelection;
  res.mainHeading = src.MainHeading;
  res.filterScreenHeading = src.FilterScreenHeading;
  res.selectionEntityHeading = src.SelectionEntityHeading;
  return res;
}
function Create_SelectionSummaryItem_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = {};
  res.selectionId = src.SelectionId;
  res.name = src.Name;
  res.targetTable = src.TargetTable;
  res.registered = Create_Date_From(src.Registered);
  res.providerName = src.ProviderName;
  return res;
}
function Create_SelectionSummaryItemArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_SelectionSummaryItem_From(src[i]);
    }
  }
  return res;
}
function Create_ContactOrPersonFromEmail_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.personId = src.PersonId;
  res.fullName = src.FullName;
  res.emailAddress = src.EmailAddress;
  res.contactId = src.ContactId;
  res.contactName = src.ContactName;
  res.contactDepartment = src.ContactDepartment;
  res.contactCategory = src.ContactCategory;
  res.sortName = src.SortName;
  return res;
}
function Create_ContactOrPersonFromEmailArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_ContactOrPersonFromEmail_From(src[i]);
    }
  }
  return res;
}
function Create_EMailAccount_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.eMailAccountId = src.EMailAccountId;
  res.eMailAddress = src.EMailAddress;
  res.associateId = src.AssociateId;
  res.incomingCredentials = Create_ServiceAuth_From(src.IncomingCredentials);
  res.outgoingCredentials = Create_ServiceAuth_From(src.OutgoingCredentials);
  res.accountStatus = src.AccountStatus;
  res.errorCount = src.ErrorCount;
  res.errorReason = src.ErrorReason;
  res.inboxFolder = src.InboxFolder;
  res.sentFolder = src.SentFolder;
  return res;
}
function Create_EMailAddress_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.contactId = src.ContactId;
  res.contactName = src.ContactName;
  res.personId = src.PersonId;
  res.personName = src.PersonName;
  res.associateId = src.AssociateId;
  res.address = src.Address;
  res.emailId = src.EmailId;
  res.duplicatePersonIds = src.DuplicatePersonIds;
  res.name = src.Name;
  return res;
}
function Create_EMailAddressArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_EMailAddress_From(src[i]);
    }
  }
  return res;
}
function Create_EMailAppointment_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.appointment = Create_Appointment_From(src.Appointment);
  res.calMethod = CalMethod[src.CalMethod];
  res.participants = src.Participants;
  res.comment = src.Comment;
  res.sequence = src.Sequence;
  res.dtStart = Create_Date_From(src.DtStart);
  res.dtEnd = Create_Date_From(src.DtEnd);
  res.superseded = src.Superseded;
  return res;
}
function Create_EMailAttachment_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.description = src.Description;
  res.filename = src.Filename;
  res.size = src.Size;
  res.type = src.Type;
  res.encoding = src.Encoding;
  res.id = src.Id;
  res.disposition = src.Disposition;
  res.isSafeFileExtension = src.IsSafeFileExtension;
  res.stream = Create_ArrayBuffer_From(src.Stream);
  return res;
}
function Create_EMailAttachmentArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_EMailAttachment_From(src[i]);
    }
  }
  return res;
}
function Create_EMailConnectionInfo_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.serverName = src.ServerName;
  res.userName = src.UserName;
  res.password = src.Password;
  res.folder = src.Folder;
  res.useSSL = src.UseSSL;
  return res;
}
function Create_EMailConnectionInfoExtended_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.port = src.Port;
  res.serverName = src.ServerName;
  res.protocol = src.Protocol;
  res.userName = src.UserName;
  res.password = src.Password;
  res.useSSL = src.UseSSL;
  res.folder = src.Folder;
  return res;
}
function Create_EMailCustomHeader_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.name = src.Name;
  res.values = src.Values;
  return res;
}
function Create_EMailCustomHeaderArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_EMailCustomHeader_From(src[i]);
    }
  }
  return res;
}
function Create_EMailEntity_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.to = Create_EMailAddressArray_From(src.To);
  res.cc = Create_EMailAddressArray_From(src.Cc);
  res.bcc = Create_EMailAddressArray_From(src.Bcc);
  res.subject = src.Subject;
  res.htmlBody = src.HTMLBody;
  res.from = Create_EMailAddress_From(src.From);
  res.sent = Create_Date_From(src.Sent);
  res.size = src.Size;
  res.priority = EMailPriority[src.Priority];
  res.flags = Create_EMailFlags_From(src.Flags);
  res.messageID = src.MessageID;
  res.plainBody = src.PlainBody;
  res.isSent = src.IsSent;
  res.eMailSOInfo = Create_EMailSOInfo_From(src.EMailSOInfo);
  res.serverId = src.ServerId;
  res.attachments = Create_EMailAttachmentArray_From(src.Attachments);
  res.customHeaderList = Create_EMailCustomHeaderArray_From(src.CustomHeaderList);
  res.folderName = src.FolderName;
  res.emailItemId = src.EmailItemId;
  res.accountId = src.AccountId;
  res.receivedAt = Create_Date_From(src.ReceivedAt);
  res.inReplyTo = Create_EMailEnvelope_From(src.InReplyTo);
  res.repliedAt = Create_Date_From(src.RepliedAt);
  res.hasCalendarData = src.HasCalendarData;
  res.calMethod = CalMethod[src.CalMethod];
  res.calReplyStatus = CalReplyStatus[src.CalReplyStatus];
  return res;
}
function Create_EMailEntityArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_EMailEntity_From(src[i]);
    }
  }
  return res;
}
function Create_EMailEnvelope_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.serverId = src.ServerId;
  res.messageId = src.MessageId;
  res.subject = src.Subject;
  res.from = Create_EMailAddress_From(src.From);
  res.to = Create_EMailAddressArray_From(src.To);
  res.sent = Create_Date_From(src.Sent);
  res.priority = EMailPriority[src.Priority];
  res.flags = Create_EMailFlags_From(src.Flags);
  res.size = src.Size;
  res.eMailSOInfo = Create_EMailSOInfo_From(src.EMailSOInfo);
  return res;
}
function Create_EMailEnvelopeArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_EMailEnvelope_From(src[i]);
    }
  }
  return res;
}
function Create_EMailFolder_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.name = src.Name;
  res.delimiter = src.Delimiter;
  res.flags = src.Flags;
  res.totalItems = src.TotalItems;
  res.unreadItems = src.UnreadItems;
  res.subscribed = src.Subscribed;
  res.emailFolderId = src.EmailFolderId;
  return res;
}
function Create_EMailFolderArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_EMailFolder_From(src[i]);
    }
  }
  return res;
}
function Create_EMailSOInfo_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.documentId = src.DocumentId;
  res.appointmentId = src.AppointmentId;
  res.projectId = src.ProjectId;
  res.saleId = src.SaleId;
  res.archived = src.Archived;
  res.archivedAt = Create_Date_From(src.ArchivedAt);
  res.archivedBy = src.ArchivedBy;
  res.archivedDisplayName = src.ArchivedDisplayName;
  return res;
}
function Create_SyncUserAccount_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.accountId = src.AccountId;
  res.associateName = src.AssociateName;
  res.associateId = src.AssociateId;
  return res;
}
function Create_SyncUserAccountArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_SyncUserAccount_From(src[i]);
    }
  }
  return res;
}
function Create_CriteriaInformation_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.restrictions = Create_ArchiveRestrictionInfoArray_From(src.Restrictions);
  res.criteriaArchiveColumns = Create_ArchiveColumnInfoArray_From(src.CriteriaArchiveColumns);
  res.criteriaArchiveRows = Create_ArchiveListItemArray_From(src.CriteriaArchiveRows);
  res.restrictionGroups = Create_ArchiveRestrictionGroupArray_From(src.RestrictionGroups);
  return res;
}
function Create_FindResults_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.archiveColumns = Create_ArchiveColumnInfoArray_From(src.ArchiveColumns);
  res.archiveRows = Create_ArchiveListItemArray_From(src.ArchiveRows);
  res.rowCount = src.RowCount;
  return res;
}
function Create_Webhook_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = {};
  res.webhookId = src.WebhookId;
  res.name = src.Name;
  res.events = src.Events;
  res.targetUrl = src.TargetUrl;
  res.secret = src.Secret;
  res.state = WebhookState[src.State];
  res.type = src.Type;
  res.headers = Create_StringDictionary_From(src.Headers);
  res.properties = Create_StringObjectDictionary_From(src.Properties);
  res.registered = Create_Date_From(src.Registered);
  res.registeredAssociate = Create_Associate_From(src.RegisteredAssociate);
  res.updated = Create_Date_From(src.Updated);
  res.updatedAssociate = Create_Associate_From(src.UpdatedAssociate);
  res.errorsEmail = src.ErrorsEmail;
  return res;
}
function Create_WebhookArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_Webhook_From(src[i]);
    }
  }
  return res;
}
function Create_WebhookResult_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.success = src.Success;
  res.message = src.Message;
  return res;
}
function Create_VisibleFor_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.visibleId = src.VisibleId;
  res.visibility = Visibility[src.Visibility];
  res.displayValue = src.DisplayValue;
  return res;
}
function Create_VisibleForArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_VisibleFor_From(src[i]);
    }
  }
  return res;
}
function Create_FieldInfoBase_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = {};
  if (src.FieldType == "Attachment")
    res = Create_FieldInfoAttachment_From(src);
  if (src.FieldType == "Blob")
    res = Create_FieldInfoBlob_From(src);
  if (src.FieldType == "Checkbox")
    res = Create_FieldInfoBool_From(src);
  if (src.FieldType == "Date")
    res = Create_FieldInfoDate_From(src);
  if (src.FieldType == "DateTime")
    res = Create_FieldInfoDateTime_From(src);
  if (src.FieldType == "Decimal")
    res = Create_FieldInfoDecimal_From(src);
  if (src.FieldType == "DynamicLink")
    res = Create_FieldInfoDynamicLink_From(src);
  if (src.FieldType == "Integer")
    res = Create_FieldInfoInt_From(src);
  if (src.FieldType == "MdoList")
    res = Create_FieldInfoMdoList_From(src);
  if (src.FieldType == "ListText")
    res = Create_FieldInfoListText_From(src);
  if (src.FieldType == "LongText")
    res = Create_FieldInfoLongText_From(src);
  if (src.FieldType == "RelationTo")
    res = Create_FieldInfoRelation_From(src);
  if (src.FieldType == "ShortText")
    res = Create_FieldInfoShortText_From(src);
  if (src.FieldType == "Time")
    res = Create_FieldInfoTime_From(src);
  if (src.FieldType == "TimeSpan")
    res = Create_FieldInfoTimeSpan_From(src);
  res.fieldType = CustomFieldType[src.FieldType];
  res.fieldName = src.FieldName;
  res.displayName = src.DisplayName;
  res.description = src.Description;
  res.shortLabel = src.ShortLabel;
  res.hideLabel = src.HideLabel;
  res.hideField = src.HideField;
  res.isIndexed = src.IsIndexed;
  res.isMandatory = src.IsMandatory;
  res.isReadOnly = src.IsReadOnly;
  res.isExternal = src.IsExternal;
  res.rank = src.Rank;
  res.templateVariableName = src.TemplateVariableName;
  return res;
}
function Create_FieldInfoBaseArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_FieldInfoBase_From(src[i]);
    }
  }
  return res;
}
function Create_FieldInfoAttachment_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = src;
  res.defaultValue = src.DefaultValue;
  return res;
}
function Create_FieldInfoBlob_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = src;
  return res;
}
function Create_FieldInfoBool_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = src;
  res.defaultValue = src.DefaultValue;
  return res;
}
function Create_FieldInfoDate_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = src;
  res.defaultValue = Create_Date_From(src.DefaultValue);
  res.isDefaultNow = src.IsDefaultNow;
  return res;
}
function Create_FieldInfoDateTime_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = src;
  res.defaultValue = Create_Date_From(src.DefaultValue);
  res.isDefaultNow = src.IsDefaultNow;
  return res;
}
function Create_FieldInfoDecimal_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = src;
  res.defaultValue = src.DefaultValue;
  res.precision = src.Precision;
  return res;
}
function Create_FieldInfoDynamicLink_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = src;
  res.linkName = src.LinkName;
  res.linkValue = src.LinkValue;
  return res;
}
function Create_FieldInfoInt_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = src;
  res.defaultValue = src.DefaultValue;
  return res;
}
function Create_FieldInfoMdoList_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = src;
  res.defaultValue = src.DefaultValue;
  res.mdoListName = src.MdoListName;
  return res;
}
function Create_FieldInfoListText_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = src;
  res.defaultValue = src.DefaultValue;
  res.textLength = src.TextLength;
  res.choices = src.Choices;
  return res;
}
function Create_FieldInfoLongText_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = src;
  res.defaultValue = src.DefaultValue;
  res.isHtml = src.IsHtml;
  res.useTextArea = src.UseTextArea;
  res.numRows = src.NumRows;
  return res;
}
function Create_FieldInfoRelation_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = src;
  res.defaultValue = src.DefaultValue;
  res.targetTable = src.TargetTable;
  res.targetLabel = src.TargetLabel;
  res.useDropDown = src.UseDropDown;
  res.mdoListName = src.MdoListName;
  return res;
}
function Create_FieldInfoShortText_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = src;
  res.defaultValue = src.DefaultValue;
  res.textLength = src.TextLength;
  res.formatMask = src.FormatMask;
  res.isHtml = src.IsHtml;
  return res;
}
function Create_FieldInfoTime_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = src;
  res.defaultValue = Create_Date_From(src.DefaultValue);
  res.isDefaultNow = src.IsDefaultNow;
  return res;
}
function Create_FieldInfoTimeSpan_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = src;
  res.defaultValue = src.DefaultValue;
  res.useDays = src.UseDays;
  res.useHours = src.UseHours;
  res.useMinutes = src.UseMinutes;
  res.maxNum = src.MaxNum;
  return res;
}
function Create_UserDefinedFieldInfo_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.uDefFieldId = src.UDefFieldId;
  res.columnId = src.ColumnId;
  res.fieldDefault = src.FieldDefault;
  res.fieldHeight = src.FieldHeight;
  res.fieldLabel = src.FieldLabel;
  res.fieldLeft = src.FieldLeft;
  res.fieldTop = src.FieldTop;
  res.fieldType = UDefFieldType[src.FieldType];
  res.fieldWidth = src.FieldWidth;
  res.formatMask = src.FormatMask;
  res.hideLabel = src.HideLabel;
  res.isIndexed = src.IsIndexed;
  res.labelHeight = src.LabelHeight;
  res.labelLeft = src.LabelLeft;
  res.labelTop = src.LabelTop;
  res.labelWidth = src.LabelWidth;
  res.lastVersionId = src.LastVersionId;
  res.listTableId = src.ListTableId;
  res.isMandatory = src.IsMandatory;
  res.type = UDefType[src.Type];
  res.page1LineNo = src.Page1LineNo;
  res.progId = src.ProgId;
  res.isReadOnly = src.IsReadOnly;
  res.shortLabel = src.ShortLabel;
  res.tabOrder = src.TabOrder;
  res.textLength = src.TextLength;
  res.tooltip = src.Tooltip;
  res.udefIdentity = src.UdefIdentity;
  res.uDListDefinitionId = src.UDListDefinitionId;
  res.justification = UdefJustification[src.Justification];
  res.version = src.Version;
  res.templateVariableName = src.TemplateVariableName;
  res.hasBeenPublished = src.HasBeenPublished;
  res.mdoListName = src.MdoListName;
  return res;
}
function Create_UserDefinedFieldInfoArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_UserDefinedFieldInfo_From(src[i]);
    }
  }
  return res;
}
function Create_ReportEntity_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.reportId = src.ReportId;
  res.reportCategory = ReportCategory[src.ReportCategory];
  res.description = src.Description;
  res.reportLayout = ReportLayout[src.ReportLayout];
  res.name = src.Name;
  res.associateId = src.AssociateId;
  res.templateId = src.TemplateId;
  res.published = src.Published;
  return res;
}
function Create_ReportLabelLayoutEntity_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.reportLabelLayoutId = src.ReportLabelLayoutId;
  res.name = src.Name;
  res.description = src.Description;
  res.orientation = ReportPaperOrientation[src.Orientation];
  res.paperWidth = src.PaperWidth;
  res.paperHeight = src.PaperHeight;
  res.leftMargin = src.LeftMargin;
  res.rightMargin = src.RightMargin;
  res.topMargin = src.TopMargin;
  res.bottomMargin = src.BottomMargin;
  res.countColumns = src.CountColumns;
  res.countRows = src.CountRows;
  return res;
}
function Create_SaintConfiguration_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.ownerTable = src.OwnerTable;
  res.enabled = src.Enabled;
  res.period1 = src.Period1;
  res.period2 = src.Period2;
  res.period3 = src.Period3;
  res.generationStart = Create_Date_From(src.GenerationStart);
  res.generationEnd = Create_Date_From(src.GenerationEnd);
  res.rowsGenerated = src.RowsGenerated;
  return res;
}
function Create_SaintConfigurationArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_SaintConfiguration_From(src[i]);
    }
  }
  return res;
}
function Create_StatusMonitor_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.ownerTable = src.OwnerTable;
  res.rank = src.Rank;
  res.defaultTask = src.DefaultTask;
  res.defaultTaskText = src.DefaultTaskText;
  res.isVisual = src.IsVisual;
  res.lastGenerated = Create_Date_From(src.LastGenerated);
  res.description = src.Description;
  res.name = src.Name;
  res.statusMonitorId = src.StatusMonitorId;
  res.pictureId = src.PictureId;
  res.needsUpdate = src.NeedsUpdate;
  res.deleted = src.Deleted;
  res.numMatches = src.NumMatches;
  res.numNeedUpdate = src.NumNeedUpdate;
  res.generationStart = Create_Date_From(src.GenerationStart);
  return res;
}
function Create_StatusMonitorArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_StatusMonitor_From(src[i]);
    }
  }
  return res;
}
function Create_StatusMonitorPeriods_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.period1 = src.Period1;
  res.period2 = src.Period2;
  res.period3 = src.Period3;
  return res;
}
function Create_BatchTaskInfo_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.id = src.Id;
  res.name = src.Name;
  res.associateId = src.AssociateId;
  res.detailsTable = src.DetailsTable;
  res.detailsRecord = src.DetailsRecord;
  res.isSystemTask = src.IsSystemTask;
  res.isInternalTask = src.IsInternalTask;
  res.parameterObject = Create_StringDictionary_From(src.ParameterObject);
  res.lastStarted = Create_Date_From(src.LastStarted);
  res.created = Create_Date_From(src.Created);
  res.startCount = src.StartCount;
  res.databaseSerialNumber = src.DatabaseSerialNumber;
  res.context = src.Context;
  res.result = src.Result;
  res.state = BatchTaskState[src.State];
  res.description = src.Description;
  res.response = src.Response;
  res.request = src.Request;
  res.progressDescription = src.ProgressDescription;
  res.progressPercent = src.ProgressPercent;
  res.fileName = src.FileName;
  res.cancellationBehaviour = BatchTaskCancellationBehaviour[src.CancellationBehaviour];
  return res;
}
function Create_BatchTaskInfoArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_BatchTaskInfo_From(src[i]);
    }
  }
  return res;
}
function Create_ContactRelationEntity_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.sourceContactId = src.SourceContactId;
  res.sourcePersonId = src.SourcePersonId;
  res.destinationContactId = src.DestinationContactId;
  res.destinationPersonId = src.DestinationPersonId;
  res.relationId = src.RelationId;
  res.comment = src.Comment;
  res.relationDefinitionId = src.RelationDefinitionId;
  res.reversed = src.Reversed;
  res.updatedDate = Create_Date_From(src.UpdatedDate);
  res.createdDate = Create_Date_From(src.CreatedDate);
  res.createdBy = Create_Associate_From(src.CreatedBy);
  res.updatedBy = Create_Associate_From(src.UpdatedBy);
  res.sourceContactName = src.SourceContactName;
  res.sourcePersonName = src.SourcePersonName;
  res.destinationContactName = src.DestinationContactName;
  res.destinationPersonName = src.DestinationPersonName;
  res.activeText = src.ActiveText;
  res.passiveText = src.PassiveText;
  return res;
}
function Create_ActivityFilter_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.fromDate = Create_Date_From(src.FromDate);
  res.toDate = Create_Date_From(src.ToDate);
  res.associateList = Create_SelectableMDOListItemArray_From(src.AssociateList);
  res.groupList = Create_SelectableMDOListItemArray_From(src.GroupList);
  res.futureDateList = Create_MDOListItemArray_From(src.FutureDateList);
  return res;
}
function Create_ArchiveColumnData_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = {};
  res.displayValue = src.DisplayValue;
  res.tooltipHint = src.TooltipHint;
  res.linkHint = src.LinkHint;
  return res;
}
function Create_ArchiveColumnInfo_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = {};
  res.displayName = src.DisplayName;
  res.displayTooltip = src.DisplayTooltip;
  res.displayType = src.DisplayType;
  res.canOrderBy = src.CanOrderBy;
  res.name = src.Name;
  res.canRestrictBy = src.CanRestrictBy;
  res.restrictionType = src.RestrictionType;
  res.restrictionListName = src.RestrictionListName;
  res.isVisible = src.IsVisible;
  res.width = src.Width;
  res.iconHint = src.IconHint;
  res.headingIconHint = src.HeadingIconHint;
  res.extraInfo = src.ExtraInfo;
  return res;
}
function Create_ArchiveColumnInfoArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_ArchiveColumnInfo_From(src[i]);
    }
  }
  return res;
}
function Create_ArchiveConfiguration_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.archiveColumnInfo = Create_ArchiveColumnInfoArray_From(src.ArchiveColumnInfo);
  res.archiveEntityInfo = Create_SelectableMDOListItemArray_From(src.ArchiveEntityInfo);
  res.archiveOrderByInfo = Create_ArchiveOrderByInfoArray_From(src.ArchiveOrderByInfo);
  res.ownerKeys = src.OwnerKeys;
  return res;
}
function Create_ArchiveListItem_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.entityName = src.EntityName;
  res.primaryKey = src.PrimaryKey;
  res.columnData = Create_ColumnDataDictionary_From(src.ColumnData);
  res.linkHint = src.LinkHint;
  res.styleHint = src.StyleHint;
  return res;
}
function Create_ArchiveListItemArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_ArchiveListItem_From(src[i]);
    }
  }
  return res;
}
function Create_ArchiveListResult_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.rowCount = src.RowCount;
  res.rows = Create_ArchiveListItemArray_From(src.Rows);
  return res;
}
function Create_ArchiveOrderByInfo_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = {};
  res.name = src.Name;
  res.direction = OrderBySortType[src.Direction];
  return res;
}
function Create_ArchiveOrderByInfoArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_ArchiveOrderByInfo_From(src[i]);
    }
  }
  return res;
}
function Create_ArchiveRestrictionGroup_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = {};
  res.name = src.Name;
  res.description = src.Description;
  res.rank = src.Rank;
  res.restrictions = Create_ArchiveRestrictionInfoArray_From(src.Restrictions);
  return res;
}
function Create_ArchiveRestrictionGroupArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_ArchiveRestrictionGroup_From(src[i]);
    }
  }
  return res;
}
function Create_ArchiveRestrictionInfo_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = {};
  res.name = src.Name;
  res.operator = src.Operator;
  res.values = src.Values;
  res.displayValues = src.DisplayValues;
  res.columnInfo = Create_ArchiveColumnInfo_From(src.ColumnInfo);
  res.isActive = src.IsActive;
  res.subRestrictions = Create_ArchiveRestrictionInfoArray_From(src.SubRestrictions);
  res.interParenthesis = src.InterParenthesis;
  res.interOperator = InterRestrictionOperator[src.InterOperator];
  res.uniqueHash = src.UniqueHash;
  return res;
}
function Create_ArchiveRestrictionInfoArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_ArchiveRestrictionInfo_From(src[i]);
    }
  }
  return res;
}
function Create_ExportArchiveResult_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.batchTaskId = src.BatchTaskId;
  res.fileName = src.FileName;
  res.message = src.Message;
  return res;
}
function Create_RelatedData_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = {};
  res.field = src.Field;
  res.fieldValue = Create_ArchiveColumnData_From(src.FieldValue);
  return res;
}
function Create_RelatedDataArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_RelatedData_From(src[i]);
    }
  }
  return res;
}
function Create_AudienceConfigParameter_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.audienceLayoutId = src.AudienceLayoutId;
  res.name = src.Name;
  res.value = src.Value;
  res.createdDate = Create_Date_From(src.CreatedDate);
  res.updatedDate = Create_Date_From(src.UpdatedDate);
  res.createdBy = src.CreatedBy;
  res.updatedBy = src.UpdatedBy;
  return res;
}
function Create_AudienceConfigParameterArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_AudienceConfigParameter_From(src[i]);
    }
  }
  return res;
}
function Create_AudienceLayoutEntity_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.audienceLayoutId = src.AudienceLayoutId;
  res.instanceLayout = src.InstanceLayout;
  res.instanceName = src.InstanceName;
  res.createdDate = Create_Date_From(src.CreatedDate);
  res.updatedDate = Create_Date_From(src.UpdatedDate);
  res.createdBy = Create_Associate_From(src.CreatedBy);
  res.updatedBy = Create_Associate_From(src.UpdatedBy);
  return res;
}
function Create_Preference_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.level = PreferenceLevel[src.Level];
  res.rawValue = src.RawValue;
  res.specification = Create_PreferenceSpec_From(src.Specification);
  res.displayValue = src.DisplayValue;
  res.displayTooltip = src.DisplayTooltip;
  res.displayType = PrefDescValueType[src.DisplayType];
  res.tabOrder = Create_TabOrder_From(src.TabOrder);
  res.targetId = src.TargetId;
  res.prefDescId = src.PrefDescId;
  res.tableName = src.TableName;
  res.userPreferenceId = src.UserPreferenceId;
  return res;
}
function Create_PreferenceArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_Preference_From(src[i]);
    }
  }
  return res;
}
function Create_PreferenceDescription_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.prefDescId = src.PrefDescId;
  res.section = src.Section;
  res.key = src.Key;
  res.name = src.Name;
  res.valueType = PrefDescValueType[src.ValueType];
  res.maxLevel = PreferenceLevel[src.MaxLevel];
  res.sysMaxLevel = PreferenceLevel[src.SysMaxLevel];
  res.accessFlags = Create_PrefDescAccessFlags_From(src.AccessFlags);
  res.description = src.Description;
  res.isBuiltin = src.IsBuiltin;
  res.tableName = src.TableName;
  res.userDefinedListId = src.UserDefinedListId;
  res.rank = src.Rank;
  res.subGroup = src.SubGroup;
  res.minLevel = src.MinLevel;
  res.maxValue = src.MaxValue;
  res.minValue = src.MinValue;
  res.requiredLicense = src.RequiredLicense;
  return res;
}
function Create_PreferenceDescriptionArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_PreferenceDescription_From(src[i]);
    }
  }
  return res;
}
function Create_PreferenceDescriptionLine_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.prefDescLineId = src.PrefDescLineId;
  res.prefDescId = src.PrefDescId;
  res.prefValue = src.PrefValue;
  res.prefShowValue = src.PrefShowValue;
  res.description = src.Description;
  res.isBuiltin = src.IsBuiltin;
  return res;
}
function Create_PreferenceDescriptionLineArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_PreferenceDescriptionLine_From(src[i]);
    }
  }
  return res;
}
function Create_PreferenceSpec_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.section = src.Section;
  res.key = src.Key;
  return res;
}
function Create_TabOrder_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.tabOrderId = src.TabOrderId;
  res.tabName = src.TabName;
  res.order = src.Order;
  res.associateId = src.AssociateId;
  return res;
}
function Create_TabOrderArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_TabOrder_From(src[i]);
    }
  }
  return res;
}
function Create_CheckLicenseStatusResult_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = {};
  res.licenseStatus = LicenseStatus[src.LicenseStatus];
  res.message = src.Message;
  res.url = src.Url;
  return res;
}
function Create_ExtendedLicenseInfo_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = {};
  res.reason = src.Reason;
  res.canBeActivated = src.CanBeActivated;
  res.new = Create_LicenseInfo_From(src.New);
  res.current = Create_LicenseInfo_From(src.Current);
  res.extendedModuleLicenses = Create_ExtendedModuleLicenseArray_From(src.ExtendedModuleLicenses);
  res.accumulatedNextCheckDate = Create_Date_From(src.AccumulatedNextCheckDate);
  return res;
}
function Create_ExtendedLicenseInfoArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_ExtendedLicenseInfo_From(src[i]);
    }
  }
  return res;
}
function Create_ExtendedModuleLicense_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = {};
  res.new = Create_ModuleLicense_From(src.New);
  res.current = Create_ModuleLicense_From(src.Current);
  res.numberOfLicensesInUse = src.NumberOfLicensesInUse;
  res.numberOfLicensesFree = src.NumberOfLicensesFree;
  res.numberOfLicensesAdded = src.NumberOfLicensesAdded;
  res.numberOfLicensesNewTotal = src.NumberOfLicensesNewTotal;
  res.numberOfLicensesNewFree = src.NumberOfLicensesNewFree;
  res.numberOfLicensesTotal = src.NumberOfLicensesTotal;
  return res;
}
function Create_ExtendedModuleLicenseArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_ExtendedModuleLicense_From(src[i]);
    }
  }
  return res;
}
function Create_LicenseInfo_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = {};
  res.companyName = src.CompanyName;
  res.serialNr = src.SerialNr;
  res.ownerName = src.OwnerName;
  res.ownerDescription = src.OwnerDescription;
  res.nextCheckDate = Create_Date_From(src.NextCheckDate);
  res.maintenanceDate = Create_Date_From(src.MaintenanceDate);
  res.adminWarningDate = Create_Date_From(src.AdminWarningDate);
  res.expiryDate = Create_Date_From(src.ExpiryDate);
  res.graceDate = Create_Date_From(src.GraceDate);
  res.extraFlags = src.ExtraFlags;
  res.licenseUrl = src.LicenseUrl;
  res.licenseVersion = src.LicenseVersion;
  res.deploymentType = src.DeploymentType;
  res.productType = src.ProductType;
  res.productDescription = src.ProductDescription;
  res.moduleLicenses = Create_ModuleLicenseArray_From(src.ModuleLicenses);
  res.publicKey = Create_SignedPublicKey_From(src.PublicKey);
  res.signature = src.Signature;
  return res;
}
function Create_LicenseOwner_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.name = src.Name;
  res.description = src.Description;
  res.restrictedModuleLicenses = Create_ModuleLicenseLinkArray_From(src.RestrictedModuleLicenses);
  res.unrestrictedModuleLicenses = Create_ModuleLicenseLinkArray_From(src.UnrestrictedModuleLicenses);
  return res;
}
function Create_LicenseOwnerArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_LicenseOwner_From(src[i]);
    }
  }
  return res;
}
function Create_LicenseResult_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.succeeded = src.Succeeded;
  res.reason = src.Reason;
  return res;
}
function Create_ModuleLicense_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = {};
  res.ownerName = src.OwnerName;
  res.moduleName = src.ModuleName;
  res.moduleDescription = src.ModuleDescription;
  res.moduleTooltip = src.ModuleTooltip;
  res.moduleVersion = src.ModuleVersion;
  res.licenseType = LicenseType[src.LicenseType];
  res.unrestricted = src.Unrestricted;
  res.allowedUserType = UserType[src.AllowedUserType];
  res.numberOfLicenses = src.NumberOfLicenses;
  res.extraFlags = src.ExtraFlags;
  res.extraInfo = src.ExtraInfo;
  res.sortOrder = src.SortOrder;
  res.isHidden = src.IsHidden;
  res.prerequisiteModuleName = src.PrerequisiteModuleName;
  res.signature = src.Signature;
  return res;
}
function Create_ModuleLicenseArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_ModuleLicense_From(src[i]);
    }
  }
  return res;
}
function Create_ModuleLicenseLink_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.unrestricted = src.Unrestricted;
  res.total = src.Total;
  res.tooltip = src.Tooltip;
  res.canAssign = src.CanAssign;
  res.free = src.Free;
  res.inUse = src.InUse;
  res.isHidden = src.IsHidden;
  res.assigned = src.Assigned;
  res.moduleLicenseId = src.ModuleLicenseId;
  res.name = src.Name;
  res.description = src.Description;
  res.prerequisiteModuleName = src.PrerequisiteModuleName;
  res.sortOrder = src.SortOrder;
  res.extraFlags = src.ExtraFlags;
  return res;
}
function Create_ModuleLicenseLinkArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_ModuleLicenseLink_From(src[i]);
    }
  }
  return res;
}
function Create_SignedPublicKey_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = {};
  res.ownerName = src.OwnerName;
  res.signDate = Create_Date_From(src.SignDate);
  res.expiryDate = Create_Date_From(src.ExpiryDate);
  res.key = Create_DSAParameters_From(src.Key);
  res.signature = src.Signature;
  return res;
}
function Create_AccessGatewayInfo_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.clientId = src.ClientId;
  res.redirectUri = src.RedirectUri;
  return res;
}
function Create_Credential_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.type = Create_CredentialType_From(src.Type);
  res.value = src.Value;
  res.displayValue = src.DisplayValue;
  return res;
}
function Create_CredentialArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_Credential_From(src[i]);
    }
  }
  return res;
}
function Create_CredentialsGroup_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.name = src.Name;
  res.displayName = src.DisplayName;
  return res;
}
function Create_CredentialsGroupArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_CredentialsGroup_From(src[i]);
    }
  }
  return res;
}
function Create_CredentialsGroupUsers_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.headings = src.Headings;
  res.users = Create_CredentialUserArray_From(src.Users);
  return res;
}
function Create_CredentialType_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.displayType = src.DisplayType;
  res.type = src.Type;
  res.description = src.Description;
  res.valueControl = CredentialControlType[src.ValueControl];
  res.canCreatePerson = src.CanCreatePerson;
  res.isUserNameSupported = src.IsUserNameSupported;
  return res;
}
function Create_CredentialTypeArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_CredentialType_From(src[i]);
    }
  }
  return res;
}
function Create_CredentialUser_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.value = src.Value;
  res.displayValue = src.DisplayValue;
  res.columns = src.Columns;
  res.canCreatePerson = src.CanCreatePerson;
  return res;
}
function Create_CredentialUserArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_CredentialUser_From(src[i]);
    }
  }
  return res;
}
function Create_DataRight_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.value = src.Value;
  res.description = src.Description;
  return res;
}
function Create_DataRightArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_DataRight_From(src[i]);
    }
  }
  return res;
}
function Create_DataRightArrayArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_DataRightArray_From(src[i]);
    }
  }
  return res;
}
function Create_DataRights_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.columnsInfo = Create_RelationToOwnerArray_From(src.ColumnsInfo);
  res.rowsInfo = Create_EntityNameArray_From(src.RowsInfo);
  res.rights = Create_DataRightArrayArray_From(src.Rights);
  return res;
}
function Create_EntityName_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.tableName = src.TableName;
  res.tableDescription = src.TableDescription;
  return res;
}
function Create_EntityNameArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_EntityName_From(src[i]);
    }
  }
  return res;
}
function Create_RelationToOwner_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.id = src.Id;
  res.value = src.Value;
  res.tooltip = src.Tooltip;
  return res;
}
function Create_RelationToOwnerArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_RelationToOwner_From(src[i]);
    }
  }
  return res;
}
function Create_ResolvedUser_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.user = Create_User_From(src.User);
  res.personCreated = src.PersonCreated;
  return res;
}
function Create_Role_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.id = src.Id;
  res.value = src.Value;
  res.tooltip = src.Tooltip;
  return res;
}
function Create_RoleEntity_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.roleId = src.RoleId;
  res.name = src.Name;
  res.tooltip = src.Tooltip;
  res.roleType = RoleType[src.RoleType];
  res.deleted = src.Deleted;
  res.rank = src.Rank;
  res.created = Create_Date_From(src.Created);
  res.useCategories = src.UseCategories;
  res.createdBy = Create_Associate_From(src.CreatedBy);
  res.updated = Create_Date_From(src.Updated);
  res.updatedBy = Create_Associate_From(src.UpdatedBy);
  res.dataRights = Create_DataRights_From(src.DataRights);
  return res;
}
function Create_ServiceAuth_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.serviceAuthId = src.ServiceAuthId;
  res.server = src.Server;
  res.port = src.Port;
  res.authType = src.AuthType;
  res.username = src.Username;
  res.password = src.Password;
  return res;
}
function Create_TokenManagementInfo_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.provider = src.Provider;
  res.accessToken = src.AccessToken;
  res.refreshToken = src.RefreshToken;
  return res;
}
function Create_UntrustedCredentials_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.validFrom = Create_Date_From(src.ValidFrom);
  res.validTo = Create_Date_From(src.ValidTo);
  res.comment = src.Comment;
  res.secretValue = src.SecretValue;
  res.publicValue = src.PublicValue;
  res.isActive = src.IsActive;
  return res;
}
function Create_UntrustedCredentialsArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_UntrustedCredentials_From(src[i]);
    }
  }
  return res;
}
function Create_User_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.associateId = src.AssociateId;
  res.name = src.Name;
  res.rank = src.Rank;
  res.tooltip = src.Tooltip;
  res.licenseOwners = Create_LicenseOwnerArray_From(src.LicenseOwners);
  res.role = Create_Role_From(src.Role);
  res.userGroup = Create_UserGroup_From(src.UserGroup);
  res.otherGroups = Create_UserGroupArray_From(src.OtherGroups);
  res.person = Create_Person_From(src.Person);
  res.deleted = src.Deleted;
  res.lastlogin = Create_Date_From(src.Lastlogin);
  res.lastlogout = Create_Date_From(src.Lastlogout);
  res.ejUserId = src.EjUserId;
  res.requestSignature = src.RequestSignature;
  res.type = UserType[src.Type];
  res.isPersonRetired = src.IsPersonRetired;
  res.isOnTravel = src.IsOnTravel;
  res.credentials = Create_CredentialArray_From(src.Credentials);
  res.userName = src.UserName;
  res.ticketCategories = Create_MDOListItemArray_From(src.TicketCategories);
  res.nickName = src.NickName;
  res.waitingForApproval = src.WaitingForApproval;
  res.extraFields = src.ExtraFields;
  res.customFields = src.CustomFields;
  res.postSaveCommands = Create_CustomCommandArray_From(src.PostSaveCommands);
  return res;
}
function Create_UserArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_User_From(src[i]);
    }
  }
  return res;
}
function Create_UserGroup_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.value = src.Value;
  res.tooltip = src.Tooltip;
  res.id = src.Id;
  res.rank = src.Rank;
  res.deleted = src.Deleted;
  return res;
}
function Create_UserGroupArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_UserGroup_From(src[i]);
    }
  }
  return res;
}
function Create_UserInfo_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.deleted = src.Deleted;
  res.userInfoId = src.UserInfoId;
  res.userName = src.UserName;
  res.personId = src.PersonId;
  res.rank = src.Rank;
  res.tooltip = src.Tooltip;
  res.userGroupId = src.UserGroupId;
  res.ejUserId = src.EjUserId;
  res.userType = UserType[src.UserType];
  res.grantedLicenses = src.GrantedLicenses;
  res.canLogon = src.CanLogon;
  res.roleName = src.RoleName;
  res.roleTooltip = src.RoleTooltip;
  res.userGroupName = src.UserGroupName;
  res.userGroupTooltip = src.UserGroupTooltip;
  return res;
}
function Create_UserInfoArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_UserInfo_From(src[i]);
    }
  }
  return res;
}
function Create_UserPresenceStatus_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = {};
  res.status = EjUserStatus[src.Status];
  res.message = src.Message;
  return res;
}
function Create_UserValidationResult_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.reason = src.Reason;
  res.result = src.Result;
  return res;
}
function Create_Area_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.areaId = src.AreaId;
  res.name = src.Name;
  res.maxDataAge = src.MaxDataAge;
  res.numberOfUsers = src.NumberOfUsers;
  res.numberOfLogins = src.NumberOfLogins;
  res.freetextEnabeled = src.FreetextEnabeled;
  return res;
}
function Create_AreaArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_Area_From(src[i]);
    }
  }
  return res;
}
function Create_Satellite_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.satelliteId = src.SatelliteId;
  res.created = Create_Date_From(src.Created);
  res.createdBy = Create_Associate_From(src.CreatedBy);
  res.updated = Create_Date_From(src.Updated);
  res.updatedBy = Create_Associate_From(src.UpdatedBy);
  res.contact = Create_Contact_From(src.Contact);
  res.area = Create_Area_From(src.Area);
  res.licenseOwners = Create_LicenseOwnerArray_From(src.LicenseOwners);
  return res;
}
function Create_PreferredTimeZone_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = {};
  res.preferenceId = src.PreferenceId;
  res.tZLocationId = src.TZLocationId;
  res.locationCode = src.LocationCode;
  res.description = src.Description;
  res.country = src.Country;
  res.bias = src.Bias;
  return res;
}
function Create_TimeZoneData_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = {};
  res.tZLocationID = src.TZLocationID;
  res.name = src.Name;
  res.tZLocationCode = src.TZLocationCode;
  res.tZLocationCities = src.TZLocationCities;
  res.isoNumber = src.IsoNumber;
  res.timeZoneSTDRules = Create_TimeZoneRuleDictionary_From(src.TimeZoneSTDRules);
  res.timeZoneDSTRules = Create_TimeZoneRuleDictionary_From(src.TimeZoneDSTRules);
  return res;
}
function Create_TimeZoneDataArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_TimeZoneData_From(src[i]);
    }
  }
  return res;
}
function Create_TimeZoneRule_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = {};
  res.tZOffset = src.TZOffset;
  res.startRulePattern = src.StartRulePattern;
  res.endRulePattern = src.EndRulePattern;
  res.startDay = src.StartDay;
  res.startMonth = src.StartMonth;
  res.endDay = src.EndDay;
  res.endMonth = src.EndMonth;
  return res;
}
function Create_TimeZoneRuleDictionary_From(src) {
  let res = src;
  if (res) {
    for (let i in res) {
      res[i] = Create_TimeZoneRule_From(src[i]);
    }
  }
  return res;
}
function Create_MessageDeliveryStatus_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.status = src.Status;
  res.statusDescription = src.StatusDescription;
  res.messagingId = src.MessagingId;
  return res;
}
function Create_MessageDeliveryStatusArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_MessageDeliveryStatus_From(src[i]);
    }
  }
  return res;
}
function Create_ProviderInfo_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.name = src.Name;
  res.supportedMessagingFormats = src.SupportedMessagingFormats;
  res.supportsConfig = src.SupportsConfig;
  return res;
}
function Create_ProviderInfoArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_ProviderInfo_From(src[i]);
    }
  }
  return res;
}
function Create_ImportLine_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.values = src.Values;
  res.selected = src.Selected;
  res.operation = Create_ImportAction_From(src.Operation);
  res.type = Create_ImportEntityType_From(src.Type);
  res.externalKey = src.ExternalKey;
  return res;
}
function Create_ImportLineArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_ImportLine_From(src[i]);
    }
  }
  return res;
}
function Create_ImportColumnInfo_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.name = src.Name;
  res.displayName = src.DisplayName;
  res.locked = src.Locked;
  return res;
}
function Create_ImportColumnInfoArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_ImportColumnInfo_From(src[i]);
    }
  }
  return res;
}
function Create_ImportErpData_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.importLines = Create_ImportLineArray_From(src.ImportLines);
  res.columnInfos = Create_ImportColumnInfoArray_From(src.ColumnInfos);
  return res;
}
function Create_FreeText_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.freeTextEnabled = src.FreeTextEnabled;
  res.singleWordOperator = FreeTextOperator[src.SingleWordOperator];
  res.multiWordOperator = FreeTextOperator[src.MultiWordOperator];
  res.countWords = src.CountWords;
  res.occurrences = src.Occurrences;
  res.lastGenerated = Create_Date_From(src.LastGenerated);
  res.autoEnableTravelAreas = src.AutoEnableTravelAreas;
  return res;
}
function Create_RefCountEntity_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.refCountsId = src.RefCountsId;
  res.field = src.Field;
  res.recordId = src.RecordId;
  res.suggestedRecords = Create_MDOListItemArray_From(src.SuggestedRecords);
  res.currentValue = src.CurrentValue;
  res.travelPrefix = src.TravelPrefix;
  res.satPrefix = src.SatPrefix;
  res.allocate = src.Allocate;
  res.unique = src.Unique;
  res.readOnly = src.ReadOnly;
  res.allowBlank = src.AllowBlank;
  return res;
}
function Create_CsSessionKey_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.key = src.Key;
  res.loginId = src.LoginId;
  res.userId = src.UserId;
  return res;
}
function Create_CustomerCenterConfig_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.custConfigId = src.CustConfigId;
  res.type = ConfigType[src.Type];
  res.config = src.Config;
  res.custLangId = src.CustLangId;
  res.registered = Create_Date_From(src.Registered);
  res.registeredAssociateId = src.RegisteredAssociateId;
  res.updated = Create_Date_From(src.Updated);
  res.updatedAssociateId = src.UpdatedAssociateId;
  return res;
}
function Create_CustomerCenterConfigArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_CustomerCenterConfig_From(src[i]);
    }
  }
  return res;
}
function Create_CustomerServiceStartup_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.timezoneEnabled = src.TimezoneEnabled;
  res.tZOffset = src.TZOffset;
  res.recaptchaSiteKey = src.RecaptchaSiteKey;
  return res;
}
function Create_EventData_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.type = EventHandlerType[src.Type];
  res.inputValues = Create_StringDictionary_From(src.InputValues);
  res.blockExecution = src.BlockExecution;
  res.navigateTo = src.NavigateTo;
  res.message = src.Message;
  res.showDialog = src.ShowDialog;
  res.outputValues = Create_StringDictionary_From(src.OutputValues);
  res.stateValues = Create_StringDictionary_From(src.StateValues);
  res.exception = src.Exception;
  res.parserValues = Create_StringDictionary_From(src.ParserValues);
  return res;
}
function Create_KbCategory_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = {};
  res.kbCategoryId = src.KbCategoryId;
  res.name = src.Name;
  res.description = src.Description;
  res.fullname = src.Fullname;
  res.parentId = src.ParentId;
  res.sortOrder = src.SortOrder;
  return res;
}
function Create_Mailbox_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.mailInFilterId = src.MailInFilterId;
  res.address = src.Address;
  res.categoryName = src.CategoryName;
  res.priorityName = src.PriorityName;
  return res;
}
function Create_MailboxArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_Mailbox_From(src[i]);
    }
  }
  return res;
}
function Create_MailboxEntity_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.mailInFilterId = src.MailInFilterId;
  res.serverType = MailboxType[src.ServerType];
  res.address = src.Address;
  res.username = src.Username;
  res.password = src.Password;
  res.server = src.Server;
  res.port = src.Port;
  return res;
}
function Create_PreviewFaqEntry_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.title = src.Title;
  res.registeredByFullName = src.RegisteredByFullName;
  res.updated = Create_Date_From(src.Updated);
  res.question = src.Question;
  res.answer = src.Answer;
  return res;
}
function Create_PreviewQuickReply_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.name = src.Name;
  res.updatedByFullName = src.UpdatedByFullName;
  res.updated = Create_Date_From(src.Updated);
  res.htmlBody = src.HtmlBody;
  return res;
}
function Create_PreviewReplyTemplate_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.name = src.Name;
  res.description = src.Description;
  res.ownedByFullName = src.OwnedByFullName;
  res.updated = Create_Date_From(src.Updated);
  res.body = src.Body;
  res.isHtml = src.IsHtml;
  return res;
}
function Create_ReplyTemplate_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = {};
  res.replyTemplateId = src.ReplyTemplateId;
  res.name = src.Name;
  res.description = src.Description;
  res.folderId = src.FolderId;
  return res;
}
function Create_ReplyTemplateParsed_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.replyTemplateId = src.ReplyTemplateId;
  res.plainParsed = src.PlainParsed;
  res.htmlParsed = src.HtmlParsed;
  res.attachments = Create_AttachmentEntityArray_From(src.Attachments);
  res.subject = src.Subject;
  return res;
}
function Create_SmsConfig_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.defaultSmsCountry = src.DefaultSmsCountry;
  res.netServerSmsProvider = src.NetServerSmsProvider;
  res.nsPluginSender = src.NsPluginSender;
  res.nsPluginConfig = Create_StringDictionary_From(src.NsPluginConfig);
  return res;
}
function Create_SmtpTestResult_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.success = src.Success;
  res.errorMessage = src.ErrorMessage;
  return res;
}
function Create_StatisticsDataSet_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.label = src.Label;
  res.values = Create_StatisticsDataValueArray_From(src.Values);
  res.description = src.Description;
  return res;
}
function Create_StatisticsDataSetArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_StatisticsDataSet_From(src[i]);
    }
  }
  return res;
}
function Create_StatisticsDataValue_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.label = src.Label;
  res.value = src.Value;
  res.description = src.Description;
  return res;
}
function Create_StatisticsDataValueArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_StatisticsDataValue_From(src[i]);
    }
  }
  return res;
}
function Create_SystemTemplateSettings_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.customerNewCustomerTemplateId = src.CustomerNewCustomerTemplateId;
  res.customerCustomerReplyTemplateId = src.CustomerCustomerReplyTemplateId;
  res.customerPasswordTemplateId = src.CustomerPasswordTemplateId;
  res.customerConfirmEmailTemplateId = src.CustomerConfirmEmailTemplateId;
  res.customerChatLogTemplateId = src.CustomerChatLogTemplateId;
  res.newLinkTemplateId = src.NewLinkTemplateId;
  res.hotlistNewMessageTemplateId = src.HotlistNewMessageTemplateId;
  res.hotlistTicketActivatedTemplateId = src.HotlistTicketActivatedTemplateId;
  res.userTicketAlarmTemplateId = src.UserTicketAlarmTemplateId;
  res.hotlistTicketTakenOverTemplateId = src.HotlistTicketTakenOverTemplateId;
  res.userActiveTicketsTemplateId = src.UserActiveTicketsTemplateId;
  res.userNewMessageTemplateId = src.UserNewMessageTemplateId;
  res.userTicketActivatedTemplateId = src.UserTicketActivatedTemplateId;
  res.userNewTicketTemplateId = src.UserNewTicketTemplateId;
  res.publishKbQuestionTemplateId = src.PublishKbQuestionTemplateId;
  res.publishKbAnswerTemplateId = src.PublishKbAnswerTemplateId;
  res.userTicketTakenOverTemplateId = src.UserTicketTakenOverTemplateId;
  res.printTicketTemplateId = src.PrintTicketTemplateId;
  res.weekStatTemplateId = src.WeekStatTemplateId;
  res.ticketAlarmHotlistTemplateId = src.TicketAlarmHotlistTemplateId;
  res.emailAddresses = src.EmailAddresses;
  return res;
}
function Create_TicketInfo_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.ticketId = src.TicketId;
  res.title = src.Title;
  res.ownerName = src.OwnerName;
  res.categoryName = src.CategoryName;
  res.priorityName = src.PriorityName;
  res.ticketUrl = src.TicketUrl;
  res.personName = src.PersonName;
  res.contactName = src.ContactName;
  return res;
}
function Create_TicketInfoArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_TicketInfo_From(src[i]);
    }
  }
  return res;
}
function Create_CallerID_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = {};
  res.phoneNumber = src.PhoneNumber;
  res.dialInPrefix = src.DialInPrefix;
  res.personId = src.PersonId;
  res.personName = src.PersonName;
  res.mrmrs = src.Mrmrs;
  res.contactId = src.ContactId;
  res.contactName = src.ContactName;
  return res;
}
function Create_CallerIDArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_CallerID_From(src[i]);
    }
  }
  return res;
}
function Create_CallerIDCollection_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = {};
  res.callerIDHash = src.CallerIDHash;
  res.callerIDs = Create_CallerIDArray_From(src.CallerIDs);
  return res;
}
function Create_PocketDeviceInfo_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = {};
  res.deviceName = src.DeviceName;
  res.deviceIdentifier = src.DeviceIdentifier;
  res.pocketVersion = src.PocketVersion;
  res.language = src.Language;
  res.pNSHandle = src.PNSHandle;
  res.platform = NotificationPlatform[src.Platform];
  res.oSVersion = src.OSVersion;
  res.timeZoneId = src.TimeZoneId;
  return res;
}
function Create_PocketDeviceInfoArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_PocketDeviceInfo_From(src[i]);
    }
  }
  return res;
}
function Create_PocketStartupData_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.tableRights = Create_ETableRight_From(src.TableRights);
  res.phoneLocaleTimeZoneData = Create_TimeZoneData_From(src.PhoneLocaleTimeZoneData);
  res.baseLocaleTimeZoneData = Create_TimeZoneData_From(src.BaseLocaleTimeZoneData);
  res.overdueSalesCount = src.OverdueSalesCount;
  res.notificationsCount = src.NotificationsCount;
  res.systemWebPanels = Create_WebPanelEntityArray_From(src.SystemWebPanels);
  res.pocketPreferences = Create_PreferenceArray_From(src.PocketPreferences);
  res.isPushNotificationEnabled = src.IsPushNotificationEnabled;
  res.customData = src.CustomData;
  return res;
}
function Create_Dashboard_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.dashboardId = src.DashboardId;
  res.associateId = src.AssociateId;
  res.caption = src.Caption;
  res.layout = DashboardLayout[src.Layout];
  res.tiles = Create_DashboardTileArray_From(src.Tiles);
  return res;
}
function Create_DashboardArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_Dashboard_From(src[i]);
    }
  }
  return res;
}
function Create_DashboardTile_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.dashboardTileId = src.DashboardTileId;
  res.caption = src.Caption;
  res.description = src.Description;
  res.chartName = src.ChartName;
  res.chartId = src.ChartId;
  res.isDefault = src.IsDefault;
  res.associateId = src.AssociateId;
  res.groupId = src.GroupId;
  res.selectionId = src.SelectionId;
  res.config = src.Config;
  res.type = DashboardTileType[src.Type];
  res.entityType = DashboardTileEntityType[src.EntityType];
  res.options = Create_DashboardTileOptionArray_From(src.Options);
  res.visibleFor = Create_VisibleForArray_From(src.VisibleFor);
  return res;
}
function Create_DashboardTileArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_DashboardTile_From(src[i]);
    }
  }
  return res;
}
function Create_DashboardTileOption_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.name = src.Name;
  res.description = src.Description;
  res.type = DashboardTileOptionType[src.Type];
  res.listName = src.ListName;
  res.listItems = Create_MDOListItemArray_From(src.ListItems);
  res.value = src.Value;
  res.defaultDataOption = src.DefaultDataOption;
  return res;
}
function Create_DashboardTileOptionArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_DashboardTileOption_From(src[i]);
    }
  }
  return res;
}
function Create_TileData_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = {};
  res.columns = Create_ArchiveColumnInfoArray_From(src.Columns);
  res.result = Create_ArchiveListResult_From(src.Result);
  return res;
}
function Create_TileDataArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_TileData_From(src[i]);
    }
  }
  return res;
}
function Create_Dash_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.dashboardId = src.DashboardId;
  res.uniqueId = src.UniqueId;
  res.name = src.Name;
  res.description = src.Description;
  res.associateId = src.AssociateId;
  res.columns = src.Columns;
  res.theme = Create_DashTheme_From(src.Theme);
  res.visibleForAll = src.VisibleForAll;
  res.visibleForAssociates = src.VisibleForAssociates;
  res.visibleForGroups = src.VisibleForGroups;
  res.pinForAll = src.PinForAll;
  res.pinForAssociates = src.PinForAssociates;
  res.pinForGroups = src.PinForGroups;
  return res;
}
function Create_DashArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_Dash_From(src[i]);
    }
  }
  return res;
}
function Create_DashCollection_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.pinned = Create_DashArray_From(src.Pinned);
  res.favourites = Create_DashArray_From(src.Favourites);
  res.other = Create_DashArray_From(src.Other);
  return res;
}
function Create_DashTheme_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.dashboardThemeId = src.DashboardThemeId;
  res.name = src.Name;
  res.config = src.Config;
  res.rank = src.Rank;
  res.client = src.Client;
  res.style = src.Style;
  return res;
}
function Create_DashTile_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.dashboardTileId = src.DashboardTileId;
  res.dashboardId = src.DashboardId;
  res.height = src.Height;
  res.width = src.Width;
  res.rank = src.Rank;
  res.dashTileDefinition = Create_DashTileDefinition_From(src.DashTileDefinition);
  return res;
}
function Create_DashTileArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_DashTile_From(src[i]);
    }
  }
  return res;
}
function Create_DashTileDefinition_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.dashboardTileDefinitionId = src.DashboardTileDefinitionId;
  res.name = src.Name;
  res.description = src.Description;
  res.defaultHeight = src.DefaultHeight;
  res.defaultWidth = src.DefaultWidth;
  res.tileType = DashTileType[src.TileType];
  res.entityType = DashTileEntityType[src.EntityType];
  res.entityName = src.EntityName;
  res.selectionId = src.SelectionId;
  res.currencyMode = DashTileCurrencyMode[src.CurrencyMode];
  res.currencyCode = src.CurrencyCode;
  res.measure = DashTileMeasure[src.Measure];
  res.measureField = src.MeasureField;
  res.sortBy = src.SortBy;
  res.layoutConfig = src.LayoutConfig;
  res.secondarySelectionId = src.SecondarySelectionId;
  res.measureByField = src.MeasureByField;
  res.usage = Create_DashTileUsage_From(src.Usage);
  res.providerName = src.ProviderName;
  return res;
}
function Create_DashTileHtml_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.languageCode = src.LanguageCode;
  res.html = src.Html;
  return res;
}
function Create_DashTileHtmlArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_DashTileHtml_From(src[i]);
    }
  }
  return res;
}
function Create_PreviewDash_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.name = src.Name;
  res.description = src.Description;
  res.ownedByFullName = src.OwnedByFullName;
  res.registered = Create_Date_From(src.Registered);
  res.tiles = Create_PreviewDashTileArray_From(src.Tiles);
  return res;
}
function Create_PreviewDashTile_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.name = src.Name;
  res.tileType = DashTileType[src.TileType];
  return res;
}
function Create_PreviewDashTileArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_PreviewDashTile_From(src[i]);
    }
  }
  return res;
}
function Create_TargetAssignment_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.targetAssignmentInfoId = src.TargetAssignmentInfoId;
  res.values = src.Values;
  res.locked = src.Locked;
  res.targetAssociate = Create_Associate_From(src.TargetAssociate);
  res.targetContact = Create_Contact_From(src.TargetContact);
  res.targetUserGroup = Create_UserGroup_From(src.TargetUserGroup);
  res.currency = Create_Currency_From(src.Currency);
  res.dimensionListItem = src.DimensionListItem;
  res.dimensionListItemDisplayName = src.DimensionListItemDisplayName;
  return res;
}
function Create_TargetAssignmentArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_TargetAssignment_From(src[i]);
    }
  }
  return res;
}
function Create_TargetChange_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.fieldIdentifier = src.FieldIdentifier;
  res.valueChangeFrom = src.ValueChangeFrom;
  res.valueChangeTo = src.ValueChangeTo;
  return res;
}
function Create_TargetChangeArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_TargetChange_From(src[i]);
    }
  }
  return res;
}
function Create_TargetDimension_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.targetDimensionId = src.TargetDimensionId;
  res.assignmentLevel = Create_TargetAssignementLevel_From(src.AssignmentLevel);
  res.entityType = TargetEntityType[src.EntityType];
  res.measurementUnit = TargetMeasurementUnit[src.MeasurementUnit];
  res.dimensionListField = src.DimensionListField;
  res.dimensionListName = src.DimensionListName;
  res.dimensionListId = src.DimensionListId;
  res.dimensionListLabel = src.DimensionListLabel;
  res.selectedDimensions = src.SelectedDimensions;
  return res;
}
function Create_TargetDimensionArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_TargetDimension_From(src[i]);
    }
  }
  return res;
}
function Create_TargetGroup_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.targetGroupId = src.TargetGroupId;
  res.year = src.Year;
  res.entityType = TargetEntityType[src.EntityType];
  res.periodType = TargetPeriodType[src.PeriodType];
  res.targetAssignments = Create_TargetAssignmentArray_From(src.TargetAssignments);
  res.targetDimension = Create_TargetDimension_From(src.TargetDimension);
  return res;
}
function Create_TargetRevision_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.logEvent = LogEvent[src.LogEvent];
  res.who = Create_Associate_From(src.Who);
  res.when = Create_Date_From(src.When);
  res.changes = Create_TargetChangeArray_From(src.Changes);
  return res;
}
function Create_TargetRevisionArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_TargetRevision_From(src[i]);
    }
  }
  return res;
}
function Create_TargetRevisionHistory_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.targetGroupId = src.TargetGroupId;
  res.year = src.Year;
  res.revisions = Create_TargetRevisionArray_From(src.Revisions);
  return res;
}
function Create_Favourite_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.tableName = src.TableName;
  res.recordId = src.RecordId;
  res.associateId = src.AssociateId;
  res.extraInfo = src.ExtraInfo;
  res.rank = src.Rank;
  return res;
}
function Create_FavouriteArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_Favourite_From(src[i]);
    }
  }
  return res;
}
function Create_DictionaryStepInformation_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.name = src.Name;
  res.stepNumber = src.StepNumber;
  return res;
}
function Create_DictionaryStepInformationArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_DictionaryStepInformation_From(src[i]);
    }
  }
  return res;
}
function Create_ControlInfo_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.type = src.Type;
  res.label = src.Label;
  res.dimension = src.Dimension;
  res.listProviderName = src.ListProviderName;
  res.listProviderExtraInfo = src.ListProviderExtraInfo;
  res.listProviderPrimaryKeyName = src.ListProviderPrimaryKeyName;
  res.listLeadText = src.ListLeadText;
  return res;
}
function Create_ControlInfoArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_ControlInfo_From(src[i]);
    }
  }
  return res;
}
function Create_FieldValueInfo_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = {};
  res.canSupportMultiUse = src.CanSupportMultiUse;
  res.defaultShowInGui = src.DefaultShowInGui;
  res.defaultShowInSelector = src.DefaultShowInSelector;
  res.isActive = src.IsActive;
  res.key = src.Key;
  res.valueType = src.ValueType;
  res.mandatory = src.Mandatory;
  res.encodedDisplayName = src.EncodedDisplayName;
  res.encodedDisplayDescription = src.EncodedDisplayDescription;
  res.iconHint = src.IconHint;
  res.controlInfos = Create_ControlInfoArray_From(src.ControlInfos);
  res.encodedDataCaption = src.EncodedDataCaption;
  res.encodedDataCaptionDescription = src.EncodedDataCaptionDescription;
  res.currentOperationType = src.CurrentOperationType;
  res.values = src.Values;
  res.displayValues = src.DisplayValues;
  res.operationInfos = Create_OperationInfoArray_From(src.OperationInfos);
  return res;
}
function Create_FieldValueInfoArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_FieldValueInfo_From(src[i]);
    }
  }
  return res;
}
function Create_OperationInfo_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.key = src.Key;
  res.encodedDisplayName = src.EncodedDisplayName;
  res.encodedLeadTexts = src.EncodedLeadTexts;
  return res;
}
function Create_OperationInfoArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_OperationInfo_From(src[i]);
    }
  }
  return res;
}
function Create_FormEntity_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.formId = src.FormId;
  res.formKey = src.FormKey;
  res.name = src.Name;
  res.description = src.Description;
  res.config = src.Config;
  res.folderId = src.FolderId;
  res.scriptId = src.ScriptId;
  res.responseShipmentId = src.ResponseShipmentId;
  res.active = src.Active;
  res.expires = Create_Date_From(src.Expires);
  res.maxSubmits = src.MaxSubmits;
  res.type = FormType[src.Type];
  res.recipe = src.Recipe;
  res.groupId = src.GroupId;
  res.newTicket = src.NewTicket;
  res.recaptchaMode = FormsRecaptchaMode[src.RecaptchaMode];
  res.registered = Create_Date_From(src.Registered);
  res.registeredAssociateId = src.RegisteredAssociateId;
  res.updated = Create_Date_From(src.Updated);
  res.updatedAssociateId = src.UpdatedAssociateId;
  res.updatedCount = src.UpdatedCount;
  res.folderName = src.FolderName;
  return res;
}
function Create_FormSubmissionEntity_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.formSubmissionId = src.FormSubmissionId;
  res.formId = src.FormId;
  res.whenSubmitted = Create_Date_From(src.WhenSubmitted);
  res.contactId = src.ContactId;
  res.personId = src.PersonId;
  res.emailAddress = src.EmailAddress;
  res.responseShipmentAddrId = src.ResponseShipmentAddrId;
  res.response = src.Response;
  res.status = FormSubmissionStatus[src.Status];
  res.processingLog = src.ProcessingLog;
  return res;
}
function Create_PreviewMailing_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.sendingTime = Create_Date_From(src.SendingTime);
  res.status = ShipmentAddrStatus[src.Status];
  res.shipmentId = src.ShipmentId;
  res.shipmentDescription = src.ShipmentDescription;
  res.fromAddress = src.FromAddress;
  res.contactId = src.ContactId;
  res.contactName = src.ContactName;
  res.personId = src.PersonId;
  res.personFullName = src.PersonFullName;
  res.shipmentType = src.ShipmentType;
  res.messageId = src.MessageId;
  res.messageSubject = src.MessageSubject;
  res.documentMessageId = src.DocumentMessageId;
  res.opened = Create_Date_From(src.Opened);
  res.linkClicks = src.LinkClicks;
  return res;
}
function Create_PreviewMailingHeader_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.startDate = Create_Date_From(src.StartDate);
  res.status = ShipmentStatus[src.Status];
  res.shipmentId = src.ShipmentId;
  res.shipmentDescription = src.ShipmentDescription;
  res.fromAddress = src.FromAddress;
  res.personId = src.PersonId;
  res.personFullName = src.PersonFullName;
  res.shipmentType = src.ShipmentType;
  res.messageId = src.MessageId;
  res.messageSubject = src.MessageSubject;
  res.documentMessageId = src.DocumentMessageId;
  res.numSent = src.NumSent;
  res.numOpened = src.NumOpened;
  res.numBounced = src.NumBounced;
  res.numClicks = src.NumClicks;
  return res;
}
function Create_ShipmentMessageBlockEntity_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.shipmentMessageBlockId = src.ShipmentMessageBlockId;
  res.associateId = src.AssociateId;
  res.block = src.Block;
  res.registered = Create_Date_From(src.Registered);
  res.registeredAssociateId = src.RegisteredAssociateId;
  res.updated = Create_Date_From(src.Updated);
  res.updatedAssociateId = src.UpdatedAssociateId;
  res.updatedCount = src.UpdatedCount;
  return res;
}
function Create_ShipmentMessageBlockEntityArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_ShipmentMessageBlockEntity_From(src[i]);
    }
  }
  return res;
}
function Create_ShipmentMessageEntity_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.shipmentMessageId = src.ShipmentMessageId;
  res.plainMessage = src.PlainMessage;
  res.htmlMessage = src.HtmlMessage;
  res.smsMessage = src.SmsMessage;
  res.description = src.Description;
  res.subject = src.Subject;
  res.folderId = src.FolderId;
  res.headerField = src.HeaderField;
  res.design = src.Design;
  res.designtype = DesignType[src.Designtype];
  res.flags = Create_ShipmentMessageType_From(src.Flags);
  res.registerViews = src.RegisterViews;
  res.inlineImages = src.InlineImages;
  res.longDescription = src.LongDescription;
  res.accessKey = src.AccessKey;
  res.documentMessage = src.DocumentMessage;
  res.registered = Create_Date_From(src.Registered);
  res.registeredAssociateId = src.RegisteredAssociateId;
  res.updated = Create_Date_From(src.Updated);
  res.updatedAssociateId = src.UpdatedAssociateId;
  res.updatedCount = src.UpdatedCount;
  return res;
}
function Create_Script_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.uniqueIdentifier = src.UniqueIdentifier;
  res.name = src.Name;
  res.description = src.Description;
  res.includeId = src.IncludeId;
  res.source = src.Source;
  res.registered = Create_Date_From(src.Registered);
  res.registeredBy = src.RegisteredBy;
  res.updated = Create_Date_From(src.Updated);
  res.updatedBy = src.UpdatedBy;
  res.path = src.Path;
  return res;
}
function Create_CRMScriptEntity_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.ejscriptId = src.EjscriptId;
  res.uniqueIdentifier = src.UniqueIdentifier;
  res.name = src.Name;
  res.description = src.Description;
  res.includeId = src.IncludeId;
  res.hierarchyId = src.HierarchyId;
  res.source = src.Source;
  res.registered = Create_Date_From(src.Registered);
  res.registeredAssociateId = src.RegisteredAssociateId;
  res.updated = Create_Date_From(src.Updated);
  res.updatedAssociateId = src.UpdatedAssociateId;
  return res;
}
function Create_CRMScriptErrorInfo_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.errorMessage = src.ErrorMessage;
  res.errorLine = src.ErrorLine;
  res.errorCharacterPosition = src.ErrorCharacterPosition;
  return res;
}
function Create_CRMScriptResult_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.valid = src.Valid;
  res.errorMessage = src.ErrorMessage;
  res.lineNumber = src.LineNumber;
  res.errorInformation = Create_CRMScriptErrorInfo_From(src.ErrorInformation);
  return res;
}
function Create_CRMScriptRunResult_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.output = src.Output;
  res.parameters = Create_StringDictionary_From(src.Parameters);
  res.trace = src.Trace;
  res.eventdata = Create_EventData_From(src.Eventdata);
  res.success = src.Success;
  res.errorInformation = Create_CRMScriptErrorInfo_From(src.ErrorInformation);
  return res;
}
function Create_TriggerScriptEntity_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.screenChooserId = src.ScreenChooserId;
  res.name = src.Name;
  res.screenType = EventHandlerType[src.ScreenType];
  res.enabled = src.Enabled;
  res.uniqueIdentifier = src.UniqueIdentifier;
  res.source = src.Source;
  res.registered = Create_Date_From(src.Registered);
  res.registeredAssociateId = src.RegisteredAssociateId;
  res.updated = Create_Date_From(src.Updated);
  res.updatedAssociateId = src.UpdatedAssociateId;
  return res;
}
function Create_AttachmentEntity_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.attachmentId = src.AttachmentId;
  res.name = src.Name;
  res.contentType = src.ContentType;
  res.attSize = src.AttSize;
  res.inlineImage = src.InlineImage;
  res.contentId = src.ContentId;
  res.authKey = src.AuthKey;
  return res;
}
function Create_AttachmentEntityArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_AttachmentEntity_From(src[i]);
    }
  }
  return res;
}
function Create_AttachmentValidationResult_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = {};
  res.attachmentId = src.AttachmentId;
  res.isValid = src.IsValid;
  res.errorMessage = src.ErrorMessage;
  return res;
}
function Create_AttachmentValidationResultArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_AttachmentValidationResult_From(src[i]);
    }
  }
  return res;
}
function Create_Ticket_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.ticketId = src.TicketId;
  res.title = src.Title;
  res.createdAt = Create_Date_From(src.CreatedAt);
  res.lastChanged = Create_Date_From(src.LastChanged);
  res.readByOwner = Create_Date_From(src.ReadByOwner);
  res.readByCustomer = Create_Date_From(src.ReadByCustomer);
  res.firstReadByUser = Create_Date_From(src.FirstReadByUser);
  res.activate = Create_Date_From(src.Activate);
  res.closedAt = Create_Date_From(src.ClosedAt);
  res.repliedAt = Create_Date_From(src.RepliedAt);
  res.alertTimeout = Create_Date_From(src.AlertTimeout);
  res.deadline = Create_Date_From(src.Deadline);
  res.createdBy = src.CreatedBy;
  res.createdByName = src.CreatedByName;
  res.author = src.Author;
  res.ownedBy = src.OwnedBy;
  res.ownedByName = src.OwnedByName;
  res.category = src.Category;
  res.categoryName = src.CategoryName;
  res.categoryFullname = src.CategoryFullname;
  res.slevel = TicketSecurityLevel[src.Slevel];
  res.priority = src.Priority;
  res.priorityName = src.PriorityName;
  res.baseStatus = TicketBaseStatus[src.BaseStatus];
  res.ticketStatus = src.TicketStatus;
  res.ticketStatusDisplayValue = src.TicketStatusDisplayValue;
  res.origin = TicketOrigin[src.Origin];
  res.custId = src.CustId;
  res.personFirstname = src.PersonFirstname;
  res.personMiddleName = src.PersonMiddleName;
  res.personLastname = src.PersonLastname;
  res.personFullname = src.PersonFullname;
  res.alertLevel = src.AlertLevel;
  res.connectId = src.ConnectId;
  res.readStatus = TicketReadStatus[src.ReadStatus];
  res.timeToReply = src.TimeToReply;
  res.realTimeToReply = src.RealTimeToReply;
  res.timeToClose = src.TimeToClose;
  res.realTimeToClose = src.RealTimeToClose;
  res.timeSpentInternally = src.TimeSpentInternally;
  res.timeSpentExternally = src.TimeSpentExternally;
  res.timeSpentQueue = src.TimeSpentQueue;
  res.realTimeSpentInternally = src.RealTimeSpentInternally;
  res.realTimeSpentExternally = src.RealTimeSpentExternally;
  res.realTimeSpentQueue = src.RealTimeSpentQueue;
  res.timeSpent = src.TimeSpent;
  res.hasAttachment = src.HasAttachment;
  res.numReplies = src.NumReplies;
  res.numMessages = src.NumMessages;
  res.fromAddress = src.FromAddress;
  res.contactId = src.ContactId;
  res.contactName = src.ContactName;
  res.ownedByAssociateId = src.OwnedByAssociateId;
  res.language = src.Language;
  res.sentiment = src.Sentiment;
  res.sentimentConfidence = src.SentimentConfidence;
  res.saleId = src.SaleId;
  res.projectId = src.ProjectId;
  res.saleHeading = src.SaleHeading;
  res.projectName = src.ProjectName;
  res.formSubmissionId = src.FormSubmissionId;
  return res;
}
function Create_TicketArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_Ticket_From(src[i]);
    }
  }
  return res;
}
function Create_TicketEntity_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.ticketId = src.TicketId;
  res.title = src.Title;
  res.createdAt = Create_Date_From(src.CreatedAt);
  res.lastChanged = Create_Date_From(src.LastChanged);
  res.readByOwner = Create_Date_From(src.ReadByOwner);
  res.readByCustomer = Create_Date_From(src.ReadByCustomer);
  res.firstReadByOwner = Create_Date_From(src.FirstReadByOwner);
  res.firstReadByUser = Create_Date_From(src.FirstReadByUser);
  res.activate = Create_Date_From(src.Activate);
  res.closedAt = Create_Date_From(src.ClosedAt);
  res.repliedAt = Create_Date_From(src.RepliedAt);
  res.alertTimeout = Create_Date_From(src.AlertTimeout);
  res.deadline = Create_Date_From(src.Deadline);
  res.createdBy = Create_Associate_From(src.CreatedBy);
  res.author = src.Author;
  res.ownedBy = Create_Associate_From(src.OwnedBy);
  res.category = Create_TicketCategoryEntity_From(src.Category);
  res.slevel = TicketSecurityLevel[src.Slevel];
  res.priority = Create_TicketPriorityEntity_From(src.Priority);
  res.baseStatus = TicketBaseStatus[src.BaseStatus];
  res.status = Create_TicketStatusEntity_From(src.Status);
  res.origin = TicketOrigin[src.Origin];
  res.person = Create_Person_From(src.Person);
  res.secondaryPersons = Create_PersonArray_From(src.SecondaryPersons);
  res.alertLevel = src.AlertLevel;
  res.connectId = src.ConnectId;
  res.readStatus = TicketReadStatus[src.ReadStatus];
  res.timeToReply = src.TimeToReply;
  res.realTimeToReply = src.RealTimeToReply;
  res.timeToClose = src.TimeToClose;
  res.realTimeToClose = src.RealTimeToClose;
  res.timeSpentInternally = src.TimeSpentInternally;
  res.timeSpentExternally = src.TimeSpentExternally;
  res.timeSpentQueue = src.TimeSpentQueue;
  res.realTimeSpentInternally = src.RealTimeSpentInternally;
  res.realTimeSpentExternally = src.RealTimeSpentExternally;
  res.realTimeSpentQueue = src.RealTimeSpentQueue;
  res.timeSpent = src.TimeSpent;
  res.hasAttachment = src.HasAttachment;
  res.numReplies = src.NumReplies;
  res.numMessages = src.NumMessages;
  res.fromAddress = src.FromAddress;
  res.messages = Create_TicketMessageArray_From(src.Messages);
  res.tags = Create_TagArray_From(src.Tags);
  res.language = src.Language;
  res.sentiment = src.Sentiment;
  res.sentimentConfidence = src.SentimentConfidence;
  res.suggestedCategoryId = src.SuggestedCategoryId;
  res.suggestedCategoryName = src.SuggestedCategoryName;
  res.origHumanCategoryId = src.OrigHumanCategoryId;
  res.iconHint = src.IconHint;
  res.sale = Create_Sale_From(src.Sale);
  res.project = Create_Project_From(src.Project);
  res.formSubmission = Create_TicketFormSubmission_From(src.FormSubmission);
  res.ticketType = Create_TicketTypeEntity_From(src.TicketType);
  res.extraFields = src.ExtraFields;
  res.customFields = src.CustomFields;
  return res;
}
function Create_TicketMessage_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.ticketMessageId = src.TicketMessageId;
  res.createdAt = Create_Date_From(src.CreatedAt);
  res.slevel = TicketSecurityLevel[src.Slevel];
  res.important = src.Important;
  res.author = src.Author;
  res.personId = src.PersonId;
  res.personFullName = src.PersonFullName;
  res.contactId = src.ContactId;
  res.contactName = src.ContactName;
  res.contactDepartment = src.ContactDepartment;
  res.numAttachments = src.NumAttachments;
  res.emailHeader = src.EmailHeader;
  res.messageHeaders = Create_TicketMessageHeaderArray_From(src.MessageHeaders);
  res.language = src.Language;
  res.sentiment = src.Sentiment;
  res.sentimentConfidence = src.SentimentConfidence;
  res.createdBy = src.CreatedBy;
  res.changedAt = Create_Date_From(src.ChangedAt);
  res.badge = BadgeType[src.Badge];
  return res;
}
function Create_TicketMessageArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_TicketMessage_From(src[i]);
    }
  }
  return res;
}
function Create_TicketMessageEntity_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.ejMessageId = src.EjMessageId;
  res.ticket = Create_Ticket_From(src.Ticket);
  res.createdAt = Create_Date_From(src.CreatedAt);
  res.createdBy = Create_Associate_From(src.CreatedBy);
  res.author = src.Author;
  res.slevel = TicketSecurityLevel[src.Slevel];
  res.type = TicketMessageType[src.Type];
  res.messageId = src.MessageId;
  res.timeSpent = src.TimeSpent;
  res.body = src.Body;
  res.htmlBody = src.HtmlBody;
  res.emailHeader = src.EmailHeader;
  res.debugInfo = src.DebugInfo;
  res.mailSorter = src.MailSorter;
  res.messageCategory = TicketMessageCategory[src.MessageCategory];
  res.person = Create_Person_From(src.Person);
  res.searchTitle = src.SearchTitle;
  res.messageHeaders = Create_TicketMessageHeaderArray_From(src.MessageHeaders);
  res.important = src.Important;
  res.language = src.Language;
  res.sentiment = src.Sentiment;
  res.sentimentConfidence = src.SentimentConfidence;
  res.badge = BadgeType[src.Badge];
  res.attachmentsInfo = Create_AttachmentEntityArray_From(src.AttachmentsInfo);
  res.extraFields = src.ExtraFields;
  res.customFields = src.CustomFields;
  return res;
}
function Create_TicketSummaryItem_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = {};
  res.ticketId = src.TicketId;
  res.ticketStatus = src.TicketStatus;
  res.title = src.Title;
  res.registered = Create_Date_From(src.Registered);
  res.iconHint = src.IconHint;
  return res;
}
function Create_TicketSummaryItemArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_TicketSummaryItem_From(src[i]);
    }
  }
  return res;
}
function Create_TableRecord_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.values = Create_StringDictionary_From(src.Values);
  return res;
}
function Create_UpsertRowStatus_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.primaryKey = src.PrimaryKey;
  res.action = UpsertRowActionStatus[src.Action];
  res.rowKeys = src.RowKeys;
  return res;
}
function Create_UpsertRowStatusArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_UpsertRowStatus_From(src[i]);
    }
  }
  return res;
}
function Create_MassOperationResult_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.success = src.Success;
  res.message = src.Message;
  res.inserts = src.Inserts;
  res.updates = src.Updates;
  res.deletes = src.Deletes;
  res.rowStatus = Create_UpsertRowStatusArray_From(src.RowStatus);
  return res;
}
function Create_ChatBotSettings_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = {};
  res.botName = src.BotName;
  res.botRegisterScriptId = src.BotRegisterScriptId;
  res.botSessionCreatedScriptId = src.BotSessionCreatedScriptId;
  res.botSessionChangedScriptId = src.BotSessionChangedScriptId;
  res.botMessageReceivedScriptId = src.BotMessageReceivedScriptId;
  return res;
}
function Create_ChatMessage_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = {};
  res.chatMessageId = src.ChatMessageId;
  res.chatSessionId = src.ChatSessionId;
  res.type = ChatMessageType[src.Type];
  res.message = src.Message;
  res.author = src.Author;
  res.readByCustomer = src.ReadByCustomer;
  res.specialType = ChatMessageSpecialType[src.SpecialType];
  res.specialParam = src.SpecialParam;
  res.whenPosted = Create_Date_From(src.WhenPosted);
  return res;
}
function Create_ChatMessageArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_ChatMessage_From(src[i]);
    }
  }
  return res;
}
function Create_ChatOpeningHours_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = {};
  res.tzLocation = Create_TimeZoneData_From(src.TzLocation);
  res.monEnabled = src.MonEnabled;
  res.monStart = Create_Duration_From(src.MonStart);
  res.monStop = Create_Duration_From(src.MonStop);
  res.tueEnabled = src.TueEnabled;
  res.tueStart = Create_Duration_From(src.TueStart);
  res.tueStop = Create_Duration_From(src.TueStop);
  res.wedEnabled = src.WedEnabled;
  res.wedStart = Create_Duration_From(src.WedStart);
  res.wedStop = Create_Duration_From(src.WedStop);
  res.thuEnabled = src.ThuEnabled;
  res.thuStart = Create_Duration_From(src.ThuStart);
  res.thuStop = Create_Duration_From(src.ThuStop);
  res.friEnabled = src.FriEnabled;
  res.friStart = Create_Duration_From(src.FriStart);
  res.friStop = Create_Duration_From(src.FriStop);
  res.satEnabled = src.SatEnabled;
  res.satStart = Create_Duration_From(src.SatStart);
  res.satStop = Create_Duration_From(src.SatStop);
  res.sunEnabled = src.SunEnabled;
  res.sunStart = Create_Duration_From(src.SunStart);
  res.sunStop = Create_Duration_From(src.SunStop);
  res.useLunchHours = src.UseLunchHours;
  res.lunchStart = Create_Duration_From(src.LunchStart);
  res.lunchStop = Create_Duration_From(src.LunchStop);
  return res;
}
function Create_ChatPresence_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.userId = src.UserId;
  res.displayName = src.DisplayName;
  res.ongoingChats = src.OngoingChats;
  res.present = src.Present;
  res.chatTopics = src.ChatTopics;
  return res;
}
function Create_ChatPresenceArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_ChatPresence_From(src[i]);
    }
  }
  return res;
}
function Create_ChatSessionEntity_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.chatSessionId = src.ChatSessionId;
  res.topicId = src.TopicId;
  res.user = Create_Associate_From(src.User);
  res.person = Create_Person_From(src.Person);
  res.customerAlias = src.CustomerAlias;
  res.customerHost = src.CustomerHost;
  res.customerName = src.CustomerName;
  res.customerEmail = src.CustomerEmail;
  res.customerPhone = src.CustomerPhone;
  res.customerConsented = src.CustomerConsented;
  res.customerCompanyName = src.CustomerCompanyName;
  res.status = ChatSessionStatus[src.Status];
  res.firstMessage = src.FirstMessage;
  res.lastMessage = src.LastMessage;
  res.whenRequested = Create_Date_From(src.WhenRequested);
  res.whenStarted = Create_Date_From(src.WhenStarted);
  res.whenEnded = Create_Date_From(src.WhenEnded);
  res.whenIdle = Create_Date_From(src.WhenIdle);
  res.whenFetched = Create_Date_From(src.WhenFetched);
  res.sessionKey = src.SessionKey;
  res.initialQueuePos = src.InitialQueuePos;
  res.alertLevel = src.AlertLevel;
  res.rank = src.Rank;
  res.flags = Create_ChatSessionFlags_From(src.Flags);
  res.contact = Create_Contact_From(src.Contact);
  res.project = Create_Project_From(src.Project);
  res.sale = Create_Sale_From(src.Sale);
  res.ticket = Create_Ticket_From(src.Ticket);
  res.transferTo = Create_Associate_From(src.TransferTo);
  res.chatbotIsActive = src.ChatbotIsActive;
  res.rating = src.Rating;
  return res;
}
function Create_ChatSessionEntityArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_ChatSessionEntity_From(src[i]);
    }
  }
  return res;
}
function Create_ChatSummaryItem_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = {};
  res.chatSessionId = src.ChatSessionId;
  res.name = src.Name;
  res.companyName = src.CompanyName;
  res.firstMessage = src.FirstMessage;
  res.lastMessage = src.LastMessage;
  res.whenRequested = Create_Date_From(src.WhenRequested);
  res.whenEnded = Create_Date_From(src.WhenEnded);
  return res;
}
function Create_ChatSummaryItemArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_ChatSummaryItem_From(src[i]);
    }
  }
  return res;
}
function Create_ChatTopicAgent_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = {};
  res.topicId = src.TopicId;
  res.user = Create_Associate_From(src.User);
  res.canListen = src.CanListen;
  res.canRespond = src.CanRespond;
  res.canManage = src.CanManage;
  res.canNotify = src.CanNotify;
  return res;
}
function Create_ChatTopicAgentArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_ChatTopicAgent_From(src[i]);
    }
  }
  return res;
}
function Create_ChatTopicEntity_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.chatTopicId = src.ChatTopicId;
  res.name = src.Name;
  res.description = src.Description;
  res.welcomeMessage = src.WelcomeMessage;
  res.language = Create_CustomerLanguage_From(src.Language);
  res.lastAccept = Create_Date_From(src.LastAccept);
  res.secondsPrAccept = src.SecondsPrAccept;
  res.alertRecipient = src.AlertRecipient;
  res.alertTemplate = Create_ReplyTemplate_From(src.AlertTemplate);
  res.collectConsent = src.CollectConsent;
  res.badgeHeader = src.BadgeHeader;
  res.customQueueTextEnabled = src.CustomQueueTextEnabled;
  res.customQueueText = src.CustomQueueText;
  res.warnNewChatMinutes = src.WarnNewChatMinutes;
  res.warnManagerNewChatMinutes = src.WarnManagerNewChatMinutes;
  res.ticketEnabled = src.TicketEnabled;
  res.ticketCategory = Create_TicketCategory_From(src.TicketCategory);
  res.ticketPriority = Create_TicketPriority_From(src.TicketPriority);
  res.openingHoursEnabled = src.OpeningHoursEnabled;
  res.openingHours = Create_ChatOpeningHours_From(src.OpeningHours);
  res.widget = Create_ChatWidgetSettings_From(src.Widget);
  res.botEnabled = src.BotEnabled;
  res.botSettings = Create_ChatBotSettings_From(src.BotSettings);
  res.offlineCollectConsent = src.OfflineCollectConsent;
  res.warnChatMessageMinutes = src.WarnChatMessageMinutes;
  res.warnManagerChatMessageMinutes = src.WarnManagerChatMessageMinutes;
  res.useQueueOfflineForm = src.UseQueueOfflineForm;
  res.offlineFormTimeLimit = src.OfflineFormTimeLimit;
  res.offlineFormQueueLength = src.OfflineFormQueueLength;
  res.widgetEnableRating = src.WidgetEnableRating;
  res.widgetRatingText = src.WidgetRatingText;
  return res;
}
function Create_ChatTopicEntityArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_ChatTopicEntity_From(src[i]);
    }
  }
  return res;
}
function Create_ChatWidgetSettings_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = {};
  res.autoFaqEnabled = src.AutoFaqEnabled;
  res.autoFaqCategory = Create_KbCategory_From(src.AutoFaqCategory);
  res.preFormEnabled = src.PreFormEnabled;
  res.preFormMessage = src.PreFormMessage;
  res.requiredFields = Create_WidgetRequiredFields_From(src.RequiredFields);
  res.postFormEnabled = src.PostFormEnabled;
  res.postFormHeader = src.PostFormHeader;
  res.postFormMessage = src.PostFormMessage;
  res.postTranscriptEnabled = src.PostTranscriptEnabled;
  res.languageIsoCode = src.LanguageIsoCode;
  res.size = ChatWidgetSize[src.Size];
  res.theme = WidgetTheme[src.Theme];
  res.color = src.Color;
  res.badgeColor = src.BadgeColor;
  res.badgeTextColor = src.BadgeTextColor;
  res.custMsgColor = src.CustMsgColor;
  res.custMsgTextColor = src.CustMsgTextColor;
  res.agentMsgColor = src.AgentMsgColor;
  res.agentMsgTextColor = src.AgentMsgTextColor;
  res.buttonColor = src.ButtonColor;
  res.buttonTextColor = src.ButtonTextColor;
  res.font = src.Font;
  res.fontSize = src.FontSize;
  res.logoEnabled = src.LogoEnabled;
  res.logoBlobId = src.LogoBlobId;
  res.logoName = src.LogoName;
  res.showAgentPhoto = src.ShowAgentPhoto;
  res.welcomeTitle = src.WelcomeTitle;
  res.welcomeMessage = src.WelcomeMessage;
  res.offlineHeader = src.OfflineHeader;
  res.offlineMessage = src.OfflineMessage;
  res.offlineFields = Create_WidgetRequiredFields_From(src.OfflineFields);
  res.useAgentFirstname = src.UseAgentFirstname;
  return res;
}
function Create_CategorizationModelDetails_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.modelBuiltDateTime = Create_Date_From(src.ModelBuiltDateTime);
  res.accuracy = src.Accuracy;
  res.ticketCountForTraining = src.TicketCountForTraining;
  return res;
}
function Create_CategorizationStatusResponse_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.contextIdentifier = src.ContextIdentifier;
  res.status = src.Status;
  res.currentModel = Create_CategorizationModelDetails_From(src.CurrentModel);
  res.previousModel = Create_CategorizationModelDetails_From(src.PreviousModel);
  return res;
}
function Create_ChatbotTurn_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = {};
  res.timestamp = Create_Date_From(src.Timestamp);
  res.userPrompt = src.UserPrompt;
  res.userDisplayText = src.UserDisplayText;
  res.botResponse = src.BotResponse;
  res.botActions = Create_StringDictionary_From(src.BotActions);
  res.attachments = src.Attachments;
  return res;
}
function Create_Sentiment_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.score = src.Score;
  res.confidence = src.Confidence;
  return res;
}
function Create_DocumentMigrationAssociate_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = {};
  res.associateId = src.AssociateId;
  res.emailAddress = src.EmailAddress;
  return res;
}
function Create_DocumentMigrationAssociateArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_DocumentMigrationAssociate_From(src[i]);
    }
  }
  return res;
}
function Create_DocumentMigrationItem_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = {};
  res.documentId = src.DocumentId;
  res.contactId = src.ContactId;
  res.personId = src.PersonId;
  res.saleId = src.SaleId;
  res.projectId = src.ProjectId;
  res.docTmplId = src.DocTmplId;
  res.associateId = src.AssociateId;
  res.userGroupId = src.UserGroupId;
  res.visibleForId = src.VisibleForId;
  return res;
}
function Create_DocumentMigrationItemArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_DocumentMigrationItem_From(src[i]);
    }
  }
  return res;
}
function Create_DocumentMigrationItemList_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = {};
  res.numDocumentsOmitted = src.NumDocumentsOmitted;
  res.numDocumentsAlreadyMigrated = src.NumDocumentsAlreadyMigrated;
  res.documents = Create_DocumentMigrationItemArray_From(src.Documents);
  res.associates = Create_DocumentMigrationAssociateArray_From(src.Associates);
  return res;
}
function Create_DocumentTemplateMigrationList_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = {};
  res.numTemplatesOmitted = src.NumTemplatesOmitted;
  res.numTemplatesAlreadyMigrated = src.NumTemplatesAlreadyMigrated;
  res.templateIds = src.TemplateIds;
  return res;
}
function Create_EmailFlow_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.emailFlowId = src.EmailFlowId;
  res.name = src.Name;
  res.description = src.Description;
  res.status = WorkflowDefinitionStatus[src.Status];
  res.jumpToFinish = src.JumpToFinish;
  res.startOnlyOnce = src.StartOnlyOnce;
  res.overrideConsentSubscription = src.OverrideConsentSubscription;
  res.fromType = EmailFromType[src.FromType];
  res.fromName = src.FromName;
  res.fromAddr = src.FromAddr;
  res.replyToType = EmailReplyToType[src.ReplyToType];
  res.replyToAddr = src.ReplyToAddr;
  res.replyToName = src.ReplyToName;
  res.smsSender = src.SmsSender;
  res.useGoogleAnalytics = src.UseGoogleAnalytics;
  res.gaSource = src.GaSource;
  res.gaCampaign = src.GaCampaign;
  res.useTimeframe = src.UseTimeframe;
  res.selectedDays = Create_Weekday_From(src.SelectedDays);
  res.timeframeStart = src.TimeframeStart;
  res.timeframeEnd = src.TimeframeEnd;
  res.useWorkflowStart = src.UseWorkflowStart;
  res.workflowStart = src.WorkflowStart;
  res.useEnrollmentEnd = src.UseEnrollmentEnd;
  res.enrollmentEnd = src.EnrollmentEnd;
  res.removeFromFlows = src.RemoveFromFlows;
  res.tzLocation = Create_TimeZoneData_From(src.TzLocation);
  res.folder = Create_HierarchyEntity_From(src.Folder);
  res.associate = Create_Associate_From(src.Associate);
  res.shipmentType = Create_MDOListItem_From(src.ShipmentType);
  res.steps = Create_WorkflowStepBaseArray_From(src.Steps);
  res.triggers = Create_WorkflowTriggerArray_From(src.Triggers);
  res.goals = Create_WorkflowGoalArray_From(src.Goals);
  res.filter = Create_WorkflowFilter_From(src.Filter);
  res.blockLists = src.BlockLists;
  res.visibleFor = Create_VisibleForArray_From(src.VisibleFor);
  return res;
}
function Create_WorkflowEvent_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.eventType = WorkflowEventType[src.EventType];
  res.attributes = src.Attributes;
  return res;
}
function Create_WorkflowEventResult_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.eventType = WorkflowEventType[src.EventType];
  res.attributes = src.Attributes;
  return res;
}
function Create_WorkflowFilter_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.restrictionGroups = Create_ArchiveRestrictionGroupArray_From(src.RestrictionGroups);
  return res;
}
function Create_WorkflowGoal_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.workflowGoalId = src.WorkflowGoalId;
  res.workflowId = src.WorkflowId;
  res.goalType = WorkflowGoalType[src.GoalType];
  res.restrictionGroups = Create_ArchiveRestrictionGroupArray_From(src.RestrictionGroups);
  return res;
}
function Create_WorkflowGoalArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_WorkflowGoal_From(src[i]);
    }
  }
  return res;
}
function Create_WorkflowStepBase_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = {};
  if (src.StepType == "AddToList")
    res = Create_WorkflowStepAddToList_From(src);
  if (src.StepType == "CreateFollowUp")
    res = Create_WorkflowStepCreateFollowUp_From(src);
  if (src.StepType == "CreateRequest")
    res = Create_WorkflowStepCreateRequest_From(src);
  if (src.StepType == "CreateSale")
    res = Create_WorkflowStepCreateSale_From(src);
  if (src.StepType == "NotifyByEmail")
    res = Create_WorkflowStepNotifyByEmail_From(src);
  if (src.StepType == "NotifyBySMS")
    res = Create_WorkflowStepNotifyBySMS_From(src);
  if (src.StepType == "RemoveFromList")
    res = Create_WorkflowStepRemoveFromList_From(src);
  if (src.StepType == "RunScript")
    res = Create_WorkflowStepRunScript_From(src);
  if (src.StepType == "SendEmail")
    res = Create_WorkflowStepSendEmail_From(src);
  if (src.StepType == "SendSMS")
    res = Create_WorkflowStepSendSMS_From(src);
  if (src.StepType == "Split")
    res = Create_WorkflowStepSplit_From(src);
  if (src.StepType == "UpdateContact")
    res = Create_WorkflowStepUpdateContact_From(src);
  if (src.StepType == "WaitForAction")
    res = Create_WorkflowStepWaitForAction_From(src);
  if (src.StepType == "WaitForTime")
    res = Create_WorkflowStepWaitForTime_From(src);
  res.workflowStepId = src.WorkflowStepId;
  res.workflowId = src.WorkflowId;
  res.stepType = WorkflowStepType[src.StepType];
  res.rank = src.Rank;
  return res;
}
function Create_WorkflowStepBaseArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_WorkflowStepBase_From(src[i]);
    }
  }
  return res;
}
function Create_WorkflowStepAddToList_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = src;
  res.selection = src.Selection;
  res.project = src.Project;
  return res;
}
function Create_WorkflowStepCreateFollowUp_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = src;
  return res;
}
function Create_WorkflowStepCreateRequest_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = src;
  res.title = src.Title;
  res.category = src.Category;
  res.priority = src.Priority;
  res.owner = src.Owner;
  res.message = src.Message;
  res.requestType = src.RequestType;
  res.status = src.Status;
  return res;
}
function Create_WorkflowStepCreateSale_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = src;
  return res;
}
function Create_WorkflowStepNotifyByEmail_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = src;
  return res;
}
function Create_WorkflowStepNotifyBySMS_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = src;
  return res;
}
function Create_WorkflowStepOption_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.workflowStepOptionId = src.WorkflowStepOptionId;
  res.workflowStepId = src.WorkflowStepId;
  res.workflowId = src.WorkflowId;
  res.key = src.Key;
  res.name = src.Name;
  res.rank = src.Rank;
  res.steps = Create_WorkflowStepBaseArray_From(src.Steps);
  return res;
}
function Create_WorkflowStepOptionArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_WorkflowStepOption_From(src[i]);
    }
  }
  return res;
}
function Create_WorkflowStepRemoveFromList_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = src;
  res.selection = src.Selection;
  res.project = src.Project;
  return res;
}
function Create_WorkflowStepRunScript_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = src;
  return res;
}
function Create_WorkflowStepSendEmail_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = src;
  res.subject = src.Subject;
  res.attachments = src.Attachments;
  res.shipmentId = src.ShipmentId;
  return res;
}
function Create_WorkflowStepSendSMS_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = src;
  return res;
}
function Create_WorkflowStepSplit_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = src;
  res.options = Create_WorkflowStepOptionArray_From(src.Options);
  return res;
}
function Create_WorkflowStepUpdateContact_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = src;
  return res;
}
function Create_WorkflowStepWaitForAction_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = src;
  return res;
}
function Create_WorkflowStepWaitForTime_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = src;
  res.timeWaitAlgorithm = WorkflowTimeWaitAlgorithm[src.TimeWaitAlgorithm];
  res.numIntervals = src.NumIntervals;
  res.intervalType = WorkflowTimeWaitIntervalType[src.IntervalType];
  res.until = src.Until;
  return res;
}
function Create_WorkflowTrigger_From(src) {
  if (src === null || src === void 0)
    return null;
  let res = Create_Carrier_From(src);
  res.workflowTriggerId = src.WorkflowTriggerId;
  res.workflowId = src.WorkflowId;
  res.triggerType = WorkflowTriggerType[src.TriggerType];
  res.restrictionGroups = Create_ArchiveRestrictionGroupArray_From(src.RestrictionGroups);
  return res;
}
function Create_WorkflowTriggerArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_WorkflowTrigger_From(src[i]);
    }
  }
  return res;
}
function Create_DSAParameters_From(src) {
  return src;
}
function Create_ArrayBuffer_From(src) {
  return src;
}
function Create_BirthDate_From(src) {
  if (src && src.indexOf && src.indexOf("-") > 1 && src.indexOf("T") > 1) {
    src = src.substr(0, src.indexOf("T"));
    return new Date(src);
  }
  return src;
}
function Create_Date_From(src) {
  if (src && src.indexOf && src.indexOf("-") > 1)
    return new Date(src);
  return null;
}
function Create_DateArray_From(src) {
  let res = [];
  if (Array.isArray(src)) {
    for (let i in src) {
      res[i] = Create_Date_From(src[i]);
    }
  }
  return res;
}
function Create_Duration_From(src) {
  if (src)
    return mkDuration(src);
  return null;
}
function Create_Object_From(src) {
  return src;
}
function Create_PrefDescAccessFlags_From(src) {
  if (!src)
    return null;
  if (Array.isArray(src)) {
    let result = Array();
    for (const i in src) {
      let r;
      for (const s of src[i].split(/,\s*/)) {
        r |= PrefDescAccessFlags[s];
      }
      result.push(r);
    }
    return result;
  } else {
    let r;
    for (const s of src.split(/,\s*/)) {
      r |= PrefDescAccessFlags[s];
    }
    return r;
  }
}
function Create_ShowState_From(src) {
  if (!src)
    return null;
  if (Array.isArray(src)) {
    let result = Array();
    for (const i in src) {
      let r;
      for (const s of src[i].split(/,\s*/)) {
        r |= ShowState[s];
      }
      result.push(r);
    }
    return result;
  } else {
    let r;
    for (const s of src.split(/,\s*/)) {
      r |= ShowState[s];
    }
    return r;
  }
}
function Create_ErpActorType_From(src) {
  if (!src)
    return null;
  if (Array.isArray(src)) {
    let result = Array();
    for (const i in src) {
      let r = ErpActorType[src[i]];
      result.push(r);
    }
    return result;
  } else {
    let r = ErpActorType[src];
    return r;
  }
}
function Create_ImportEntityType_From(src) {
  if (!src)
    return null;
  if (Array.isArray(src)) {
    let result = Array();
    for (const i in src) {
      let r;
      for (const s of src[i].split(/,\s*/)) {
        r |= ImportEntityType[s];
      }
      result.push(r);
    }
    return result;
  } else {
    let r;
    for (const s of src.split(/,\s*/)) {
      r |= ImportEntityType[s];
    }
    return r;
  }
}
function Create_ImportAction_From(src) {
  if (!src)
    return null;
  if (Array.isArray(src)) {
    let result = Array();
    for (const i in src) {
      let r;
      for (const s of src[i].split(/,\s*/)) {
        r |= ImportAction[s];
      }
      result.push(r);
    }
    return result;
  } else {
    let r;
    for (const s of src.split(/,\s*/)) {
      r |= ImportAction[s];
    }
    return r;
  }
}
function Create_EMailFlags_From(src) {
  if (!src)
    return null;
  if (Array.isArray(src)) {
    let result = Array();
    for (const i in src) {
      let r;
      for (const s of src[i].split(/,\s*/)) {
        r |= EMailFlags[s];
      }
      result.push(r);
    }
    return result;
  } else {
    let r;
    for (const s of src.split(/,\s*/)) {
      r |= EMailFlags[s];
    }
    return r;
  }
}
function Create_DashTileUsage_From(src) {
  if (!src)
    return null;
  if (Array.isArray(src)) {
    let result = Array();
    for (const i in src) {
      let r;
      for (const s of src[i].split(/,\s*/)) {
        r |= DashTileUsage[s];
      }
      result.push(r);
    }
    return result;
  } else {
    let r;
    for (const s of src.split(/,\s*/)) {
      r |= DashTileUsage[s];
    }
    return r;
  }
}
function Create_TargetAssignementLevel_From(src) {
  if (!src)
    return null;
  if (Array.isArray(src)) {
    let result = Array();
    for (const i in src) {
      let r;
      for (const s of src[i].split(/,\s*/)) {
        r |= TargetAssignementLevel[s];
      }
      result.push(r);
    }
    return result;
  } else {
    let r;
    for (const s of src.split(/,\s*/)) {
      r |= TargetAssignementLevel[s];
    }
    return r;
  }
}
function Create_ContactAction_From(src) {
  if (!src)
    return null;
  if (Array.isArray(src)) {
    let result = Array();
    for (const i in src) {
      let r;
      for (const s of src[i].split(/,\s*/)) {
        r |= ContactAction[s];
      }
      result.push(r);
    }
    return result;
  } else {
    let r;
    for (const s of src.split(/,\s*/)) {
      r |= ContactAction[s];
    }
    return r;
  }
}
function Create_ETableRight_From(src) {
  if (!src)
    return null;
  if (Array.isArray(src)) {
    let result = Array();
    for (const i in src) {
      let r;
      for (const s of src[i].split(/,\s*/)) {
        r |= ETableRight[s];
      }
      result.push(r);
    }
    return result;
  } else {
    let r;
    for (const s of src.split(/,\s*/)) {
      r |= ETableRight[s];
    }
    return r;
  }
}
function Create_EFieldRight_From(src) {
  if (!src)
    return null;
  if (Array.isArray(src)) {
    let result = Array();
    for (const i in src) {
      let r;
      for (const s of src[i].split(/,\s*/)) {
        r |= EFieldRight[s];
      }
      result.push(r);
    }
    return result;
  } else {
    let r;
    for (const s of src.split(/,\s*/)) {
      r |= EFieldRight[s];
    }
    return r;
  }
}
function Create_Weekday_From(src) {
  if (!src)
    return null;
  if (Array.isArray(src)) {
    let result = Array();
    for (const i in src) {
      let r;
      for (const s of src[i].split(/,\s*/)) {
        r |= Weekday[s];
      }
      result.push(r);
    }
    return result;
  } else {
    let r;
    for (const s of src.split(/,\s*/)) {
      r |= Weekday[s];
    }
    return r;
  }
}
function Create_ShowTaskItemInClient_From(src) {
  if (!src)
    return null;
  if (Array.isArray(src)) {
    let result = Array();
    for (const i in src) {
      let r;
      for (const s of src[i].split(/,\s*/)) {
        r |= ShowTaskItemInClient[s];
      }
      result.push(r);
    }
    return result;
  } else {
    let r;
    for (const s of src.split(/,\s*/)) {
      r |= ShowTaskItemInClient[s];
    }
    return r;
  }
}
function Create_ArchiveBehaviour_From(src) {
  if (!src)
    return null;
  if (Array.isArray(src)) {
    let result = Array();
    for (const i in src) {
      let r;
      for (const s of src[i].split(/,\s*/)) {
        r |= ArchiveBehaviour[s];
      }
      result.push(r);
    }
    return result;
  } else {
    let r;
    for (const s of src.split(/,\s*/)) {
      r |= ArchiveBehaviour[s];
    }
    return r;
  }
}
function Create_TicketCategoryFlags_From(src) {
  if (!src)
    return null;
  if (Array.isArray(src)) {
    let result = Array();
    for (const i in src) {
      let r;
      for (const s of src[i].split(/,\s*/)) {
        r |= TicketCategoryFlags[s];
      }
      result.push(r);
    }
    return result;
  } else {
    let r;
    for (const s of src.split(/,\s*/)) {
      r |= TicketCategoryFlags[s];
    }
    return r;
  }
}
function Create_TicketPriorityFlags_From(src) {
  if (!src)
    return null;
  if (Array.isArray(src)) {
    let result = Array();
    for (const i in src) {
      let r;
      for (const s of src[i].split(/,\s*/)) {
        r |= TicketPriorityFlags[s];
      }
      result.push(r);
    }
    return result;
  } else {
    let r;
    for (const s of src.split(/,\s*/)) {
      r |= TicketPriorityFlags[s];
    }
    return r;
  }
}
function Create_ShipmentMessageType_From(src) {
  if (!src)
    return null;
  if (Array.isArray(src)) {
    let result = Array();
    for (const i in src) {
      let r;
      for (const s of src[i].split(/,\s*/)) {
        r |= ShipmentMessageType[s];
      }
      result.push(r);
    }
    return result;
  } else {
    let r;
    for (const s of src.split(/,\s*/)) {
      r |= ShipmentMessageType[s];
    }
    return r;
  }
}
function Create_WidgetRequiredFields_From(src) {
  if (!src)
    return null;
  if (Array.isArray(src)) {
    let result = Array();
    for (const i in src) {
      let r;
      for (const s of src[i].split(/,\s*/)) {
        r |= WidgetRequiredFields[s];
      }
      result.push(r);
    }
    return result;
  } else {
    let r;
    for (const s of src.split(/,\s*/)) {
      r |= WidgetRequiredFields[s];
    }
    return r;
  }
}
function Create_ChatSessionFlags_From(src) {
  if (!src)
    return null;
  if (Array.isArray(src)) {
    let result = Array();
    for (const i in src) {
      let r;
      for (const s of src[i].split(/,\s*/)) {
        r |= ChatSessionFlags[s];
      }
      result.push(r);
    }
    return result;
  } else {
    let r;
    for (const s of src.split(/,\s*/)) {
      r |= ChatSessionFlags[s];
    }
    return r;
  }
}

// server/node_modules/@superoffice/webapi/dist/esm/Base64.js
function b64ToUint6(nChr) {
  return nChr > 64 && nChr < 91 ? nChr - 65 : nChr > 96 && nChr < 123 ? nChr - 71 : nChr > 47 && nChr < 58 ? nChr + 4 : nChr === 43 ? 62 : nChr === 47 ? 63 : 0;
}
function base64DecToArr(sBase64, nBlockSize) {
  var sB64Enc = sBase64.replace(/[^A-Za-z0-9\+\/]/g, ""), nInLen = sB64Enc.length, nOutLen = nBlockSize ? Math.ceil((nInLen * 3 + 1 >>> 2) / nBlockSize) * nBlockSize : nInLen * 3 + 1 >>> 2, aBytes = new Uint8Array(nOutLen);
  for (var nMod3, nMod4, nUint24 = 0, nOutIdx = 0, nInIdx = 0; nInIdx < nInLen; nInIdx++) {
    nMod4 = nInIdx & 3;
    nUint24 |= b64ToUint6(sB64Enc.charCodeAt(nInIdx)) << 18 - 6 * nMod4;
    if (nMod4 === 3 || nInLen - nInIdx === 1) {
      for (nMod3 = 0; nMod3 < 3 && nOutIdx < nOutLen; nMod3++, nOutIdx++) {
        aBytes[nOutIdx] = nUint24 >>> (16 >>> nMod3 & 24) & 255;
      }
      nUint24 = 0;
    }
  }
  return aBytes;
}
function uint6ToB64(nUint6) {
  return nUint6 < 26 ? nUint6 + 65 : nUint6 < 52 ? nUint6 + 71 : nUint6 < 62 ? nUint6 - 4 : nUint6 === 62 ? 43 : nUint6 === 63 ? 47 : 65;
}
function base64EncArr(aBytes) {
  var eqLen = (3 - aBytes.length % 3) % 3, sB64Enc = "";
  for (var nMod3, nLen = aBytes.length, nUint24 = 0, nIdx = 0; nIdx < nLen; nIdx++) {
    nMod3 = nIdx % 3;
    nUint24 |= aBytes[nIdx] << (16 >>> nMod3 & 24);
    if (nMod3 === 2 || aBytes.length - nIdx === 1) {
      sB64Enc += String.fromCharCode(uint6ToB64(nUint24 >>> 18 & 63), uint6ToB64(nUint24 >>> 12 & 63), uint6ToB64(nUint24 >>> 6 & 63), uint6ToB64(nUint24 & 63));
      nUint24 = 0;
    }
  }
  return eqLen === 0 ? sB64Enc : sB64Enc.substring(0, sB64Enc.length - eqLen) + (eqLen === 1 ? "=" : "==");
}
function UTF8ArrToStr(aBytes) {
  var sView = "";
  for (var nPart, nLen = aBytes.length, nIdx = 0; nIdx < nLen; nIdx++) {
    nPart = aBytes[nIdx];
    sView += String.fromCharCode(nPart > 251 && nPart < 254 && nIdx + 5 < nLen ? (
      /* six bytes */
      /* (nPart - 252 << 30) may be not so safe in ECMAScript! So...: */
      (nPart - 252) * 1073741824 + (aBytes[++nIdx] - 128 << 24) + (aBytes[++nIdx] - 128 << 18) + (aBytes[++nIdx] - 128 << 12) + (aBytes[++nIdx] - 128 << 6) + aBytes[++nIdx] - 128
    ) : nPart > 247 && nPart < 252 && nIdx + 4 < nLen ? (
      /* five bytes */
      (nPart - 248 << 24) + (aBytes[++nIdx] - 128 << 18) + (aBytes[++nIdx] - 128 << 12) + (aBytes[++nIdx] - 128 << 6) + aBytes[++nIdx] - 128
    ) : nPart > 239 && nPart < 248 && nIdx + 3 < nLen ? (
      /* four bytes */
      (nPart - 240 << 18) + (aBytes[++nIdx] - 128 << 12) + (aBytes[++nIdx] - 128 << 6) + aBytes[++nIdx] - 128
    ) : nPart > 223 && nPart < 240 && nIdx + 2 < nLen ? (
      /* three bytes */
      (nPart - 224 << 12) + (aBytes[++nIdx] - 128 << 6) + aBytes[++nIdx] - 128
    ) : nPart > 191 && nPart < 224 && nIdx + 1 < nLen ? (
      /* two bytes */
      (nPart - 192 << 6) + aBytes[++nIdx] - 128
    ) : (
      /* nPart < 127 ? */
      /* one byte */
      nPart
    ));
  }
  return sView;
}
function strToUTF8Arr(sDOMStr) {
  var aBytes, nChr, nStrLen = sDOMStr.length, nArrLen = 0;
  for (var nMapIdx = 0; nMapIdx < nStrLen; nMapIdx++) {
    nChr = sDOMStr.charCodeAt(nMapIdx);
    nArrLen += nChr < 128 ? 1 : nChr < 2048 ? 2 : nChr < 65536 ? 3 : nChr < 2097152 ? 4 : nChr < 67108864 ? 5 : 6;
  }
  aBytes = new Uint8Array(nArrLen);
  for (var nIdx = 0, nChrIdx = 0; nIdx < nArrLen; nChrIdx++) {
    nChr = sDOMStr.charCodeAt(nChrIdx);
    if (nChr < 128) {
      aBytes[nIdx++] = nChr;
    } else if (nChr < 2048) {
      aBytes[nIdx++] = 192 + (nChr >>> 6);
      aBytes[nIdx++] = 128 + (nChr & 63);
    } else if (nChr < 65536) {
      aBytes[nIdx++] = 224 + (nChr >>> 12);
      aBytes[nIdx++] = 128 + (nChr >>> 6 & 63);
      aBytes[nIdx++] = 128 + (nChr & 63);
    } else if (nChr < 2097152) {
      aBytes[nIdx++] = 240 + (nChr >>> 18);
      aBytes[nIdx++] = 128 + (nChr >>> 12 & 63);
      aBytes[nIdx++] = 128 + (nChr >>> 6 & 63);
      aBytes[nIdx++] = 128 + (nChr & 63);
    } else if (nChr < 67108864) {
      aBytes[nIdx++] = 248 + (nChr >>> 24);
      aBytes[nIdx++] = 128 + (nChr >>> 18 & 63);
      aBytes[nIdx++] = 128 + (nChr >>> 12 & 63);
      aBytes[nIdx++] = 128 + (nChr >>> 6 & 63);
      aBytes[nIdx++] = 128 + (nChr & 63);
    } else {
      aBytes[nIdx++] = 252 + (nChr >>> 30);
      aBytes[nIdx++] = 128 + (nChr >>> 24 & 63);
      aBytes[nIdx++] = 128 + (nChr >>> 18 & 63);
      aBytes[nIdx++] = 128 + (nChr >>> 12 & 63);
      aBytes[nIdx++] = 128 + (nChr >>> 6 & 63);
      aBytes[nIdx++] = 128 + (nChr & 63);
    }
  }
  return aBytes;
}
function ArrayBufferToBase64(buffer) {
  var binary = "";
  var bytes = new Uint8Array(buffer);
  var len = bytes.byteLength;
  for (var i = 0; i < len; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return btoa(binary);
}
function Utf8toBase64(str) {
  var utf8 = strToUTF8Arr(str);
  var b64 = base64EncArr(utf8);
  return b64;
}
function FromBase64ToString(base64) {
  var utf8 = base64DecToArr(base64, 0);
  var str = UTF8ArrToStr(utf8);
  return str;
}
function ToBase64(content) {
  if (content) {
    if (typeof content === "string")
      return Utf8toBase64(content);
    if (content.byteLength)
      return ArrayBufferToBase64(content);
  }
  return "";
}

// server/node_modules/@superoffice/webapi/dist/esm/QuoteAgent.js
var QuoteAgent = class extends WebApiBase {
  constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
    const options = WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
    options.basePath = "v1/Agents/Quote/";
    super(options);
  }
  /**
   * Set default values into a new PriceList.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultPriceListAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultPriceList", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PriceList_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing PriceList or creates a new PriceList if the id parameter is empty
   * @param entity - The PriceList to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated PriceList
   */
  async savePriceListAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SavePriceList", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PriceList_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Deletes the PriceList
   * @param PriceListId - The id of the PriceList to be deleted.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   */
  async deletePriceListAsync(PriceListId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("DeletePriceList?PriceListId=" + PriceListId, null, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new Product.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultProductAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultProduct", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Product_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing Product or creates a new Product if the id parameter is empty
   * @param entity - The Product to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated Product
   */
  async saveProductAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveProduct", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Product_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Deletes the Product
   * @param ProductId - The id of the Product to be deleted.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   */
  async deleteProductAsync(ProductId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("DeleteProduct?ProductId=" + ProductId, null, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new QuoteAlternative.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultQuoteAlternativeAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultQuoteAlternative", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_QuoteAlternative_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing QuoteAlternative or creates a new QuoteAlternative if the id parameter is empty
   * @param entity - The QuoteAlternative to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated QuoteAlternative
   */
  async saveQuoteAlternativeAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveQuoteAlternative", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_QuoteAlternative_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getConfigurationFieldsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetConfigurationFields", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_FieldMetadataDictionary_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getConfigurationFieldsAsync(connectionId, connectorName, webapi_options) {
    let _request = null;
    let _options = null;
    const first = connectionId;
    if (typeof first === "object" && first && (typeof first.connectionId != "undefined" || typeof first.connectorName != "undefined")) {
      _request = connectionId;
      _options = connectorName;
    } else {
      _request = {
        connectionId,
        connectorName
      };
      _options = webapi_options;
    }
    return this._getConfigurationFieldsAsync(_request, _options);
  }
  async _testConnectionAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("TestConnection", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PluginResponse_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async testConnectionAsync(connectorName, connectionData, webapi_options) {
    let _request = null;
    let _options = null;
    const first = connectorName;
    if (typeof first === "object" && first && (typeof first.connectorName != "undefined" || typeof first.connectionData != "undefined")) {
      _request = connectorName;
      _options = connectionData;
    } else {
      _request = {
        connectorName,
        connectionData
      };
      _options = webapi_options;
    }
    return this._testConnectionAsync(_request, _options);
  }
  /*
   * Gets a PriceList object.
   * @param priceListId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single PriceList
   */
  async getPriceListAsync(priceListId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetPriceList?priceListId=" + priceListId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PriceList_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _copySuperOfficePriceListAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CopySuperOfficePriceList", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PriceList_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async copySuperOfficePriceListAsync(originalPriceListId, newName, validFrom, validTo, newCurrencyId, convertCurrency, webapi_options) {
    let _request = null;
    let _options = null;
    const first = originalPriceListId;
    if (typeof first === "object" && first && (typeof first.originalPriceListId != "undefined" || typeof first.newName != "undefined" || typeof first.validFrom != "undefined" || typeof first.validTo != "undefined" || typeof first.newCurrencyId != "undefined" || typeof first.convertCurrency != "undefined")) {
      _request = originalPriceListId;
      _options = newName;
    } else {
      _request = {
        originalPriceListId,
        newName,
        validFrom,
        validTo,
        newCurrencyId,
        convertCurrency
      };
      _options = webapi_options;
    }
    return this._copySuperOfficePriceListAsync(_request, _options);
  }
  async _getProductImageAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetProductImage", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getProductImageAsync(quoteConnectionId, erpProductKey, rank, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quoteConnectionId;
    if (typeof first === "object" && first && (typeof first.quoteConnectionId != "undefined" || typeof first.erpProductKey != "undefined" || typeof first.rank != "undefined")) {
      _request = quoteConnectionId;
      _options = erpProductKey;
    } else {
      _request = {
        quoteConnectionId,
        erpProductKey,
        rank
      };
      _options = webapi_options;
    }
    return this._getProductImageAsync(_request, _options);
  }
  async _findProductAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("FindProduct", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ProductArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async findProductAsync(quoteAlternativeId, userInput, priceListKey, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quoteAlternativeId;
    if (typeof first === "object" && first && (typeof first.quoteAlternativeId != "undefined" || typeof first.userInput != "undefined" || typeof first.priceListKey != "undefined")) {
      _request = quoteAlternativeId;
      _options = userInput;
    } else {
      _request = {
        quoteAlternativeId,
        userInput,
        priceListKey
      };
      _options = webapi_options;
    }
    return this._findProductAsync(_request, _options);
  }
  async _getProductAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetProduct", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Product_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getProductAsync(quoteConnectionId, erpProductKey, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quoteConnectionId;
    if (typeof first === "object" && first && (typeof first.quoteConnectionId != "undefined" || typeof first.erpProductKey != "undefined")) {
      _request = quoteConnectionId;
      _options = erpProductKey;
    } else {
      _request = {
        quoteConnectionId,
        erpProductKey
      };
      _options = webapi_options;
    }
    return this._getProductAsync(_request, _options);
  }
  async _getProductFromDbIdAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetProductFromDbId", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Product_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getProductFromDbIdAsync(productId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = productId;
    if (typeof first === "object" && first && typeof first.productId != "undefined") {
      _request = productId;
      _options = webapi_options;
    } else {
      _request = {
        productId
      };
      _options = webapi_options;
    }
    return this._getProductFromDbIdAsync(_request, _options);
  }
  async _removeProductAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("RemoveProduct", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async removeProductAsync(productId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = productId;
    if (typeof first === "object" && first && typeof first.productId != "undefined") {
      _request = productId;
      _options = webapi_options;
    } else {
      _request = {
        productId
      };
      _options = webapi_options;
    }
    return this._removeProductAsync(_request, _options);
  }
  async _toggleProductInAssortmentAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ToggleProductInAssortment", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async toggleProductInAssortmentAsync(productId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = productId;
    if (typeof first === "object" && first && typeof first.productId != "undefined") {
      _request = productId;
      _options = webapi_options;
    } else {
      _request = {
        productId
      };
      _options = webapi_options;
    }
    return this._toggleProductInAssortmentAsync(_request, _options);
  }
  async _saveQuoteAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveQuote", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Quote_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveQuoteAsync(quote, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quote;
    if (typeof first === "object" && first && typeof first.quote != "undefined") {
      _request = quote;
      _options = webapi_options;
    } else {
      _request = {
        quote
      };
      _options = webapi_options;
    }
    return this._saveQuoteAsync(_request, _options);
  }
  async _getQuoteAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetQuote", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Quote_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getQuoteAsync(quoteId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quoteId;
    if (typeof first === "object" && first && typeof first.quoteId != "undefined") {
      _request = quoteId;
      _options = webapi_options;
    } else {
      _request = {
        quoteId
      };
      _options = webapi_options;
    }
    return this._getQuoteAsync(_request, _options);
  }
  async _getQuoteFromSaleIdAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetQuoteFromSaleId", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Quote_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getQuoteFromSaleIdAsync(saleId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = saleId;
    if (typeof first === "object" && first && typeof first.saleId != "undefined") {
      _request = saleId;
      _options = webapi_options;
    } else {
      _request = {
        saleId
      };
      _options = webapi_options;
    }
    return this._getQuoteFromSaleIdAsync(_request, _options);
  }
  /*
   * Gets a QuoteAlternative object.
   * @param quoteAlternativeId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single QuoteAlternative
   */
  async getQuoteAlternativeAsync(quoteAlternativeId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetQuoteAlternative?quoteAlternativeId=" + quoteAlternativeId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_QuoteAlternative_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _recalculateQuoteAlternativeAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("RecalculateQuoteAlternative", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_QuoteAlternativeRecalculated_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async recalculateQuoteAlternativeAsync(quoteAlternative, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quoteAlternative;
    if (typeof first === "object" && first && typeof first.quoteAlternative != "undefined") {
      _request = quoteAlternative;
      _options = webapi_options;
    } else {
      _request = {
        quoteAlternative
      };
      _options = webapi_options;
    }
    return this._recalculateQuoteAlternativeAsync(_request, _options);
  }
  async _getQuoteAlternativesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetQuoteAlternatives", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_QuoteAlternativeArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getQuoteAlternativesAsync(quoteVersionId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quoteVersionId;
    if (typeof first === "object" && first && typeof first.quoteVersionId != "undefined") {
      _request = quoteVersionId;
      _options = webapi_options;
    } else {
      _request = {
        quoteVersionId
      };
      _options = webapi_options;
    }
    return this._getQuoteAlternativesAsync(_request, _options);
  }
  async _moveQuoteLineAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("MoveQuoteLine", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async moveQuoteLineAsync(quoteLineId, direction, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quoteLineId;
    if (typeof first === "object" && first && (typeof first.quoteLineId != "undefined" || typeof first.direction != "undefined")) {
      _request = quoteLineId;
      _options = direction;
    } else {
      _request = {
        quoteLineId,
        direction
      };
      _options = webapi_options;
    }
    return this._moveQuoteLineAsync(_request, _options);
  }
  async _createQuoteAlternativeAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateQuoteAlternative", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_QuoteAlternative_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createQuoteAlternativeAsync(quoteVersionId, quoteAlternativeName, quoteAlternativeDescription, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quoteVersionId;
    if (typeof first === "object" && first && (typeof first.quoteVersionId != "undefined" || typeof first.quoteAlternativeName != "undefined" || typeof first.quoteAlternativeDescription != "undefined")) {
      _request = quoteVersionId;
      _options = quoteAlternativeName;
    } else {
      _request = {
        quoteVersionId,
        quoteAlternativeName,
        quoteAlternativeDescription
      };
      _options = webapi_options;
    }
    return this._createQuoteAlternativeAsync(_request, _options);
  }
  async _copyQuoteAlternativeAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CopyQuoteAlternative", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_QuoteAlternative_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async copyQuoteAlternativeAsync(quoteVersionId, quoteAlternativeId, quoteAlternativeName, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quoteVersionId;
    if (typeof first === "object" && first && (typeof first.quoteVersionId != "undefined" || typeof first.quoteAlternativeId != "undefined" || typeof first.quoteAlternativeName != "undefined")) {
      _request = quoteVersionId;
      _options = quoteAlternativeId;
    } else {
      _request = {
        quoteVersionId,
        quoteAlternativeId,
        quoteAlternativeName
      };
      _options = webapi_options;
    }
    return this._copyQuoteAlternativeAsync(_request, _options);
  }
  async _deleteQuoteAlternativeAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeleteQuoteAlternative", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async deleteQuoteAlternativeAsync(quoteAlternativeId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quoteAlternativeId;
    if (typeof first === "object" && first && typeof first.quoteAlternativeId != "undefined") {
      _request = quoteAlternativeId;
      _options = webapi_options;
    } else {
      _request = {
        quoteAlternativeId
      };
      _options = webapi_options;
    }
    return this._deleteQuoteAlternativeAsync(_request, _options);
  }
  async _hasConnectionsAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("HasConnections", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PluginResponse_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Whether or not the system has any connections available for this user.
   * @returns The response
   */
  async hasConnectionsAsync(webapi_options) {
    return this._hasConnectionsAsync(webapi_options);
  }
  async _getAllInstalledQuoteConnectionsAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetAllInstalledQuoteConnections", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_QuoteConnectionArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Get all installed connections. Some installed connections may not be available to the user.
   * @returns List of connections
   */
  async getAllInstalledQuoteConnectionsAsync(webapi_options) {
    return this._getAllInstalledQuoteConnectionsAsync(webapi_options);
  }
  async _getAllAvailableQuoteConnectionsAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetAllAvailableQuoteConnections", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_QuoteConnectionArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Get all available connections. Some installed connections may not be available to the user. Use GetAllAvailableQuoteConnectionsWithPriceLists if you need the pricelists on the connections as well.
   * @returns List of connections
   */
  async getAllAvailableQuoteConnectionsAsync(webapi_options) {
    return this._getAllAvailableQuoteConnectionsAsync(webapi_options);
  }
  async _getAllAvailableQuoteConnectionsWithPriceListsAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetAllAvailableQuoteConnectionsWithPriceLists", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_QuoteConnectionArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Get all available connections. Some installed connections may not be available to the user. Includes pricelists for the connection. This is a heavy call
   * @returns List of connections
   */
  async getAllAvailableQuoteConnectionsWithPriceListsAsync(webapi_options) {
    return this._getAllAvailableQuoteConnectionsWithPriceListsAsync(webapi_options);
  }
  async _createConnectionFromConnectorNameAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateConnectionFromConnectorName", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_QuoteConnection_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createConnectionFromConnectorNameAsync(connectorName, webapi_options) {
    let _request = null;
    let _options = null;
    const first = connectorName;
    if (typeof first === "object" && first && typeof first.connectorName != "undefined") {
      _request = connectorName;
      _options = webapi_options;
    } else {
      _request = {
        connectorName
      };
      _options = webapi_options;
    }
    return this._createConnectionFromConnectorNameAsync(_request, _options);
  }
  async _getConnectionAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetConnection", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_QuoteConnection_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getConnectionAsync(quoteConnectionId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quoteConnectionId;
    if (typeof first === "object" && first && typeof first.quoteConnectionId != "undefined") {
      _request = quoteConnectionId;
      _options = webapi_options;
    } else {
      _request = {
        quoteConnectionId
      };
      _options = webapi_options;
    }
    return this._getConnectionAsync(_request, _options);
  }
  async _saveConnectionAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveConnection", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_QuoteConnection_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveConnectionAsync(connection2, webapi_options) {
    let _request = null;
    let _options = null;
    const first = connection2;
    if (typeof first === "object" && first && typeof first.connection != "undefined") {
      _request = connection2;
      _options = webapi_options;
    } else {
      _request = {
        connection: connection2
      };
      _options = webapi_options;
    }
    return this._saveConnectionAsync(_request, _options);
  }
  async _deleteConnectionAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeleteConnection", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async deleteConnectionAsync(quoteConnectionId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quoteConnectionId;
    if (typeof first === "object" && first && typeof first.quoteConnectionId != "undefined") {
      _request = quoteConnectionId;
      _options = webapi_options;
    } else {
      _request = {
        quoteConnectionId
      };
      _options = webapi_options;
    }
    return this._deleteConnectionAsync(_request, _options);
  }
  async _restoreConnectionAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("RestoreConnection", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async restoreConnectionAsync(quoteConnectionId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quoteConnectionId;
    if (typeof first === "object" && first && typeof first.quoteConnectionId != "undefined") {
      _request = quoteConnectionId;
      _options = webapi_options;
    } else {
      _request = {
        quoteConnectionId
      };
      _options = webapi_options;
    }
    return this._restoreConnectionAsync(_request, _options);
  }
  async _getConnectionsForAssociateAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetConnectionsForAssociate", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_QuoteConnectionArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getConnectionsForAssociateAsync(associateId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = associateId;
    if (typeof first === "object" && first && typeof first.associateId != "undefined") {
      _request = associateId;
      _options = webapi_options;
    } else {
      _request = {
        associateId
      };
      _options = webapi_options;
    }
    return this._getConnectionsForAssociateAsync(_request, _options);
  }
  async _getActivePriceListsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetActivePriceLists", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PriceListArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getActivePriceListsAsync(quoteConnectionId, currency, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quoteConnectionId;
    if (typeof first === "object" && first && (typeof first.quoteConnectionId != "undefined" || typeof first.currency != "undefined")) {
      _request = quoteConnectionId;
      _options = currency;
    } else {
      _request = {
        quoteConnectionId,
        currency
      };
      _options = webapi_options;
    }
    return this._getActivePriceListsAsync(_request, _options);
  }
  async _getActivePriceListsByCurrencyIdAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetActivePriceListsByCurrencyId", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PriceListArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getActivePriceListsByCurrencyIdAsync(quoteConnectionId, currencyId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quoteConnectionId;
    if (typeof first === "object" && first && (typeof first.quoteConnectionId != "undefined" || typeof first.currencyId != "undefined")) {
      _request = quoteConnectionId;
      _options = currencyId;
    } else {
      _request = {
        quoteConnectionId,
        currencyId
      };
      _options = webapi_options;
    }
    return this._getActivePriceListsByCurrencyIdAsync(_request, _options);
  }
  async _getAllPriceListsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetAllPriceLists", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PriceListArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getAllPriceListsAsync(quoteConnectionId, currency, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quoteConnectionId;
    if (typeof first === "object" && first && (typeof first.quoteConnectionId != "undefined" || typeof first.currency != "undefined")) {
      _request = quoteConnectionId;
      _options = currency;
    } else {
      _request = {
        quoteConnectionId,
        currency
      };
      _options = webapi_options;
    }
    return this._getAllPriceListsAsync(_request, _options);
  }
  async _getAllPriceListsByCurrencyIdAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetAllPriceListsByCurrencyId", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PriceListArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getAllPriceListsByCurrencyIdAsync(quoteConnectionId, currencyId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quoteConnectionId;
    if (typeof first === "object" && first && (typeof first.quoteConnectionId != "undefined" || typeof first.currencyId != "undefined")) {
      _request = quoteConnectionId;
      _options = currencyId;
    } else {
      _request = {
        quoteConnectionId,
        currencyId
      };
      _options = webapi_options;
    }
    return this._getAllPriceListsByCurrencyIdAsync(_request, _options);
  }
  async _getConnectorCapabilityNamesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetConnectorCapabilityNames", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getConnectorCapabilityNamesAsync(quoteConnectionId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quoteConnectionId;
    if (typeof first === "object" && first && typeof first.quoteConnectionId != "undefined") {
      _request = quoteConnectionId;
      _options = webapi_options;
    } else {
      _request = {
        quoteConnectionId
      };
      _options = webapi_options;
    }
    return this._getConnectorCapabilityNamesAsync(_request, _options);
  }
  async _getConnectorCapabilitiesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetConnectorCapabilities", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getConnectorCapabilitiesAsync(quoteConnectionId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quoteConnectionId;
    if (typeof first === "object" && first && typeof first.quoteConnectionId != "undefined") {
      _request = quoteConnectionId;
      _options = webapi_options;
    } else {
      _request = {
        quoteConnectionId
      };
      _options = webapi_options;
    }
    return this._getConnectorCapabilitiesAsync(_request, _options);
  }
  async _canConnectorProvideCapabilityAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CanConnectorProvideCapability", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async canConnectorProvideCapabilityAsync(quoteConnectionId, capabilityName, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quoteConnectionId;
    if (typeof first === "object" && first && (typeof first.quoteConnectionId != "undefined" || typeof first.capabilityName != "undefined")) {
      _request = quoteConnectionId;
      _options = capabilityName;
    } else {
      _request = {
        quoteConnectionId,
        capabilityName
      };
      _options = webapi_options;
    }
    return this._canConnectorProvideCapabilityAsync(_request, _options);
  }
  async _getConnectionStartupErrorsAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetConnectionStartupErrors", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PluginResponseArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Returns an array of PluginResponseInfos for all failed connection initializations.
   * @returns Array of PluginResponseInfos for each failed connection initialization.
   */
  async getConnectionStartupErrorsAsync(webapi_options) {
    return this._getConnectionStartupErrorsAsync(webapi_options);
  }
  async _getConnectionStartupResponseAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetConnectionStartupResponse", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PluginResponse_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getConnectionStartupResponseAsync(quoteConnectionId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quoteConnectionId;
    if (typeof first === "object" && first && typeof first.quoteConnectionId != "undefined") {
      _request = quoteConnectionId;
      _options = webapi_options;
    } else {
      _request = {
        quoteConnectionId
      };
      _options = webapi_options;
    }
    return this._getConnectionStartupResponseAsync(_request, _options);
  }
  async _getConnectionConfigFieldsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetConnectionConfigFields", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_StringDictionary_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getConnectionConfigFieldsAsync(quoteConnectionId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quoteConnectionId;
    if (typeof first === "object" && first && typeof first.quoteConnectionId != "undefined") {
      _request = quoteConnectionId;
      _options = webapi_options;
    } else {
      _request = {
        quoteConnectionId
      };
      _options = webapi_options;
    }
    return this._getConnectionConfigFieldsAsync(_request, _options);
  }
  async _saveConnectionConfigFieldsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveConnectionConfigFields", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_StringDictionary_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveConnectionConfigFieldsAsync(quoteConnectionId, connectionConfigFields, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quoteConnectionId;
    if (typeof first === "object" && first && (typeof first.quoteConnectionId != "undefined" || typeof first.connectionConfigFields != "undefined")) {
      _request = quoteConnectionId;
      _options = connectionConfigFields;
    } else {
      _request = {
        quoteConnectionId,
        connectionConfigFields
      };
      _options = webapi_options;
    }
    return this._saveConnectionConfigFieldsAsync(_request, _options);
  }
  async _createAndSaveQuoteAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateAndSaveQuote", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_QuoteEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createAndSaveQuoteAsync(saleId, connectionId, firstAlternativeName, webapi_options) {
    let _request = null;
    let _options = null;
    const first = saleId;
    if (typeof first === "object" && first && (typeof first.saleId != "undefined" || typeof first.connectionId != "undefined" || typeof first.firstAlternativeName != "undefined")) {
      _request = saleId;
      _options = connectionId;
    } else {
      _request = {
        saleId,
        connectionId,
        firstAlternativeName
      };
      _options = webapi_options;
    }
    return this._createAndSaveQuoteAsync(_request, _options);
  }
  async _getQuoteEntityAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetQuoteEntity", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_QuoteEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getQuoteEntityAsync(quoteId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quoteId;
    if (typeof first === "object" && first && typeof first.quoteId != "undefined") {
      _request = quoteId;
      _options = webapi_options;
    } else {
      _request = {
        quoteId
      };
      _options = webapi_options;
    }
    return this._getQuoteEntityAsync(_request, _options);
  }
  async _getQuoteEntityFromSaleIdAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetQuoteEntityFromSaleId", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_QuoteEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getQuoteEntityFromSaleIdAsync(saleId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = saleId;
    if (typeof first === "object" && first && typeof first.saleId != "undefined") {
      _request = saleId;
      _options = webapi_options;
    } else {
      _request = {
        saleId
      };
      _options = webapi_options;
    }
    return this._getQuoteEntityFromSaleIdAsync(_request, _options);
  }
  async _saveQuoteEntityAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveQuoteEntity", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_QuoteEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveQuoteEntityAsync(quoteEntity, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quoteEntity;
    if (typeof first === "object" && first && typeof first.quoteEntity != "undefined") {
      _request = quoteEntity;
      _options = webapi_options;
    } else {
      _request = {
        quoteEntity
      };
      _options = webapi_options;
    }
    return this._saveQuoteEntityAsync(_request, _options);
  }
  async _createAndSaveQuoteFromSaleAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateAndSaveQuoteFromSale", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_QuoteEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createAndSaveQuoteFromSaleAsync(copyFromSaleId, copyToSaleId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = copyFromSaleId;
    if (typeof first === "object" && first && (typeof first.copyFromSaleId != "undefined" || typeof first.copyToSaleId != "undefined")) {
      _request = copyFromSaleId;
      _options = copyToSaleId;
    } else {
      _request = {
        copyFromSaleId,
        copyToSaleId
      };
      _options = webapi_options;
    }
    return this._createAndSaveQuoteFromSaleAsync(_request, _options);
  }
  async _placeOrderAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("PlaceOrder", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PluginUrlResponse_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async placeOrderAsync(quoteAlternativeId, markSaleAsSold, poNumber, orderComment, culture, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quoteAlternativeId;
    if (typeof first === "object" && first && (typeof first.quoteAlternativeId != "undefined" || typeof first.markSaleAsSold != "undefined" || typeof first.poNumber != "undefined" || typeof first.orderComment != "undefined" || typeof first.culture != "undefined")) {
      _request = quoteAlternativeId;
      _options = markSaleAsSold;
    } else {
      _request = {
        quoteAlternativeId,
        markSaleAsSold,
        poNumber,
        orderComment,
        culture
      };
      _options = webapi_options;
    }
    return this._placeOrderAsync(_request, _options);
  }
  async _getOrderStateAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetOrderState", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PluginUrlResponse_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getOrderStateAsync(quoteVersionId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quoteVersionId;
    if (typeof first === "object" && first && typeof first.quoteVersionId != "undefined") {
      _request = quoteVersionId;
      _options = webapi_options;
    } else {
      _request = {
        quoteVersionId
      };
      _options = webapi_options;
    }
    return this._getOrderStateAsync(_request, _options);
  }
  async _deleteQuoteAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeleteQuote", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async deleteQuoteAsync(quoteId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quoteId;
    if (typeof first === "object" && first && typeof first.quoteId != "undefined") {
      _request = quoteId;
      _options = webapi_options;
    } else {
      _request = {
        quoteId
      };
      _options = webapi_options;
    }
    return this._deleteQuoteAsync(_request, _options);
  }
  async _createQuoteLineAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateQuoteLine", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_QuoteLine_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createQuoteLineAsync(quoteAlternativeId, erpProductKey, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quoteAlternativeId;
    if (typeof first === "object" && first && (typeof first.quoteAlternativeId != "undefined" || typeof first.erpProductKey != "undefined")) {
      _request = quoteAlternativeId;
      _options = erpProductKey;
    } else {
      _request = {
        quoteAlternativeId,
        erpProductKey
      };
      _options = webapi_options;
    }
    return this._createQuoteLineAsync(_request, _options);
  }
  async _createQuoteLineFromProductAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateQuoteLineFromProduct", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_QuoteLine_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createQuoteLineFromProductAsync(quoteAlternativeId, product, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quoteAlternativeId;
    if (typeof first === "object" && first && (typeof first.quoteAlternativeId != "undefined" || typeof first.product != "undefined")) {
      _request = quoteAlternativeId;
      _options = product;
    } else {
      _request = {
        quoteAlternativeId,
        product
      };
      _options = webapi_options;
    }
    return this._createQuoteLineFromProductAsync(_request, _options);
  }
  async _saveQuoteLineAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveQuoteLine", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_QuoteLine_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveQuoteLineAsync(quoteLine, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quoteLine;
    if (typeof first === "object" && first && typeof first.quoteLine != "undefined") {
      _request = quoteLine;
      _options = webapi_options;
    } else {
      _request = {
        quoteLine
      };
      _options = webapi_options;
    }
    return this._saveQuoteLineAsync(_request, _options);
  }
  async _saveQuoteLinesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveQuoteLines", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_QuoteLineArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveQuoteLinesAsync(quoteLines, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quoteLines;
    if (typeof first === "object" && first && typeof first.quoteLines != "undefined") {
      _request = quoteLines;
      _options = webapi_options;
    } else {
      _request = {
        quoteLines
      };
      _options = webapi_options;
    }
    return this._saveQuoteLinesAsync(_request, _options);
  }
  async _getQuoteLineAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetQuoteLine", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_QuoteLine_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getQuoteLineAsync(quoteLineId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quoteLineId;
    if (typeof first === "object" && first && typeof first.quoteLineId != "undefined") {
      _request = quoteLineId;
      _options = webapi_options;
    } else {
      _request = {
        quoteLineId
      };
      _options = webapi_options;
    }
    return this._getQuoteLineAsync(_request, _options);
  }
  async _getQuoteLinesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetQuoteLines", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_QuoteLineArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getQuoteLinesAsync(quoteAlternativeId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quoteAlternativeId;
    if (typeof first === "object" && first && typeof first.quoteAlternativeId != "undefined") {
      _request = quoteAlternativeId;
      _options = webapi_options;
    } else {
      _request = {
        quoteAlternativeId
      };
      _options = webapi_options;
    }
    return this._getQuoteLinesAsync(_request, _options);
  }
  async _deleteQuoteLineAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeleteQuoteLine", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async deleteQuoteLineAsync(quoteLineId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quoteLineId;
    if (typeof first === "object" && first && typeof first.quoteLineId != "undefined") {
      _request = quoteLineId;
      _options = webapi_options;
    } else {
      _request = {
        quoteLineId
      };
      _options = webapi_options;
    }
    return this._deleteQuoteLineAsync(_request, _options);
  }
  async _deleteQuoteLinesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeleteQuoteLines", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async deleteQuoteLinesAsync(quoteLineIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quoteLineIds;
    if (typeof first === "object" && first && typeof first.quoteLineIds != "undefined") {
      _request = quoteLineIds;
      _options = webapi_options;
    } else {
      _request = {
        quoteLineIds
      };
      _options = webapi_options;
    }
    return this._deleteQuoteLinesAsync(_request, _options);
  }
  async _recalculateQuoteLineAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("RecalculateQuoteLine", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_QuoteLine_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async recalculateQuoteLineAsync(quoteLine, changedFields, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quoteLine;
    if (typeof first === "object" && first && (typeof first.quoteLine != "undefined" || typeof first.changedFields != "undefined")) {
      _request = quoteLine;
      _options = changedFields;
    } else {
      _request = {
        quoteLine,
        changedFields
      };
      _options = webapi_options;
    }
    return this._recalculateQuoteLineAsync(_request, _options);
  }
  async _getQuoteLineImageAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        if (!options || options.returnBlobAs == ReturnBlobType.AsArrayBuffer) {
          config.responseType = "arraybuffer";
          config.headers = config.headers || {};
          config.headers["Accept"] = "application/octet-stream";
        }
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetQuoteLineImage", request, config);
        WebApiBase.SetCompleted(options);
        let res = null;
        if (options && options.returnBlobAs != ReturnBlobType.AsArrayBuffer) {
          res = response.data;
          if (options.returnBlobAs == ReturnBlobType.AsString) {
            res = FromBase64ToString(res);
          }
        } else {
          res = response.data;
        }
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getQuoteLineImageAsync(quoteLineId, rank, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quoteLineId;
    if (typeof first === "object" && first && (typeof first.quoteLineId != "undefined" || typeof first.rank != "undefined")) {
      _request = quoteLineId;
      _options = rank;
    } else {
      _request = {
        quoteLineId,
        rank
      };
      _options = webapi_options;
    }
    return this._getQuoteLineImageAsync(_request, _options);
  }
  async _saveQuoteLineImageAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveQuoteLineImage", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveQuoteLineImageAsync(quoteLineId, image, rank, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quoteLineId;
    if (typeof first === "object" && first && (typeof first.quoteLineId != "undefined" || typeof first.image != "undefined" || typeof first.rank != "undefined")) {
      _request = quoteLineId;
      _options = image;
    } else {
      _request = {
        quoteLineId,
        image,
        rank
      };
      _options = webapi_options;
    }
    _request.image = ToBase64(_request.image);
    return this._saveQuoteLineImageAsync(_request, _options);
  }
  async _getExtraInfoAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetExtraInfo", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ProductExtraDataFieldArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getExtraInfoAsync(quoteLineExtraData, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quoteLineExtraData;
    if (typeof first === "object" && first && typeof first.quoteLineExtraData != "undefined") {
      _request = quoteLineExtraData;
      _options = webapi_options;
    } else {
      _request = {
        quoteLineExtraData
      };
      _options = webapi_options;
    }
    return this._getExtraInfoAsync(_request, _options);
  }
  async _getQuoteLineConfigurationAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetQuoteLineConfiguration", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_QuoteLineConfiguration_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getQuoteLineConfigurationAsync(quoteLineConfigurationId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quoteLineConfigurationId;
    if (typeof first === "object" && first && typeof first.quoteLineConfigurationId != "undefined") {
      _request = quoteLineConfigurationId;
      _options = webapi_options;
    } else {
      _request = {
        quoteLineConfigurationId
      };
      _options = webapi_options;
    }
    return this._getQuoteLineConfigurationAsync(_request, _options);
  }
  async _getQuoteLineConfigurationFromFieldNameAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetQuoteLineConfigurationFromFieldName", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_QuoteLineConfiguration_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getQuoteLineConfigurationFromFieldNameAsync(fieldName, webapi_options) {
    let _request = null;
    let _options = null;
    const first = fieldName;
    if (typeof first === "object" && first && typeof first.fieldName != "undefined") {
      _request = fieldName;
      _options = webapi_options;
    } else {
      _request = {
        fieldName
      };
      _options = webapi_options;
    }
    return this._getQuoteLineConfigurationFromFieldNameAsync(_request, _options);
  }
  async _getAllQuoteLineConfigurationsAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetAllQuoteLineConfigurations", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_QuoteLineConfigurationArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Returns all the configuration fields
   * @returns Array of QuoteLineConfigurations
   */
  async getAllQuoteLineConfigurationsAsync(webapi_options) {
    return this._getAllQuoteLineConfigurationsAsync(webapi_options);
  }
  async _getInUseQuoteLineConfigurationsAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetInUseQuoteLineConfigurations", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_QuoteLineConfigurationArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Returns the configuration fields that should be visible in the GUI.
   * @returns Array of QuoteLineConfigurations
   */
  async getInUseQuoteLineConfigurationsAsync(webapi_options) {
    return this._getInUseQuoteLineConfigurationsAsync(webapi_options);
  }
  async _saveQuoteLineConfigurationAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveQuoteLineConfiguration", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_QuoteLineConfiguration_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveQuoteLineConfigurationAsync(quoteLineConfiguration, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quoteLineConfiguration;
    if (typeof first === "object" && first && typeof first.quoteLineConfiguration != "undefined") {
      _request = quoteLineConfiguration;
      _options = webapi_options;
    } else {
      _request = {
        quoteLineConfiguration
      };
      _options = webapi_options;
    }
    return this._saveQuoteLineConfigurationAsync(_request, _options);
  }
  async _saveQuoteLineConfigurationsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveQuoteLineConfigurations", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_QuoteLineConfigurationArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveQuoteLineConfigurationsAsync(quoteLineConfigurations, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quoteLineConfigurations;
    if (typeof first === "object" && first && typeof first.quoteLineConfigurations != "undefined") {
      _request = quoteLineConfigurations;
      _options = webapi_options;
    } else {
      _request = {
        quoteLineConfigurations
      };
      _options = webapi_options;
    }
    return this._saveQuoteLineConfigurationsAsync(_request, _options);
  }
  async _getQuoteListAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetQuoteList", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_QuoteListItemArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getQuoteListAsync(quoteListType, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quoteListType;
    if (typeof first === "object" && first && typeof first.quoteListType != "undefined") {
      _request = quoteListType;
      _options = webapi_options;
    } else {
      _request = {
        quoteListType
      };
      _options = webapi_options;
    }
    return this._getQuoteListAsync(_request, _options);
  }
  async _validateQuoteVersionAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ValidateQuoteVersion", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_QuoteVersionValidated_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async validateQuoteVersionAsync(quoteVersionId, action, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quoteVersionId;
    if (typeof first === "object" && first && (typeof first.quoteVersionId != "undefined" || typeof first.action != "undefined")) {
      _request = quoteVersionId;
      _options = action;
    } else {
      _request = {
        quoteVersionId,
        action
      };
      _options = webapi_options;
    }
    return this._validateQuoteVersionAsync(_request, _options);
  }
  async _createAndSaveQuoteVersionAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateAndSaveQuoteVersion", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_QuoteVersion_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createAndSaveQuoteVersionAsync(quoteVersionId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quoteVersionId;
    if (typeof first === "object" && first && typeof first.quoteVersionId != "undefined") {
      _request = quoteVersionId;
      _options = webapi_options;
    } else {
      _request = {
        quoteVersionId
      };
      _options = webapi_options;
    }
    return this._createAndSaveQuoteVersionAsync(_request, _options);
  }
  async _getQuoteVersionAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetQuoteVersion", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_QuoteVersion_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getQuoteVersionAsync(quoteVersionId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quoteVersionId;
    if (typeof first === "object" && first && typeof first.quoteVersionId != "undefined") {
      _request = quoteVersionId;
      _options = webapi_options;
    } else {
      _request = {
        quoteVersionId
      };
      _options = webapi_options;
    }
    return this._getQuoteVersionAsync(_request, _options);
  }
  async _getQuoteVersionsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetQuoteVersions", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_QuoteVersionArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getQuoteVersionsAsync(quoteId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quoteId;
    if (typeof first === "object" && first && typeof first.quoteId != "undefined") {
      _request = quoteId;
      _options = webapi_options;
    } else {
      _request = {
        quoteId
      };
      _options = webapi_options;
    }
    return this._getQuoteVersionsAsync(_request, _options);
  }
  async _sendQuoteVersionAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SendQuoteVersion", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PluginUrlResponse_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async sendQuoteVersionAsync(quoteVersionId, expiryDate, followupDate, followupText, culture, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quoteVersionId;
    if (typeof first === "object" && first && (typeof first.quoteVersionId != "undefined" || typeof first.expiryDate != "undefined" || typeof first.followupDate != "undefined" || typeof first.followupText != "undefined" || typeof first.culture != "undefined")) {
      _request = quoteVersionId;
      _options = expiryDate;
    } else {
      _request = {
        quoteVersionId,
        expiryDate,
        followupDate,
        followupText,
        culture
      };
      _options = webapi_options;
    }
    return this._sendQuoteVersionAsync(_request, _options);
  }
  async _saveQuoteVersionAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveQuoteVersion", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_QuoteVersion_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveQuoteVersionAsync(quoteVersion, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quoteVersion;
    if (typeof first === "object" && first && typeof first.quoteVersion != "undefined") {
      _request = quoteVersion;
      _options = webapi_options;
    } else {
      _request = {
        quoteVersion
      };
      _options = webapi_options;
    }
    return this._saveQuoteVersionAsync(_request, _options);
  }
  async _approveQuoteVersionAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ApproveQuoteVersion", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ApproveRejectResponse_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async approveQuoteVersionAsync(quoteVersionId, approvedByText, approvedByAssociateId, approvalText, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quoteVersionId;
    if (typeof first === "object" && first && (typeof first.quoteVersionId != "undefined" || typeof first.approvedByText != "undefined" || typeof first.approvedByAssociateId != "undefined" || typeof first.approvalText != "undefined")) {
      _request = quoteVersionId;
      _options = approvedByText;
    } else {
      _request = {
        quoteVersionId,
        approvedByText,
        approvedByAssociateId,
        approvalText
      };
      _options = webapi_options;
    }
    return this._approveQuoteVersionAsync(_request, _options);
  }
  async _rejectQuoteVersionAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("RejectQuoteVersion", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ApproveRejectResponse_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async rejectQuoteVersionAsync(quoteVersionId, rejectedByText, rejectedByAssociateId, rejectionText, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quoteVersionId;
    if (typeof first === "object" && first && (typeof first.quoteVersionId != "undefined" || typeof first.rejectedByText != "undefined" || typeof first.rejectedByAssociateId != "undefined" || typeof first.rejectionText != "undefined")) {
      _request = quoteVersionId;
      _options = rejectedByText;
    } else {
      _request = {
        quoteVersionId,
        rejectedByText,
        rejectedByAssociateId,
        rejectionText
      };
      _options = webapi_options;
    }
    return this._rejectQuoteVersionAsync(_request, _options);
  }
  async _generateQuoteDocumentsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GenerateQuoteDocuments", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_QuotePublishDocuments_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async generateQuoteDocumentsAsync(quoteVersionId, emailBodyTemplateId, attachMainDocument, quotedProductsTemplateId, includeAttachments, rawMailSubject, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quoteVersionId;
    if (typeof first === "object" && first && (typeof first.quoteVersionId != "undefined" || typeof first.emailBodyTemplateId != "undefined" || typeof first.attachMainDocument != "undefined" || typeof first.quotedProductsTemplateId != "undefined" || typeof first.includeAttachments != "undefined" || typeof first.rawMailSubject != "undefined")) {
      _request = quoteVersionId;
      _options = emailBodyTemplateId;
    } else {
      _request = {
        quoteVersionId,
        emailBodyTemplateId,
        attachMainDocument,
        quotedProductsTemplateId,
        includeAttachments,
        rawMailSubject
      };
      _options = webapi_options;
    }
    return this._generateQuoteDocumentsAsync(_request, _options);
  }
  async _getOrderConfirmationAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetOrderConfirmation", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getOrderConfirmationAsync(quoteVersionId, confirmationTemplateId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quoteVersionId;
    if (typeof first === "object" && first && (typeof first.quoteVersionId != "undefined" || typeof first.confirmationTemplateId != "undefined")) {
      _request = quoteVersionId;
      _options = confirmationTemplateId;
    } else {
      _request = {
        quoteVersionId,
        confirmationTemplateId
      };
      _options = webapi_options;
    }
    return this._getOrderConfirmationAsync(_request, _options);
  }
  async _getQuoteVersionWorkflowStateAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetQuoteVersionWorkflowState", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_QuoteVersionWorkflowState_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getQuoteVersionWorkflowStateAsync(quoteVersionId, quoteAlternativeId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quoteVersionId;
    if (typeof first === "object" && first && (typeof first.quoteVersionId != "undefined" || typeof first.quoteAlternativeId != "undefined")) {
      _request = quoteVersionId;
      _options = quoteAlternativeId;
    } else {
      _request = {
        quoteVersionId,
        quoteAlternativeId
      };
      _options = webapi_options;
    }
    return this._getQuoteVersionWorkflowStateAsync(_request, _options);
  }
  async _updateQuoteVersionPricesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("UpdateQuoteVersionPrices", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_QuoteVersionValidated_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async updateQuoteVersionPricesAsync(quoteVersionId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quoteVersionId;
    if (typeof first === "object" && first && typeof first.quoteVersionId != "undefined") {
      _request = quoteVersionId;
      _options = webapi_options;
    } else {
      _request = {
        quoteVersionId
      };
      _options = webapi_options;
    }
    return this._updateQuoteVersionPricesAsync(_request, _options);
  }
  async _saveQuoteVersionNumberAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveQuoteVersionNumber", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveQuoteVersionNumberAsync(quoteVersionId, number, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quoteVersionId;
    if (typeof first === "object" && first && (typeof first.quoteVersionId != "undefined" || typeof first.number != "undefined")) {
      _request = quoteVersionId;
      _options = number;
    } else {
      _request = {
        quoteVersionId,
        number
      };
      _options = webapi_options;
    }
    return this._saveQuoteVersionNumberAsync(_request, _options);
  }
  async _getQuoteVersionWorkflowImageStateAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetQuoteVersionWorkflowImageState", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_QuoteVersionButtonState_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getQuoteVersionWorkflowImageStateAsync(quoteVersionId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quoteVersionId;
    if (typeof first === "object" && first && typeof first.quoteVersionId != "undefined") {
      _request = quoteVersionId;
      _options = webapi_options;
    } else {
      _request = {
        quoteVersionId
      };
      _options = webapi_options;
    }
    return this._getQuoteVersionWorkflowImageStateAsync(_request, _options);
  }
  async _getQuoteVersionWorkflowButtonStatesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetQuoteVersionWorkflowButtonStates", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_QuoteVersionWorkflowState_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getQuoteVersionWorkflowButtonStatesAsync(quoteVersionId, quoteAlternativeId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quoteVersionId;
    if (typeof first === "object" && first && (typeof first.quoteVersionId != "undefined" || typeof first.quoteAlternativeId != "undefined")) {
      _request = quoteVersionId;
      _options = quoteAlternativeId;
    } else {
      _request = {
        quoteVersionId,
        quoteAlternativeId
      };
      _options = webapi_options;
    }
    return this._getQuoteVersionWorkflowButtonStatesAsync(_request, _options);
  }
  async _getQuoteVersionWorkflowStatusInfoAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetQuoteVersionWorkflowStatusInfo", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_QuoteVersionStatusInformation_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getQuoteVersionWorkflowStatusInfoAsync(quoteVersionId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quoteVersionId;
    if (typeof first === "object" && first && typeof first.quoteVersionId != "undefined") {
      _request = quoteVersionId;
      _options = webapi_options;
    } else {
      _request = {
        quoteVersionId
      };
      _options = webapi_options;
    }
    return this._getQuoteVersionWorkflowStatusInfoAsync(_request, _options);
  }
  async _requestApprovalAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("RequestApproval", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PluginResponse_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async requestApprovalAsync(quoteVersionId, associateId, comment, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quoteVersionId;
    if (typeof first === "object" && first && (typeof first.quoteVersionId != "undefined" || typeof first.associateId != "undefined" || typeof first.comment != "undefined")) {
      _request = quoteVersionId;
      _options = associateId;
    } else {
      _request = {
        quoteVersionId,
        associateId,
        comment
      };
      _options = webapi_options;
    }
    return this._requestApprovalAsync(_request, _options);
  }
  async _cancelApprovalRequestAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CancelApprovalRequest", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PluginResponse_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async cancelApprovalRequestAsync(quoteVersionId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quoteVersionId;
    if (typeof first === "object" && first && typeof first.quoteVersionId != "undefined") {
      _request = quoteVersionId;
      _options = webapi_options;
    } else {
      _request = {
        quoteVersionId
      };
      _options = webapi_options;
    }
    return this._cancelApprovalRequestAsync(_request, _options);
  }
  async _createOrUpdateQuoteVersionAttachmentsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateOrUpdateQuoteVersionAttachments", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_QuoteVersionAttachmentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createOrUpdateQuoteVersionAttachmentsAsync(quoteVersionId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quoteVersionId;
    if (typeof first === "object" && first && typeof first.quoteVersionId != "undefined") {
      _request = quoteVersionId;
      _options = webapi_options;
    } else {
      _request = {
        quoteVersionId
      };
      _options = webapi_options;
    }
    return this._createOrUpdateQuoteVersionAttachmentsAsync(_request, _options);
  }
  async _includeQuoteVersionAttachmentAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("IncludeQuoteVersionAttachment", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async includeQuoteVersionAttachmentAsync(quoteVersionId, documentId, include, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quoteVersionId;
    if (typeof first === "object" && first && (typeof first.quoteVersionId != "undefined" || typeof first.documentId != "undefined" || typeof first.include != "undefined")) {
      _request = quoteVersionId;
      _options = documentId;
    } else {
      _request = {
        quoteVersionId,
        documentId,
        include
      };
      _options = webapi_options;
    }
    return this._includeQuoteVersionAttachmentAsync(_request, _options);
  }
  async _toggleSaleTypeQuoteAttachmentDefaultIncludedAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ToggleSaleTypeQuoteAttachmentDefaultIncluded", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async toggleSaleTypeQuoteAttachmentDefaultIncludedAsync(saleTypeQuoteAttachmentId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = saleTypeQuoteAttachmentId;
    if (typeof first === "object" && first && typeof first.saleTypeQuoteAttachmentId != "undefined") {
      _request = saleTypeQuoteAttachmentId;
      _options = webapi_options;
    } else {
      _request = {
        saleTypeQuoteAttachmentId
      };
      _options = webapi_options;
    }
    return this._toggleSaleTypeQuoteAttachmentDefaultIncludedAsync(_request, _options);
  }
  async _addSaleTypeQuoteAttachmentAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("AddSaleTypeQuoteAttachment", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async addSaleTypeQuoteAttachmentAsync(saleTypeId, documentId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = saleTypeId;
    if (typeof first === "object" && first && (typeof first.saleTypeId != "undefined" || typeof first.documentId != "undefined")) {
      _request = saleTypeId;
      _options = documentId;
    } else {
      _request = {
        saleTypeId,
        documentId
      };
      _options = webapi_options;
    }
    return this._addSaleTypeQuoteAttachmentAsync(_request, _options);
  }
  async _deleteSaleTypeQuoteAttachmentAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeleteSaleTypeQuoteAttachment", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async deleteSaleTypeQuoteAttachmentAsync(saleTypeQuoteAttachmentId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = saleTypeQuoteAttachmentId;
    if (typeof first === "object" && first && typeof first.saleTypeQuoteAttachmentId != "undefined") {
      _request = saleTypeQuoteAttachmentId;
      _options = webapi_options;
    } else {
      _request = {
        saleTypeQuoteAttachmentId
      };
      _options = webapi_options;
    }
    return this._deleteSaleTypeQuoteAttachmentAsync(_request, _options);
  }
  async _toggleQuoteVersionAttachmentIncludedAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ToggleQuoteVersionAttachmentIncluded", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async toggleQuoteVersionAttachmentIncludedAsync(quoteVersionAttachmentId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quoteVersionAttachmentId;
    if (typeof first === "object" && first && typeof first.quoteVersionAttachmentId != "undefined") {
      _request = quoteVersionAttachmentId;
      _options = webapi_options;
    } else {
      _request = {
        quoteVersionAttachmentId
      };
      _options = webapi_options;
    }
    return this._toggleQuoteVersionAttachmentIncludedAsync(_request, _options);
  }
};

// server/node_modules/@superoffice/webapi/dist/esm/ErpSyncAgent.js
var ErpSyncAgent = class extends WebApiBase {
  constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
    const options = WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
    options.basePath = "v1/Agents/ErpSync/";
    super(options);
  }
  /**
   * Set default values into a new ErpSyncConnectorEntity.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultErpSyncConnectorEntityAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultErpSyncConnectorEntity", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ErpSyncConnectorEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing ErpSyncConnectorEntity or creates a new ErpSyncConnectorEntity if the id parameter is empty
   * @param entity - The ErpSyncConnectorEntity to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated ErpSyncConnectorEntity
   */
  async saveErpSyncConnectorEntityAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveErpSyncConnectorEntity", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ErpSyncConnectorEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Deletes the ErpSyncConnectorEntity
   * @param ErpSyncConnectorEntityId - The id of the ErpSyncConnectorEntity to be deleted.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   */
  async deleteErpSyncConnectorEntityAsync(ErpSyncConnectorEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("DeleteErpSyncConnectorEntity?ErpSyncConnectorEntityId=" + ErpSyncConnectorEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getConnectionAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetConnection", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ErpConnection_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getConnectionAsync(erpConnectionId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = erpConnectionId;
    if (typeof first === "object" && first && typeof first.erpConnectionId != "undefined") {
      _request = erpConnectionId;
      _options = webapi_options;
    } else {
      _request = {
        erpConnectionId
      };
      _options = webapi_options;
    }
    return this._getConnectionAsync(_request, _options);
  }
  async _saveConnectionAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveConnection", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ErpConnection_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveConnectionAsync(connection2, webapi_options) {
    let _request = null;
    let _options = null;
    const first = connection2;
    if (typeof first === "object" && first && typeof first.connection != "undefined") {
      _request = connection2;
      _options = webapi_options;
    } else {
      _request = {
        connection: connection2
      };
      _options = webapi_options;
    }
    return this._saveConnectionAsync(_request, _options);
  }
  async _deleteConnectionAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeleteConnection", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async deleteConnectionAsync(erpConnectionId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = erpConnectionId;
    if (typeof first === "object" && first && typeof first.erpConnectionId != "undefined") {
      _request = erpConnectionId;
      _options = webapi_options;
    } else {
      _request = {
        erpConnectionId
      };
      _options = webapi_options;
    }
    return this._deleteConnectionAsync(_request, _options);
  }
  async _getConfigurationFieldsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetConfigurationFields", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_FieldMetadataArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getConfigurationFieldsAsync(erpConnectorId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = erpConnectorId;
    if (typeof first === "object" && first && typeof first.erpConnectorId != "undefined") {
      _request = erpConnectorId;
      _options = webapi_options;
    } else {
      _request = {
        erpConnectorId
      };
      _options = webapi_options;
    }
    return this._getConfigurationFieldsAsync(_request, _options);
  }
  async _getErpConnectionConfigFieldsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetErpConnectionConfigFields", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_StringDictionary_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getErpConnectionConfigFieldsAsync(erpConnectionId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = erpConnectionId;
    if (typeof first === "object" && first && typeof first.erpConnectionId != "undefined") {
      _request = erpConnectionId;
      _options = webapi_options;
    } else {
      _request = {
        erpConnectionId
      };
      _options = webapi_options;
    }
    return this._getErpConnectionConfigFieldsAsync(_request, _options);
  }
  async _toggleErpConnectionActiveAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ToggleErpConnectionActive", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async toggleErpConnectionActiveAsync(erpConnectionId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = erpConnectionId;
    if (typeof first === "object" && first && typeof first.erpConnectionId != "undefined") {
      _request = erpConnectionId;
      _options = webapi_options;
    } else {
      _request = {
        erpConnectionId
      };
      _options = webapi_options;
    }
    return this._toggleErpConnectionActiveAsync(_request, _options);
  }
  async _testConnectionByIdAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("TestConnectionById", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async testConnectionByIdAsync(erpConnectionId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = erpConnectionId;
    if (typeof first === "object" && first && typeof first.erpConnectionId != "undefined") {
      _request = erpConnectionId;
      _options = webapi_options;
    } else {
      _request = {
        erpConnectionId
      };
      _options = webapi_options;
    }
    return this._testConnectionByIdAsync(_request, _options);
  }
  async _testConnectionByConfigAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("TestConnectionByConfig", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async testConnectionByConfigAsync(erpConnectionId, configFields, webapi_options) {
    let _request = null;
    let _options = null;
    const first = erpConnectionId;
    if (typeof first === "object" && first && (typeof first.erpConnectionId != "undefined" || typeof first.configFields != "undefined")) {
      _request = erpConnectionId;
      _options = configFields;
    } else {
      _request = {
        erpConnectionId,
        configFields
      };
      _options = webapi_options;
    }
    return this._testConnectionByConfigAsync(_request, _options);
  }
  async _saveErpConnectionSyncPrioritiesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveErpConnectionSyncPriorities", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveErpConnectionSyncPrioritiesAsync(erpConnectionIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = erpConnectionIds;
    if (typeof first === "object" && first && typeof first.erpConnectionIds != "undefined") {
      _request = erpConnectionIds;
      _options = webapi_options;
    } else {
      _request = {
        erpConnectionIds
      };
      _options = webapi_options;
    }
    return this._saveErpConnectionSyncPrioritiesAsync(_request, _options);
  }
  async _moveErpFieldItemAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("MoveErpFieldItem", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async moveErpFieldItemAsync(erpFieldId, direction, erpConnectionId, erpActorType, webapi_options) {
    let _request = null;
    let _options = null;
    const first = erpFieldId;
    if (typeof first === "object" && first && (typeof first.erpFieldId != "undefined" || typeof first.direction != "undefined" || typeof first.erpConnectionId != "undefined" || typeof first.erpActorType != "undefined")) {
      _request = erpFieldId;
      _options = direction;
    } else {
      _request = {
        erpFieldId,
        direction,
        erpConnectionId,
        erpActorType
      };
      _options = webapi_options;
    }
    return this._moveErpFieldItemAsync(_request, _options);
  }
  async _supportsAdvancedSearchAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SupportsAdvancedSearch", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async supportsAdvancedSearchAsync(erpConnectionId, erpActorType, webapi_options) {
    let _request = null;
    let _options = null;
    const first = erpConnectionId;
    if (typeof first === "object" && first && (typeof first.erpConnectionId != "undefined" || typeof first.erpActorType != "undefined")) {
      _request = erpConnectionId;
      _options = erpActorType;
    } else {
      _request = {
        erpConnectionId,
        erpActorType
      };
      _options = webapi_options;
    }
    return this._supportsAdvancedSearchAsync(_request, _options);
  }
  async _getAllConnectorsAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetAllConnectors", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ListItemArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Returns all ERP Sync connectors. Uses the `ErpConnector` archive.
   * @returns The connector id, name, url
   */
  async getAllConnectorsAsync(webapi_options) {
    return this._getAllConnectorsAsync(webapi_options);
  }
  async _getAllConnectionsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetAllConnections", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ErpConnectionArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getAllConnectionsAsync(includeDeleted, webapi_options) {
    let _request = null;
    let _options = null;
    const first = includeDeleted;
    if (typeof first === "object" && first && typeof first.includeDeleted != "undefined") {
      _request = includeDeleted;
      _options = webapi_options;
    } else {
      _request = {
        includeDeleted
      };
      _options = webapi_options;
    }
    return this._getAllConnectionsAsync(_request, _options);
  }
  async _getConnectionsAndDisplayFieldsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetConnectionsAndDisplayFields", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ErpConnectionDataArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getConnectionsAndDisplayFieldsAsync(crmActorType, entityId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = crmActorType;
    if (typeof first === "object" && first && (typeof first.crmActorType != "undefined" || typeof first.entityId != "undefined")) {
      _request = crmActorType;
      _options = entityId;
    } else {
      _request = {
        crmActorType,
        entityId
      };
      _options = webapi_options;
    }
    return this._getConnectionsAndDisplayFieldsAsync(_request, _options);
  }
  async _getErpFieldValuesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetErpFieldValues", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getErpFieldValuesAsync(erpConnectionId, crmActorType, entityId, fieldKeys, webapi_options) {
    let _request = null;
    let _options = null;
    const first = erpConnectionId;
    if (typeof first === "object" && first && (typeof first.erpConnectionId != "undefined" || typeof first.crmActorType != "undefined" || typeof first.entityId != "undefined" || typeof first.fieldKeys != "undefined")) {
      _request = erpConnectionId;
      _options = crmActorType;
    } else {
      _request = {
        erpConnectionId,
        crmActorType,
        entityId,
        fieldKeys
      };
      _options = webapi_options;
    }
    return this._getErpFieldValuesAsync(_request, _options);
  }
  async _getFieldsForNewErpActorAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetFieldsForNewErpActor", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_FieldMetadataArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getFieldsForNewErpActorAsync(erpConnectionId, erpActorType, webapi_options) {
    let _request = null;
    let _options = null;
    const first = erpConnectionId;
    if (typeof first === "object" && first && (typeof first.erpConnectionId != "undefined" || typeof first.erpActorType != "undefined")) {
      _request = erpConnectionId;
      _options = erpActorType;
    } else {
      _request = {
        erpConnectionId,
        erpActorType
      };
      _options = webapi_options;
    }
    return this._getFieldsForNewErpActorAsync(_request, _options);
  }
  async _getConnectionListMappingsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetConnectionListMappings", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ErpConnectionListMappingContainer_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getConnectionListMappingsAsync(erpConnectionId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = erpConnectionId;
    if (typeof first === "object" && first && typeof first.erpConnectionId != "undefined") {
      _request = erpConnectionId;
      _options = webapi_options;
    } else {
      _request = {
        erpConnectionId
      };
      _options = webapi_options;
    }
    return this._getConnectionListMappingsAsync(_request, _options);
  }
  async _saveConnectionListMappingsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveConnectionListMappings", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ErpConnectionListMappingContainer_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveConnectionListMappingsAsync(listMapping, webapi_options) {
    let _request = null;
    let _options = null;
    const first = listMapping;
    if (typeof first === "object" && first && typeof first.listMapping != "undefined") {
      _request = listMapping;
      _options = webapi_options;
    } else {
      _request = {
        listMapping
      };
      _options = webapi_options;
    }
    return this._saveConnectionListMappingsAsync(_request, _options);
  }
  async _connectActorAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ConnectActor", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async connectActorAsync(erpConnectionId, crmRecordId, crmActorType, erpKey, erpActorType, fieldValues, webapi_options) {
    let _request = null;
    let _options = null;
    const first = erpConnectionId;
    if (typeof first === "object" && first && (typeof first.erpConnectionId != "undefined" || typeof first.crmRecordId != "undefined" || typeof first.crmActorType != "undefined" || typeof first.erpKey != "undefined" || typeof first.erpActorType != "undefined" || typeof first.fieldValues != "undefined")) {
      _request = erpConnectionId;
      _options = crmRecordId;
    } else {
      _request = {
        erpConnectionId,
        crmRecordId,
        crmActorType,
        erpKey,
        erpActorType,
        fieldValues
      };
      _options = webapi_options;
    }
    return this._connectActorAsync(_request, _options);
  }
  async _tryConnectActorAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("TryConnectActor", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async tryConnectActorAsync(erpConnectionId, crmRecordId, crmActorType, erpKey, erpActorType, fieldValues, webapi_options) {
    let _request = null;
    let _options = null;
    const first = erpConnectionId;
    if (typeof first === "object" && first && (typeof first.erpConnectionId != "undefined" || typeof first.crmRecordId != "undefined" || typeof first.crmActorType != "undefined" || typeof first.erpKey != "undefined" || typeof first.erpActorType != "undefined" || typeof first.fieldValues != "undefined")) {
      _request = erpConnectionId;
      _options = crmRecordId;
    } else {
      _request = {
        erpConnectionId,
        crmRecordId,
        crmActorType,
        erpKey,
        erpActorType,
        fieldValues
      };
      _options = webapi_options;
    }
    return this._tryConnectActorAsync(_request, _options);
  }
  async _getFieldValuesFromCrmAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetFieldValuesFromCrm", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ErpSyncFieldValueArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getFieldValuesFromCrmAsync(recordId, actorTypeCrm, webapi_options) {
    let _request = null;
    let _options = null;
    const first = recordId;
    if (typeof first === "object" && first && (typeof first.recordId != "undefined" || typeof first.actorTypeCrm != "undefined")) {
      _request = recordId;
      _options = actorTypeCrm;
    } else {
      _request = {
        recordId,
        actorTypeCrm
      };
      _options = webapi_options;
    }
    return this._getFieldValuesFromCrmAsync(_request, _options);
  }
  async _getFieldValuesFromErpAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetFieldValuesFromErp", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ErpSyncFieldValueArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getFieldValuesFromErpAsync(erpConnectionId, actorTypeErp, erpKey, webapi_options) {
    let _request = null;
    let _options = null;
    const first = erpConnectionId;
    if (typeof first === "object" && first && (typeof first.erpConnectionId != "undefined" || typeof first.actorTypeErp != "undefined" || typeof first.erpKey != "undefined")) {
      _request = erpConnectionId;
      _options = actorTypeErp;
    } else {
      _request = {
        erpConnectionId,
        actorTypeErp,
        erpKey
      };
      _options = webapi_options;
    }
    return this._getFieldValuesFromErpAsync(_request, _options);
  }
  async _getActorTypeMappingAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetActorTypeMapping", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ErpSyncActorTypeMapping_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getActorTypeMappingAsync(erpConnectionId, actorType, webapi_options) {
    let _request = null;
    let _options = null;
    const first = erpConnectionId;
    if (typeof first === "object" && first && (typeof first.erpConnectionId != "undefined" || typeof first.actorType != "undefined")) {
      _request = erpConnectionId;
      _options = actorType;
    } else {
      _request = {
        erpConnectionId,
        actorType
      };
      _options = webapi_options;
    }
    return this._getActorTypeMappingAsync(_request, _options);
  }
  async _createActorLinkAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateActorLink", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createActorLinkAsync(erpConnectionId, crmRecordId, crmActorType, erpKey, erpActorType, webapi_options) {
    let _request = null;
    let _options = null;
    const first = erpConnectionId;
    if (typeof first === "object" && first && (typeof first.erpConnectionId != "undefined" || typeof first.crmRecordId != "undefined" || typeof first.crmActorType != "undefined" || typeof first.erpKey != "undefined" || typeof first.erpActorType != "undefined")) {
      _request = erpConnectionId;
      _options = crmRecordId;
    } else {
      _request = {
        erpConnectionId,
        crmRecordId,
        crmActorType,
        erpKey,
        erpActorType
      };
      _options = webapi_options;
    }
    return this._createActorLinkAsync(_request, _options);
  }
  async _breakActorLinkAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("BreakActorLink", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async breakActorLinkAsync(erpConnectionId, crmRecordId, crmActorType, webapi_options) {
    let _request = null;
    let _options = null;
    const first = erpConnectionId;
    if (typeof first === "object" && first && (typeof first.erpConnectionId != "undefined" || typeof first.crmRecordId != "undefined" || typeof first.crmActorType != "undefined")) {
      _request = erpConnectionId;
      _options = crmRecordId;
    } else {
      _request = {
        erpConnectionId,
        crmRecordId,
        crmActorType
      };
      _options = webapi_options;
    }
    return this._breakActorLinkAsync(_request, _options);
  }
  async _createErpActorFromCrmAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateErpActorFromCrm", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createErpActorFromCrmAsync(connectionId, crmEntityId, erpActorType, crmActorType, erpFieldKeyValues, webapi_options) {
    let _request = null;
    let _options = null;
    const first = connectionId;
    if (typeof first === "object" && first && (typeof first.connectionId != "undefined" || typeof first.crmEntityId != "undefined" || typeof first.erpActorType != "undefined" || typeof first.crmActorType != "undefined" || typeof first.erpFieldKeyValues != "undefined")) {
      _request = connectionId;
      _options = crmEntityId;
    } else {
      _request = {
        connectionId,
        crmEntityId,
        erpActorType,
        crmActorType,
        erpFieldKeyValues
      };
      _options = webapi_options;
    }
    return this._createErpActorFromCrmAsync(_request, _options);
  }
  async _saveActorTypeMappingAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveActorTypeMapping", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ErpSyncActorTypeMapping_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveActorTypeMappingAsync(mapping, webapi_options) {
    let _request = null;
    let _options = null;
    const first = mapping;
    if (typeof first === "object" && first && typeof first.mapping != "undefined") {
      _request = mapping;
      _options = webapi_options;
    } else {
      _request = {
        mapping
      };
      _options = webapi_options;
    }
    return this._saveActorTypeMappingAsync(_request, _options);
  }
  async _validateArchiveColumnConfigAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ValidateArchiveColumnConfig", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async validateArchiveColumnConfigAsync(listOwner, erpConnectionId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = listOwner;
    if (typeof first === "object" && first && (typeof first.listOwner != "undefined" || typeof first.erpConnectionId != "undefined")) {
      _request = listOwner;
      _options = erpConnectionId;
    } else {
      _request = {
        listOwner,
        erpConnectionId
      };
      _options = webapi_options;
    }
    return this._validateArchiveColumnConfigAsync(_request, _options);
  }
  async _updateConnectionFieldsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("UpdateConnectionFields", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async updateConnectionFieldsAsync(erpConnectionId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = erpConnectionId;
    if (typeof first === "object" && first && typeof first.erpConnectionId != "undefined") {
      _request = erpConnectionId;
      _options = webapi_options;
    } else {
      _request = {
        erpConnectionId
      };
      _options = webapi_options;
    }
    return this._updateConnectionFieldsAsync(_request, _options);
  }
  async _getCrmActorTypeAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetCrmActorType", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getCrmActorTypeAsync(erpConnectionId, erpActorType, webapi_options) {
    let _request = null;
    let _options = null;
    const first = erpConnectionId;
    if (typeof first === "object" && first && (typeof first.erpConnectionId != "undefined" || typeof first.erpActorType != "undefined")) {
      _request = erpConnectionId;
      _options = erpActorType;
    } else {
      _request = {
        erpConnectionId,
        erpActorType
      };
      _options = webapi_options;
    }
    return this._getCrmActorTypeAsync(_request, _options);
  }
  async _getErpSyncConnectionSummaryAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetErpSyncConnectionSummary", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ErpSyncConnectionSummary_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getErpSyncConnectionSummaryAsync(erpSyncConnectionId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = erpSyncConnectionId;
    if (typeof first === "object" && first && typeof first.erpSyncConnectionId != "undefined") {
      _request = erpSyncConnectionId;
      _options = webapi_options;
    } else {
      _request = {
        erpSyncConnectionId
      };
      _options = webapi_options;
    }
    return this._getErpSyncConnectionSummaryAsync(_request, _options);
  }
  /*
   * Gets a ErpSyncConnectorEntity object.
   * @param erpSyncConnectorEntityId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single ErpSyncConnectorEntity
   */
  async getErpSyncConnectorEntityAsync(erpSyncConnectorEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetErpSyncConnectorEntity?erpSyncConnectorEntityId=" + erpSyncConnectorEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ErpSyncConnectorEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _canDeleteErpSyncConnectorEntityAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CanDeleteErpSyncConnectorEntity", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async canDeleteErpSyncConnectorEntityAsync(erpSyncConnectorId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = erpSyncConnectorId;
    if (typeof first === "object" && first && typeof first.erpSyncConnectorId != "undefined") {
      _request = erpSyncConnectorId;
      _options = webapi_options;
    } else {
      _request = {
        erpSyncConnectorId
      };
      _options = webapi_options;
    }
    return this._canDeleteErpSyncConnectorEntityAsync(_request, _options);
  }
  async _testConnectorUrlAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("TestConnectorUrl", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async testConnectorUrlAsync(url, webapi_options) {
    let _request = null;
    let _options = null;
    const first = url;
    if (typeof first === "object" && first && typeof first.url != "undefined") {
      _request = url;
      _options = webapi_options;
    } else {
      _request = {
        url
      };
      _options = webapi_options;
    }
    return this._testConnectorUrlAsync(_request, _options);
  }
  async _saveDefaultValueInfoAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveDefaultValueInfo", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ErpSyncDefaultValue_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveDefaultValueInfoAsync(erpSyncDefaultValue, webapi_options) {
    let _request = null;
    let _options = null;
    const first = erpSyncDefaultValue;
    if (typeof first === "object" && first && typeof first.erpSyncDefaultValue != "undefined") {
      _request = erpSyncDefaultValue;
      _options = webapi_options;
    } else {
      _request = {
        erpSyncDefaultValue
      };
      _options = webapi_options;
    }
    return this._saveDefaultValueInfoAsync(_request, _options);
  }
  async _getDefaultValueInfoAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetDefaultValueInfo", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ErpSyncDefaultValue_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getDefaultValueInfoAsync(erpFieldId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = erpFieldId;
    if (typeof first === "object" && first && typeof first.erpFieldId != "undefined") {
      _request = erpFieldId;
      _options = webapi_options;
    } else {
      _request = {
        erpFieldId
      };
      _options = webapi_options;
    }
    return this._getDefaultValueInfoAsync(_request, _options);
  }
  async _syncAllAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SyncAll", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PluginResponse_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Sync all active connections
   * @returns The response
   */
  async syncAllAsync(webapi_options) {
    return this._syncAllAsync(webapi_options);
  }
  async _forceSyncAllAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ForceSyncAll", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PluginResponse_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Sync all active connections even when automatic sync is off
   * @returns The response
   */
  async forceSyncAllAsync(webapi_options) {
    return this._forceSyncAllAsync(webapi_options);
  }
  async _forceResyncAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ForceResync", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PluginResponse_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async forceResyncAsync(erpConnectionId, internalKeyIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = erpConnectionId;
    if (typeof first === "object" && first && (typeof first.erpConnectionId != "undefined" || typeof first.internalKeyIds != "undefined")) {
      _request = erpConnectionId;
      _options = internalKeyIds;
    } else {
      _request = {
        erpConnectionId,
        internalKeyIds
      };
      _options = webapi_options;
    }
    return this._forceResyncAsync(_request, _options);
  }
  async _forceResyncNoBlankValuesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ForceResyncNoBlankValues", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PluginResponse_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async forceResyncNoBlankValuesAsync(erpConnectionId, internalKeyIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = erpConnectionId;
    if (typeof first === "object" && first && (typeof first.erpConnectionId != "undefined" || typeof first.internalKeyIds != "undefined")) {
      _request = erpConnectionId;
      _options = internalKeyIds;
    } else {
      _request = {
        erpConnectionId,
        internalKeyIds
      };
      _options = webapi_options;
    }
    return this._forceResyncNoBlankValuesAsync(_request, _options);
  }
  async _forceResyncBatchTaskAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ForceResyncBatchTask", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async forceResyncBatchTaskAsync(erpConnectionId, internalKeyIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = erpConnectionId;
    if (typeof first === "object" && first && (typeof first.erpConnectionId != "undefined" || typeof first.internalKeyIds != "undefined")) {
      _request = erpConnectionId;
      _options = internalKeyIds;
    } else {
      _request = {
        erpConnectionId,
        internalKeyIds
      };
      _options = webapi_options;
    }
    return this._forceResyncBatchTaskAsync(_request, _options);
  }
  async _forceResyncExternalAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ForceResyncExternal", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PluginResponse_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async forceResyncExternalAsync(erpConnectionId, erpActorType, externalKeys, webapi_options) {
    let _request = null;
    let _options = null;
    const first = erpConnectionId;
    if (typeof first === "object" && first && (typeof first.erpConnectionId != "undefined" || typeof first.erpActorType != "undefined" || typeof first.externalKeys != "undefined")) {
      _request = erpConnectionId;
      _options = erpActorType;
    } else {
      _request = {
        erpConnectionId,
        erpActorType,
        externalKeys
      };
      _options = webapi_options;
    }
    return this._forceResyncExternalAsync(_request, _options);
  }
  async _forceResyncExternalNoBlankValuesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ForceResyncExternalNoBlankValues", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PluginResponse_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async forceResyncExternalNoBlankValuesAsync(erpConnectionId, erpActorType, externalKeys, webapi_options) {
    let _request = null;
    let _options = null;
    const first = erpConnectionId;
    if (typeof first === "object" && first && (typeof first.erpConnectionId != "undefined" || typeof first.erpActorType != "undefined" || typeof first.externalKeys != "undefined")) {
      _request = erpConnectionId;
      _options = erpActorType;
    } else {
      _request = {
        erpConnectionId,
        erpActorType,
        externalKeys
      };
      _options = webapi_options;
    }
    return this._forceResyncExternalNoBlankValuesAsync(_request, _options);
  }
  async _getEngineStatusAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetEngineStatus", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ErpSyncEngineStatus_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Get the current status of the Sync engine
   * @returns The current status of the engine
   */
  async getEngineStatusAsync(webapi_options) {
    return this._getEngineStatusAsync(webapi_options);
  }
  async _changeEngineStatusAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ChangeEngineStatus", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ErpSyncEngineStatus_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async changeEngineStatusAsync(run, webapi_options) {
    let _request = null;
    let _options = null;
    const first = run;
    if (typeof first === "object" && first && typeof first.run != "undefined") {
      _request = run;
      _options = webapi_options;
    } else {
      _request = {
        run
      };
      _options = webapi_options;
    }
    return this._changeEngineStatusAsync(_request, _options);
  }
  async _changeEngineIntervalAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ChangeEngineInterval", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async changeEngineIntervalAsync(interval, webapi_options) {
    let _request = null;
    let _options = null;
    const first = interval;
    if (typeof first === "object" && first && typeof first.interval != "undefined") {
      _request = interval;
      _options = webapi_options;
    } else {
      _request = {
        interval
      };
      _options = webapi_options;
    }
    return this._changeEngineIntervalAsync(_request, _options);
  }
};

// server/node_modules/@superoffice/webapi/dist/esm/ResourceAgent.js
var ResourceAgent = class extends WebApiBase {
  constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
    const options = WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
    options.basePath = "v1/Agents/Resource/";
    super(options);
  }
  async _setResourceSubstitutionAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetResourceSubstitution", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setResourceSubstitutionAsync(resourceName, resourceValues, culture, isActive, webapi_options) {
    let _request = null;
    let _options = null;
    const first = resourceName;
    if (typeof first === "object" && first && (typeof first.resourceName != "undefined" || typeof first.resourceValues != "undefined" || typeof first.culture != "undefined" || typeof first.isActive != "undefined")) {
      _request = resourceName;
      _options = resourceValues;
    } else {
      _request = {
        resourceName,
        resourceValues,
        culture,
        isActive
      };
      _options = webapi_options;
    }
    return this._setResourceSubstitutionAsync(_request, _options);
  }
  async _deleteResourceSubstitutionAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeleteResourceSubstitution", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async deleteResourceSubstitutionAsync(resourceName, culture, webapi_options) {
    let _request = null;
    let _options = null;
    const first = resourceName;
    if (typeof first === "object" && first && (typeof first.resourceName != "undefined" || typeof first.culture != "undefined")) {
      _request = resourceName;
      _options = culture;
    } else {
      _request = {
        resourceName,
        culture
      };
      _options = webapi_options;
    }
    return this._deleteResourceSubstitutionAsync(_request, _options);
  }
  async _activateResourceSubstitutionAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ActivateResourceSubstitution", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async activateResourceSubstitutionAsync(resourceName, culture, isActive, webapi_options) {
    let _request = null;
    let _options = null;
    const first = resourceName;
    if (typeof first === "object" && first && (typeof first.resourceName != "undefined" || typeof first.culture != "undefined" || typeof first.isActive != "undefined")) {
      _request = resourceName;
      _options = culture;
    } else {
      _request = {
        resourceName,
        culture,
        isActive
      };
      _options = webapi_options;
    }
    return this._activateResourceSubstitutionAsync(_request, _options);
  }
  async _getResourceSubstitutionsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetResourceSubstitutions", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ResourceOverrideArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getResourceSubstitutionsAsync(resourceNames, culture, activeOnly, webapi_options) {
    let _request = null;
    let _options = null;
    const first = resourceNames;
    if (typeof first === "object" && first && (typeof first.resourceNames != "undefined" || typeof first.culture != "undefined" || typeof first.activeOnly != "undefined")) {
      _request = resourceNames;
      _options = culture;
    } else {
      _request = {
        resourceNames,
        culture,
        activeOnly
      };
      _options = webapi_options;
    }
    return this._getResourceSubstitutionsAsync(_request, _options);
  }
  async _isResourceSubstitutionActiveAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("IsResourceSubstitutionActive", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ResourceOverrideArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async isResourceSubstitutionActiveAsync(resourceNames, culture, webapi_options) {
    let _request = null;
    let _options = null;
    const first = resourceNames;
    if (typeof first === "object" && first && (typeof first.resourceNames != "undefined" || typeof first.culture != "undefined")) {
      _request = resourceNames;
      _options = culture;
    } else {
      _request = {
        resourceNames,
        culture
      };
      _options = webapi_options;
    }
    return this._isResourceSubstitutionActiveAsync(_request, _options);
  }
};

// server/node_modules/@superoffice/webapi/dist/esm/ContactAgent.js
var ContactAgent = class extends WebApiBase {
  constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
    const options = WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
    options.basePath = "v1/Agents/Contact/";
    super(options);
  }
  /**
   * Set default values into a new ContactEntity.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultContactEntityAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultContactEntity", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ContactEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing ContactEntity or creates a new ContactEntity if the id parameter is empty
   * @param entity - The ContactEntity to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated ContactEntity
   */
  async saveContactEntityAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveContactEntity", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ContactEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Deletes the ContactEntity
   * @param ContactEntityId - The id of the ContactEntity to be deleted.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   */
  async deleteContactEntityAsync(ContactEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("DeleteContactEntity?ContactEntityId=" + ContactEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new PreviewContact.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultPreviewContactAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultPreviewContact", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PreviewContact_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets a Contact object.
   * @param contactId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single Contact
   */
  async getContactAsync(contactId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetContact?contactId=" + contactId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Contact_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getMyActiveContactsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetMyActiveContacts", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ContactActivityArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getMyActiveContactsAsync(activityStartTime, contactCategories, actionType, webapi_options) {
    let _request = null;
    let _options = null;
    const first = activityStartTime;
    if (typeof first === "object" && first && (typeof first.activityStartTime != "undefined" || typeof first.contactCategories != "undefined" || typeof first.actionType != "undefined")) {
      _request = activityStartTime;
      _options = contactCategories;
    } else {
      _request = {
        activityStartTime,
        contactCategories,
        actionType
      };
      _options = webapi_options;
    }
    return this._getMyActiveContactsAsync(_request, _options);
  }
  /*
   * Gets a ContactEntity object.
   * @param contactEntityId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single ContactEntity
   */
  async getContactEntityAsync(contactEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetContactEntity?contactEntityId=" + contactEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ContactEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _undeleteAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("Undelete", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async undeleteAsync(id, webapi_options) {
    let _request = null;
    let _options = null;
    const first = id;
    if (typeof first === "object" && first && typeof first.id != "undefined") {
      _request = id;
      _options = webapi_options;
    } else {
      _request = {
        id
      };
      _options = webapi_options;
    }
    return this._undeleteAsync(_request, _options);
  }
  async _getPersonsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPersons", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PersonArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getPersonsAsync(contactId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = contactId;
    if (typeof first === "object" && first && typeof first.contactId != "undefined") {
      _request = contactId;
      _options = webapi_options;
    } else {
      _request = {
        contactId
      };
      _options = webapi_options;
    }
    return this._getPersonsAsync(_request, _options);
  }
  async _getContactWithPersonsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetContactWithPersons", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ContactEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getContactWithPersonsAsync(contactId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = contactId;
    if (typeof first === "object" && first && typeof first.contactId != "undefined") {
      _request = contactId;
      _options = webapi_options;
    } else {
      _request = {
        contactId
      };
      _options = webapi_options;
    }
    return this._getContactWithPersonsAsync(_request, _options);
  }
  async _getMyContactAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetMyContact", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ContactEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Gets the contact belonging to the currently logged on user.
   * @returns The Contact
   */
  async getMyContactAsync(webapi_options) {
    return this._getMyContactAsync(webapi_options);
  }
  async _getMyBizCardAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetMyBizCard", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ContactEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Returns all data needed to display the logged on person&apos;s business card. That is company, person, and company interest data.
   * @returns The contact object with persons and interests
   */
  async getMyBizCardAsync(webapi_options) {
    return this._getMyBizCardAsync(webapi_options);
  }
  async _changeCountryAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ChangeCountry", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ContactEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async changeCountryAsync(contactEntity, toCountryId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = contactEntity;
    if (typeof first === "object" && first && (typeof first.contactEntity != "undefined" || typeof first.toCountryId != "undefined")) {
      _request = contactEntity;
      _options = toCountryId;
    } else {
      _request = {
        contactEntity,
        toCountryId
      };
      _options = webapi_options;
    }
    return this._changeCountryAsync(_request, _options);
  }
  async _getAddressAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetAddress", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Address_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getAddressAsync(contactId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = contactId;
    if (typeof first === "object" && first && typeof first.contactId != "undefined") {
      _request = contactId;
      _options = webapi_options;
    } else {
      _request = {
        contactId
      };
      _options = webapi_options;
    }
    return this._getAddressAsync(_request, _options);
  }
  async _getAddressByCountryAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetAddressByCountry", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Address_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getAddressByCountryAsync(contactId, countryId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = contactId;
    if (typeof first === "object" && first && (typeof first.contactId != "undefined" || typeof first.countryId != "undefined")) {
      _request = contactId;
      _options = countryId;
    } else {
      _request = {
        contactId,
        countryId
      };
      _options = webapi_options;
    }
    return this._getAddressByCountryAsync(_request, _options);
  }
  async _addPersonAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("AddPerson", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PersonEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async addPersonAsync(contactId, newPersonEntity, webapi_options) {
    let _request = null;
    let _options = null;
    const first = contactId;
    if (typeof first === "object" && first && (typeof first.contactId != "undefined" || typeof first.newPersonEntity != "undefined")) {
      _request = contactId;
      _options = newPersonEntity;
    } else {
      _request = {
        contactId,
        newPersonEntity
      };
      _options = webapi_options;
    }
    return this._addPersonAsync(_request, _options);
  }
  async _getDuplicatesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetDuplicates", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DuplicateEntryArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getDuplicatesAsync(name, webapi_options) {
    let _request = null;
    let _options = null;
    const first = name;
    if (typeof first === "object" && first && typeof first.name != "undefined") {
      _request = name;
      _options = webapi_options;
    } else {
      _request = {
        name
      };
      _options = webapi_options;
    }
    return this._getDuplicatesAsync(_request, _options);
  }
  async _createNewEntryAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateNewEntry", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createNewEntryAsync(duplicate, webapi_options) {
    let _request = null;
    let _options = null;
    const first = duplicate;
    if (typeof first === "object" && first && typeof first.duplicate != "undefined") {
      _request = duplicate;
      _options = webapi_options;
    } else {
      _request = {
        duplicate
      };
      _options = webapi_options;
    }
    return this._createNewEntryAsync(_request, _options);
  }
  async _getDuplicateRulesAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetDuplicateRules", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DuplicateRuleArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Retrieve all available duplicate rules for contact
   * @returns All available duplicate rules
   */
  async getDuplicateRulesAsync(webapi_options) {
    return this._getDuplicateRulesAsync(webapi_options);
  }
  async _setDuplicateRulesStatusAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetDuplicateRulesStatus", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setDuplicateRulesStatusAsync(rules, webapi_options) {
    let _request = null;
    let _options = null;
    const first = rules;
    if (typeof first === "object" && first && typeof first.rules != "undefined") {
      _request = rules;
      _options = webapi_options;
    } else {
      _request = {
        rules
      };
      _options = webapi_options;
    }
    return this._setDuplicateRulesStatusAsync(_request, _options);
  }
  async _mergeAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("Merge", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async mergeAsync(sourceContactId, destinationContactId, mergeIdenticalPersons, replaceEmptyFieldsOnDestination, webapi_options) {
    let _request = null;
    let _options = null;
    const first = sourceContactId;
    if (typeof first === "object" && first && (typeof first.sourceContactId != "undefined" || typeof first.destinationContactId != "undefined" || typeof first.mergeIdenticalPersons != "undefined" || typeof first.replaceEmptyFieldsOnDestination != "undefined")) {
      _request = sourceContactId;
      _options = destinationContactId;
    } else {
      _request = {
        sourceContactId,
        destinationContactId,
        mergeIdenticalPersons,
        replaceEmptyFieldsOnDestination
      };
      _options = webapi_options;
    }
    return this._mergeAsync(_request, _options);
  }
  async _copyAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("Copy", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async copyAsync(sourceContactId, destinationContactName, destinationContactDepartment, copyPersons, webapi_options) {
    let _request = null;
    let _options = null;
    const first = sourceContactId;
    if (typeof first === "object" && first && (typeof first.sourceContactId != "undefined" || typeof first.destinationContactName != "undefined" || typeof first.destinationContactDepartment != "undefined" || typeof first.copyPersons != "undefined")) {
      _request = sourceContactId;
      _options = destinationContactName;
    } else {
      _request = {
        sourceContactId,
        destinationContactName,
        destinationContactDepartment,
        copyPersons
      };
      _options = webapi_options;
    }
    return this._copyAsync(_request, _options);
  }
  async _getNameDepartmentDuplicatesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetNameDepartmentDuplicates", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DuplicateEntryArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getNameDepartmentDuplicatesAsync(name, department, webapi_options) {
    let _request = null;
    let _options = null;
    const first = name;
    if (typeof first === "object" && first && (typeof first.name != "undefined" || typeof first.department != "undefined")) {
      _request = name;
      _options = department;
    } else {
      _request = {
        name,
        department
      };
      _options = webapi_options;
    }
    return this._getNameDepartmentDuplicatesAsync(_request, _options);
  }
  async _isNumberValidAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("IsNumberValid", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async isNumberValidAsync(contactId, number, webapi_options) {
    let _request = null;
    let _options = null;
    const first = contactId;
    if (typeof first === "object" && first && (typeof first.contactId != "undefined" || typeof first.number != "undefined")) {
      _request = contactId;
      _options = number;
    } else {
      _request = {
        contactId,
        number
      };
      _options = webapi_options;
    }
    return this._isNumberValidAsync(_request, _options);
  }
  async _getQuoteVersionAddressesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetQuoteVersionAddresses", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AddressArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getQuoteVersionAddressesAsync(quoteVersionId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quoteVersionId;
    if (typeof first === "object" && first && typeof first.quoteVersionId != "undefined") {
      _request = quoteVersionId;
      _options = webapi_options;
    } else {
      _request = {
        quoteVersionId
      };
      _options = webapi_options;
    }
    return this._getQuoteVersionAddressesAsync(_request, _options);
  }
  async _saveQuoteVersionAddressAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveQuoteVersionAddress", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Address_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveQuoteVersionAddressAsync(quoteVersionId, address, addressType, countryId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quoteVersionId;
    if (typeof first === "object" && first && (typeof first.quoteVersionId != "undefined" || typeof first.address != "undefined" || typeof first.addressType != "undefined" || typeof first.countryId != "undefined")) {
      _request = quoteVersionId;
      _options = address;
    } else {
      _request = {
        quoteVersionId,
        address,
        addressType,
        countryId
      };
      _options = webapi_options;
    }
    return this._saveQuoteVersionAddressAsync(_request, _options);
  }
  async _deleteExpiredAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeleteExpired", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Trigger deletion of contacts (companies) that has been (soft) deleted and have timed out the expiry period (the SoftDeleteRetention preference).
   * @returns
   */
  async deleteExpiredAsync(webapi_options) {
    return this._deleteExpiredAsync(webapi_options);
  }
  async _getContactSummaryAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetContactSummary", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ContactSummary_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getContactSummaryAsync(contactId, limit, webapi_options) {
    let _request = null;
    let _options = null;
    const first = contactId;
    if (typeof first === "object" && first && (typeof first.contactId != "undefined" || typeof first.limit != "undefined")) {
      _request = contactId;
      _options = limit;
    } else {
      _request = {
        contactId,
        limit
      };
      _options = webapi_options;
    }
    return this._getContactSummaryAsync(_request, _options);
  }
  async _validateContactEntityAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ValidateContactEntity", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_StringDictionary_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async validateContactEntityAsync(contactEntity, webapi_options) {
    let _request = null;
    let _options = null;
    const first = contactEntity;
    if (typeof first === "object" && first && typeof first.contactEntity != "undefined") {
      _request = contactEntity;
      _options = webapi_options;
    } else {
      _request = {
        contactEntity
      };
      _options = webapi_options;
    }
    return this._validateContactEntityAsync(_request, _options);
  }
  /*
   * Gets an array of Contact objects.
   * @param contactIds - The primary keys.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns An array of Contact
   */
  async getContactListAsync(contactIds, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetContactList", contactIds, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ContactArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getMyContactsAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetMyContacts", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ContactArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Getting the contacts where the user currently logged in is set as contact owner.
   * @returns Array of contacts
   */
  async getMyContactsAsync(webapi_options) {
    return this._getMyContactsAsync(webapi_options);
  }
  async _getMyRecentContactsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetMyRecentContacts", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ContactArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getMyRecentContactsAsync(sourceType, webapi_options) {
    let _request = null;
    let _options = null;
    const first = sourceType;
    if (typeof first === "object" && first && typeof first.sourceType != "undefined") {
      _request = sourceType;
      _options = webapi_options;
    } else {
      _request = {
        sourceType
      };
      _options = webapi_options;
    }
    return this._getMyRecentContactsAsync(_request, _options);
  }
  async _getPreviewContactAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPreviewContact", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PreviewContact_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getPreviewContactAsync(contactId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = contactId;
    if (typeof first === "object" && first && typeof first.contactId != "undefined") {
      _request = contactId;
      _options = webapi_options;
    } else {
      _request = {
        contactId
      };
      _options = webapi_options;
    }
    return this._getPreviewContactAsync(_request, _options);
  }
};

// server/node_modules/@superoffice/webapi/dist/esm/PersonAgent.js
var PersonAgent = class extends WebApiBase {
  constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
    const options = WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
    options.basePath = "v1/Agents/Person/";
    super(options);
  }
  /**
   * Set default values into a new ConsentPerson.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultConsentPersonAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultConsentPerson", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ConsentPerson_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing ConsentPerson or creates a new ConsentPerson if the id parameter is empty
   * @param entity - The ConsentPerson to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated ConsentPerson
   */
  async saveConsentPersonAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveConsentPerson", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ConsentPerson_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Deletes the ConsentPerson
   * @param ConsentPersonId - The id of the ConsentPerson to be deleted.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   */
  async deleteConsentPersonAsync(ConsentPersonId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("DeleteConsentPerson?ConsentPersonId=" + ConsentPersonId, null, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new PersonEntity.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultPersonEntityAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultPersonEntity", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PersonEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing PersonEntity or creates a new PersonEntity if the id parameter is empty
   * @param entity - The PersonEntity to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated PersonEntity
   */
  async savePersonEntityAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SavePersonEntity", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PersonEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Deletes the PersonEntity
   * @param PersonEntityId - The id of the PersonEntity to be deleted.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   */
  async deletePersonEntityAsync(PersonEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("DeletePersonEntity?PersonEntityId=" + PersonEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new PersonImage.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultPersonImageAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultPersonImage", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PersonImage_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets a ConsentPerson object.
   * @param consentPersonId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single ConsentPerson
   */
  async getConsentPersonAsync(consentPersonId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetConsentPerson?consentPersonId=" + consentPersonId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ConsentPerson_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets a Person object.
   * @param personId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single Person
   */
  async getPersonAsync(personId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetPerson?personId=" + personId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Person_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets a PersonEntity object.
   * @param personEntityId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single PersonEntity
   */
  async getPersonEntityAsync(personEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetPersonEntity?personEntityId=" + personEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PersonEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _undeleteAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("Undelete", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async undeleteAsync(id, webapi_options) {
    let _request = null;
    let _options = null;
    const first = id;
    if (typeof first === "object" && first && typeof first.id != "undefined") {
      _request = id;
      _options = webapi_options;
    } else {
      _request = {
        id
      };
      _options = webapi_options;
    }
    return this._undeleteAsync(_request, _options);
  }
  async _getMyPersonAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetMyPerson", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PersonEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Gets the person info belonging to the currently logged on user.
   * @returns The PersonEntity
   */
  async getMyPersonAsync(webapi_options) {
    return this._getMyPersonAsync(webapi_options);
  }
  async _getSalesRepAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetSalesRep", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PersonEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getSalesRepAsync(contactName, personFirstname, personLastname, emailAddress, phoneNumber, webapi_options) {
    let _request = null;
    let _options = null;
    const first = contactName;
    if (typeof first === "object" && first && (typeof first.contactName != "undefined" || typeof first.personFirstname != "undefined" || typeof first.personLastname != "undefined" || typeof first.emailAddress != "undefined" || typeof first.phoneNumber != "undefined")) {
      _request = contactName;
      _options = personFirstname;
    } else {
      _request = {
        contactName,
        personFirstname,
        personLastname,
        emailAddress,
        phoneNumber
      };
      _options = webapi_options;
    }
    return this._getSalesRepAsync(_request, _options);
  }
  async _getPhonesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPhones", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_EntityElementArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getPhonesAsync(personId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = personId;
    if (typeof first === "object" && first && typeof first.personId != "undefined") {
      _request = personId;
      _options = webapi_options;
    } else {
      _request = {
        personId
      };
      _options = webapi_options;
    }
    return this._getPhonesAsync(_request, _options);
  }
  async _changeCountryAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ChangeCountry", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PersonEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async changeCountryAsync(personEntity, toCountryId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = personEntity;
    if (typeof first === "object" && first && (typeof first.personEntity != "undefined" || typeof first.toCountryId != "undefined")) {
      _request = personEntity;
      _options = toCountryId;
    } else {
      _request = {
        personEntity,
        toCountryId
      };
      _options = webapi_options;
    }
    return this._changeCountryAsync(_request, _options);
  }
  async _getAddressAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetAddress", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Address_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getAddressAsync(personId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = personId;
    if (typeof first === "object" && first && typeof first.personId != "undefined") {
      _request = personId;
      _options = webapi_options;
    } else {
      _request = {
        personId
      };
      _options = webapi_options;
    }
    return this._getAddressAsync(_request, _options);
  }
  async _getAddressByCountryAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetAddressByCountry", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Address_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getAddressByCountryAsync(personId, countryId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = personId;
    if (typeof first === "object" && first && (typeof first.personId != "undefined" || typeof first.countryId != "undefined")) {
      _request = personId;
      _options = countryId;
    } else {
      _request = {
        personId,
        countryId
      };
      _options = webapi_options;
    }
    return this._getAddressByCountryAsync(_request, _options);
  }
  async _getPersonImageAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        if (!options || options.returnBlobAs == ReturnBlobType.AsArrayBuffer) {
          config.responseType = "arraybuffer";
          config.headers = config.headers || {};
          config.headers["Accept"] = "application/octet-stream";
        }
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPersonImage", request, config);
        WebApiBase.SetCompleted(options);
        let res = null;
        if (options && options.returnBlobAs != ReturnBlobType.AsArrayBuffer) {
          res = response.data;
          if (options.returnBlobAs == ReturnBlobType.AsString) {
            res = FromBase64ToString(res);
          }
        } else {
          res = response.data;
        }
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getPersonImageAsync(personId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = personId;
    if (typeof first === "object" && first && typeof first.personId != "undefined") {
      _request = personId;
      _options = webapi_options;
    } else {
      _request = {
        personId
      };
      _options = webapi_options;
    }
    return this._getPersonImageAsync(_request, _options);
  }
  async _setPersonImageAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetPersonImage", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setPersonImageAsync(personId, image, webapi_options) {
    let _request = null;
    let _options = null;
    const first = personId;
    if (typeof first === "object" && first && (typeof first.personId != "undefined" || typeof first.image != "undefined")) {
      _request = personId;
      _options = image;
    } else {
      _request = {
        personId,
        image
      };
      _options = webapi_options;
    }
    _request.image = ToBase64(_request.image);
    return this._setPersonImageAsync(_request, _options);
  }
  async _createDefaultByContactIdAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateDefaultByContactId", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PersonEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createDefaultByContactIdAsync(contactId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = contactId;
    if (typeof first === "object" && first && typeof first.contactId != "undefined") {
      _request = contactId;
      _options = webapi_options;
    } else {
      _request = {
        contactId
      };
      _options = webapi_options;
    }
    return this._createDefaultByContactIdAsync(_request, _options);
  }
  async _moveAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("Move", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async moveAsync(personId, destinationContactId, moveAfterDate, webapi_options) {
    let _request = null;
    let _options = null;
    const first = personId;
    if (typeof first === "object" && first && (typeof first.personId != "undefined" || typeof first.destinationContactId != "undefined" || typeof first.moveAfterDate != "undefined")) {
      _request = personId;
      _options = destinationContactId;
    } else {
      _request = {
        personId,
        destinationContactId,
        moveAfterDate
      };
      _options = webapi_options;
    }
    return this._moveAsync(_request, _options);
  }
  async _mergeAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("Merge", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async mergeAsync(sourcePersonId, destinationPersonId, moveAfterDate, deleteSource, replaceEmptyFieldsOnDestination, webapi_options) {
    let _request = null;
    let _options = null;
    const first = sourcePersonId;
    if (typeof first === "object" && first && (typeof first.sourcePersonId != "undefined" || typeof first.destinationPersonId != "undefined" || typeof first.moveAfterDate != "undefined" || typeof first.deleteSource != "undefined" || typeof first.replaceEmptyFieldsOnDestination != "undefined")) {
      _request = sourcePersonId;
      _options = destinationPersonId;
    } else {
      _request = {
        sourcePersonId,
        destinationPersonId,
        moveAfterDate,
        deleteSource,
        replaceEmptyFieldsOnDestination
      };
      _options = webapi_options;
    }
    return this._mergeAsync(_request, _options);
  }
  async _createDefaultFromCredentialAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateDefaultFromCredential", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PersonEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createDefaultFromCredentialAsync(contactId, credentialType, credentialValue, credentialDisplayValue, webapi_options) {
    let _request = null;
    let _options = null;
    const first = contactId;
    if (typeof first === "object" && first && (typeof first.contactId != "undefined" || typeof first.credentialType != "undefined" || typeof first.credentialValue != "undefined" || typeof first.credentialDisplayValue != "undefined")) {
      _request = contactId;
      _options = credentialType;
    } else {
      _request = {
        contactId,
        credentialType,
        credentialValue,
        credentialDisplayValue
      };
      _options = webapi_options;
    }
    return this._createDefaultFromCredentialAsync(_request, _options);
  }
  async _isNumberValidAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("IsNumberValid", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async isNumberValidAsync(contactId, number, webapi_options) {
    let _request = null;
    let _options = null;
    const first = contactId;
    if (typeof first === "object" && first && (typeof first.contactId != "undefined" || typeof first.number != "undefined")) {
      _request = contactId;
      _options = number;
    } else {
      _request = {
        contactId,
        number
      };
      _options = webapi_options;
    }
    return this._isNumberValidAsync(_request, _options);
  }
  async _setConsentAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetConsent", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setConsentAsync(personId, purpose, source, legalBase, comment, webapi_options) {
    let _request = null;
    let _options = null;
    const first = personId;
    if (typeof first === "object" && first && (typeof first.personId != "undefined" || typeof first.purpose != "undefined" || typeof first.source != "undefined" || typeof first.legalBase != "undefined" || typeof first.comment != "undefined")) {
      _request = personId;
      _options = purpose;
    } else {
      _request = {
        personId,
        purpose,
        source,
        legalBase,
        comment
      };
      _options = webapi_options;
    }
    return this._setConsentAsync(_request, _options);
  }
  async _removeConsentAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("RemoveConsent", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async removeConsentAsync(personId, purpose, webapi_options) {
    let _request = null;
    let _options = null;
    const first = personId;
    if (typeof first === "object" && first && (typeof first.personId != "undefined" || typeof first.purpose != "undefined")) {
      _request = personId;
      _options = purpose;
    } else {
      _request = {
        personId,
        purpose
      };
      _options = webapi_options;
    }
    return this._removeConsentAsync(_request, _options);
  }
  async _hasConsentAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("HasConsent", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async hasConsentAsync(personId, purpose, webapi_options) {
    let _request = null;
    let _options = null;
    const first = personId;
    if (typeof first === "object" && first && (typeof first.personId != "undefined" || typeof first.purpose != "undefined")) {
      _request = personId;
      _options = purpose;
    } else {
      _request = {
        personId,
        purpose
      };
      _options = webapi_options;
    }
    return this._hasConsentAsync(_request, _options);
  }
  async _getConsentInfosAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetConsentInfos", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ConsentInfoArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getConsentInfosAsync(personId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = personId;
    if (typeof first === "object" && first && typeof first.personId != "undefined") {
      _request = personId;
      _options = webapi_options;
    } else {
      _request = {
        personId
      };
      _options = webapi_options;
    }
    return this._getConsentInfosAsync(_request, _options);
  }
  async _sendConsentConfirmationEmailAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SendConsentConfirmationEmail", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async sendConsentConfirmationEmailAsync(personId, emailAddress, emailTemplateId, cultureLcidId, subject, webapi_options) {
    let _request = null;
    let _options = null;
    const first = personId;
    if (typeof first === "object" && first && (typeof first.personId != "undefined" || typeof first.emailAddress != "undefined" || typeof first.emailTemplateId != "undefined" || typeof first.cultureLcidId != "undefined" || typeof first.subject != "undefined")) {
      _request = personId;
      _options = emailAddress;
    } else {
      _request = {
        personId,
        emailAddress,
        emailTemplateId,
        cultureLcidId,
        subject
      };
      _options = webapi_options;
    }
    return this._sendConsentConfirmationEmailAsync(_request, _options);
  }
  async _resolvePersonFromInfoAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ResolvePersonFromInfo", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ResolvedPerson_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async resolvePersonFromInfoAsync(contactId, personName, phoneNumbers, emails, webapi_options) {
    let _request = null;
    let _options = null;
    const first = contactId;
    if (typeof first === "object" && first && (typeof first.contactId != "undefined" || typeof first.personName != "undefined" || typeof first.phoneNumbers != "undefined" || typeof first.emails != "undefined")) {
      _request = contactId;
      _options = personName;
    } else {
      _request = {
        contactId,
        personName,
        phoneNumbers,
        emails
      };
      _options = webapi_options;
    }
    return this._resolvePersonFromInfoAsync(_request, _options);
  }
  async _addEmailAddressToPersonAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("AddEmailAddressToPerson", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async addEmailAddressToPersonAsync(personId, emailAddress, setAsPrimaryEmail, webapi_options) {
    let _request = null;
    let _options = null;
    const first = personId;
    if (typeof first === "object" && first && (typeof first.personId != "undefined" || typeof first.emailAddress != "undefined" || typeof first.setAsPrimaryEmail != "undefined")) {
      _request = personId;
      _options = emailAddress;
    } else {
      _request = {
        personId,
        emailAddress,
        setAsPrimaryEmail
      };
      _options = webapi_options;
    }
    return this._addEmailAddressToPersonAsync(_request, _options);
  }
  async _createTemporaryKeyAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateTemporaryKey", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createTemporaryKeyAsync(domain, targetId, personId, expires, webapi_options) {
    let _request = null;
    let _options = null;
    const first = domain;
    if (typeof first === "object" && first && (typeof first.domain != "undefined" || typeof first.targetId != "undefined" || typeof first.personId != "undefined" || typeof first.expires != "undefined")) {
      _request = domain;
      _options = targetId;
    } else {
      _request = {
        domain,
        targetId,
        personId,
        expires
      };
      _options = webapi_options;
    }
    return this._createTemporaryKeyAsync(_request, _options);
  }
  async _checkTemporaryKeyAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CheckTemporaryKey", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TemporaryKeyInfo_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async checkTemporaryKeyAsync(temporaryKey, webapi_options) {
    let _request = null;
    let _options = null;
    const first = temporaryKey;
    if (typeof first === "object" && first && typeof first.temporaryKey != "undefined") {
      _request = temporaryKey;
      _options = webapi_options;
    } else {
      _request = {
        temporaryKey
      };
      _options = webapi_options;
    }
    return this._checkTemporaryKeyAsync(_request, _options);
  }
  async _deleteTemporaryKeysOfDomainAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeleteTemporaryKeysOfDomain", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async deleteTemporaryKeysOfDomainAsync(domain, personId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = domain;
    if (typeof first === "object" && first && (typeof first.domain != "undefined" || typeof first.personId != "undefined")) {
      _request = domain;
      _options = personId;
    } else {
      _request = {
        domain,
        personId
      };
      _options = webapi_options;
    }
    return this._deleteTemporaryKeysOfDomainAsync(_request, _options);
  }
  async _deleteExpiredAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeleteExpired", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Trigger deletion of persons that has been (soft) deleted and have timed out the expiry period (the SoftDeleteRetention preference).
   * @returns
   */
  async deleteExpiredAsync(webapi_options) {
    return this._deleteExpiredAsync(webapi_options);
  }
  async _getPersonSummaryAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPersonSummary", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PersonSummary_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getPersonSummaryAsync(personId, limit, webapi_options) {
    let _request = null;
    let _options = null;
    const first = personId;
    if (typeof first === "object" && first && (typeof first.personId != "undefined" || typeof first.limit != "undefined")) {
      _request = personId;
      _options = limit;
    } else {
      _request = {
        personId,
        limit
      };
      _options = webapi_options;
    }
    return this._getPersonSummaryAsync(_request, _options);
  }
  async _addBounceAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("AddBounce", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async addBounceAsync(emailAddress, webapi_options) {
    let _request = null;
    let _options = null;
    const first = emailAddress;
    if (typeof first === "object" && first && typeof first.emailAddress != "undefined") {
      _request = emailAddress;
      _options = webapi_options;
    } else {
      _request = {
        emailAddress
      };
      _options = webapi_options;
    }
    return this._addBounceAsync(_request, _options);
  }
  async _validatePersonEntityAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ValidatePersonEntity", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_StringDictionary_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async validatePersonEntityAsync(personEntity, webapi_options) {
    let _request = null;
    let _options = null;
    const first = personEntity;
    if (typeof first === "object" && first && typeof first.personEntity != "undefined") {
      _request = personEntity;
      _options = webapi_options;
    } else {
      _request = {
        personEntity
      };
      _options = webapi_options;
    }
    return this._validatePersonEntityAsync(_request, _options);
  }
  async _addBounceWithCountAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("AddBounceWithCount", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async addBounceWithCountAsync(emailAddress, counts, webapi_options) {
    let _request = null;
    let _options = null;
    const first = emailAddress;
    if (typeof first === "object" && first && (typeof first.emailAddress != "undefined" || typeof first.counts != "undefined")) {
      _request = emailAddress;
      _options = counts;
    } else {
      _request = {
        emailAddress,
        counts
      };
      _options = webapi_options;
    }
    return this._addBounceWithCountAsync(_request, _options);
  }
  async _getBestSoLanguageForTemplateAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetBestSoLanguageForTemplate", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getBestSoLanguageForTemplateAsync(personId, templateId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = personId;
    if (typeof first === "object" && first && (typeof first.personId != "undefined" || typeof first.templateId != "undefined")) {
      _request = personId;
      _options = templateId;
    } else {
      _request = {
        personId,
        templateId
      };
      _options = webapi_options;
    }
    return this._getBestSoLanguageForTemplateAsync(_request, _options);
  }
  async _addBounceWithDetailsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("AddBounceWithDetails", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async addBounceWithDetailsAsync(emailAddress, counts, code, reason, webapi_options) {
    let _request = null;
    let _options = null;
    const first = emailAddress;
    if (typeof first === "object" && first && (typeof first.emailAddress != "undefined" || typeof first.counts != "undefined" || typeof first.code != "undefined" || typeof first.reason != "undefined")) {
      _request = emailAddress;
      _options = counts;
    } else {
      _request = {
        emailAddress,
        counts,
        code,
        reason
      };
      _options = webapi_options;
    }
    return this._addBounceWithDetailsAsync(_request, _options);
  }
  async _getPersonImagesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPersonImages", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PersonImageArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getPersonImagesAsync(personIds, scaledWidth, scaledHeight, webapi_options) {
    let _request = null;
    let _options = null;
    const first = personIds;
    if (typeof first === "object" && first && (typeof first.personIds != "undefined" || typeof first.scaledWidth != "undefined" || typeof first.scaledHeight != "undefined")) {
      _request = personIds;
      _options = scaledWidth;
    } else {
      _request = {
        personIds,
        scaledWidth,
        scaledHeight
      };
      _options = webapi_options;
    }
    return this._getPersonImagesAsync(_request, _options);
  }
  async _createOrUpdateUserCandidateAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateOrUpdateUserCandidate", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_UserCandidate_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createOrUpdateUserCandidateAsync(personId, username, accessAllRequests, webapi_options) {
    let _request = null;
    let _options = null;
    const first = personId;
    if (typeof first === "object" && first && (typeof first.personId != "undefined" || typeof first.username != "undefined" || typeof first.accessAllRequests != "undefined")) {
      _request = personId;
      _options = username;
    } else {
      _request = {
        personId,
        username,
        accessAllRequests
      };
      _options = webapi_options;
    }
    return this._createOrUpdateUserCandidateAsync(_request, _options);
  }
  async _getUserCandidateByPersonAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetUserCandidateByPerson", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_UserCandidate_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getUserCandidateByPersonAsync(personId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = personId;
    if (typeof first === "object" && first && typeof first.personId != "undefined") {
      _request = personId;
      _options = webapi_options;
    } else {
      _request = {
        personId
      };
      _options = webapi_options;
    }
    return this._getUserCandidateByPersonAsync(_request, _options);
  }
  async _getCustomerCentrePasswordReplyTemplateAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetCustomerCentrePasswordReplyTemplate", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ReplyTemplateParsed_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getCustomerCentrePasswordReplyTemplateAsync(personId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = personId;
    if (typeof first === "object" && first && typeof first.personId != "undefined") {
      _request = personId;
      _options = webapi_options;
    } else {
      _request = {
        personId
      };
      _options = webapi_options;
    }
    return this._getCustomerCentrePasswordReplyTemplateAsync(_request, _options);
  }
  async _sendEmailAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SendEmail", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async sendEmailAsync(from, to, subject, plainBody, htmlBody, attachmentIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = from;
    if (typeof first === "object" && first && (typeof first.from != "undefined" || typeof first.to != "undefined" || typeof first.subject != "undefined" || typeof first.plainBody != "undefined" || typeof first.htmlBody != "undefined" || typeof first.attachmentIds != "undefined")) {
      _request = from;
      _options = to;
    } else {
      _request = {
        from,
        to,
        subject,
        plainBody,
        htmlBody,
        attachmentIds
      };
      _options = webapi_options;
    }
    return this._sendEmailAsync(_request, _options);
  }
  /*
   * Gets an array of Person objects.
   * @param personIds - The primary keys.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns An array of Person
   */
  async getPersonListAsync(personIds, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetPersonList", personIds, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PersonArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getPersonsFromContactAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPersonsFromContact", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PersonArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getPersonsFromContactAsync(contactId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = contactId;
    if (typeof first === "object" && first && typeof first.contactId != "undefined") {
      _request = contactId;
      _options = webapi_options;
    } else {
      _request = {
        contactId
      };
      _options = webapi_options;
    }
    return this._getPersonsFromContactAsync(_request, _options);
  }
  async _getPersonsFromProjectAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPersonsFromProject", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PersonArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getPersonsFromProjectAsync(projectId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = projectId;
    if (typeof first === "object" && first && typeof first.projectId != "undefined") {
      _request = projectId;
      _options = webapi_options;
    } else {
      _request = {
        projectId
      };
      _options = webapi_options;
    }
    return this._getPersonsFromProjectAsync(_request, _options);
  }
  async _getColleaguesAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetColleagues", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PersonArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Gets the persons working in the same company as the logged on user.
   * @returns Colleagues.
   */
  async getColleaguesAsync(webapi_options) {
    return this._getColleaguesAsync(webapi_options);
  }
  async _getColleaguesByDepartmentAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetColleaguesByDepartment", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PersonArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getColleaguesByDepartmentAsync(departmentId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = departmentId;
    if (typeof first === "object" && first && typeof first.departmentId != "undefined") {
      _request = departmentId;
      _options = webapi_options;
    } else {
      _request = {
        departmentId
      };
      _options = webapi_options;
    }
    return this._getColleaguesByDepartmentAsync(_request, _options);
  }
  async _getColleaguesBySourceAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetColleaguesBySource", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PersonArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getColleaguesBySourceAsync(sourceType, count, webapi_options) {
    let _request = null;
    let _options = null;
    const first = sourceType;
    if (typeof first === "object" && first && (typeof first.sourceType != "undefined" || typeof first.count != "undefined")) {
      _request = sourceType;
      _options = count;
    } else {
      _request = {
        sourceType,
        count
      };
      _options = webapi_options;
    }
    return this._getColleaguesBySourceAsync(_request, _options);
  }
  async _getMyOwnerAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetMyOwner", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Person_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Get the owner of the logged in person.
   * @returns Person
   */
  async getMyOwnerAsync(webapi_options) {
    return this._getMyOwnerAsync(webapi_options);
  }
  async _getOwnerOnPersonIdAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetOwnerOnPersonId", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Person_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getOwnerOnPersonIdAsync(personId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = personId;
    if (typeof first === "object" && first && typeof first.personId != "undefined") {
      _request = personId;
      _options = webapi_options;
    } else {
      _request = {
        personId
      };
      _options = webapi_options;
    }
    return this._getOwnerOnPersonIdAsync(_request, _options);
  }
  async _changePersonRankAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ChangePersonRank", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async changePersonRankAsync(personId, moveUp, webapi_options) {
    let _request = null;
    let _options = null;
    const first = personId;
    if (typeof first === "object" && first && (typeof first.personId != "undefined" || typeof first.moveUp != "undefined")) {
      _request = personId;
      _options = moveUp;
    } else {
      _request = {
        personId,
        moveUp
      };
      _options = webapi_options;
    }
    return this._changePersonRankAsync(_request, _options);
  }
  async _setPersonRankAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetPersonRank", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setPersonRankAsync(personId, desiredRank, webapi_options) {
    let _request = null;
    let _options = null;
    const first = personId;
    if (typeof first === "object" && first && (typeof first.personId != "undefined" || typeof first.desiredRank != "undefined")) {
      _request = personId;
      _options = desiredRank;
    } else {
      _request = {
        personId,
        desiredRank
      };
      _options = webapi_options;
    }
    return this._setPersonRankAsync(_request, _options);
  }
  async _normalizeRanksAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("NormalizeRanks", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async normalizeRanksAsync(contactId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = contactId;
    if (typeof first === "object" && first && typeof first.contactId != "undefined") {
      _request = contactId;
      _options = webapi_options;
    } else {
      _request = {
        contactId
      };
      _options = webapi_options;
    }
    return this._normalizeRanksAsync(_request, _options);
  }
};

// server/node_modules/@superoffice/webapi/dist/esm/SaleAgent.js
var SaleAgent = class extends WebApiBase {
  constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
    const options = WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
    options.basePath = "v1/Agents/Sale/";
    super(options);
  }
  /**
   * Set default values into a new SaleEntity.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultSaleEntityAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultSaleEntity", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SaleEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing SaleEntity or creates a new SaleEntity if the id parameter is empty
   * @param entity - The SaleEntity to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated SaleEntity
   */
  async saveSaleEntityAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveSaleEntity", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SaleEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Deletes the SaleEntity
   * @param SaleEntityId - The id of the SaleEntity to be deleted.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   */
  async deleteSaleEntityAsync(SaleEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("DeleteSaleEntity?SaleEntityId=" + SaleEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new SaleStakeholder.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultSaleStakeholderAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultSaleStakeholder", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SaleStakeholder_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing SaleStakeholder or creates a new SaleStakeholder if the id parameter is empty
   * @param entity - The SaleStakeholder to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated SaleStakeholder
   */
  async saveSaleStakeholderAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveSaleStakeholder", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SaleStakeholder_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Deletes the SaleStakeholder
   * @param SaleStakeholderId - The id of the SaleStakeholder to be deleted.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   */
  async deleteSaleStakeholderAsync(SaleStakeholderId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("DeleteSaleStakeholder?SaleStakeholderId=" + SaleStakeholderId, null, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new SaleSummary.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultSaleSummaryAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultSaleSummary", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SaleSummary_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets a Sale object.
   * @param saleId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single Sale
   */
  async getSaleAsync(saleId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetSale?saleId=" + saleId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Sale_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets a SaleEntity object.
   * @param saleEntityId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single SaleEntity
   */
  async getSaleEntityAsync(saleEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetSaleEntity?saleEntityId=" + saleEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SaleEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _hasGuideAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("HasGuide", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async hasGuideAsync(saleId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = saleId;
    if (typeof first === "object" && first && typeof first.saleId != "undefined") {
      _request = saleId;
      _options = webapi_options;
    } else {
      _request = {
        saleId
      };
      _options = webapi_options;
    }
    return this._hasGuideAsync(_request, _options);
  }
  async _getNextDueDateAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetNextDueDate", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getNextDueDateAsync(saleId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = saleId;
    if (typeof first === "object" && first && typeof first.saleId != "undefined") {
      _request = saleId;
      _options = webapi_options;
    } else {
      _request = {
        saleId
      };
      _options = webapi_options;
    }
    return this._getNextDueDateAsync(_request, _options);
  }
  async _batchUpdateNextDueDateAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("BatchUpdateNextDueDate", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Re-calculate all the next due dates
   * @returns
   */
  async batchUpdateNextDueDateAsync(webapi_options) {
    return this._batchUpdateNextDueDateAsync(webapi_options);
  }
  async _getNextSaleStageAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetNextSaleStage", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getNextSaleStageAsync(saleId, includeCurrentStage, webapi_options) {
    let _request = null;
    let _options = null;
    const first = saleId;
    if (typeof first === "object" && first && (typeof first.saleId != "undefined" || typeof first.includeCurrentStage != "undefined")) {
      _request = saleId;
      _options = includeCurrentStage;
    } else {
      _request = {
        saleId,
        includeCurrentStage
      };
      _options = webapi_options;
    }
    return this._getNextSaleStageAsync(_request, _options);
  }
  async _hasGuideActivitiesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("HasGuideActivities", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async hasGuideActivitiesAsync(saleId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = saleId;
    if (typeof first === "object" && first && typeof first.saleId != "undefined") {
      _request = saleId;
      _options = webapi_options;
    } else {
      _request = {
        saleId
      };
      _options = webapi_options;
    }
    return this._hasGuideActivitiesAsync(_request, _options);
  }
  async _offerAutoNextStageOnApppointmentCompletedAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("OfferAutoNextStageOnApppointmentCompleted", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async offerAutoNextStageOnApppointmentCompletedAsync(appointmentId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = appointmentId;
    if (typeof first === "object" && first && typeof first.appointmentId != "undefined") {
      _request = appointmentId;
      _options = webapi_options;
    } else {
      _request = {
        appointmentId
      };
      _options = webapi_options;
    }
    return this._offerAutoNextStageOnApppointmentCompletedAsync(_request, _options);
  }
  async _getProbabilityFromStageAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetProbabilityFromStage", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getProbabilityFromStageAsync(stageId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = stageId;
    if (typeof first === "object" && first && typeof first.stageId != "undefined") {
      _request = stageId;
      _options = webapi_options;
    } else {
      _request = {
        stageId
      };
      _options = webapi_options;
    }
    return this._getProbabilityFromStageAsync(_request, _options);
  }
  async _isNumberValidAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("IsNumberValid", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async isNumberValidAsync(contactId, number, webapi_options) {
    let _request = null;
    let _options = null;
    const first = contactId;
    if (typeof first === "object" && first && (typeof first.contactId != "undefined" || typeof first.number != "undefined")) {
      _request = contactId;
      _options = number;
    } else {
      _request = {
        contactId,
        number
      };
      _options = webapi_options;
    }
    return this._isNumberValidAsync(_request, _options);
  }
  async _addSaleStakeholdersAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("AddSaleStakeholders", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async addSaleStakeholdersAsync(saleId, saleStakeholders, webapi_options) {
    let _request = null;
    let _options = null;
    const first = saleId;
    if (typeof first === "object" && first && (typeof first.saleId != "undefined" || typeof first.saleStakeholders != "undefined")) {
      _request = saleId;
      _options = saleStakeholders;
    } else {
      _request = {
        saleId,
        saleStakeholders
      };
      _options = webapi_options;
    }
    return this._addSaleStakeholdersAsync(_request, _options);
  }
  async _deleteSaleStakeholdersAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeleteSaleStakeholders", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async deleteSaleStakeholdersAsync(saleStakeholderIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = saleStakeholderIds;
    if (typeof first === "object" && first && typeof first.saleStakeholderIds != "undefined") {
      _request = saleStakeholderIds;
      _options = webapi_options;
    } else {
      _request = {
        saleStakeholderIds
      };
      _options = webapi_options;
    }
    return this._deleteSaleStakeholdersAsync(_request, _options);
  }
  async _hasStakeholderSettingAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("HasStakeholderSetting", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async hasStakeholderSettingAsync(saleId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = saleId;
    if (typeof first === "object" && first && typeof first.saleId != "undefined") {
      _request = saleId;
      _options = webapi_options;
    } else {
      _request = {
        saleId
      };
      _options = webapi_options;
    }
    return this._hasStakeholderSettingAsync(_request, _options);
  }
  async _validateSaleEntityAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ValidateSaleEntity", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_StringDictionary_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async validateSaleEntityAsync(saleEntity, webapi_options) {
    let _request = null;
    let _options = null;
    const first = saleEntity;
    if (typeof first === "object" && first && typeof first.saleEntity != "undefined") {
      _request = saleEntity;
      _options = webapi_options;
    } else {
      _request = {
        saleEntity
      };
      _options = webapi_options;
    }
    return this._validateSaleEntityAsync(_request, _options);
  }
  /*
   * Gets an array of Sale objects.
   * @param saleIds - The primary keys.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns An array of Sale
   */
  async getSaleListAsync(saleIds, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetSaleList", saleIds, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SaleArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getMyOpportunitiesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetMyOpportunities", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SaleArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getMyOpportunitiesAsync(count, webapi_options) {
    let _request = null;
    let _options = null;
    const first = count;
    if (typeof first === "object" && first && typeof first.count != "undefined") {
      _request = count;
      _options = webapi_options;
    } else {
      _request = {
        count
      };
      _options = webapi_options;
    }
    return this._getMyOpportunitiesAsync(_request, _options);
  }
  async _getRecentSalesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetRecentSales", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SaleArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getRecentSalesAsync(amountLimit, count, webapi_options) {
    let _request = null;
    let _options = null;
    const first = amountLimit;
    if (typeof first === "object" && first && (typeof first.amountLimit != "undefined" || typeof first.count != "undefined")) {
      _request = amountLimit;
      _options = count;
    } else {
      _request = {
        amountLimit,
        count
      };
      _options = webapi_options;
    }
    return this._getRecentSalesAsync(_request, _options);
  }
  async _getUpcomingSalesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetUpcomingSales", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SaleArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getUpcomingSalesAsync(weightedAmountLimit, count, webapi_options) {
    let _request = null;
    let _options = null;
    const first = weightedAmountLimit;
    if (typeof first === "object" && first && (typeof first.weightedAmountLimit != "undefined" || typeof first.count != "undefined")) {
      _request = weightedAmountLimit;
      _options = count;
    } else {
      _request = {
        weightedAmountLimit,
        count
      };
      _options = webapi_options;
    }
    return this._getUpcomingSalesAsync(_request, _options);
  }
  async _getSalesByDateAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetSalesByDate", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SaleArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getSalesByDateAsync(fromDate, toDate, amountLimit, status, webapi_options) {
    let _request = null;
    let _options = null;
    const first = fromDate;
    if (typeof first === "object" && first && (typeof first.fromDate != "undefined" || typeof first.toDate != "undefined" || typeof first.amountLimit != "undefined" || typeof first.status != "undefined")) {
      _request = fromDate;
      _options = toDate;
    } else {
      _request = {
        fromDate,
        toDate,
        amountLimit,
        status
      };
      _options = webapi_options;
    }
    return this._getSalesByDateAsync(_request, _options);
  }
  async _getOpenSalesForContactAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetOpenSalesForContact", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SaleArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getOpenSalesForContactAsync(contactId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = contactId;
    if (typeof first === "object" && first && typeof first.contactId != "undefined") {
      _request = contactId;
      _options = webapi_options;
    } else {
      _request = {
        contactId
      };
      _options = webapi_options;
    }
    return this._getOpenSalesForContactAsync(_request, _options);
  }
  async _setAsSoldAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetAsSold", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setAsSoldAsync(saleIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = saleIds;
    if (typeof first === "object" && first && typeof first.saleIds != "undefined") {
      _request = saleIds;
      _options = webapi_options;
    } else {
      _request = {
        saleIds
      };
      _options = webapi_options;
    }
    return this._setAsSoldAsync(_request, _options);
  }
  async _setAsLostAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetAsLost", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setAsLostAsync(saleIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = saleIds;
    if (typeof first === "object" && first && typeof first.saleIds != "undefined") {
      _request = saleIds;
      _options = webapi_options;
    } else {
      _request = {
        saleIds
      };
      _options = webapi_options;
    }
    return this._setAsLostAsync(_request, _options);
  }
  async _getSalesFromContactAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetSalesFromContact", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SaleArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getSalesFromContactAsync(contactId, onlyOpenSales, webapi_options) {
    let _request = null;
    let _options = null;
    const first = contactId;
    if (typeof first === "object" && first && (typeof first.contactId != "undefined" || typeof first.onlyOpenSales != "undefined")) {
      _request = contactId;
      _options = onlyOpenSales;
    } else {
      _request = {
        contactId,
        onlyOpenSales
      };
      _options = webapi_options;
    }
    return this._getSalesFromContactAsync(_request, _options);
  }
  async _getSalesFromPersonAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetSalesFromPerson", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SaleArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getSalesFromPersonAsync(personId, onlyOpenSales, webapi_options) {
    let _request = null;
    let _options = null;
    const first = personId;
    if (typeof first === "object" && first && (typeof first.personId != "undefined" || typeof first.onlyOpenSales != "undefined")) {
      _request = personId;
      _options = onlyOpenSales;
    } else {
      _request = {
        personId,
        onlyOpenSales
      };
      _options = webapi_options;
    }
    return this._getSalesFromPersonAsync(_request, _options);
  }
  /*
   * Gets a SaleStakeholder object.
   * @param saleStakeholderId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single SaleStakeholder
   */
  async getSaleStakeholderAsync(saleStakeholderId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetSaleStakeholder?saleStakeholderId=" + saleStakeholderId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SaleStakeholder_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets an array of SaleStakeholder objects.
   * @param saleStakeholderIds - The primary keys.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns An array of SaleStakeholder
   */
  async getSaleStakeholderListAsync(saleStakeholderIds, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetSaleStakeholderList", saleStakeholderIds, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SaleStakeholderArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getSaleStakeholdersAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetSaleStakeholders", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SaleStakeholderArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getSaleStakeholdersAsync(saleId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = saleId;
    if (typeof first === "object" && first && typeof first.saleId != "undefined") {
      _request = saleId;
      _options = webapi_options;
    } else {
      _request = {
        saleId
      };
      _options = webapi_options;
    }
    return this._getSaleStakeholdersAsync(_request, _options);
  }
  async _updateSaleStakeholdersAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("UpdateSaleStakeholders", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SaleStakeholderArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async updateSaleStakeholdersAsync(stakeholders, webapi_options) {
    let _request = null;
    let _options = null;
    const first = stakeholders;
    if (typeof first === "object" && first && typeof first.stakeholders != "undefined") {
      _request = stakeholders;
      _options = webapi_options;
    } else {
      _request = {
        stakeholders
      };
      _options = webapi_options;
    }
    return this._updateSaleStakeholdersAsync(_request, _options);
  }
  async _getSaleStakeholderByIdAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetSaleStakeholderById", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SaleStakeholderArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getSaleStakeholderByIdAsync(saleStakeholderIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = saleStakeholderIds;
    if (typeof first === "object" && first && typeof first.saleStakeholderIds != "undefined") {
      _request = saleStakeholderIds;
      _options = webapi_options;
    } else {
      _request = {
        saleStakeholderIds
      };
      _options = webapi_options;
    }
    return this._getSaleStakeholderByIdAsync(_request, _options);
  }
  async _getSummaryByAssociateAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetSummaryByAssociate", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SaleSummary_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getSummaryByAssociateAsync(associateId, fromDate, toDate, webapi_options) {
    let _request = null;
    let _options = null;
    const first = associateId;
    if (typeof first === "object" && first && (typeof first.associateId != "undefined" || typeof first.fromDate != "undefined" || typeof first.toDate != "undefined")) {
      _request = associateId;
      _options = fromDate;
    } else {
      _request = {
        associateId,
        fromDate,
        toDate
      };
      _options = webapi_options;
    }
    return this._getSummaryByAssociateAsync(_request, _options);
  }
  async _getSummaryByGroupAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetSummaryByGroup", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SaleSummary_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getSummaryByGroupAsync(groupId, fromDate, toDate, webapi_options) {
    let _request = null;
    let _options = null;
    const first = groupId;
    if (typeof first === "object" && first && (typeof first.groupId != "undefined" || typeof first.fromDate != "undefined" || typeof first.toDate != "undefined")) {
      _request = groupId;
      _options = fromDate;
    } else {
      _request = {
        groupId,
        fromDate,
        toDate
      };
      _options = webapi_options;
    }
    return this._getSummaryByGroupAsync(_request, _options);
  }
  async _getSummaryByContactAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetSummaryByContact", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SaleSummary_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getSummaryByContactAsync(contactId, fromDate, toDate, webapi_options) {
    let _request = null;
    let _options = null;
    const first = contactId;
    if (typeof first === "object" && first && (typeof first.contactId != "undefined" || typeof first.fromDate != "undefined" || typeof first.toDate != "undefined")) {
      _request = contactId;
      _options = fromDate;
    } else {
      _request = {
        contactId,
        fromDate,
        toDate
      };
      _options = webapi_options;
    }
    return this._getSummaryByContactAsync(_request, _options);
  }
};

// server/node_modules/@superoffice/webapi/dist/esm/PhoneListAgent.js
var PhoneListAgent = class extends WebApiBase {
  constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
    const options = WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
    options.basePath = "v1/Agents/PhoneList/";
    super(options);
  }
  async _searchAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("Search", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PhoneListItemArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async searchAsync(searchString, webapi_options) {
    let _request = null;
    let _options = null;
    const first = searchString;
    if (typeof first === "object" && first && typeof first.searchString != "undefined") {
      _request = searchString;
      _options = webapi_options;
    } else {
      _request = {
        searchString
      };
      _options = webapi_options;
    }
    return this._searchAsync(_request, _options);
  }
  async _searchWithPreferencesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SearchWithPreferences", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PhoneListItemArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async searchWithPreferencesAsync(searchString, preferences, webapi_options) {
    let _request = null;
    let _options = null;
    const first = searchString;
    if (typeof first === "object" && first && (typeof first.searchString != "undefined" || typeof first.preferences != "undefined")) {
      _request = searchString;
      _options = preferences;
    } else {
      _request = {
        searchString,
        preferences
      };
      _options = webapi_options;
    }
    return this._searchWithPreferencesAsync(_request, _options);
  }
  async _getDepartmentPhonesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetDepartmentPhones", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PhoneListItemArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getDepartmentPhonesAsync(departmentId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = departmentId;
    if (typeof first === "object" && first && typeof first.departmentId != "undefined") {
      _request = departmentId;
      _options = webapi_options;
    } else {
      _request = {
        departmentId
      };
      _options = webapi_options;
    }
    return this._getDepartmentPhonesAsync(_request, _options);
  }
  async _getFavoritesPhonesAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetFavoritesPhones", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PhoneListItemArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Returns an array of phone list items with the Contacts in the users favorites dropdown list.
   * @returns The favorite contact phone list
   */
  async getFavoritesPhonesAsync(webapi_options) {
    return this._getFavoritesPhonesAsync(webapi_options);
  }
  async _getContactPhonesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetContactPhones", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PhoneListItemArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getContactPhonesAsync(contactId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = contactId;
    if (typeof first === "object" && first && typeof first.contactId != "undefined") {
      _request = contactId;
      _options = webapi_options;
    } else {
      _request = {
        contactId
      };
      _options = webapi_options;
    }
    return this._getContactPhonesAsync(_request, _options);
  }
  async _addToFavoritesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("AddToFavorites", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async addToFavoritesAsync(contactId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = contactId;
    if (typeof first === "object" && first && typeof first.contactId != "undefined") {
      _request = contactId;
      _options = webapi_options;
    } else {
      _request = {
        contactId
      };
      _options = webapi_options;
    }
    return this._addToFavoritesAsync(_request, _options);
  }
  async _getPreferencesAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPreferences", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PhoneListPreferences_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Getting Phone List Preferences from the CRM 5 user preferences
   * @returns The Phone List Preferences
   */
  async getPreferencesAsync(webapi_options) {
    return this._getPreferencesAsync(webapi_options);
  }
  async _setPreferencesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetPreferences", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setPreferencesAsync(preferences, webapi_options) {
    let _request = null;
    let _options = null;
    const first = preferences;
    if (typeof first === "object" && first && typeof first.preferences != "undefined") {
      _request = preferences;
      _options = webapi_options;
    } else {
      _request = {
        preferences
      };
      _options = webapi_options;
    }
    return this._setPreferencesAsync(_request, _options);
  }
};

// server/node_modules/@superoffice/webapi/dist/esm/ProjectAgent.js
var ProjectAgent = class extends WebApiBase {
  constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
    const options = WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
    options.basePath = "v1/Agents/Project/";
    super(options);
  }
  /**
   * Set default values into a new ProjectEntity.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultProjectEntityAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultProjectEntity", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ProjectEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing ProjectEntity or creates a new ProjectEntity if the id parameter is empty
   * @param entity - The ProjectEntity to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated ProjectEntity
   */
  async saveProjectEntityAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveProjectEntity", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ProjectEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Deletes the ProjectEntity
   * @param ProjectEntityId - The id of the ProjectEntity to be deleted.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   */
  async deleteProjectEntityAsync(ProjectEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("DeleteProjectEntity?ProjectEntityId=" + ProjectEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new ProjectEventEntity.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultProjectEventEntityAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultProjectEventEntity", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ProjectEventEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing ProjectEventEntity or creates a new ProjectEventEntity if the id parameter is empty
   * @param entity - The ProjectEventEntity to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated ProjectEventEntity
   */
  async saveProjectEventEntityAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveProjectEventEntity", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ProjectEventEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Deletes the ProjectEventEntity
   * @param ProjectEventEntityId - The id of the ProjectEventEntity to be deleted.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   */
  async deleteProjectEventEntityAsync(ProjectEventEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("DeleteProjectEventEntity?ProjectEventEntityId=" + ProjectEventEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new ProjectMember.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultProjectMemberAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultProjectMember", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ProjectMember_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing ProjectMember or creates a new ProjectMember if the id parameter is empty
   * @param entity - The ProjectMember to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated ProjectMember
   */
  async saveProjectMemberAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveProjectMember", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ProjectMember_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Deletes the ProjectMember
   * @param ProjectMemberId - The id of the ProjectMember to be deleted.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   */
  async deleteProjectMemberAsync(ProjectMemberId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("DeleteProjectMember?ProjectMemberId=" + ProjectMemberId, null, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets a Project object.
   * @param projectId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single Project
   */
  async getProjectAsync(projectId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetProject?projectId=" + projectId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Project_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets a ProjectEntity object.
   * @param projectEntityId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single ProjectEntity
   */
  async getProjectEntityAsync(projectEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetProjectEntity?projectEntityId=" + projectEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ProjectEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _addProjectMembersAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("AddProjectMembers", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async addProjectMembersAsync(projectEntityId, projectMembers, webapi_options) {
    let _request = null;
    let _options = null;
    const first = projectEntityId;
    if (typeof first === "object" && first && (typeof first.projectEntityId != "undefined" || typeof first.projectMembers != "undefined")) {
      _request = projectEntityId;
      _options = projectMembers;
    } else {
      _request = {
        projectEntityId,
        projectMembers
      };
      _options = webapi_options;
    }
    return this._addProjectMembersAsync(_request, _options);
  }
  async _deleteProjectMembersAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeleteProjectMembers", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async deleteProjectMembersAsync(projectEntityId, memberIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = projectEntityId;
    if (typeof first === "object" && first && (typeof first.projectEntityId != "undefined" || typeof first.memberIds != "undefined")) {
      _request = projectEntityId;
      _options = memberIds;
    } else {
      _request = {
        projectEntityId,
        memberIds
      };
      _options = webapi_options;
    }
    return this._deleteProjectMembersAsync(_request, _options);
  }
  async _getProjectImageAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        if (!options || options.returnBlobAs == ReturnBlobType.AsArrayBuffer) {
          config.responseType = "arraybuffer";
          config.headers = config.headers || {};
          config.headers["Accept"] = "application/octet-stream";
        }
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetProjectImage", request, config);
        WebApiBase.SetCompleted(options);
        let res = null;
        if (options && options.returnBlobAs != ReturnBlobType.AsArrayBuffer) {
          res = response.data;
          if (options.returnBlobAs == ReturnBlobType.AsString) {
            res = FromBase64ToString(res);
          }
        } else {
          res = response.data;
        }
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getProjectImageAsync(projectId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = projectId;
    if (typeof first === "object" && first && typeof first.projectId != "undefined") {
      _request = projectId;
      _options = webapi_options;
    } else {
      _request = {
        projectId
      };
      _options = webapi_options;
    }
    return this._getProjectImageAsync(_request, _options);
  }
  async _setProjectImageAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetProjectImage", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setProjectImageAsync(projectId, image, webapi_options) {
    let _request = null;
    let _options = null;
    const first = projectId;
    if (typeof first === "object" && first && (typeof first.projectId != "undefined" || typeof first.image != "undefined")) {
      _request = projectId;
      _options = image;
    } else {
      _request = {
        projectId,
        image
      };
      _options = webapi_options;
    }
    _request.image = ToBase64(_request.image);
    return this._setProjectImageAsync(_request, _options);
  }
  async _deleteProjectMemberByIdsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeleteProjectMemberByIds", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async deleteProjectMemberByIdsAsync(projectMemberIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = projectMemberIds;
    if (typeof first === "object" && first && typeof first.projectMemberIds != "undefined") {
      _request = projectMemberIds;
      _options = webapi_options;
    } else {
      _request = {
        projectMemberIds
      };
      _options = webapi_options;
    }
    return this._deleteProjectMemberByIdsAsync(_request, _options);
  }
  async _getDuplicatesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetDuplicates", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DuplicateEntryArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getDuplicatesAsync(name, webapi_options) {
    let _request = null;
    let _options = null;
    const first = name;
    if (typeof first === "object" && first && typeof first.name != "undefined") {
      _request = name;
      _options = webapi_options;
    } else {
      _request = {
        name
      };
      _options = webapi_options;
    }
    return this._getDuplicatesAsync(_request, _options);
  }
  async _createNewEntryAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateNewEntry", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createNewEntryAsync(duplicate, webapi_options) {
    let _request = null;
    let _options = null;
    const first = duplicate;
    if (typeof first === "object" && first && typeof first.duplicate != "undefined") {
      _request = duplicate;
      _options = webapi_options;
    } else {
      _request = {
        duplicate
      };
      _options = webapi_options;
    }
    return this._createNewEntryAsync(_request, _options);
  }
  async _setDuplicateRulesStatusAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetDuplicateRulesStatus", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setDuplicateRulesStatusAsync(rules, webapi_options) {
    let _request = null;
    let _options = null;
    const first = rules;
    if (typeof first === "object" && first && typeof first.rules != "undefined") {
      _request = rules;
      _options = webapi_options;
    } else {
      _request = {
        rules
      };
      _options = webapi_options;
    }
    return this._setDuplicateRulesStatusAsync(_request, _options);
  }
  async _getDuplicateRulesAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetDuplicateRules", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DuplicateRuleArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Retrieve all available duplicate rules for project
   * @returns All available duplicate rules
   */
  async getDuplicateRulesAsync(webapi_options) {
    return this._getDuplicateRulesAsync(webapi_options);
  }
  async _mergeAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("Merge", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async mergeAsync(sourceProjectId, destinationProjectId, replaceEmptyFieldsOnDestination, webapi_options) {
    let _request = null;
    let _options = null;
    const first = sourceProjectId;
    if (typeof first === "object" && first && (typeof first.sourceProjectId != "undefined" || typeof first.destinationProjectId != "undefined" || typeof first.replaceEmptyFieldsOnDestination != "undefined")) {
      _request = sourceProjectId;
      _options = destinationProjectId;
    } else {
      _request = {
        sourceProjectId,
        destinationProjectId,
        replaceEmptyFieldsOnDestination
      };
      _options = webapi_options;
    }
    return this._mergeAsync(_request, _options);
  }
  async _isNumberValidAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("IsNumberValid", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async isNumberValidAsync(contactId, number, webapi_options) {
    let _request = null;
    let _options = null;
    const first = contactId;
    if (typeof first === "object" && first && (typeof first.contactId != "undefined" || typeof first.number != "undefined")) {
      _request = contactId;
      _options = number;
    } else {
      _request = {
        contactId,
        number
      };
      _options = webapi_options;
    }
    return this._isNumberValidAsync(_request, _options);
  }
  async _hasGuideAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("HasGuide", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async hasGuideAsync(projectId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = projectId;
    if (typeof first === "object" && first && typeof first.projectId != "undefined") {
      _request = projectId;
      _options = webapi_options;
    } else {
      _request = {
        projectId
      };
      _options = webapi_options;
    }
    return this._hasGuideAsync(_request, _options);
  }
  async _getNextMilestoneAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetNextMilestone", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Appointment_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getNextMilestoneAsync(projectId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = projectId;
    if (typeof first === "object" && first && typeof first.projectId != "undefined") {
      _request = projectId;
      _options = webapi_options;
    } else {
      _request = {
        projectId
      };
      _options = webapi_options;
    }
    return this._getNextMilestoneAsync(_request, _options);
  }
  async _offerAutoNextStatusOnApppointmentCompletedAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("OfferAutoNextStatusOnApppointmentCompleted", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async offerAutoNextStatusOnApppointmentCompletedAsync(appointmentId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = appointmentId;
    if (typeof first === "object" && first && typeof first.appointmentId != "undefined") {
      _request = appointmentId;
      _options = webapi_options;
    } else {
      _request = {
        appointmentId
      };
      _options = webapi_options;
    }
    return this._offerAutoNextStatusOnApppointmentCompletedAsync(_request, _options);
  }
  async _getNextProjectStatusAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetNextProjectStatus", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getNextProjectStatusAsync(projectId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = projectId;
    if (typeof first === "object" && first && typeof first.projectId != "undefined") {
      _request = projectId;
      _options = webapi_options;
    } else {
      _request = {
        projectId
      };
      _options = webapi_options;
    }
    return this._getNextProjectStatusAsync(_request, _options);
  }
  async _hasGuideActivitiesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("HasGuideActivities", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async hasGuideActivitiesAsync(projectId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = projectId;
    if (typeof first === "object" && first && typeof first.projectId != "undefined") {
      _request = projectId;
      _options = webapi_options;
    } else {
      _request = {
        projectId
      };
      _options = webapi_options;
    }
    return this._hasGuideActivitiesAsync(_request, _options);
  }
  async _validateProjectEntityAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ValidateProjectEntity", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_StringDictionary_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async validateProjectEntityAsync(projectEntity, webapi_options) {
    let _request = null;
    let _options = null;
    const first = projectEntity;
    if (typeof first === "object" && first && typeof first.projectEntity != "undefined") {
      _request = projectEntity;
      _options = webapi_options;
    } else {
      _request = {
        projectEntity
      };
      _options = webapi_options;
    }
    return this._validateProjectEntityAsync(_request, _options);
  }
  /*
   * Gets a ProjectEvent object.
   * @param projectEventId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single ProjectEvent
   */
  async getProjectEventAsync(projectEventId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetProjectEvent?projectEventId=" + projectEventId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ProjectEvent_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getProjectEventOnPersonAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetProjectEventOnPerson", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ProjectEvent_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getProjectEventOnPersonAsync(projectId, personId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = projectId;
    if (typeof first === "object" && first && (typeof first.projectId != "undefined" || typeof first.personId != "undefined")) {
      _request = projectId;
      _options = personId;
    } else {
      _request = {
        projectId,
        personId
      };
      _options = webapi_options;
    }
    return this._getProjectEventOnPersonAsync(_request, _options);
  }
  /*
   * Gets a ProjectEventEntity object.
   * @param projectEventEntityId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single ProjectEventEntity
   */
  async getProjectEventEntityAsync(projectEventEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetProjectEventEntity?projectEventEntityId=" + projectEventEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ProjectEventEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getProjectEventEntityFromProjectIdAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetProjectEventEntityFromProjectId", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ProjectEventEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getProjectEventEntityFromProjectIdAsync(projectId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = projectId;
    if (typeof first === "object" && first && typeof first.projectId != "undefined") {
      _request = projectId;
      _options = webapi_options;
    } else {
      _request = {
        projectId
      };
      _options = webapi_options;
    }
    return this._getProjectEventEntityFromProjectIdAsync(_request, _options);
  }
  async _deleteProjectEventEntityFromProjectIdAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeleteProjectEventEntityFromProjectId", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async deleteProjectEventEntityFromProjectIdAsync(projectId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = projectId;
    if (typeof first === "object" && first && typeof first.projectId != "undefined") {
      _request = projectId;
      _options = webapi_options;
    } else {
      _request = {
        projectId
      };
      _options = webapi_options;
    }
    return this._deleteProjectEventEntityFromProjectIdAsync(_request, _options);
  }
  /*
   * Gets an array of ProjectEvent objects.
   * @param projectEventIds - The primary keys.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns An array of ProjectEvent
   */
  async getProjectEventListAsync(projectEventIds, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetProjectEventList", projectEventIds, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ProjectEventArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getMyProjectEventsAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetMyProjectEvents", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ProjectEventArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Gets all project events that belongs to the currently logged on user. The list of events are filtered by the Audience Visibility restrictions set when the project event is created.
   * @returns Array of project events
   */
  async getMyProjectEventsAsync(webapi_options) {
    return this._getMyProjectEventsAsync(webapi_options);
  }
  async _getProjectEventsOnPersonAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetProjectEventsOnPerson", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ProjectEventArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getProjectEventsOnPersonAsync(personId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = personId;
    if (typeof first === "object" && first && typeof first.personId != "undefined") {
      _request = personId;
      _options = webapi_options;
    } else {
      _request = {
        personId
      };
      _options = webapi_options;
    }
    return this._getProjectEventsOnPersonAsync(_request, _options);
  }
  /*
   * Gets an array of Project objects.
   * @param projectIds - The primary keys.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns An array of Project
   */
  async getProjectListAsync(projectIds, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetProjectList", projectIds, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ProjectArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getMyProjectsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetMyProjects", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ProjectArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getMyProjectsAsync(includeMemberProjects, webapi_options) {
    let _request = null;
    let _options = null;
    const first = includeMemberProjects;
    if (typeof first === "object" && first && typeof first.includeMemberProjects != "undefined") {
      _request = includeMemberProjects;
      _options = webapi_options;
    } else {
      _request = {
        includeMemberProjects
      };
      _options = webapi_options;
    }
    return this._getMyProjectsAsync(_request, _options);
  }
  async _getMyMemberProjectsAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetMyMemberProjects", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ProjectArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Returning the projects where an user is project member.
   * @returns The list of projects.
   */
  async getMyMemberProjectsAsync(webapi_options) {
    return this._getMyMemberProjectsAsync(webapi_options);
  }
  async _getProjectsFromPersonAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetProjectsFromPerson", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ProjectArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getProjectsFromPersonAsync(personId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = personId;
    if (typeof first === "object" && first && typeof first.personId != "undefined") {
      _request = personId;
      _options = webapi_options;
    } else {
      _request = {
        personId
      };
      _options = webapi_options;
    }
    return this._getProjectsFromPersonAsync(_request, _options);
  }
  async _getProjectsFromContactAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetProjectsFromContact", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ProjectArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getProjectsFromContactAsync(contactId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = contactId;
    if (typeof first === "object" && first && typeof first.contactId != "undefined") {
      _request = contactId;
      _options = webapi_options;
    } else {
      _request = {
        contactId
      };
      _options = webapi_options;
    }
    return this._getProjectsFromContactAsync(_request, _options);
  }
  async _getPublishedProjectAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPublishedProject", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Project_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getPublishedProjectAsync(projectId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = projectId;
    if (typeof first === "object" && first && typeof first.projectId != "undefined") {
      _request = projectId;
      _options = webapi_options;
    } else {
      _request = {
        projectId
      };
      _options = webapi_options;
    }
    return this._getPublishedProjectAsync(_request, _options);
  }
  async _getPublishedProjectsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPublishedProjects", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ProjectArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getPublishedProjectsAsync(projectIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = projectIds;
    if (typeof first === "object" && first && typeof first.projectIds != "undefined") {
      _request = projectIds;
      _options = webapi_options;
    } else {
      _request = {
        projectIds
      };
      _options = webapi_options;
    }
    return this._getPublishedProjectsAsync(_request, _options);
  }
  async _getMyPublishedProjectsAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetMyPublishedProjects", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ProjectArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Get published projects from the logged in user.
   * @returns Projects
   */
  async getMyPublishedProjectsAsync(webapi_options) {
    return this._getMyPublishedProjectsAsync(webapi_options);
  }
  async _getPublishedProjectsOnPersonIdAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPublishedProjectsOnPersonId", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ProjectArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getPublishedProjectsOnPersonIdAsync(personId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = personId;
    if (typeof first === "object" && first && typeof first.personId != "undefined") {
      _request = personId;
      _options = webapi_options;
    } else {
      _request = {
        personId
      };
      _options = webapi_options;
    }
    return this._getPublishedProjectsOnPersonIdAsync(_request, _options);
  }
  /*
   * Gets a ProjectMember object.
   * @param projectMemberId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single ProjectMember
   */
  async getProjectMemberAsync(projectMemberId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetProjectMember?projectMemberId=" + projectMemberId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ProjectMember_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getProjectMembersAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetProjectMembers", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ProjectMemberArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getProjectMembersAsync(projectId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = projectId;
    if (typeof first === "object" && first && typeof first.projectId != "undefined") {
      _request = projectId;
      _options = webapi_options;
    } else {
      _request = {
        projectId
      };
      _options = webapi_options;
    }
    return this._getProjectMembersAsync(_request, _options);
  }
  async _updateProjectMemberAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("UpdateProjectMember", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ProjectMember_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async updateProjectMemberAsync(projectMember, webapi_options) {
    let _request = null;
    let _options = null;
    const first = projectMember;
    if (typeof first === "object" && first && typeof first.projectMember != "undefined") {
      _request = projectMember;
      _options = webapi_options;
    } else {
      _request = {
        projectMember
      };
      _options = webapi_options;
    }
    return this._updateProjectMemberAsync(_request, _options);
  }
  async _getProjectMembersByIdAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetProjectMembersById", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ProjectMemberArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getProjectMembersByIdAsync(projectMemberIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = projectMemberIds;
    if (typeof first === "object" && first && typeof first.projectMemberIds != "undefined") {
      _request = projectMemberIds;
      _options = webapi_options;
    } else {
      _request = {
        projectMemberIds
      };
      _options = webapi_options;
    }
    return this._getProjectMembersByIdAsync(_request, _options);
  }
  async _saveProjectMembersFunctionAndCommentAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveProjectMembersFunctionAndComment", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveProjectMembersFunctionAndCommentAsync(projectMemberIds, roleId, comment, webapi_options) {
    let _request = null;
    let _options = null;
    const first = projectMemberIds;
    if (typeof first === "object" && first && (typeof first.projectMemberIds != "undefined" || typeof first.roleId != "undefined" || typeof first.comment != "undefined")) {
      _request = projectMemberIds;
      _options = roleId;
    } else {
      _request = {
        projectMemberIds,
        roleId,
        comment
      };
      _options = webapi_options;
    }
    return this._saveProjectMembersFunctionAndCommentAsync(_request, _options);
  }
};

// server/node_modules/@superoffice/webapi/dist/esm/AppointmentAgent.js
var AppointmentAgent = class extends WebApiBase {
  constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
    const options = WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
    options.basePath = "v1/Agents/Appointment/";
    super(options);
  }
  /**
   * Set default values into a new AppointmentEntity.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultAppointmentEntityAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultAppointmentEntity", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AppointmentEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing AppointmentEntity or creates a new AppointmentEntity if the id parameter is empty
   * @param entity - The AppointmentEntity to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated AppointmentEntity
   */
  async saveAppointmentEntityAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveAppointmentEntity", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AppointmentEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Deletes the AppointmentEntity
   * @param AppointmentEntityId - The id of the AppointmentEntity to be deleted.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   */
  async deleteAppointmentEntityAsync(AppointmentEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("DeleteAppointmentEntity?AppointmentEntityId=" + AppointmentEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new SuggestedAppointmentEntity.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultSuggestedAppointmentEntityAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultSuggestedAppointmentEntity", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SuggestedAppointmentEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing SuggestedAppointmentEntity or creates a new SuggestedAppointmentEntity if the id parameter is empty
   * @param entity - The SuggestedAppointmentEntity to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated SuggestedAppointmentEntity
   */
  async saveSuggestedAppointmentEntityAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveSuggestedAppointmentEntity", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SuggestedAppointmentEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new TaskListItem.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultTaskListItemAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultTaskListItem", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TaskListItem_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing TaskListItem or creates a new TaskListItem if the id parameter is empty
   * @param entity - The TaskListItem to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated TaskListItem
   */
  async saveTaskListItemAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveTaskListItem", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TaskListItem_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets a Appointment object.
   * @param appointmentId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single Appointment
   */
  async getAppointmentAsync(appointmentId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetAppointment?appointmentId=" + appointmentId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Appointment_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _toggleAppointmentStatusAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ToggleAppointmentStatus", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async toggleAppointmentStatusAsync(appointmentId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = appointmentId;
    if (typeof first === "object" && first && typeof first.appointmentId != "undefined") {
      _request = appointmentId;
      _options = webapi_options;
    } else {
      _request = {
        appointmentId
      };
      _options = webapi_options;
    }
    return this._toggleAppointmentStatusAsync(_request, _options);
  }
  async _toggleActivityAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ToggleActivity", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async toggleActivityAsync(activityIdentifier, webapi_options) {
    let _request = null;
    let _options = null;
    const first = activityIdentifier;
    if (typeof first === "object" && first && typeof first.activityIdentifier != "undefined") {
      _request = activityIdentifier;
      _options = webapi_options;
    } else {
      _request = {
        activityIdentifier
      };
      _options = webapi_options;
    }
    return this._toggleActivityAsync(_request, _options);
  }
  async _toggleActivitiesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ToggleActivities", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async toggleActivitiesAsync(activityIdentifier, webapi_options) {
    let _request = null;
    let _options = null;
    const first = activityIdentifier;
    if (typeof first === "object" && first && typeof first.activityIdentifier != "undefined") {
      _request = activityIdentifier;
      _options = webapi_options;
    } else {
      _request = {
        activityIdentifier
      };
      _options = webapi_options;
    }
    return this._toggleActivitiesAsync(_request, _options);
  }
  async _setActivityStatusAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetActivityStatus", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setActivityStatusAsync(activityIdentifier, activityStatus, webapi_options) {
    let _request = null;
    let _options = null;
    const first = activityIdentifier;
    if (typeof first === "object" && first && (typeof first.activityIdentifier != "undefined" || typeof first.activityStatus != "undefined")) {
      _request = activityIdentifier;
      _options = activityStatus;
    } else {
      _request = {
        activityIdentifier,
        activityStatus
      };
      _options = webapi_options;
    }
    return this._setActivityStatusAsync(_request, _options);
  }
  async _toggleAndSetActivitiesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ToggleAndSetActivities", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async toggleAndSetActivitiesAsync(activityIdentifiers, webapi_options) {
    let _request = null;
    let _options = null;
    const first = activityIdentifiers;
    if (typeof first === "object" && first && typeof first.activityIdentifiers != "undefined") {
      _request = activityIdentifiers;
      _options = webapi_options;
    } else {
      _request = {
        activityIdentifiers
      };
      _options = webapi_options;
    }
    return this._toggleAndSetActivitiesAsync(_request, _options);
  }
  /*
   * Gets a AppointmentEntity object.
   * @param appointmentEntityId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single AppointmentEntity
   */
  async getAppointmentEntityAsync(appointmentEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetAppointmentEntity?appointmentEntityId=" + appointmentEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AppointmentEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _createDefaultAppointmentEntityByTypeAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateDefaultAppointmentEntityByType", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AppointmentEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createDefaultAppointmentEntityByTypeAsync(type, webapi_options) {
    let _request = null;
    let _options = null;
    const first = type;
    if (typeof first === "object" && first && typeof first.type != "undefined") {
      _request = type;
      _options = webapi_options;
    } else {
      _request = {
        type
      };
      _options = webapi_options;
    }
    return this._createDefaultAppointmentEntityByTypeAsync(_request, _options);
  }
  async _createAppointmentEntityFromExistingAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateAppointmentEntityFromExisting", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AppointmentEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createAppointmentEntityFromExistingAsync(appointmentId, associateId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = appointmentId;
    if (typeof first === "object" && first && (typeof first.appointmentId != "undefined" || typeof first.associateId != "undefined")) {
      _request = appointmentId;
      _options = associateId;
    } else {
      _request = {
        appointmentId,
        associateId
      };
      _options = webapi_options;
    }
    return this._createAppointmentEntityFromExistingAsync(_request, _options);
  }
  async _acceptAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("Accept", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async acceptAsync(appointmentId, updateMode, webapi_options) {
    let _request = null;
    let _options = null;
    const first = appointmentId;
    if (typeof first === "object" && first && (typeof first.appointmentId != "undefined" || typeof first.updateMode != "undefined")) {
      _request = appointmentId;
      _options = updateMode;
    } else {
      _request = {
        appointmentId,
        updateMode
      };
      _options = webapi_options;
    }
    return this._acceptAsync(_request, _options);
  }
  async _createAndAcceptAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateAndAccept", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createAndAcceptAsync(emailItemId, updateMode, webapi_options) {
    let _request = null;
    let _options = null;
    const first = emailItemId;
    if (typeof first === "object" && first && (typeof first.emailItemId != "undefined" || typeof first.updateMode != "undefined")) {
      _request = emailItemId;
      _options = updateMode;
    } else {
      _request = {
        emailItemId,
        updateMode
      };
      _options = webapi_options;
    }
    return this._createAndAcceptAsync(_request, _options);
  }
  async _acceptWithEmailConfirmationAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("AcceptWithEmailConfirmation", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async acceptWithEmailConfirmationAsync(appointmentId, updateMode, webapi_options) {
    let _request = null;
    let _options = null;
    const first = appointmentId;
    if (typeof first === "object" && first && (typeof first.appointmentId != "undefined" || typeof first.updateMode != "undefined")) {
      _request = appointmentId;
      _options = updateMode;
    } else {
      _request = {
        appointmentId,
        updateMode
      };
      _options = webapi_options;
    }
    return this._acceptWithEmailConfirmationAsync(_request, _options);
  }
  async _createAndAcceptWithEmailConfirmationAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateAndAcceptWithEmailConfirmation", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createAndAcceptWithEmailConfirmationAsync(emailItemId, updateMode, webapi_options) {
    let _request = null;
    let _options = null;
    const first = emailItemId;
    if (typeof first === "object" && first && (typeof first.emailItemId != "undefined" || typeof first.updateMode != "undefined")) {
      _request = emailItemId;
      _options = updateMode;
    } else {
      _request = {
        emailItemId,
        updateMode
      };
      _options = webapi_options;
    }
    return this._createAndAcceptWithEmailConfirmationAsync(_request, _options);
  }
  async _rejectAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("Reject", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async rejectAsync(appointmentId, rejectReason, updateMode, webapi_options) {
    let _request = null;
    let _options = null;
    const first = appointmentId;
    if (typeof first === "object" && first && (typeof first.appointmentId != "undefined" || typeof first.rejectReason != "undefined" || typeof first.updateMode != "undefined")) {
      _request = appointmentId;
      _options = rejectReason;
    } else {
      _request = {
        appointmentId,
        rejectReason,
        updateMode
      };
      _options = webapi_options;
    }
    return this._rejectAsync(_request, _options);
  }
  async _rejectWithEmailConfirmationAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("RejectWithEmailConfirmation", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async rejectWithEmailConfirmationAsync(appointmentId, rejectReason, updateMode, webapi_options) {
    let _request = null;
    let _options = null;
    const first = appointmentId;
    if (typeof first === "object" && first && (typeof first.appointmentId != "undefined" || typeof first.rejectReason != "undefined" || typeof first.updateMode != "undefined")) {
      _request = appointmentId;
      _options = rejectReason;
    } else {
      _request = {
        appointmentId,
        rejectReason,
        updateMode
      };
      _options = webapi_options;
    }
    return this._rejectWithEmailConfirmationAsync(_request, _options);
  }
  async _declineInvitationFromEmailItemAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeclineInvitationFromEmailItem", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async declineInvitationFromEmailItemAsync(emailItemId, rejectReason, webapi_options) {
    let _request = null;
    let _options = null;
    const first = emailItemId;
    if (typeof first === "object" && first && (typeof first.emailItemId != "undefined" || typeof first.rejectReason != "undefined")) {
      _request = emailItemId;
      _options = rejectReason;
    } else {
      _request = {
        emailItemId,
        rejectReason
      };
      _options = webapi_options;
    }
    return this._declineInvitationFromEmailItemAsync(_request, _options);
  }
  async _getOrganizerNameAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetOrganizerName", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getOrganizerNameAsync(motherAppointmentId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = motherAppointmentId;
    if (typeof first === "object" && first && typeof first.motherAppointmentId != "undefined") {
      _request = motherAppointmentId;
      _options = webapi_options;
    } else {
      _request = {
        motherAppointmentId
      };
      _options = webapi_options;
    }
    return this._getOrganizerNameAsync(_request, _options);
  }
  async _saveAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("Save", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AppointmentEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveAsync(appointmentEntity, updateMode, sendEmailToParticipants, smtpEMailConnectionInfo, imapEMailConnectionInfo, webapi_options) {
    let _request = null;
    let _options = null;
    const first = appointmentEntity;
    if (typeof first === "object" && first && (typeof first.appointmentEntity != "undefined" || typeof first.updateMode != "undefined" || typeof first.sendEmailToParticipants != "undefined" || typeof first.smtpEMailConnectionInfo != "undefined" || typeof first.imapEMailConnectionInfo != "undefined")) {
      _request = appointmentEntity;
      _options = updateMode;
    } else {
      _request = {
        appointmentEntity,
        updateMode,
        sendEmailToParticipants,
        smtpEMailConnectionInfo,
        imapEMailConnectionInfo
      };
      _options = webapi_options;
    }
    return this._saveAsync(_request, _options);
  }
  async _deleteAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("Delete", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async deleteAsync(appointmentId, updateMode, sendEmailToParticipants, smtpEMailConnectionInfo, imapEMailConnectionInfo, webapi_options) {
    let _request = null;
    let _options = null;
    const first = appointmentId;
    if (typeof first === "object" && first && (typeof first.appointmentId != "undefined" || typeof first.updateMode != "undefined" || typeof first.sendEmailToParticipants != "undefined" || typeof first.smtpEMailConnectionInfo != "undefined" || typeof first.imapEMailConnectionInfo != "undefined")) {
      _request = appointmentId;
      _options = updateMode;
    } else {
      _request = {
        appointmentId,
        updateMode,
        sendEmailToParticipants,
        smtpEMailConnectionInfo,
        imapEMailConnectionInfo
      };
      _options = webapi_options;
    }
    return this._deleteAsync(_request, _options);
  }
  async _calculateDaysAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CalculateDays", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_RecurrenceInfo_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async calculateDaysAsync(appointmentEntity, webapi_options) {
    let _request = null;
    let _options = null;
    const first = appointmentEntity;
    if (typeof first === "object" && first && typeof first.appointmentEntity != "undefined") {
      _request = appointmentEntity;
      _options = webapi_options;
    } else {
      _request = {
        appointmentEntity
      };
      _options = webapi_options;
    }
    return this._calculateDaysAsync(_request, _options);
  }
  async _validateDaysAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ValidateDays", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_RecurrenceDateArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async validateDaysAsync(appointmentEntity, dates, webapi_options) {
    let _request = null;
    let _options = null;
    const first = appointmentEntity;
    if (typeof first === "object" && first && (typeof first.appointmentEntity != "undefined" || typeof first.dates != "undefined")) {
      _request = appointmentEntity;
      _options = dates;
    } else {
      _request = {
        appointmentEntity,
        dates
      };
      _options = webapi_options;
    }
    return this._validateDaysAsync(_request, _options);
  }
  async _createDefaultRecurrenceAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateDefaultRecurrence", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_RecurrenceInfo_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Creates a RecurrenceInfo object populated with the default values for the specific type.
   * @returns RecurrenceInfo object with default values.
   */
  async createDefaultRecurrenceAsync(webapi_options) {
    return this._createDefaultRecurrenceAsync(webapi_options);
  }
  async _assignToAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("AssignTo", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AppointmentEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async assignToAsync(appointmentId, participant, updateMode, webapi_options) {
    let _request = null;
    let _options = null;
    const first = appointmentId;
    if (typeof first === "object" && first && (typeof first.appointmentId != "undefined" || typeof first.participant != "undefined" || typeof first.updateMode != "undefined")) {
      _request = appointmentId;
      _options = participant;
    } else {
      _request = {
        appointmentId,
        participant,
        updateMode
      };
      _options = webapi_options;
    }
    return this._assignToAsync(_request, _options);
  }
  async _setSeenAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetSeen", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setSeenAsync(appointmentId, updateMode, webapi_options) {
    let _request = null;
    let _options = null;
    const first = appointmentId;
    if (typeof first === "object" && first && (typeof first.appointmentId != "undefined" || typeof first.updateMode != "undefined")) {
      _request = appointmentId;
      _options = updateMode;
    } else {
      _request = {
        appointmentId,
        updateMode
      };
      _options = webapi_options;
    }
    return this._setSeenAsync(_request, _options);
  }
  async _setSeenManyAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetSeenMany", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setSeenManyAsync(appointmentIds, updateMode, webapi_options) {
    let _request = null;
    let _options = null;
    const first = appointmentIds;
    if (typeof first === "object" && first && (typeof first.appointmentIds != "undefined" || typeof first.updateMode != "undefined")) {
      _request = appointmentIds;
      _options = updateMode;
    } else {
      _request = {
        appointmentIds,
        updateMode
      };
      _options = webapi_options;
    }
    return this._setSeenManyAsync(_request, _options);
  }
  async _moveAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("Move", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AppointmentEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async moveAsync(appointmentId, newStartTime, updateMode, webapi_options) {
    let _request = null;
    let _options = null;
    const first = appointmentId;
    if (typeof first === "object" && first && (typeof first.appointmentId != "undefined" || typeof first.newStartTime != "undefined" || typeof first.updateMode != "undefined")) {
      _request = appointmentId;
      _options = newStartTime;
    } else {
      _request = {
        appointmentId,
        newStartTime,
        updateMode
      };
      _options = webapi_options;
    }
    return this._moveAsync(_request, _options);
  }
  async _acceptRejectedAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("AcceptRejected", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AppointmentEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async acceptRejectedAsync(appointmentId, updateMode, webapi_options) {
    let _request = null;
    let _options = null;
    const first = appointmentId;
    if (typeof first === "object" && first && (typeof first.appointmentId != "undefined" || typeof first.updateMode != "undefined")) {
      _request = appointmentId;
      _options = updateMode;
    } else {
      _request = {
        appointmentId,
        updateMode
      };
      _options = webapi_options;
    }
    return this._acceptRejectedAsync(_request, _options);
  }
  async _createDefaultRecurrenceByDateAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateDefaultRecurrenceByDate", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_RecurrenceInfo_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createDefaultRecurrenceByDateAsync(startDate, webapi_options) {
    let _request = null;
    let _options = null;
    const first = startDate;
    if (typeof first === "object" && first && typeof first.startDate != "undefined") {
      _request = startDate;
      _options = webapi_options;
    } else {
      _request = {
        startDate
      };
      _options = webapi_options;
    }
    return this._createDefaultRecurrenceByDateAsync(_request, _options);
  }
  async _cleanUpBookingDeletedAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CleanUpBookingDeleted", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async cleanUpBookingDeletedAsync(appointmentIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = appointmentIds;
    if (typeof first === "object" && first && typeof first.appointmentIds != "undefined") {
      _request = appointmentIds;
      _options = webapi_options;
    } else {
      _request = {
        appointmentIds
      };
      _options = webapi_options;
    }
    return this._cleanUpBookingDeletedAsync(_request, _options);
  }
  async _cleanUpBookingDeletedWithUpdateModeAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CleanUpBookingDeletedWithUpdateMode", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async cleanUpBookingDeletedWithUpdateModeAsync(appointmentIds, updateMode, webapi_options) {
    let _request = null;
    let _options = null;
    const first = appointmentIds;
    if (typeof first === "object" && first && (typeof first.appointmentIds != "undefined" || typeof first.updateMode != "undefined")) {
      _request = appointmentIds;
      _options = updateMode;
    } else {
      _request = {
        appointmentIds,
        updateMode
      };
      _options = webapi_options;
    }
    return this._cleanUpBookingDeletedWithUpdateModeAsync(_request, _options);
  }
  async _cleanUpRecurringBookingDeletedAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CleanUpRecurringBookingDeleted", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Deletes all appointments with status BookingDeleted and for in logged user.
   * @returns
   */
  async cleanUpRecurringBookingDeletedAsync(webapi_options) {
    return this._cleanUpRecurringBookingDeletedAsync(webapi_options);
  }
  async _createDefaultAppointmentEntityByTypeAndAssociateAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateDefaultAppointmentEntityByTypeAndAssociate", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AppointmentEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createDefaultAppointmentEntityByTypeAndAssociateAsync(type, associateId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = type;
    if (typeof first === "object" && first && (typeof first.type != "undefined" || typeof first.associateId != "undefined")) {
      _request = type;
      _options = associateId;
    } else {
      _request = {
        type,
        associateId
      };
      _options = webapi_options;
    }
    return this._createDefaultAppointmentEntityByTypeAndAssociateAsync(_request, _options);
  }
  async _getCanInsertForAssociatesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetCanInsertForAssociates", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getCanInsertForAssociatesAsync(associateIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = associateIds;
    if (typeof first === "object" && first && typeof first.associateIds != "undefined") {
      _request = associateIds;
      _options = webapi_options;
    } else {
      _request = {
        associateIds
      };
      _options = webapi_options;
    }
    return this._getCanInsertForAssociatesAsync(_request, _options);
  }
  async _getAppointmentHaveParticipantsWithEmailAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetAppointmentHaveParticipantsWithEmail", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getAppointmentHaveParticipantsWithEmailAsync(appointmentId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = appointmentId;
    if (typeof first === "object" && first && typeof first.appointmentId != "undefined") {
      _request = appointmentId;
      _options = webapi_options;
    } else {
      _request = {
        appointmentId
      };
      _options = webapi_options;
    }
    return this._getAppointmentHaveParticipantsWithEmailAsync(_request, _options);
  }
  async _createDefaultAppointmentEntityFromSaleSuggestionAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateDefaultAppointmentEntityFromSaleSuggestion", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AppointmentEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createDefaultAppointmentEntityFromSaleSuggestionAsync(suggestedAppointmentId, saleId, createNow, ownerId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = suggestedAppointmentId;
    if (typeof first === "object" && first && (typeof first.suggestedAppointmentId != "undefined" || typeof first.saleId != "undefined" || typeof first.createNow != "undefined" || typeof first.ownerId != "undefined")) {
      _request = suggestedAppointmentId;
      _options = saleId;
    } else {
      _request = {
        suggestedAppointmentId,
        saleId,
        createNow,
        ownerId
      };
      _options = webapi_options;
    }
    return this._createDefaultAppointmentEntityFromSaleSuggestionAsync(_request, _options);
  }
  async _getNextSuggestedAppointmentBySaleAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetNextSuggestedAppointmentBySale", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SuggestedAppointment_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getNextSuggestedAppointmentBySaleAsync(saleId, currentAppointmentId, skipCompleteCheck, webapi_options) {
    let _request = null;
    let _options = null;
    const first = saleId;
    if (typeof first === "object" && first && (typeof first.saleId != "undefined" || typeof first.currentAppointmentId != "undefined" || typeof first.skipCompleteCheck != "undefined")) {
      _request = saleId;
      _options = currentAppointmentId;
    } else {
      _request = {
        saleId,
        currentAppointmentId,
        skipCompleteCheck
      };
      _options = webapi_options;
    }
    return this._getNextSuggestedAppointmentBySaleAsync(_request, _options);
  }
  async _createDefaultReOpenAppointmentAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateDefaultReOpenAppointment", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AppointmentEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createDefaultReOpenAppointmentAsync(saleId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = saleId;
    if (typeof first === "object" && first && typeof first.saleId != "undefined") {
      _request = saleId;
      _options = webapi_options;
    } else {
      _request = {
        saleId
      };
      _options = webapi_options;
    }
    return this._createDefaultReOpenAppointmentAsync(_request, _options);
  }
  async _createDefaultAppointmentEntityFromProjectSuggestionAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateDefaultAppointmentEntityFromProjectSuggestion", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AppointmentEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createDefaultAppointmentEntityFromProjectSuggestionAsync(suggestedAppointmentId, projectId, createNow, ownerId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = suggestedAppointmentId;
    if (typeof first === "object" && first && (typeof first.suggestedAppointmentId != "undefined" || typeof first.projectId != "undefined" || typeof first.createNow != "undefined" || typeof first.ownerId != "undefined")) {
      _request = suggestedAppointmentId;
      _options = projectId;
    } else {
      _request = {
        suggestedAppointmentId,
        projectId,
        createNow,
        ownerId
      };
      _options = webapi_options;
    }
    return this._createDefaultAppointmentEntityFromProjectSuggestionAsync(_request, _options);
  }
  async _createAppointmentForUIDAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateAppointmentForUID", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AppointmentEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createAppointmentForUIDAsync(appointmentEntity, uid, webapi_options) {
    let _request = null;
    let _options = null;
    const first = appointmentEntity;
    if (typeof first === "object" && first && (typeof first.appointmentEntity != "undefined" || typeof first.uid != "undefined")) {
      _request = appointmentEntity;
      _options = uid;
    } else {
      _request = {
        appointmentEntity,
        uid
      };
      _options = webapi_options;
    }
    return this._createAppointmentForUIDAsync(_request, _options);
  }
  async _getAppointmentFromUIDAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetAppointmentFromUID", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AppointmentEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getAppointmentFromUIDAsync(uid, webapi_options) {
    let _request = null;
    let _options = null;
    const first = uid;
    if (typeof first === "object" && first && typeof first.uid != "undefined") {
      _request = uid;
      _options = webapi_options;
    } else {
      _request = {
        uid
      };
      _options = webapi_options;
    }
    return this._getAppointmentFromUIDAsync(_request, _options);
  }
  async _canAssignToProjectMemberAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CanAssignToProjectMember", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async canAssignToProjectMemberAsync(projectId, suggestedAppointmentId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = projectId;
    if (typeof first === "object" && first && (typeof first.projectId != "undefined" || typeof first.suggestedAppointmentId != "undefined")) {
      _request = projectId;
      _options = suggestedAppointmentId;
    } else {
      _request = {
        projectId,
        suggestedAppointmentId
      };
      _options = webapi_options;
    }
    return this._canAssignToProjectMemberAsync(_request, _options);
  }
  async _getUIDFromAppointmentIdAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetUIDFromAppointmentId", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getUIDFromAppointmentIdAsync(appointmentId, useMotherId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = appointmentId;
    if (typeof first === "object" && first && (typeof first.appointmentId != "undefined" || typeof first.useMotherId != "undefined")) {
      _request = appointmentId;
      _options = useMotherId;
    } else {
      _request = {
        appointmentId,
        useMotherId
      };
      _options = webapi_options;
    }
    return this._getUIDFromAppointmentIdAsync(_request, _options);
  }
  async _updateAppointmentFromIcsResponseAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("UpdateAppointmentFromIcsResponse", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async updateAppointmentFromIcsResponseAsync(emailAddress, icsData, webapi_options) {
    let _request = null;
    let _options = null;
    const first = emailAddress;
    if (typeof first === "object" && first && (typeof first.emailAddress != "undefined" || typeof first.icsData != "undefined")) {
      _request = emailAddress;
      _options = icsData;
    } else {
      _request = {
        emailAddress,
        icsData
      };
      _options = webapi_options;
    }
    _request.icsData = ToBase64(_request.icsData);
    return this._updateAppointmentFromIcsResponseAsync(_request, _options);
  }
  async _validateAppointmentEntityAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ValidateAppointmentEntity", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_StringDictionary_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async validateAppointmentEntityAsync(appointmentEntity, webapi_options) {
    let _request = null;
    let _options = null;
    const first = appointmentEntity;
    if (typeof first === "object" && first && typeof first.appointmentEntity != "undefined") {
      _request = appointmentEntity;
      _options = webapi_options;
    } else {
      _request = {
        appointmentEntity
      };
      _options = webapi_options;
    }
    return this._validateAppointmentEntityAsync(_request, _options);
  }
  async _willSendEmailAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("WillSendEmail", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async willSendEmailAsync(appointment, webapi_options) {
    let _request = null;
    let _options = null;
    const first = appointment;
    if (typeof first === "object" && first && typeof first.appointment != "undefined") {
      _request = appointment;
      _options = webapi_options;
    } else {
      _request = {
        appointment
      };
      _options = webapi_options;
    }
    return this._willSendEmailAsync(_request, _options);
  }
  async _acceptWithSmtpEmailConfirmationAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("AcceptWithSmtpEmailConfirmation", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async acceptWithSmtpEmailConfirmationAsync(appointmentId, updateMode, smtpEMailConnectionInfo, webapi_options) {
    let _request = null;
    let _options = null;
    const first = appointmentId;
    if (typeof first === "object" && first && (typeof first.appointmentId != "undefined" || typeof first.updateMode != "undefined" || typeof first.smtpEMailConnectionInfo != "undefined")) {
      _request = appointmentId;
      _options = updateMode;
    } else {
      _request = {
        appointmentId,
        updateMode,
        smtpEMailConnectionInfo
      };
      _options = webapi_options;
    }
    return this._acceptWithSmtpEmailConfirmationAsync(_request, _options);
  }
  async _rejectWithSmtpEmailConfirmationAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("RejectWithSmtpEmailConfirmation", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async rejectWithSmtpEmailConfirmationAsync(appointmentId, rejectReason, updateMode, smtpEMailConnectionInfo, webapi_options) {
    let _request = null;
    let _options = null;
    const first = appointmentId;
    if (typeof first === "object" && first && (typeof first.appointmentId != "undefined" || typeof first.rejectReason != "undefined" || typeof first.updateMode != "undefined" || typeof first.smtpEMailConnectionInfo != "undefined")) {
      _request = appointmentId;
      _options = rejectReason;
    } else {
      _request = {
        appointmentId,
        rejectReason,
        updateMode,
        smtpEMailConnectionInfo
      };
      _options = webapi_options;
    }
    return this._rejectWithSmtpEmailConfirmationAsync(_request, _options);
  }
  /*
   * Gets an array of Appointment objects.
   * @param appointmentIds - The primary keys.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns An array of Appointment
   */
  async getAppointmentListAsync(appointmentIds, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetAppointmentList", appointmentIds, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AppointmentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getMyAppointmentsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetMyAppointments", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AppointmentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getMyAppointmentsAsync(startTime, endTime, count, webapi_options) {
    let _request = null;
    let _options = null;
    const first = startTime;
    if (typeof first === "object" && first && (typeof first.startTime != "undefined" || typeof first.endTime != "undefined" || typeof first.count != "undefined")) {
      _request = startTime;
      _options = endTime;
    } else {
      _request = {
        startTime,
        endTime,
        count
      };
      _options = webapi_options;
    }
    return this._getMyAppointmentsAsync(_request, _options);
  }
  async _getPersonAppointmentsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPersonAppointments", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AppointmentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getPersonAppointmentsAsync(personId, includeProjectAppointments, startTime, endTime, count, webapi_options) {
    let _request = null;
    let _options = null;
    const first = personId;
    if (typeof first === "object" && first && (typeof first.personId != "undefined" || typeof first.includeProjectAppointments != "undefined" || typeof first.startTime != "undefined" || typeof first.endTime != "undefined" || typeof first.count != "undefined")) {
      _request = personId;
      _options = includeProjectAppointments;
    } else {
      _request = {
        personId,
        includeProjectAppointments,
        startTime,
        endTime,
        count
      };
      _options = webapi_options;
    }
    return this._getPersonAppointmentsAsync(_request, _options);
  }
  async _getMyDiaryAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetMyDiary", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AppointmentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getMyDiaryAsync(startTime, endTime, count, webapi_options) {
    let _request = null;
    let _options = null;
    const first = startTime;
    if (typeof first === "object" && first && (typeof first.startTime != "undefined" || typeof first.endTime != "undefined" || typeof first.count != "undefined")) {
      _request = startTime;
      _options = endTime;
    } else {
      _request = {
        startTime,
        endTime,
        count
      };
      _options = webapi_options;
    }
    return this._getMyDiaryAsync(_request, _options);
  }
  async _getMyTasksAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetMyTasks", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AppointmentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getMyTasksAsync(count, webapi_options) {
    let _request = null;
    let _options = null;
    const first = count;
    if (typeof first === "object" && first && typeof first.count != "undefined") {
      _request = count;
      _options = webapi_options;
    } else {
      _request = {
        count
      };
      _options = webapi_options;
    }
    return this._getMyTasksAsync(_request, _options);
  }
  async _getPersonDiaryAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPersonDiary", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AppointmentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getPersonDiaryAsync(personId, startTime, endTime, count, webapi_options) {
    let _request = null;
    let _options = null;
    const first = personId;
    if (typeof first === "object" && first && (typeof first.personId != "undefined" || typeof first.startTime != "undefined" || typeof first.endTime != "undefined" || typeof first.count != "undefined")) {
      _request = personId;
      _options = startTime;
    } else {
      _request = {
        personId,
        startTime,
        endTime,
        count
      };
      _options = webapi_options;
    }
    return this._getPersonDiaryAsync(_request, _options);
  }
  async _getPersonTasksAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPersonTasks", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AppointmentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getPersonTasksAsync(personId, count, webapi_options) {
    let _request = null;
    let _options = null;
    const first = personId;
    if (typeof first === "object" && first && (typeof first.personId != "undefined" || typeof first.count != "undefined")) {
      _request = personId;
      _options = count;
    } else {
      _request = {
        personId,
        count
      };
      _options = webapi_options;
    }
    return this._getPersonTasksAsync(_request, _options);
  }
  async _getPersonAppointmentsByTypeAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPersonAppointmentsByType", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AppointmentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getPersonAppointmentsByTypeAsync(personId, includeProjectAppointments, startTime, endTime, count, appointmentType, webapi_options) {
    let _request = null;
    let _options = null;
    const first = personId;
    if (typeof first === "object" && first && (typeof first.personId != "undefined" || typeof first.includeProjectAppointments != "undefined" || typeof first.startTime != "undefined" || typeof first.endTime != "undefined" || typeof first.count != "undefined" || typeof first.appointmentType != "undefined")) {
      _request = personId;
      _options = includeProjectAppointments;
    } else {
      _request = {
        personId,
        includeProjectAppointments,
        startTime,
        endTime,
        count,
        appointmentType
      };
      _options = webapi_options;
    }
    return this._getPersonAppointmentsByTypeAsync(_request, _options);
  }
  async _getProjectAppointmentsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetProjectAppointments", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AppointmentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getProjectAppointmentsAsync(projectId, startTime, endTime, count, webapi_options) {
    let _request = null;
    let _options = null;
    const first = projectId;
    if (typeof first === "object" && first && (typeof first.projectId != "undefined" || typeof first.startTime != "undefined" || typeof first.endTime != "undefined" || typeof first.count != "undefined")) {
      _request = projectId;
      _options = startTime;
    } else {
      _request = {
        projectId,
        startTime,
        endTime,
        count
      };
      _options = webapi_options;
    }
    return this._getProjectAppointmentsAsync(_request, _options);
  }
  async _getProjectAppointmentsByTypeAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetProjectAppointmentsByType", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AppointmentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getProjectAppointmentsByTypeAsync(projectId, startTime, endTime, count, appointmentType, webapi_options) {
    let _request = null;
    let _options = null;
    const first = projectId;
    if (typeof first === "object" && first && (typeof first.projectId != "undefined" || typeof first.startTime != "undefined" || typeof first.endTime != "undefined" || typeof first.count != "undefined" || typeof first.appointmentType != "undefined")) {
      _request = projectId;
      _options = startTime;
    } else {
      _request = {
        projectId,
        startTime,
        endTime,
        count,
        appointmentType
      };
      _options = webapi_options;
    }
    return this._getProjectAppointmentsByTypeAsync(_request, _options);
  }
  async _getContactAppointmentsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetContactAppointments", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AppointmentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getContactAppointmentsAsync(contactId, startTime, endTime, count, webapi_options) {
    let _request = null;
    let _options = null;
    const first = contactId;
    if (typeof first === "object" && first && (typeof first.contactId != "undefined" || typeof first.startTime != "undefined" || typeof first.endTime != "undefined" || typeof first.count != "undefined")) {
      _request = contactId;
      _options = startTime;
    } else {
      _request = {
        contactId,
        startTime,
        endTime,
        count
      };
      _options = webapi_options;
    }
    return this._getContactAppointmentsAsync(_request, _options);
  }
  async _getContactAppointmentsByTypeAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetContactAppointmentsByType", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AppointmentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getContactAppointmentsByTypeAsync(contactId, startTime, endTime, count, appointmentType, webapi_options) {
    let _request = null;
    let _options = null;
    const first = contactId;
    if (typeof first === "object" && first && (typeof first.contactId != "undefined" || typeof first.startTime != "undefined" || typeof first.endTime != "undefined" || typeof first.count != "undefined" || typeof first.appointmentType != "undefined")) {
      _request = contactId;
      _options = startTime;
    } else {
      _request = {
        contactId,
        startTime,
        endTime,
        count,
        appointmentType
      };
      _options = webapi_options;
    }
    return this._getContactAppointmentsByTypeAsync(_request, _options);
  }
  async _getProjectMemberAppointmentsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetProjectMemberAppointments", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AppointmentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getProjectMemberAppointmentsAsync(personId, startTime, endTime, count, webapi_options) {
    let _request = null;
    let _options = null;
    const first = personId;
    if (typeof first === "object" && first && (typeof first.personId != "undefined" || typeof first.startTime != "undefined" || typeof first.endTime != "undefined" || typeof first.count != "undefined")) {
      _request = personId;
      _options = startTime;
    } else {
      _request = {
        personId,
        startTime,
        endTime,
        count
      };
      _options = webapi_options;
    }
    return this._getProjectMemberAppointmentsAsync(_request, _options);
  }
  async _getProjectMemberAppointmentsByTypeAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetProjectMemberAppointmentsByType", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AppointmentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getProjectMemberAppointmentsByTypeAsync(personId, startTime, endTime, count, appointmentType, webapi_options) {
    let _request = null;
    let _options = null;
    const first = personId;
    if (typeof first === "object" && first && (typeof first.personId != "undefined" || typeof first.startTime != "undefined" || typeof first.endTime != "undefined" || typeof first.count != "undefined" || typeof first.appointmentType != "undefined")) {
      _request = personId;
      _options = startTime;
    } else {
      _request = {
        personId,
        startTime,
        endTime,
        count,
        appointmentType
      };
      _options = webapi_options;
    }
    return this._getProjectMemberAppointmentsByTypeAsync(_request, _options);
  }
  async _getPersonAppointmentsByTaskAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPersonAppointmentsByTask", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AppointmentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getPersonAppointmentsByTaskAsync(personId, includeProjectAppointments, startTime, endTime, count, taskId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = personId;
    if (typeof first === "object" && first && (typeof first.personId != "undefined" || typeof first.includeProjectAppointments != "undefined" || typeof first.startTime != "undefined" || typeof first.endTime != "undefined" || typeof first.count != "undefined" || typeof first.taskId != "undefined")) {
      _request = personId;
      _options = includeProjectAppointments;
    } else {
      _request = {
        personId,
        includeProjectAppointments,
        startTime,
        endTime,
        count,
        taskId
      };
      _options = webapi_options;
    }
    return this._getPersonAppointmentsByTaskAsync(_request, _options);
  }
  async _getPersonAppointmentsByTasksAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPersonAppointmentsByTasks", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AppointmentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getPersonAppointmentsByTasksAsync(personId, includeProjectAppointments, startTime, endTime, count, taskIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = personId;
    if (typeof first === "object" && first && (typeof first.personId != "undefined" || typeof first.includeProjectAppointments != "undefined" || typeof first.startTime != "undefined" || typeof first.endTime != "undefined" || typeof first.count != "undefined" || typeof first.taskIds != "undefined")) {
      _request = personId;
      _options = includeProjectAppointments;
    } else {
      _request = {
        personId,
        includeProjectAppointments,
        startTime,
        endTime,
        count,
        taskIds
      };
      _options = webapi_options;
    }
    return this._getPersonAppointmentsByTasksAsync(_request, _options);
  }
  async _getPersonAppointmentsByTaskHeadingAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPersonAppointmentsByTaskHeading", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AppointmentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getPersonAppointmentsByTaskHeadingAsync(personId, includeProjectAppointments, startTime, endTime, count, taskHeadingId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = personId;
    if (typeof first === "object" && first && (typeof first.personId != "undefined" || typeof first.includeProjectAppointments != "undefined" || typeof first.startTime != "undefined" || typeof first.endTime != "undefined" || typeof first.count != "undefined" || typeof first.taskHeadingId != "undefined")) {
      _request = personId;
      _options = includeProjectAppointments;
    } else {
      _request = {
        personId,
        includeProjectAppointments,
        startTime,
        endTime,
        count,
        taskHeadingId
      };
      _options = webapi_options;
    }
    return this._getPersonAppointmentsByTaskHeadingAsync(_request, _options);
  }
  async _getProjectAppointmentsByTaskAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetProjectAppointmentsByTask", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AppointmentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getProjectAppointmentsByTaskAsync(projectId, startTime, endTime, count, taskId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = projectId;
    if (typeof first === "object" && first && (typeof first.projectId != "undefined" || typeof first.startTime != "undefined" || typeof first.endTime != "undefined" || typeof first.count != "undefined" || typeof first.taskId != "undefined")) {
      _request = projectId;
      _options = startTime;
    } else {
      _request = {
        projectId,
        startTime,
        endTime,
        count,
        taskId
      };
      _options = webapi_options;
    }
    return this._getProjectAppointmentsByTaskAsync(_request, _options);
  }
  async _getProjectAppointmentsByTasksAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetProjectAppointmentsByTasks", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AppointmentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getProjectAppointmentsByTasksAsync(projectId, startTime, endTime, count, taskIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = projectId;
    if (typeof first === "object" && first && (typeof first.projectId != "undefined" || typeof first.startTime != "undefined" || typeof first.endTime != "undefined" || typeof first.count != "undefined" || typeof first.taskIds != "undefined")) {
      _request = projectId;
      _options = startTime;
    } else {
      _request = {
        projectId,
        startTime,
        endTime,
        count,
        taskIds
      };
      _options = webapi_options;
    }
    return this._getProjectAppointmentsByTasksAsync(_request, _options);
  }
  async _getProjectAppointmentsByTaskHeadingAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetProjectAppointmentsByTaskHeading", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AppointmentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getProjectAppointmentsByTaskHeadingAsync(projectId, startTime, endTime, count, taskHeadingId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = projectId;
    if (typeof first === "object" && first && (typeof first.projectId != "undefined" || typeof first.startTime != "undefined" || typeof first.endTime != "undefined" || typeof first.count != "undefined" || typeof first.taskHeadingId != "undefined")) {
      _request = projectId;
      _options = startTime;
    } else {
      _request = {
        projectId,
        startTime,
        endTime,
        count,
        taskHeadingId
      };
      _options = webapi_options;
    }
    return this._getProjectAppointmentsByTaskHeadingAsync(_request, _options);
  }
  async _getProjectMemberAppointmentsByTaskAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetProjectMemberAppointmentsByTask", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AppointmentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getProjectMemberAppointmentsByTaskAsync(personId, startTime, endTime, count, taskId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = personId;
    if (typeof first === "object" && first && (typeof first.personId != "undefined" || typeof first.startTime != "undefined" || typeof first.endTime != "undefined" || typeof first.count != "undefined" || typeof first.taskId != "undefined")) {
      _request = personId;
      _options = startTime;
    } else {
      _request = {
        personId,
        startTime,
        endTime,
        count,
        taskId
      };
      _options = webapi_options;
    }
    return this._getProjectMemberAppointmentsByTaskAsync(_request, _options);
  }
  async _getProjectMemberAppointmentsByTasksAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetProjectMemberAppointmentsByTasks", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AppointmentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getProjectMemberAppointmentsByTasksAsync(personId, startTime, endTime, count, taskIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = personId;
    if (typeof first === "object" && first && (typeof first.personId != "undefined" || typeof first.startTime != "undefined" || typeof first.endTime != "undefined" || typeof first.count != "undefined" || typeof first.taskIds != "undefined")) {
      _request = personId;
      _options = startTime;
    } else {
      _request = {
        personId,
        startTime,
        endTime,
        count,
        taskIds
      };
      _options = webapi_options;
    }
    return this._getProjectMemberAppointmentsByTasksAsync(_request, _options);
  }
  async _getProjectMemberAppointmentsByTaskHeadingAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetProjectMemberAppointmentsByTaskHeading", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AppointmentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getProjectMemberAppointmentsByTaskHeadingAsync(personId, startTime, endTime, count, taskHeadingId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = personId;
    if (typeof first === "object" && first && (typeof first.personId != "undefined" || typeof first.startTime != "undefined" || typeof first.endTime != "undefined" || typeof first.count != "undefined" || typeof first.taskHeadingId != "undefined")) {
      _request = personId;
      _options = startTime;
    } else {
      _request = {
        personId,
        startTime,
        endTime,
        count,
        taskHeadingId
      };
      _options = webapi_options;
    }
    return this._getProjectMemberAppointmentsByTaskHeadingAsync(_request, _options);
  }
  async _getContactAppointmentsByTaskAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetContactAppointmentsByTask", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AppointmentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getContactAppointmentsByTaskAsync(contactId, startTime, endTime, count, taskId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = contactId;
    if (typeof first === "object" && first && (typeof first.contactId != "undefined" || typeof first.startTime != "undefined" || typeof first.endTime != "undefined" || typeof first.count != "undefined" || typeof first.taskId != "undefined")) {
      _request = contactId;
      _options = startTime;
    } else {
      _request = {
        contactId,
        startTime,
        endTime,
        count,
        taskId
      };
      _options = webapi_options;
    }
    return this._getContactAppointmentsByTaskAsync(_request, _options);
  }
  async _getContactAppointmentsByTasksAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetContactAppointmentsByTasks", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AppointmentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getContactAppointmentsByTasksAsync(contactId, startTime, endTime, count, taskIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = contactId;
    if (typeof first === "object" && first && (typeof first.contactId != "undefined" || typeof first.startTime != "undefined" || typeof first.endTime != "undefined" || typeof first.count != "undefined" || typeof first.taskIds != "undefined")) {
      _request = contactId;
      _options = startTime;
    } else {
      _request = {
        contactId,
        startTime,
        endTime,
        count,
        taskIds
      };
      _options = webapi_options;
    }
    return this._getContactAppointmentsByTasksAsync(_request, _options);
  }
  async _getContactAppointmentsByTaskHeadingAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetContactAppointmentsByTaskHeading", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AppointmentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getContactAppointmentsByTaskHeadingAsync(contactId, startTime, endTime, count, taskHeadingId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = contactId;
    if (typeof first === "object" && first && (typeof first.contactId != "undefined" || typeof first.startTime != "undefined" || typeof first.endTime != "undefined" || typeof first.count != "undefined" || typeof first.taskHeadingId != "undefined")) {
      _request = contactId;
      _options = startTime;
    } else {
      _request = {
        contactId,
        startTime,
        endTime,
        count,
        taskHeadingId
      };
      _options = webapi_options;
    }
    return this._getContactAppointmentsByTaskHeadingAsync(_request, _options);
  }
  async _getPublishedAppointmentAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPublishedAppointment", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Appointment_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getPublishedAppointmentAsync(appointmentId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = appointmentId;
    if (typeof first === "object" && first && typeof first.appointmentId != "undefined") {
      _request = appointmentId;
      _options = webapi_options;
    } else {
      _request = {
        appointmentId
      };
      _options = webapi_options;
    }
    return this._getPublishedAppointmentAsync(_request, _options);
  }
  async _getPublishedAppointmentsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPublishedAppointments", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AppointmentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getPublishedAppointmentsAsync(appointmentIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = appointmentIds;
    if (typeof first === "object" && first && typeof first.appointmentIds != "undefined") {
      _request = appointmentIds;
      _options = webapi_options;
    } else {
      _request = {
        appointmentIds
      };
      _options = webapi_options;
    }
    return this._getPublishedAppointmentsAsync(_request, _options);
  }
  async _getMyPublishedAppointmentsAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetMyPublishedAppointments", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AppointmentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Get published appointments from the logged in user.
   * @returns Appointments
   */
  async getMyPublishedAppointmentsAsync(webapi_options) {
    return this._getMyPublishedAppointmentsAsync(webapi_options);
  }
  async _getPublishedProjectAppointmentsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPublishedProjectAppointments", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AppointmentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getPublishedProjectAppointmentsAsync(projectId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = projectId;
    if (typeof first === "object" && first && typeof first.projectId != "undefined") {
      _request = projectId;
      _options = webapi_options;
    } else {
      _request = {
        projectId
      };
      _options = webapi_options;
    }
    return this._getPublishedProjectAppointmentsAsync(_request, _options);
  }
  async _getAppointmentsByTaskHeadingAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetAppointmentsByTaskHeading", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AppointmentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getAppointmentsByTaskHeadingAsync(taskHeadingId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = taskHeadingId;
    if (typeof first === "object" && first && typeof first.taskHeadingId != "undefined") {
      _request = taskHeadingId;
      _options = webapi_options;
    } else {
      _request = {
        taskHeadingId
      };
      _options = webapi_options;
    }
    return this._getAppointmentsByTaskHeadingAsync(_request, _options);
  }
  async _getAssociateDiaryAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetAssociateDiary", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AppointmentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getAssociateDiaryAsync(associateId, startTime, endTime, count, webapi_options) {
    let _request = null;
    let _options = null;
    const first = associateId;
    if (typeof first === "object" && first && (typeof first.associateId != "undefined" || typeof first.startTime != "undefined" || typeof first.endTime != "undefined" || typeof first.count != "undefined")) {
      _request = associateId;
      _options = startTime;
    } else {
      _request = {
        associateId,
        startTime,
        endTime,
        count
      };
      _options = webapi_options;
    }
    return this._getAssociateDiaryAsync(_request, _options);
  }
  async _getDiaryByGroupAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetDiaryByGroup", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AppointmentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getDiaryByGroupAsync(groupId, groupType, startTime, endTime, count, webapi_options) {
    let _request = null;
    let _options = null;
    const first = groupId;
    if (typeof first === "object" && first && (typeof first.groupId != "undefined" || typeof first.groupType != "undefined" || typeof first.startTime != "undefined" || typeof first.endTime != "undefined" || typeof first.count != "undefined")) {
      _request = groupId;
      _options = groupType;
    } else {
      _request = {
        groupId,
        groupType,
        startTime,
        endTime,
        count
      };
      _options = webapi_options;
    }
    return this._getDiaryByGroupAsync(_request, _options);
  }
  async _updateAppointmentAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("UpdateAppointment", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Appointment_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async updateAppointmentAsync(id, startTime, endTime, status, type, associateId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = id;
    if (typeof first === "object" && first && (typeof first.id != "undefined" || typeof first.startTime != "undefined" || typeof first.endTime != "undefined" || typeof first.status != "undefined" || typeof first.type != "undefined" || typeof first.associateId != "undefined")) {
      _request = id;
      _options = startTime;
    } else {
      _request = {
        id,
        startTime,
        endTime,
        status,
        type,
        associateId
      };
      _options = webapi_options;
    }
    return this._updateAppointmentAsync(_request, _options);
  }
  async _getAssociatesDiaryAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetAssociatesDiary", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AppointmentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getAssociatesDiaryAsync(associateIds, startTime, endTime, webapi_options) {
    let _request = null;
    let _options = null;
    const first = associateIds;
    if (typeof first === "object" && first && (typeof first.associateIds != "undefined" || typeof first.startTime != "undefined" || typeof first.endTime != "undefined")) {
      _request = associateIds;
      _options = startTime;
    } else {
      _request = {
        associateIds,
        startTime,
        endTime
      };
      _options = webapi_options;
    }
    return this._getAssociatesDiaryAsync(_request, _options);
  }
  async _getAppointmentRecordsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetAppointmentRecords", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AppointmentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getAppointmentRecordsAsync(motherId, recurrenceRuleId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = motherId;
    if (typeof first === "object" && first && (typeof first.motherId != "undefined" || typeof first.recurrenceRuleId != "undefined")) {
      _request = motherId;
      _options = recurrenceRuleId;
    } else {
      _request = {
        motherId,
        recurrenceRuleId
      };
      _options = webapi_options;
    }
    return this._getAppointmentRecordsAsync(_request, _options);
  }
  async _getMySyncAppointmentsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetMySyncAppointments", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AppointmentSyncDataArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getMySyncAppointmentsAsync(startTime, endTime, webapi_options) {
    let _request = null;
    let _options = null;
    const first = startTime;
    if (typeof first === "object" && first && (typeof first.startTime != "undefined" || typeof first.endTime != "undefined")) {
      _request = startTime;
      _options = endTime;
    } else {
      _request = {
        startTime,
        endTime
      };
      _options = webapi_options;
    }
    return this._getMySyncAppointmentsAsync(_request, _options);
  }
  async _getDayInformationListByDatesAndAssociateAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetDayInformationListByDatesAndAssociate", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DayInformationListItemArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getDayInformationListByDatesAndAssociateAsync(startDate, endDate, associateId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = startDate;
    if (typeof first === "object" && first && (typeof first.startDate != "undefined" || typeof first.endDate != "undefined" || typeof first.associateId != "undefined")) {
      _request = startDate;
      _options = endDate;
    } else {
      _request = {
        startDate,
        endDate,
        associateId
      };
      _options = webapi_options;
    }
    return this._getDayInformationListByDatesAndAssociateAsync(_request, _options);
  }
  async _getActivityInformationListByDatesAndAssociateAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetActivityInformationListByDatesAndAssociate", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ActivityInformationListItemArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getActivityInformationListByDatesAndAssociateAsync(startDate, endDate, associateId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = startDate;
    if (typeof first === "object" && first && (typeof first.startDate != "undefined" || typeof first.endDate != "undefined" || typeof first.associateId != "undefined")) {
      _request = startDate;
      _options = endDate;
    } else {
      _request = {
        startDate,
        endDate,
        associateId
      };
      _options = webapi_options;
    }
    return this._getActivityInformationListByDatesAndAssociateAsync(_request, _options);
  }
  async _getRedLetterInformationListByDatesAndAssociateAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetRedLetterInformationListByDatesAndAssociate", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_RedLetterInformationListItemArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getRedLetterInformationListByDatesAndAssociateAsync(startDate, endDate, associateId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = startDate;
    if (typeof first === "object" && first && (typeof first.startDate != "undefined" || typeof first.endDate != "undefined" || typeof first.associateId != "undefined")) {
      _request = startDate;
      _options = endDate;
    } else {
      _request = {
        startDate,
        endDate,
        associateId
      };
      _options = webapi_options;
    }
    return this._getRedLetterInformationListByDatesAndAssociateAsync(_request, _options);
  }
  async _getAlarmsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetAlarms", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_MultiAlarmData_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getAlarmsAsync(includeInvitations, includeAllAppointments, defaultAlarmLeadTimeInMinutes, webapi_options) {
    let _request = null;
    let _options = null;
    const first = includeInvitations;
    if (typeof first === "object" && first && (typeof first.includeInvitations != "undefined" || typeof first.includeAllAppointments != "undefined" || typeof first.defaultAlarmLeadTimeInMinutes != "undefined")) {
      _request = includeInvitations;
      _options = includeAllAppointments;
    } else {
      _request = {
        includeInvitations,
        includeAllAppointments,
        defaultAlarmLeadTimeInMinutes
      };
      _options = webapi_options;
    }
    return this._getAlarmsAsync(_request, _options);
  }
  async _generateLeadAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GenerateLead", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SalesActivity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async generateLeadAsync(associateIdForNewContact, leadDescription, relation, relationId, leadContact, leadPersonFirstname, leadPersonLastname, leadPersonEmail, leadPhoneNumber, creatorsContact, creatorsFirstname, creatorsLastname, webapi_options) {
    let _request = null;
    let _options = null;
    const first = associateIdForNewContact;
    if (typeof first === "object" && first && (typeof first.associateIdForNewContact != "undefined" || typeof first.leadDescription != "undefined" || typeof first.relation != "undefined" || typeof first.relationId != "undefined" || typeof first.leadContact != "undefined" || typeof first.leadPersonFirstname != "undefined" || typeof first.leadPersonLastname != "undefined" || typeof first.leadPersonEmail != "undefined" || typeof first.leadPhoneNumber != "undefined" || typeof first.creatorsContact != "undefined" || typeof first.creatorsFirstname != "undefined" || typeof first.creatorsLastname != "undefined")) {
      _request = associateIdForNewContact;
      _options = leadDescription;
    } else {
      _request = {
        associateIdForNewContact,
        leadDescription,
        relation,
        relationId,
        leadContact,
        leadPersonFirstname,
        leadPersonLastname,
        leadPersonEmail,
        leadPhoneNumber,
        creatorsContact,
        creatorsFirstname,
        creatorsLastname
      };
      _options = webapi_options;
    }
    return this._generateLeadAsync(_request, _options);
  }
  async _requestForInfoAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("RequestForInfo", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SalesActivity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async requestForInfoAsync(associateIdForNewContact, channel, regarding, contactName, personFirstname, personLastname, emailAddress, phoneNumber, webapi_options) {
    let _request = null;
    let _options = null;
    const first = associateIdForNewContact;
    if (typeof first === "object" && first && (typeof first.associateIdForNewContact != "undefined" || typeof first.channel != "undefined" || typeof first.regarding != "undefined" || typeof first.contactName != "undefined" || typeof first.personFirstname != "undefined" || typeof first.personLastname != "undefined" || typeof first.emailAddress != "undefined" || typeof first.phoneNumber != "undefined")) {
      _request = associateIdForNewContact;
      _options = channel;
    } else {
      _request = {
        associateIdForNewContact,
        channel,
        regarding,
        contactName,
        personFirstname,
        personLastname,
        emailAddress,
        phoneNumber
      };
      _options = webapi_options;
    }
    return this._requestForInfoAsync(_request, _options);
  }
  /*
   * Gets a SuggestedAppointment object.
   * @param suggestedAppointmentId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single SuggestedAppointment
   */
  async getSuggestedAppointmentAsync(suggestedAppointmentId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetSuggestedAppointment?suggestedAppointmentId=" + suggestedAppointmentId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SuggestedAppointment_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets a SuggestedAppointmentEntity object.
   * @param suggestedAppointmentEntityId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single SuggestedAppointmentEntity
   */
  async getSuggestedAppointmentEntityAsync(suggestedAppointmentEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetSuggestedAppointmentEntity?suggestedAppointmentEntityId=" + suggestedAppointmentEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SuggestedAppointmentEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets a TaskListItem object.
   * @param taskListItemId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single TaskListItem
   */
  async getTaskListItemAsync(taskListItemId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetTaskListItem?taskListItemId=" + taskListItemId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TaskListItem_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getTaskListItemsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetTaskListItems", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TaskListItemArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getTaskListItemsAsync(includeDeleted, webapi_options) {
    let _request = null;
    let _options = null;
    const first = includeDeleted;
    if (typeof first === "object" && first && typeof first.includeDeleted != "undefined") {
      _request = includeDeleted;
      _options = webapi_options;
    } else {
      _request = {
        includeDeleted
      };
      _options = webapi_options;
    }
    return this._getTaskListItemsAsync(_request, _options);
  }
};

// server/node_modules/@superoffice/webapi/dist/esm/ForeignSystemAgent.js
var ForeignSystemAgent = class extends WebApiBase {
  constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
    const options = WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
    options.basePath = "v1/Agents/ForeignSystem/";
    super(options);
  }
  /**
   * Set default values into a new ForeignAppEntity.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultForeignAppEntityAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultForeignAppEntity", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ForeignAppEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing ForeignAppEntity or creates a new ForeignAppEntity if the id parameter is empty
   * @param entity - The ForeignAppEntity to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated ForeignAppEntity
   */
  async saveForeignAppEntityAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveForeignAppEntity", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ForeignAppEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Deletes the ForeignAppEntity
   * @param ForeignAppEntityId - The id of the ForeignAppEntity to be deleted.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   */
  async deleteForeignAppEntityAsync(ForeignAppEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("DeleteForeignAppEntity?ForeignAppEntityId=" + ForeignAppEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets a ForeignAppEntity object.
   * @param foreignAppEntityId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single ForeignAppEntity
   */
  async getForeignAppEntityAsync(foreignAppEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetForeignAppEntity?foreignAppEntityId=" + foreignAppEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ForeignAppEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getAppByNameAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetAppByName", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ForeignAppEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getAppByNameAsync(applicationName, webapi_options) {
    let _request = null;
    let _options = null;
    const first = applicationName;
    if (typeof first === "object" && first && typeof first.applicationName != "undefined") {
      _request = applicationName;
      _options = webapi_options;
    } else {
      _request = {
        applicationName
      };
      _options = webapi_options;
    }
    return this._getAppByNameAsync(_request, _options);
  }
  async _getApplicationDevicesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetApplicationDevices", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ForeignDeviceArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getApplicationDevicesAsync(applicationName, webapi_options) {
    let _request = null;
    let _options = null;
    const first = applicationName;
    if (typeof first === "object" && first && typeof first.applicationName != "undefined") {
      _request = applicationName;
      _options = webapi_options;
    } else {
      _request = {
        applicationName
      };
      _options = webapi_options;
    }
    return this._getApplicationDevicesAsync(_request, _options);
  }
  async _getDeviceByNameAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetDeviceByName", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ForeignDevice_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getDeviceByNameAsync(applicationName, deviceName, webapi_options) {
    let _request = null;
    let _options = null;
    const first = applicationName;
    if (typeof first === "object" && first && (typeof first.applicationName != "undefined" || typeof first.deviceName != "undefined")) {
      _request = applicationName;
      _options = deviceName;
    } else {
      _request = {
        applicationName,
        deviceName
      };
      _options = webapi_options;
    }
    return this._getDeviceByNameAsync(_request, _options);
  }
  async _getDeviceByIdentifierAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetDeviceByIdentifier", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ForeignDevice_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getDeviceByIdentifierAsync(applicationName, deviceName, deviceIdentifier, webapi_options) {
    let _request = null;
    let _options = null;
    const first = applicationName;
    if (typeof first === "object" && first && (typeof first.applicationName != "undefined" || typeof first.deviceName != "undefined" || typeof first.deviceIdentifier != "undefined")) {
      _request = applicationName;
      _options = deviceName;
    } else {
      _request = {
        applicationName,
        deviceName,
        deviceIdentifier
      };
      _options = webapi_options;
    }
    return this._getDeviceByIdentifierAsync(_request, _options);
  }
  async _addDeviceByIdentifierAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("AddDeviceByIdentifier", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ForeignDevice_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async addDeviceByIdentifierAsync(applicationName, deviceName, deviceIdentifier, webapi_options) {
    let _request = null;
    let _options = null;
    const first = applicationName;
    if (typeof first === "object" && first && (typeof first.applicationName != "undefined" || typeof first.deviceName != "undefined" || typeof first.deviceIdentifier != "undefined")) {
      _request = applicationName;
      _options = deviceName;
    } else {
      _request = {
        applicationName,
        deviceName,
        deviceIdentifier
      };
      _options = webapi_options;
    }
    return this._addDeviceByIdentifierAsync(_request, _options);
  }
  async _saveDeviceByIdentifierAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveDeviceByIdentifier", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ForeignDevice_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveDeviceByIdentifierAsync(applicationName, deviceName, deviceIdentifier, foreignDevice, webapi_options) {
    let _request = null;
    let _options = null;
    const first = applicationName;
    if (typeof first === "object" && first && (typeof first.applicationName != "undefined" || typeof first.deviceName != "undefined" || typeof first.deviceIdentifier != "undefined" || typeof first.foreignDevice != "undefined")) {
      _request = applicationName;
      _options = deviceName;
    } else {
      _request = {
        applicationName,
        deviceName,
        deviceIdentifier,
        foreignDevice
      };
      _options = webapi_options;
    }
    return this._saveDeviceByIdentifierAsync(_request, _options);
  }
  async _deleteDeviceByIdentifierAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeleteDeviceByIdentifier", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async deleteDeviceByIdentifierAsync(applicationName, deviceName, deviceIdentifier, webapi_options) {
    let _request = null;
    let _options = null;
    const first = applicationName;
    if (typeof first === "object" && first && (typeof first.applicationName != "undefined" || typeof first.deviceName != "undefined" || typeof first.deviceIdentifier != "undefined")) {
      _request = applicationName;
      _options = deviceName;
    } else {
      _request = {
        applicationName,
        deviceName,
        deviceIdentifier
      };
      _options = webapi_options;
    }
    return this._deleteDeviceByIdentifierAsync(_request, _options);
  }
  async _getKeyAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetKey", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ForeignKey_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getKeyAsync(applicationName, deviceName, keyName, tableName, recordId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = applicationName;
    if (typeof first === "object" && first && (typeof first.applicationName != "undefined" || typeof first.deviceName != "undefined" || typeof first.keyName != "undefined" || typeof first.tableName != "undefined" || typeof first.recordId != "undefined")) {
      _request = applicationName;
      _options = deviceName;
    } else {
      _request = {
        applicationName,
        deviceName,
        keyName,
        tableName,
        recordId
      };
      _options = webapi_options;
    }
    return this._getKeyAsync(_request, _options);
  }
  async _getKeyValueAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetKeyValue", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getKeyValueAsync(applicationName, deviceName, keyName, tableName, recordId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = applicationName;
    if (typeof first === "object" && first && (typeof first.applicationName != "undefined" || typeof first.deviceName != "undefined" || typeof first.keyName != "undefined" || typeof first.tableName != "undefined" || typeof first.recordId != "undefined")) {
      _request = applicationName;
      _options = deviceName;
    } else {
      _request = {
        applicationName,
        deviceName,
        keyName,
        tableName,
        recordId
      };
      _options = webapi_options;
    }
    return this._getKeyValueAsync(_request, _options);
  }
  async _getKeyOnDeviceIdentifierAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetKeyOnDeviceIdentifier", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ForeignKey_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getKeyOnDeviceIdentifierAsync(applicationName, deviceName, deviceIdentifier, keyName, tableName, recordId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = applicationName;
    if (typeof first === "object" && first && (typeof first.applicationName != "undefined" || typeof first.deviceName != "undefined" || typeof first.deviceIdentifier != "undefined" || typeof first.keyName != "undefined" || typeof first.tableName != "undefined" || typeof first.recordId != "undefined")) {
      _request = applicationName;
      _options = deviceName;
    } else {
      _request = {
        applicationName,
        deviceName,
        deviceIdentifier,
        keyName,
        tableName,
        recordId
      };
      _options = webapi_options;
    }
    return this._getKeyOnDeviceIdentifierAsync(_request, _options);
  }
  async _getKeyValueOnDeviceIdentifierAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetKeyValueOnDeviceIdentifier", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getKeyValueOnDeviceIdentifierAsync(applicationName, deviceName, deviceIdentifier, keyName, tableName, recordId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = applicationName;
    if (typeof first === "object" && first && (typeof first.applicationName != "undefined" || typeof first.deviceName != "undefined" || typeof first.deviceIdentifier != "undefined" || typeof first.keyName != "undefined" || typeof first.tableName != "undefined" || typeof first.recordId != "undefined")) {
      _request = applicationName;
      _options = deviceName;
    } else {
      _request = {
        applicationName,
        deviceName,
        deviceIdentifier,
        keyName,
        tableName,
        recordId
      };
      _options = webapi_options;
    }
    return this._getKeyValueOnDeviceIdentifierAsync(_request, _options);
  }
  async _addForeignKeyAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("AddForeignKey", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ForeignKey_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async addForeignKeyAsync(foreignKey, applicationName, deviceName, deviceIdentifier, webapi_options) {
    let _request = null;
    let _options = null;
    const first = foreignKey;
    if (typeof first === "object" && first && (typeof first.foreignKey != "undefined" || typeof first.applicationName != "undefined" || typeof first.deviceName != "undefined" || typeof first.deviceIdentifier != "undefined")) {
      _request = foreignKey;
      _options = applicationName;
    } else {
      _request = {
        foreignKey,
        applicationName,
        deviceName,
        deviceIdentifier
      };
      _options = webapi_options;
    }
    return this._addForeignKeyAsync(_request, _options);
  }
  async _saveForeignKeyAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveForeignKey", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ForeignKey_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveForeignKeyAsync(foreignKey, applicationName, deviceName, deviceIdentifier, webapi_options) {
    let _request = null;
    let _options = null;
    const first = foreignKey;
    if (typeof first === "object" && first && (typeof first.foreignKey != "undefined" || typeof first.applicationName != "undefined" || typeof first.deviceName != "undefined" || typeof first.deviceIdentifier != "undefined")) {
      _request = foreignKey;
      _options = applicationName;
    } else {
      _request = {
        foreignKey,
        applicationName,
        deviceName,
        deviceIdentifier
      };
      _options = webapi_options;
    }
    return this._saveForeignKeyAsync(_request, _options);
  }
  async _deleteForeignKeyOnNameAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeleteForeignKeyOnName", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async deleteForeignKeyOnNameAsync(applicationName, deviceName, deviceIdentifier, keyName, tableName, recordId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = applicationName;
    if (typeof first === "object" && first && (typeof first.applicationName != "undefined" || typeof first.deviceName != "undefined" || typeof first.deviceIdentifier != "undefined" || typeof first.keyName != "undefined" || typeof first.tableName != "undefined" || typeof first.recordId != "undefined")) {
      _request = applicationName;
      _options = deviceName;
    } else {
      _request = {
        applicationName,
        deviceName,
        deviceIdentifier,
        keyName,
        tableName,
        recordId
      };
      _options = webapi_options;
    }
    return this._deleteForeignKeyOnNameAsync(_request, _options);
  }
  async _getKeyByValueAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetKeyByValue", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ForeignKey_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getKeyByValueAsync(applicationName, deviceName, keyName, keyValue, tableName, webapi_options) {
    let _request = null;
    let _options = null;
    const first = applicationName;
    if (typeof first === "object" && first && (typeof first.applicationName != "undefined" || typeof first.deviceName != "undefined" || typeof first.keyName != "undefined" || typeof first.keyValue != "undefined" || typeof first.tableName != "undefined")) {
      _request = applicationName;
      _options = deviceName;
    } else {
      _request = {
        applicationName,
        deviceName,
        keyName,
        keyValue,
        tableName
      };
      _options = webapi_options;
    }
    return this._getKeyByValueAsync(_request, _options);
  }
  async _getKeyByValueAndIdentifierAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetKeyByValueAndIdentifier", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ForeignKey_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getKeyByValueAndIdentifierAsync(applicationName, deviceName, deviceIdentifier, keyName, keyValue, tableName, webapi_options) {
    let _request = null;
    let _options = null;
    const first = applicationName;
    if (typeof first === "object" && first && (typeof first.applicationName != "undefined" || typeof first.deviceName != "undefined" || typeof first.deviceIdentifier != "undefined" || typeof first.keyName != "undefined" || typeof first.keyValue != "undefined" || typeof first.tableName != "undefined")) {
      _request = applicationName;
      _options = deviceName;
    } else {
      _request = {
        applicationName,
        deviceName,
        deviceIdentifier,
        keyName,
        keyValue,
        tableName
      };
      _options = webapi_options;
    }
    return this._getKeyByValueAndIdentifierAsync(_request, _options);
  }
  async _getAllForeignKeysOnEntityAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetAllForeignKeysOnEntity", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_StringDictionary_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getAllForeignKeysOnEntityAsync(entityType, entityId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = entityType;
    if (typeof first === "object" && first && (typeof first.entityType != "undefined" || typeof first.entityId != "undefined")) {
      _request = entityType;
      _options = entityId;
    } else {
      _request = {
        entityType,
        entityId
      };
      _options = webapi_options;
    }
    return this._getAllForeignKeysOnEntityAsync(_request, _options);
  }
  /*
   * Gets a ForeignDevice object.
   * @param foreignDeviceId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single ForeignDevice
   */
  async getForeignDeviceAsync(foreignDeviceId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetForeignDevice?foreignDeviceId=" + foreignDeviceId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ForeignDevice_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _saveForeignDeviceAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveForeignDevice", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ForeignDevice_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveForeignDeviceAsync(foreignDevice, applicationName, webapi_options) {
    let _request = null;
    let _options = null;
    const first = foreignDevice;
    if (typeof first === "object" && first && (typeof first.foreignDevice != "undefined" || typeof first.applicationName != "undefined")) {
      _request = foreignDevice;
      _options = applicationName;
    } else {
      _request = {
        foreignDevice,
        applicationName
      };
      _options = webapi_options;
    }
    return this._saveForeignDeviceAsync(_request, _options);
  }
  async _deleteForeignDeviceAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeleteForeignDevice", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async deleteForeignDeviceAsync(foreignDevice, applicationName, webapi_options) {
    let _request = null;
    let _options = null;
    const first = foreignDevice;
    if (typeof first === "object" && first && (typeof first.foreignDevice != "undefined" || typeof first.applicationName != "undefined")) {
      _request = foreignDevice;
      _options = applicationName;
    } else {
      _request = {
        foreignDevice,
        applicationName
      };
      _options = webapi_options;
    }
    return this._deleteForeignDeviceAsync(_request, _options);
  }
  async _deleteForeignKeyAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeleteForeignKey", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async deleteForeignKeyAsync(foreignKey, applicationName, deviceName, deviceIdentifier, tableName, recordId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = foreignKey;
    if (typeof first === "object" && first && (typeof first.foreignKey != "undefined" || typeof first.applicationName != "undefined" || typeof first.deviceName != "undefined" || typeof first.deviceIdentifier != "undefined" || typeof first.tableName != "undefined" || typeof first.recordId != "undefined")) {
      _request = foreignKey;
      _options = applicationName;
    } else {
      _request = {
        foreignKey,
        applicationName,
        deviceName,
        deviceIdentifier,
        tableName,
        recordId
      };
      _options = webapi_options;
    }
    return this._deleteForeignKeyAsync(_request, _options);
  }
  async _getDeviceKeysAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetDeviceKeys", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ForeignKeyArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getDeviceKeysAsync(applicationName, deviceName, webapi_options) {
    let _request = null;
    let _options = null;
    const first = applicationName;
    if (typeof first === "object" && first && (typeof first.applicationName != "undefined" || typeof first.deviceName != "undefined")) {
      _request = applicationName;
      _options = deviceName;
    } else {
      _request = {
        applicationName,
        deviceName
      };
      _options = webapi_options;
    }
    return this._getDeviceKeysAsync(_request, _options);
  }
  async _getApplicationKeysAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetApplicationKeys", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ForeignKeyArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getApplicationKeysAsync(applicationName, webapi_options) {
    let _request = null;
    let _options = null;
    const first = applicationName;
    if (typeof first === "object" && first && typeof first.applicationName != "undefined") {
      _request = applicationName;
      _options = webapi_options;
    } else {
      _request = {
        applicationName
      };
      _options = webapi_options;
    }
    return this._getApplicationKeysAsync(_request, _options);
  }
  async _getDeviceKeysOnDeviceIdentifierAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetDeviceKeysOnDeviceIdentifier", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ForeignKeyArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getDeviceKeysOnDeviceIdentifierAsync(applicationName, deviceName, deviceIdentifier, webapi_options) {
    let _request = null;
    let _options = null;
    const first = applicationName;
    if (typeof first === "object" && first && (typeof first.applicationName != "undefined" || typeof first.deviceName != "undefined" || typeof first.deviceIdentifier != "undefined")) {
      _request = applicationName;
      _options = deviceName;
    } else {
      _request = {
        applicationName,
        deviceName,
        deviceIdentifier
      };
      _options = webapi_options;
    }
    return this._getDeviceKeysOnDeviceIdentifierAsync(_request, _options);
  }
  async _getDeviceKeysOnDeviceIdentifierTableAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetDeviceKeysOnDeviceIdentifierTable", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ForeignKeyArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getDeviceKeysOnDeviceIdentifierTableAsync(applicationName, deviceName, deviceIdentifier, tableName, webapi_options) {
    let _request = null;
    let _options = null;
    const first = applicationName;
    if (typeof first === "object" && first && (typeof first.applicationName != "undefined" || typeof first.deviceName != "undefined" || typeof first.deviceIdentifier != "undefined" || typeof first.tableName != "undefined")) {
      _request = applicationName;
      _options = deviceName;
    } else {
      _request = {
        applicationName,
        deviceName,
        deviceIdentifier,
        tableName
      };
      _options = webapi_options;
    }
    return this._getDeviceKeysOnDeviceIdentifierTableAsync(_request, _options);
  }
  async _getDeviceKeysOnDeviceIdentifierTableRecordIdAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetDeviceKeysOnDeviceIdentifierTableRecordId", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ForeignKeyArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getDeviceKeysOnDeviceIdentifierTableRecordIdAsync(applicationName, deviceName, deviceIdentifier, tableName, recordId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = applicationName;
    if (typeof first === "object" && first && (typeof first.applicationName != "undefined" || typeof first.deviceName != "undefined" || typeof first.deviceIdentifier != "undefined" || typeof first.tableName != "undefined" || typeof first.recordId != "undefined")) {
      _request = applicationName;
      _options = deviceName;
    } else {
      _request = {
        applicationName,
        deviceName,
        deviceIdentifier,
        tableName,
        recordId
      };
      _options = webapi_options;
    }
    return this._getDeviceKeysOnDeviceIdentifierTableRecordIdAsync(_request, _options);
  }
};

// server/node_modules/@superoffice/webapi/dist/esm/DocumentAgent.js
var DocumentAgent = class extends WebApiBase {
  constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
    const options = WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
    options.basePath = "v1/Agents/Document/";
    super(options);
  }
  /**
   * Set default values into a new DocumentEntity.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultDocumentEntityAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultDocumentEntity", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DocumentEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing DocumentEntity or creates a new DocumentEntity if the id parameter is empty
   * @param entity - The DocumentEntity to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated DocumentEntity
   */
  async saveDocumentEntityAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveDocumentEntity", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DocumentEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Deletes the DocumentEntity
   * @param DocumentEntityId - The id of the DocumentEntity to be deleted.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   */
  async deleteDocumentEntityAsync(DocumentEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("DeleteDocumentEntity?DocumentEntityId=" + DocumentEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new DocumentPreview.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultDocumentPreviewAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultDocumentPreview", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DocumentPreview_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new SuggestedDocumentEntity.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultSuggestedDocumentEntityAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultSuggestedDocumentEntity", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SuggestedDocumentEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing SuggestedDocumentEntity or creates a new SuggestedDocumentEntity if the id parameter is empty
   * @param entity - The SuggestedDocumentEntity to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated SuggestedDocumentEntity
   */
  async saveSuggestedDocumentEntityAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveSuggestedDocumentEntity", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SuggestedDocumentEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new TemplateVariablesParameters.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultTemplateVariablesParametersAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultTemplateVariablesParameters", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TemplateVariablesParameters_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets a Document object.
   * @param documentId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single Document
   */
  async getDocumentAsync(documentId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetDocument?documentId=" + documentId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Document_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets a DocumentEntity object.
   * @param documentEntityId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single DocumentEntity
   */
  async getDocumentEntityAsync(documentEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetDocumentEntity?documentEntityId=" + documentEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DocumentEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getDocumentStreamFromEntityAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        if (!options || options.returnBlobAs == ReturnBlobType.AsArrayBuffer) {
          config.responseType = "arraybuffer";
          config.headers = config.headers || {};
          config.headers["Accept"] = "application/octet-stream";
        }
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetDocumentStreamFromEntity", request, config);
        WebApiBase.SetCompleted(options);
        let res = null;
        if (options && options.returnBlobAs != ReturnBlobType.AsArrayBuffer) {
          res = response.data;
          if (options.returnBlobAs == ReturnBlobType.AsString) {
            res = FromBase64ToString(res);
          }
        } else {
          res = response.data;
        }
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getDocumentStreamFromEntityAsync(documentEntity, webapi_options) {
    let _request = null;
    let _options = null;
    const first = documentEntity;
    if (typeof first === "object" && first && typeof first.documentEntity != "undefined") {
      _request = documentEntity;
      _options = webapi_options;
    } else {
      _request = {
        documentEntity
      };
      _options = webapi_options;
    }
    return this._getDocumentStreamFromEntityAsync(_request, _options);
  }
  async _setDocumentStreamAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetDocumentStream", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DocumentEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setDocumentStreamAsync(documentEntity, stream, overwriteExistingData, webapi_options) {
    let _request = null;
    let _options = null;
    const first = documentEntity;
    if (typeof first === "object" && first && (typeof first.documentEntity != "undefined" || typeof first.stream != "undefined" || typeof first.overwriteExistingData != "undefined")) {
      _request = documentEntity;
      _options = stream;
    } else {
      _request = {
        documentEntity,
        stream,
        overwriteExistingData
      };
      _options = webapi_options;
    }
    _request.stream = ToBase64(_request.stream);
    return this._setDocumentStreamAsync(_request, _options);
  }
  async _createDocumentStreamAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        if (!options || options.returnBlobAs == ReturnBlobType.AsArrayBuffer) {
          config.responseType = "arraybuffer";
          config.headers = config.headers || {};
          config.headers["Accept"] = "application/octet-stream";
        }
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateDocumentStream", request, config);
        WebApiBase.SetCompleted(options);
        let res = null;
        if (options && options.returnBlobAs != ReturnBlobType.AsArrayBuffer) {
          res = response.data;
          if (options.returnBlobAs == ReturnBlobType.AsString) {
            res = FromBase64ToString(res);
          }
        } else {
          res = response.data;
        }
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createDocumentStreamAsync(documentEntity, overwriteExistingData, webapi_options) {
    let _request = null;
    let _options = null;
    const first = documentEntity;
    if (typeof first === "object" && first && (typeof first.documentEntity != "undefined" || typeof first.overwriteExistingData != "undefined")) {
      _request = documentEntity;
      _options = overwriteExistingData;
    } else {
      _request = {
        documentEntity,
        overwriteExistingData
      };
      _options = webapi_options;
    }
    return this._createDocumentStreamAsync(_request, _options);
  }
  async _getTemplateStreamAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        if (!options || options.returnBlobAs == ReturnBlobType.AsArrayBuffer) {
          config.responseType = "arraybuffer";
          config.headers = config.headers || {};
          config.headers["Accept"] = "application/octet-stream";
        }
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetTemplateStream", request, config);
        WebApiBase.SetCompleted(options);
        let res = null;
        if (options && options.returnBlobAs != ReturnBlobType.AsArrayBuffer) {
          res = response.data;
          if (options.returnBlobAs == ReturnBlobType.AsString) {
            res = FromBase64ToString(res);
          }
        } else {
          res = response.data;
        }
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getTemplateStreamAsync(templateName, allowPersonal, uiCulture, webapi_options) {
    let _request = null;
    let _options = null;
    const first = templateName;
    if (typeof first === "object" && first && (typeof first.templateName != "undefined" || typeof first.allowPersonal != "undefined" || typeof first.uiCulture != "undefined")) {
      _request = templateName;
      _options = allowPersonal;
    } else {
      _request = {
        templateName,
        allowPersonal,
        uiCulture
      };
      _options = webapi_options;
    }
    return this._getTemplateStreamAsync(_request, _options);
  }
  async _getSanitizedTemplateStreamAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        if (!options || options.returnBlobAs == ReturnBlobType.AsArrayBuffer) {
          config.responseType = "arraybuffer";
          config.headers = config.headers || {};
          config.headers["Accept"] = "application/octet-stream";
        }
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetSanitizedTemplateStream", request, config);
        WebApiBase.SetCompleted(options);
        let res = null;
        if (options && options.returnBlobAs != ReturnBlobType.AsArrayBuffer) {
          res = response.data;
          if (options.returnBlobAs == ReturnBlobType.AsString) {
            res = FromBase64ToString(res);
          }
        } else {
          res = response.data;
        }
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getSanitizedTemplateStreamAsync(templateName, allowPersonal, uiCulture, webapi_options) {
    let _request = null;
    let _options = null;
    const first = templateName;
    if (typeof first === "object" && first && (typeof first.templateName != "undefined" || typeof first.allowPersonal != "undefined" || typeof first.uiCulture != "undefined")) {
      _request = templateName;
      _options = allowPersonal;
    } else {
      _request = {
        templateName,
        allowPersonal,
        uiCulture
      };
      _options = webapi_options;
    }
    return this._getSanitizedTemplateStreamAsync(_request, _options);
  }
  async _getTemplateStreamFromIdAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        if (!options || options.returnBlobAs == ReturnBlobType.AsArrayBuffer) {
          config.responseType = "arraybuffer";
          config.headers = config.headers || {};
          config.headers["Accept"] = "application/octet-stream";
        }
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetTemplateStreamFromId", request, config);
        WebApiBase.SetCompleted(options);
        let res = null;
        if (options && options.returnBlobAs != ReturnBlobType.AsArrayBuffer) {
          res = response.data;
          if (options.returnBlobAs == ReturnBlobType.AsString) {
            res = FromBase64ToString(res);
          }
        } else {
          res = response.data;
        }
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getTemplateStreamFromIdAsync(templateId, uiCulture, webapi_options) {
    let _request = null;
    let _options = null;
    const first = templateId;
    if (typeof first === "object" && first && (typeof first.templateId != "undefined" || typeof first.uiCulture != "undefined")) {
      _request = templateId;
      _options = uiCulture;
    } else {
      _request = {
        templateId,
        uiCulture
      };
      _options = webapi_options;
    }
    return this._getTemplateStreamFromIdAsync(_request, _options);
  }
  async _getSanitizedTemplateStreamFromIdAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        if (!options || options.returnBlobAs == ReturnBlobType.AsArrayBuffer) {
          config.responseType = "arraybuffer";
          config.headers = config.headers || {};
          config.headers["Accept"] = "application/octet-stream";
        }
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetSanitizedTemplateStreamFromId", request, config);
        WebApiBase.SetCompleted(options);
        let res = null;
        if (options && options.returnBlobAs != ReturnBlobType.AsArrayBuffer) {
          res = response.data;
          if (options.returnBlobAs == ReturnBlobType.AsString) {
            res = FromBase64ToString(res);
          }
        } else {
          res = response.data;
        }
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getSanitizedTemplateStreamFromIdAsync(templateId, uiCulture, webapi_options) {
    let _request = null;
    let _options = null;
    const first = templateId;
    if (typeof first === "object" && first && (typeof first.templateId != "undefined" || typeof first.uiCulture != "undefined")) {
      _request = templateId;
      _options = uiCulture;
    } else {
      _request = {
        templateId,
        uiCulture
      };
      _options = webapi_options;
    }
    return this._getSanitizedTemplateStreamFromIdAsync(_request, _options);
  }
  async _getDocumentStreamAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        if (!options || options.returnBlobAs == ReturnBlobType.AsArrayBuffer) {
          config.responseType = "arraybuffer";
          config.headers = config.headers || {};
          config.headers["Accept"] = "application/octet-stream";
        }
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetDocumentStream", request, config);
        WebApiBase.SetCompleted(options);
        let res = null;
        if (options && options.returnBlobAs != ReturnBlobType.AsArrayBuffer) {
          res = response.data;
          if (options.returnBlobAs == ReturnBlobType.AsString) {
            res = FromBase64ToString(res);
          }
        } else {
          res = response.data;
        }
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getDocumentStreamAsync(documentId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = documentId;
    if (typeof first === "object" && first && typeof first.documentId != "undefined") {
      _request = documentId;
      _options = webapi_options;
    } else {
      _request = {
        documentId
      };
      _options = webapi_options;
    }
    return this._getDocumentStreamAsync(_request, _options);
  }
  async _getSanitizedDocumentStreamAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        if (!options || options.returnBlobAs == ReturnBlobType.AsArrayBuffer) {
          config.responseType = "arraybuffer";
          config.headers = config.headers || {};
          config.headers["Accept"] = "application/octet-stream";
        }
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetSanitizedDocumentStream", request, config);
        WebApiBase.SetCompleted(options);
        let res = null;
        if (options && options.returnBlobAs != ReturnBlobType.AsArrayBuffer) {
          res = response.data;
          if (options.returnBlobAs == ReturnBlobType.AsString) {
            res = FromBase64ToString(res);
          }
        } else {
          res = response.data;
        }
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getSanitizedDocumentStreamAsync(documentId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = documentId;
    if (typeof first === "object" && first && typeof first.documentId != "undefined") {
      _request = documentId;
      _options = webapi_options;
    } else {
      _request = {
        documentId
      };
      _options = webapi_options;
    }
    return this._getSanitizedDocumentStreamAsync(_request, _options);
  }
  async _getPreviewDocumentStreamAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPreviewDocumentStream", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DocumentPreview_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getPreviewDocumentStreamAsync(documentId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = documentId;
    if (typeof first === "object" && first && typeof first.documentId != "undefined") {
      _request = documentId;
      _options = webapi_options;
    } else {
      _request = {
        documentId
      };
      _options = webapi_options;
    }
    return this._getPreviewDocumentStreamAsync(_request, _options);
  }
  async _getUnsanitizedPreviewDocumentStreamAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetUnsanitizedPreviewDocumentStream", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DocumentPreview_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getUnsanitizedPreviewDocumentStreamAsync(documentId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = documentId;
    if (typeof first === "object" && first && typeof first.documentId != "undefined") {
      _request = documentId;
      _options = webapi_options;
    } else {
      _request = {
        documentId
      };
      _options = webapi_options;
    }
    return this._getUnsanitizedPreviewDocumentStreamAsync(_request, _options);
  }
  async _createNewPhysicalMailMergeDocumentFromTemplateAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateNewPhysicalMailMergeDocumentFromTemplate", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DocumentEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createNewPhysicalMailMergeDocumentFromTemplateAsync(documentId, uiCulture, webapi_options) {
    let _request = null;
    let _options = null;
    const first = documentId;
    if (typeof first === "object" && first && (typeof first.documentId != "undefined" || typeof first.uiCulture != "undefined")) {
      _request = documentId;
      _options = uiCulture;
    } else {
      _request = {
        documentId,
        uiCulture
      };
      _options = webapi_options;
    }
    return this._createNewPhysicalMailMergeDocumentFromTemplateAsync(_request, _options);
  }
  async _createNewPhysicalDocumentFromTemplateWithCustomTagsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateNewPhysicalDocumentFromTemplateWithCustomTags", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DocumentEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createNewPhysicalDocumentFromTemplateWithCustomTagsAsync(contactId, personId, appointmentId, documentId, saleId, selectionId, projectId, customTags, customValues, uiCulture, webapi_options) {
    let _request = null;
    let _options = null;
    const first = contactId;
    if (typeof first === "object" && first && (typeof first.contactId != "undefined" || typeof first.personId != "undefined" || typeof first.appointmentId != "undefined" || typeof first.documentId != "undefined" || typeof first.saleId != "undefined" || typeof first.selectionId != "undefined" || typeof first.projectId != "undefined" || typeof first.customTags != "undefined" || typeof first.customValues != "undefined" || typeof first.uiCulture != "undefined")) {
      _request = contactId;
      _options = personId;
    } else {
      _request = {
        contactId,
        personId,
        appointmentId,
        documentId,
        saleId,
        selectionId,
        projectId,
        customTags,
        customValues,
        uiCulture
      };
      _options = webapi_options;
    }
    return this._createNewPhysicalDocumentFromTemplateWithCustomTagsAsync(_request, _options);
  }
  async _createNewPhysicalDocumentFromTemplateWithCustomTags2Async(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateNewPhysicalDocumentFromTemplateWithCustomTags2", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DocumentEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createNewPhysicalDocumentFromTemplateWithCustomTags2Async(contactId, personId, appointmentId, documentId, saleId, selectionId, projectId, customTags, uiCulture, webapi_options) {
    let _request = null;
    let _options = null;
    const first = contactId;
    if (typeof first === "object" && first && (typeof first.contactId != "undefined" || typeof first.personId != "undefined" || typeof first.appointmentId != "undefined" || typeof first.documentId != "undefined" || typeof first.saleId != "undefined" || typeof first.selectionId != "undefined" || typeof first.projectId != "undefined" || typeof first.customTags != "undefined" || typeof first.uiCulture != "undefined")) {
      _request = contactId;
      _options = personId;
    } else {
      _request = {
        contactId,
        personId,
        appointmentId,
        documentId,
        saleId,
        selectionId,
        projectId,
        customTags,
        uiCulture
      };
      _options = webapi_options;
    }
    return this._createNewPhysicalDocumentFromTemplateWithCustomTags2Async(_request, _options);
  }
  async _substituteTemplateVariablesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SubstituteTemplateVariables", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async substituteTemplateVariablesAsync(source, generatorEncoding, contactId, personId, appointmentId, documentId, saleId, selectionId, projectId, cultureName, webapi_options) {
    let _request = null;
    let _options = null;
    const first = source;
    if (typeof first === "object" && first && (typeof first.source != "undefined" || typeof first.generatorEncoding != "undefined" || typeof first.contactId != "undefined" || typeof first.personId != "undefined" || typeof first.appointmentId != "undefined" || typeof first.documentId != "undefined" || typeof first.saleId != "undefined" || typeof first.selectionId != "undefined" || typeof first.projectId != "undefined" || typeof first.cultureName != "undefined")) {
      _request = source;
      _options = generatorEncoding;
    } else {
      _request = {
        source,
        generatorEncoding,
        contactId,
        personId,
        appointmentId,
        documentId,
        saleId,
        selectionId,
        projectId,
        cultureName
      };
      _options = webapi_options;
    }
    return this._substituteTemplateVariablesAsync(_request, _options);
  }
  async _substituteTemplateVariablesWithCustomTagsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SubstituteTemplateVariablesWithCustomTags", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async substituteTemplateVariablesWithCustomTagsAsync(source, generatorEncoding, customTags, customValues, contactId, personId, appointmentId, documentId, saleId, selectionId, projectId, cultureName, webapi_options) {
    let _request = null;
    let _options = null;
    const first = source;
    if (typeof first === "object" && first && (typeof first.source != "undefined" || typeof first.generatorEncoding != "undefined" || typeof first.customTags != "undefined" || typeof first.customValues != "undefined" || typeof first.contactId != "undefined" || typeof first.personId != "undefined" || typeof first.appointmentId != "undefined" || typeof first.documentId != "undefined" || typeof first.saleId != "undefined" || typeof first.selectionId != "undefined" || typeof first.projectId != "undefined" || typeof first.cultureName != "undefined")) {
      _request = source;
      _options = generatorEncoding;
    } else {
      _request = {
        source,
        generatorEncoding,
        customTags,
        customValues,
        contactId,
        personId,
        appointmentId,
        documentId,
        saleId,
        selectionId,
        projectId,
        cultureName
      };
      _options = webapi_options;
    }
    return this._substituteTemplateVariablesWithCustomTagsAsync(_request, _options);
  }
  async _substituteTemplateVariablesWithCustomTags2Async(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SubstituteTemplateVariablesWithCustomTags2", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async substituteTemplateVariablesWithCustomTags2Async(source, generatorEncoding, customTags, contactId, personId, appointmentId, documentId, saleId, selectionId, projectId, cultureName, webapi_options) {
    let _request = null;
    let _options = null;
    const first = source;
    if (typeof first === "object" && first && (typeof first.source != "undefined" || typeof first.generatorEncoding != "undefined" || typeof first.customTags != "undefined" || typeof first.contactId != "undefined" || typeof first.personId != "undefined" || typeof first.appointmentId != "undefined" || typeof first.documentId != "undefined" || typeof first.saleId != "undefined" || typeof first.selectionId != "undefined" || typeof first.projectId != "undefined" || typeof first.cultureName != "undefined")) {
      _request = source;
      _options = generatorEncoding;
    } else {
      _request = {
        source,
        generatorEncoding,
        customTags,
        contactId,
        personId,
        appointmentId,
        documentId,
        saleId,
        selectionId,
        projectId,
        cultureName
      };
      _options = webapi_options;
    }
    return this._substituteTemplateVariablesWithCustomTags2Async(_request, _options);
  }
  async _createTempFileAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateTempFile", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createTempFileAsync(filename, dataStream, webapi_options) {
    let _request = null;
    let _options = null;
    const first = filename;
    if (typeof first === "object" && first && (typeof first.filename != "undefined" || typeof first.dataStream != "undefined")) {
      _request = filename;
      _options = dataStream;
    } else {
      _request = {
        filename,
        dataStream
      };
      _options = webapi_options;
    }
    _request.dataStream = ToBase64(_request.dataStream);
    return this._createTempFileAsync(_request, _options);
  }
  async _getTempFileAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        if (!options || options.returnBlobAs == ReturnBlobType.AsArrayBuffer) {
          config.responseType = "arraybuffer";
          config.headers = config.headers || {};
          config.headers["Accept"] = "application/octet-stream";
        }
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetTempFile", request, config);
        WebApiBase.SetCompleted(options);
        let res = null;
        if (options && options.returnBlobAs != ReturnBlobType.AsArrayBuffer) {
          res = response.data;
          if (options.returnBlobAs == ReturnBlobType.AsString) {
            res = FromBase64ToString(res);
          }
        } else {
          res = response.data;
        }
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getTempFileAsync(filename, webapi_options) {
    let _request = null;
    let _options = null;
    const first = filename;
    if (typeof first === "object" && first && typeof first.filename != "undefined") {
      _request = filename;
      _options = webapi_options;
    } else {
      _request = {
        filename
      };
      _options = webapi_options;
    }
    return this._getTempFileAsync(_request, _options);
  }
  async _deleteTempFileAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeleteTempFile", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async deleteTempFileAsync(filename, webapi_options) {
    let _request = null;
    let _options = null;
    const first = filename;
    if (typeof first === "object" && first && typeof first.filename != "undefined") {
      _request = filename;
      _options = webapi_options;
    } else {
      _request = {
        filename
      };
      _options = webapi_options;
    }
    return this._deleteTempFileAsync(_request, _options);
  }
  async _setTemplateStreamAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetTemplateStream", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setTemplateStreamAsync(filename, personal, stream, webapi_options) {
    let _request = null;
    let _options = null;
    const first = filename;
    if (typeof first === "object" && first && (typeof first.filename != "undefined" || typeof first.personal != "undefined" || typeof first.stream != "undefined")) {
      _request = filename;
      _options = personal;
    } else {
      _request = {
        filename,
        personal,
        stream
      };
      _options = webapi_options;
    }
    _request.stream = ToBase64(_request.stream);
    return this._setTemplateStreamAsync(_request, _options);
  }
  async _createNewPhysicalDocumentFromTemplateAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateNewPhysicalDocumentFromTemplate", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DocumentEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createNewPhysicalDocumentFromTemplateAsync(contactId, personId, appointmentId, documentId, saleId, selectionId, projectId, uiCulture, webapi_options) {
    let _request = null;
    let _options = null;
    const first = contactId;
    if (typeof first === "object" && first && (typeof first.contactId != "undefined" || typeof first.personId != "undefined" || typeof first.appointmentId != "undefined" || typeof first.documentId != "undefined" || typeof first.saleId != "undefined" || typeof first.selectionId != "undefined" || typeof first.projectId != "undefined" || typeof first.uiCulture != "undefined")) {
      _request = contactId;
      _options = personId;
    } else {
      _request = {
        contactId,
        personId,
        appointmentId,
        documentId,
        saleId,
        selectionId,
        projectId,
        uiCulture
      };
      _options = webapi_options;
    }
    return this._createNewPhysicalDocumentFromTemplateAsync(_request, _options);
  }
  async _substituteMergeDocumentTemplateVariablesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        if (!options || options.returnBlobAs == ReturnBlobType.AsArrayBuffer) {
          config.responseType = "arraybuffer";
          config.headers = config.headers || {};
          config.headers["Accept"] = "application/octet-stream";
        }
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SubstituteMergeDocumentTemplateVariables", request, config);
        WebApiBase.SetCompleted(options);
        let res = null;
        if (options && options.returnBlobAs != ReturnBlobType.AsArrayBuffer) {
          res = response.data;
          if (options.returnBlobAs == ReturnBlobType.AsString) {
            res = FromBase64ToString(res);
          }
        } else {
          res = response.data;
        }
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async substituteMergeDocumentTemplateVariablesAsync(documentId, associateId, customTags, customValues, webapi_options) {
    let _request = null;
    let _options = null;
    const first = documentId;
    if (typeof first === "object" && first && (typeof first.documentId != "undefined" || typeof first.associateId != "undefined" || typeof first.customTags != "undefined" || typeof first.customValues != "undefined")) {
      _request = documentId;
      _options = associateId;
    } else {
      _request = {
        documentId,
        associateId,
        customTags,
        customValues
      };
      _options = webapi_options;
    }
    return this._substituteMergeDocumentTemplateVariablesAsync(_request, _options);
  }
  async _substituteMergeDocumentTemplateVariables2Async(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        if (!options || options.returnBlobAs == ReturnBlobType.AsArrayBuffer) {
          config.responseType = "arraybuffer";
          config.headers = config.headers || {};
          config.headers["Accept"] = "application/octet-stream";
        }
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SubstituteMergeDocumentTemplateVariables2", request, config);
        WebApiBase.SetCompleted(options);
        let res = null;
        if (options && options.returnBlobAs != ReturnBlobType.AsArrayBuffer) {
          res = response.data;
          if (options.returnBlobAs == ReturnBlobType.AsString) {
            res = FromBase64ToString(res);
          }
        } else {
          res = response.data;
        }
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async substituteMergeDocumentTemplateVariables2Async(documentId, associateId, customTags, webapi_options) {
    let _request = null;
    let _options = null;
    const first = documentId;
    if (typeof first === "object" && first && (typeof first.documentId != "undefined" || typeof first.associateId != "undefined" || typeof first.customTags != "undefined")) {
      _request = documentId;
      _options = associateId;
    } else {
      _request = {
        documentId,
        associateId,
        customTags
      };
      _options = webapi_options;
    }
    return this._substituteMergeDocumentTemplateVariables2Async(_request, _options);
  }
  async _substituteTemplateVariablesExAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SubstituteTemplateVariablesEx", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async substituteTemplateVariablesExAsync(parameters, webapi_options) {
    let _request = null;
    let _options = null;
    const first = parameters;
    if (typeof first === "object" && first && typeof first.parameters != "undefined") {
      _request = parameters;
      _options = webapi_options;
    } else {
      _request = {
        parameters
      };
      _options = webapi_options;
    }
    return this._substituteTemplateVariablesExAsync(_request, _options);
  }
  async _verifyGetDocumentStreamAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("VerifyGetDocumentStream", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async verifyGetDocumentStreamAsync(documentId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = documentId;
    if (typeof first === "object" && first && typeof first.documentId != "undefined") {
      _request = documentId;
      _options = webapi_options;
    } else {
      _request = {
        documentId
      };
      _options = webapi_options;
    }
    return this._verifyGetDocumentStreamAsync(_request, _options);
  }
  async _substituteMergeDocumentTemplateVariablesExAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        if (!options || options.returnBlobAs == ReturnBlobType.AsArrayBuffer) {
          config.responseType = "arraybuffer";
          config.headers = config.headers || {};
          config.headers["Accept"] = "application/octet-stream";
        }
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SubstituteMergeDocumentTemplateVariablesEx", request, config);
        WebApiBase.SetCompleted(options);
        let res = null;
        if (options && options.returnBlobAs != ReturnBlobType.AsArrayBuffer) {
          res = response.data;
          if (options.returnBlobAs == ReturnBlobType.AsString) {
            res = FromBase64ToString(res);
          }
        } else {
          res = response.data;
        }
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async substituteMergeDocumentTemplateVariablesExAsync(mergeDocumentId, contactId, personId, projectId, selectionId, appointmentId, documentId, saleId, customTags, customValues, webapi_options) {
    let _request = null;
    let _options = null;
    const first = mergeDocumentId;
    if (typeof first === "object" && first && (typeof first.mergeDocumentId != "undefined" || typeof first.contactId != "undefined" || typeof first.personId != "undefined" || typeof first.projectId != "undefined" || typeof first.selectionId != "undefined" || typeof first.appointmentId != "undefined" || typeof first.documentId != "undefined" || typeof first.saleId != "undefined" || typeof first.customTags != "undefined" || typeof first.customValues != "undefined")) {
      _request = mergeDocumentId;
      _options = contactId;
    } else {
      _request = {
        mergeDocumentId,
        contactId,
        personId,
        projectId,
        selectionId,
        appointmentId,
        documentId,
        saleId,
        customTags,
        customValues
      };
      _options = webapi_options;
    }
    return this._substituteMergeDocumentTemplateVariablesExAsync(_request, _options);
  }
  async _substituteMergeDocumentTemplateVariablesEx2Async(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        if (!options || options.returnBlobAs == ReturnBlobType.AsArrayBuffer) {
          config.responseType = "arraybuffer";
          config.headers = config.headers || {};
          config.headers["Accept"] = "application/octet-stream";
        }
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SubstituteMergeDocumentTemplateVariablesEx2", request, config);
        WebApiBase.SetCompleted(options);
        let res = null;
        if (options && options.returnBlobAs != ReturnBlobType.AsArrayBuffer) {
          res = response.data;
          if (options.returnBlobAs == ReturnBlobType.AsString) {
            res = FromBase64ToString(res);
          }
        } else {
          res = response.data;
        }
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async substituteMergeDocumentTemplateVariablesEx2Async(mergeDocumentId, contactId, personId, projectId, selectionId, appointmentId, documentId, saleId, customTags, webapi_options) {
    let _request = null;
    let _options = null;
    const first = mergeDocumentId;
    if (typeof first === "object" && first && (typeof first.mergeDocumentId != "undefined" || typeof first.contactId != "undefined" || typeof first.personId != "undefined" || typeof first.projectId != "undefined" || typeof first.selectionId != "undefined" || typeof first.appointmentId != "undefined" || typeof first.documentId != "undefined" || typeof first.saleId != "undefined" || typeof first.customTags != "undefined")) {
      _request = mergeDocumentId;
      _options = contactId;
    } else {
      _request = {
        mergeDocumentId,
        contactId,
        personId,
        projectId,
        selectionId,
        appointmentId,
        documentId,
        saleId,
        customTags
      };
      _options = webapi_options;
    }
    return this._substituteMergeDocumentTemplateVariablesEx2Async(_request, _options);
  }
  async _getDocumentUrlAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetDocumentUrl", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getDocumentUrlAsync(documentId, versionId, writeableUrl, webapi_options) {
    let _request = null;
    let _options = null;
    const first = documentId;
    if (typeof first === "object" && first && (typeof first.documentId != "undefined" || typeof first.versionId != "undefined" || typeof first.writeableUrl != "undefined")) {
      _request = documentId;
      _options = versionId;
    } else {
      _request = {
        documentId,
        versionId,
        writeableUrl
      };
      _options = webapi_options;
    }
    return this._getDocumentUrlAsync(_request, _options);
  }
  async _deletePhysicalDocumentAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeletePhysicalDocument", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ReturnInfo_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async deletePhysicalDocumentAsync(documentId, allowedReturnType, webapi_options) {
    let _request = null;
    let _options = null;
    const first = documentId;
    if (typeof first === "object" && first && (typeof first.documentId != "undefined" || typeof first.allowedReturnType != "undefined")) {
      _request = documentId;
      _options = allowedReturnType;
    } else {
      _request = {
        documentId,
        allowedReturnType
      };
      _options = webapi_options;
    }
    return this._deletePhysicalDocumentAsync(_request, _options);
  }
  async _renameDocumentAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("RenameDocument", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async renameDocumentAsync(documentId, newFilename, webapi_options) {
    let _request = null;
    let _options = null;
    const first = documentId;
    if (typeof first === "object" && first && (typeof first.documentId != "undefined" || typeof first.newFilename != "undefined")) {
      _request = documentId;
      _options = newFilename;
    } else {
      _request = {
        documentId,
        newFilename
      };
      _options = webapi_options;
    }
    return this._renameDocumentAsync(_request, _options);
  }
  async _getCheckoutStateAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetCheckoutState", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_CheckoutInfo_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getCheckoutStateAsync(documentId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = documentId;
    if (typeof first === "object" && first && typeof first.documentId != "undefined") {
      _request = documentId;
      _options = webapi_options;
    } else {
      _request = {
        documentId
      };
      _options = webapi_options;
    }
    return this._getCheckoutStateAsync(_request, _options);
  }
  async _checkoutDocumentAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CheckoutDocument", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ReturnInfo_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async checkoutDocumentAsync(documentId, allowedReturnTypes, webapi_options) {
    let _request = null;
    let _options = null;
    const first = documentId;
    if (typeof first === "object" && first && (typeof first.documentId != "undefined" || typeof first.allowedReturnTypes != "undefined")) {
      _request = documentId;
      _options = allowedReturnTypes;
    } else {
      _request = {
        documentId,
        allowedReturnTypes
      };
      _options = webapi_options;
    }
    return this._checkoutDocumentAsync(_request, _options);
  }
  async _checkinDocumentAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CheckinDocument", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ReturnInfo_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async checkinDocumentAsync(documentId, allowedReturnTypes, versionDescription, versionExtraFields, webapi_options) {
    let _request = null;
    let _options = null;
    const first = documentId;
    if (typeof first === "object" && first && (typeof first.documentId != "undefined" || typeof first.allowedReturnTypes != "undefined" || typeof first.versionDescription != "undefined" || typeof first.versionExtraFields != "undefined")) {
      _request = documentId;
      _options = allowedReturnTypes;
    } else {
      _request = {
        documentId,
        allowedReturnTypes,
        versionDescription,
        versionExtraFields
      };
      _options = webapi_options;
    }
    return this._checkinDocumentAsync(_request, _options);
  }
  async _undoCheckoutDocumentAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("UndoCheckoutDocument", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ReturnInfo_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async undoCheckoutDocumentAsync(documentId, allowedReturnTypes, webapi_options) {
    let _request = null;
    let _options = null;
    const first = documentId;
    if (typeof first === "object" && first && (typeof first.documentId != "undefined" || typeof first.allowedReturnTypes != "undefined")) {
      _request = documentId;
      _options = allowedReturnTypes;
    } else {
      _request = {
        documentId,
        allowedReturnTypes
      };
      _options = webapi_options;
    }
    return this._undoCheckoutDocumentAsync(_request, _options);
  }
  async _getVersionListAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetVersionList", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_VersionInfoArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getVersionListAsync(documentId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = documentId;
    if (typeof first === "object" && first && typeof first.documentId != "undefined") {
      _request = documentId;
      _options = webapi_options;
    } else {
      _request = {
        documentId
      };
      _options = webapi_options;
    }
    return this._getVersionListAsync(_request, _options);
  }
  async _getPluginListAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPluginList", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_StringDictionary_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Get a list of installed document plugins
   * @returns Dictionary mapping plugin id=plugin name
   */
  async getPluginListAsync(webapi_options) {
    return this._getPluginListAsync(webapi_options);
  }
  async _getPluginCapabilitiesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPluginCapabilities", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_StringDictionary_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getPluginCapabilitiesAsync(pluginId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = pluginId;
    if (typeof first === "object" && first && typeof first.pluginId != "undefined") {
      _request = pluginId;
      _options = webapi_options;
    } else {
      _request = {
        pluginId
      };
      _options = webapi_options;
    }
    return this._getPluginCapabilitiesAsync(_request, _options);
  }
  async _getDocumentPropertiesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetDocumentProperties", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_StringDictionary_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getDocumentPropertiesAsync(documentId, requestedProperties, webapi_options) {
    let _request = null;
    let _options = null;
    const first = documentId;
    if (typeof first === "object" && first && (typeof first.documentId != "undefined" || typeof first.requestedProperties != "undefined")) {
      _request = documentId;
      _options = requestedProperties;
    } else {
      _request = {
        documentId,
        requestedProperties
      };
      _options = webapi_options;
    }
    return this._getDocumentPropertiesAsync(_request, _options);
  }
  async _getDocumentCommandsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetDocumentCommands", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_CommandInfoArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getDocumentCommandsAsync(documentId, allowedReturnTypes, webapi_options) {
    let _request = null;
    let _options = null;
    const first = documentId;
    if (typeof first === "object" && first && (typeof first.documentId != "undefined" || typeof first.allowedReturnTypes != "undefined")) {
      _request = documentId;
      _options = allowedReturnTypes;
    } else {
      _request = {
        documentId,
        allowedReturnTypes
      };
      _options = webapi_options;
    }
    return this._getDocumentCommandsAsync(_request, _options);
  }
  async _executeDocumentCommandAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ExecuteDocumentCommand", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ReturnInfo_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async executeDocumentCommandAsync(documentId, versionId, allowedReturnTypes, command, additionalData, webapi_options) {
    let _request = null;
    let _options = null;
    const first = documentId;
    if (typeof first === "object" && first && (typeof first.documentId != "undefined" || typeof first.versionId != "undefined" || typeof first.allowedReturnTypes != "undefined" || typeof first.command != "undefined" || typeof first.additionalData != "undefined")) {
      _request = documentId;
      _options = versionId;
    } else {
      _request = {
        documentId,
        versionId,
        allowedReturnTypes,
        command,
        additionalData
      };
      _options = webapi_options;
    }
    return this._executeDocumentCommandAsync(_request, _options);
  }
  async _createDefaultDocumentEntityFromSuggestionAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateDefaultDocumentEntityFromSuggestion", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DocumentEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createDefaultDocumentEntityFromSuggestionAsync(suggestedDocumentId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = suggestedDocumentId;
    if (typeof first === "object" && first && typeof first.suggestedDocumentId != "undefined") {
      _request = suggestedDocumentId;
      _options = webapi_options;
    } else {
      _request = {
        suggestedDocumentId
      };
      _options = webapi_options;
    }
    return this._createDefaultDocumentEntityFromSuggestionAsync(_request, _options);
  }
  async _saveDocumentTemplateStreamAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveDocumentTemplateStream", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TemplateInfo_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveDocumentTemplateStreamAsync(documentTemplateId, content, languageCode, pluginId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = documentTemplateId;
    if (typeof first === "object" && first && (typeof first.documentTemplateId != "undefined" || typeof first.content != "undefined" || typeof first.languageCode != "undefined" || typeof first.pluginId != "undefined")) {
      _request = documentTemplateId;
      _options = content;
    } else {
      _request = {
        documentTemplateId,
        content,
        languageCode,
        pluginId
      };
      _options = webapi_options;
    }
    _request.content = ToBase64(_request.content);
    return this._saveDocumentTemplateStreamAsync(_request, _options);
  }
  async _setDocumentStreamFromIdAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetDocumentStreamFromId", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DocumentEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setDocumentStreamFromIdAsync(documentId, stream, webapi_options) {
    let _request = null;
    let _options = null;
    const first = documentId;
    if (typeof first === "object" && first && (typeof first.documentId != "undefined" || typeof first.stream != "undefined")) {
      _request = documentId;
      _options = stream;
    } else {
      _request = {
        documentId,
        stream
      };
      _options = webapi_options;
    }
    _request.stream = ToBase64(_request.stream);
    return this._setDocumentStreamFromIdAsync(_request, _options);
  }
  async _savePrivacyReportAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SavePrivacyReport", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async savePrivacyReportAsync(htmlReport, title, personId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = htmlReport;
    if (typeof first === "object" && first && (typeof first.htmlReport != "undefined" || typeof first.title != "undefined" || typeof first.personId != "undefined")) {
      _request = htmlReport;
      _options = title;
    } else {
      _request = {
        htmlReport,
        title,
        personId
      };
      _options = webapi_options;
    }
    return this._savePrivacyReportAsync(_request, _options);
  }
  async _validateDocumentEntityAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ValidateDocumentEntity", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_StringDictionary_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async validateDocumentEntityAsync(documentEntity, webapi_options) {
    let _request = null;
    let _options = null;
    const first = documentEntity;
    if (typeof first === "object" && first && typeof first.documentEntity != "undefined") {
      _request = documentEntity;
      _options = webapi_options;
    } else {
      _request = {
        documentEntity
      };
      _options = webapi_options;
    }
    return this._validateDocumentEntityAsync(_request, _options);
  }
  async _getDocumentLengthAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetDocumentLength", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getDocumentLengthAsync(documentId, versionId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = documentId;
    if (typeof first === "object" && first && (typeof first.documentId != "undefined" || typeof first.versionId != "undefined")) {
      _request = documentId;
      _options = versionId;
    } else {
      _request = {
        documentId,
        versionId
      };
      _options = webapi_options;
    }
    return this._getDocumentLengthAsync(_request, _options);
  }
  async _copyDocumentToCsAttachmentAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CopyDocumentToCsAttachment", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async copyDocumentToCsAttachmentAsync(documentId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = documentId;
    if (typeof first === "object" && first && typeof first.documentId != "undefined") {
      _request = documentId;
      _options = webapi_options;
    } else {
      _request = {
        documentId
      };
      _options = webapi_options;
    }
    return this._copyDocumentToCsAttachmentAsync(_request, _options);
  }
  /*
   * Gets an array of Document objects.
   * @param documentIds - The primary keys.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns An array of Document
   */
  async getDocumentListAsync(documentIds, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetDocumentList", documentIds, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DocumentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getAppointmentDocumentsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetAppointmentDocuments", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DocumentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getAppointmentDocumentsAsync(appointmentId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = appointmentId;
    if (typeof first === "object" && first && typeof first.appointmentId != "undefined") {
      _request = appointmentId;
      _options = webapi_options;
    } else {
      _request = {
        appointmentId
      };
      _options = webapi_options;
    }
    return this._getAppointmentDocumentsAsync(_request, _options);
  }
  async _getSaleDocumentsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetSaleDocuments", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DocumentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getSaleDocumentsAsync(saleId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = saleId;
    if (typeof first === "object" && first && typeof first.saleId != "undefined") {
      _request = saleId;
      _options = webapi_options;
    } else {
      _request = {
        saleId
      };
      _options = webapi_options;
    }
    return this._getSaleDocumentsAsync(_request, _options);
  }
  async _getPersonDocumentsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPersonDocuments", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DocumentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getPersonDocumentsAsync(personId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = personId;
    if (typeof first === "object" && first && typeof first.personId != "undefined") {
      _request = personId;
      _options = webapi_options;
    } else {
      _request = {
        personId
      };
      _options = webapi_options;
    }
    return this._getPersonDocumentsAsync(_request, _options);
  }
  async _getPublishedDocumentAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPublishedDocument", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Document_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getPublishedDocumentAsync(documentId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = documentId;
    if (typeof first === "object" && first && typeof first.documentId != "undefined") {
      _request = documentId;
      _options = webapi_options;
    } else {
      _request = {
        documentId
      };
      _options = webapi_options;
    }
    return this._getPublishedDocumentAsync(_request, _options);
  }
  async _getPublishedDocumentsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPublishedDocuments", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DocumentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getPublishedDocumentsAsync(documentIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = documentIds;
    if (typeof first === "object" && first && typeof first.documentIds != "undefined") {
      _request = documentIds;
      _options = webapi_options;
    } else {
      _request = {
        documentIds
      };
      _options = webapi_options;
    }
    return this._getPublishedDocumentsAsync(_request, _options);
  }
  async _getMyPublishedDocumentsAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetMyPublishedDocuments", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DocumentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   *
   * @returns Array of documents
   */
  async getMyPublishedDocumentsAsync(webapi_options) {
    return this._getMyPublishedDocumentsAsync(webapi_options);
  }
  async _getPublishedDocumentsByDateAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPublishedDocumentsByDate", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DocumentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getPublishedDocumentsByDateAsync(personId, includeProjectDocuments, startTime, endTime, count, webapi_options) {
    let _request = null;
    let _options = null;
    const first = personId;
    if (typeof first === "object" && first && (typeof first.personId != "undefined" || typeof first.includeProjectDocuments != "undefined" || typeof first.startTime != "undefined" || typeof first.endTime != "undefined" || typeof first.count != "undefined")) {
      _request = personId;
      _options = includeProjectDocuments;
    } else {
      _request = {
        personId,
        includeProjectDocuments,
        startTime,
        endTime,
        count
      };
      _options = webapi_options;
    }
    return this._getPublishedDocumentsByDateAsync(_request, _options);
  }
  async _getContactDocumentsByTemplateTypesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetContactDocumentsByTemplateTypes", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DocumentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getContactDocumentsByTemplateTypesAsync(contactId, startTime, endTime, count, documentTemplateIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = contactId;
    if (typeof first === "object" && first && (typeof first.contactId != "undefined" || typeof first.startTime != "undefined" || typeof first.endTime != "undefined" || typeof first.count != "undefined" || typeof first.documentTemplateIds != "undefined")) {
      _request = contactId;
      _options = startTime;
    } else {
      _request = {
        contactId,
        startTime,
        endTime,
        count,
        documentTemplateIds
      };
      _options = webapi_options;
    }
    return this._getContactDocumentsByTemplateTypesAsync(_request, _options);
  }
  async _getContactDocumentsByTemplateTypeAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetContactDocumentsByTemplateType", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DocumentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getContactDocumentsByTemplateTypeAsync(contactId, startTime, endTime, count, documentTemplateId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = contactId;
    if (typeof first === "object" && first && (typeof first.contactId != "undefined" || typeof first.startTime != "undefined" || typeof first.endTime != "undefined" || typeof first.count != "undefined" || typeof first.documentTemplateId != "undefined")) {
      _request = contactId;
      _options = startTime;
    } else {
      _request = {
        contactId,
        startTime,
        endTime,
        count,
        documentTemplateId
      };
      _options = webapi_options;
    }
    return this._getContactDocumentsByTemplateTypeAsync(_request, _options);
  }
  async _getContactDocumentsByTemplateHeadingAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetContactDocumentsByTemplateHeading", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DocumentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getContactDocumentsByTemplateHeadingAsync(contactId, startTime, endTime, count, templateHeadingId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = contactId;
    if (typeof first === "object" && first && (typeof first.contactId != "undefined" || typeof first.startTime != "undefined" || typeof first.endTime != "undefined" || typeof first.count != "undefined" || typeof first.templateHeadingId != "undefined")) {
      _request = contactId;
      _options = startTime;
    } else {
      _request = {
        contactId,
        startTime,
        endTime,
        count,
        templateHeadingId
      };
      _options = webapi_options;
    }
    return this._getContactDocumentsByTemplateHeadingAsync(_request, _options);
  }
  async _getContactDocumentsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetContactDocuments", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DocumentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getContactDocumentsAsync(contactId, startTime, endTime, count, webapi_options) {
    let _request = null;
    let _options = null;
    const first = contactId;
    if (typeof first === "object" && first && (typeof first.contactId != "undefined" || typeof first.startTime != "undefined" || typeof first.endTime != "undefined" || typeof first.count != "undefined")) {
      _request = contactId;
      _options = startTime;
    } else {
      _request = {
        contactId,
        startTime,
        endTime,
        count
      };
      _options = webapi_options;
    }
    return this._getContactDocumentsAsync(_request, _options);
  }
  async _getPublishedPersonDocumentsByDateAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPublishedPersonDocumentsByDate", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DocumentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getPublishedPersonDocumentsByDateAsync(personId, includeProjectDocuments, startTime, endTime, count, webapi_options) {
    let _request = null;
    let _options = null;
    const first = personId;
    if (typeof first === "object" && first && (typeof first.personId != "undefined" || typeof first.includeProjectDocuments != "undefined" || typeof first.startTime != "undefined" || typeof first.endTime != "undefined" || typeof first.count != "undefined")) {
      _request = personId;
      _options = includeProjectDocuments;
    } else {
      _request = {
        personId,
        includeProjectDocuments,
        startTime,
        endTime,
        count
      };
      _options = webapi_options;
    }
    return this._getPublishedPersonDocumentsByDateAsync(_request, _options);
  }
  async _getPublishedProjectDocumentsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPublishedProjectDocuments", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DocumentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getPublishedProjectDocumentsAsync(projectId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = projectId;
    if (typeof first === "object" && first && typeof first.projectId != "undefined") {
      _request = projectId;
      _options = webapi_options;
    } else {
      _request = {
        projectId
      };
      _options = webapi_options;
    }
    return this._getPublishedProjectDocumentsAsync(_request, _options);
  }
  async _getProjectMemberDocumentsByTemplateTypesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetProjectMemberDocumentsByTemplateTypes", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DocumentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getProjectMemberDocumentsByTemplateTypesAsync(personId, startTime, endTime, count, documentTemplateIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = personId;
    if (typeof first === "object" && first && (typeof first.personId != "undefined" || typeof first.startTime != "undefined" || typeof first.endTime != "undefined" || typeof first.count != "undefined" || typeof first.documentTemplateIds != "undefined")) {
      _request = personId;
      _options = startTime;
    } else {
      _request = {
        personId,
        startTime,
        endTime,
        count,
        documentTemplateIds
      };
      _options = webapi_options;
    }
    return this._getProjectMemberDocumentsByTemplateTypesAsync(_request, _options);
  }
  async _getProjectMemberDocumentsByTemplateTypeAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetProjectMemberDocumentsByTemplateType", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DocumentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getProjectMemberDocumentsByTemplateTypeAsync(personId, startTime, endTime, count, documentTemplateId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = personId;
    if (typeof first === "object" && first && (typeof first.personId != "undefined" || typeof first.startTime != "undefined" || typeof first.endTime != "undefined" || typeof first.count != "undefined" || typeof first.documentTemplateId != "undefined")) {
      _request = personId;
      _options = startTime;
    } else {
      _request = {
        personId,
        startTime,
        endTime,
        count,
        documentTemplateId
      };
      _options = webapi_options;
    }
    return this._getProjectMemberDocumentsByTemplateTypeAsync(_request, _options);
  }
  async _getProjectMemberDocumentsByTemplateHeadingAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetProjectMemberDocumentsByTemplateHeading", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DocumentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getProjectMemberDocumentsByTemplateHeadingAsync(personId, startTime, endTime, count, templateHeadingId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = personId;
    if (typeof first === "object" && first && (typeof first.personId != "undefined" || typeof first.startTime != "undefined" || typeof first.endTime != "undefined" || typeof first.count != "undefined" || typeof first.templateHeadingId != "undefined")) {
      _request = personId;
      _options = startTime;
    } else {
      _request = {
        personId,
        startTime,
        endTime,
        count,
        templateHeadingId
      };
      _options = webapi_options;
    }
    return this._getProjectMemberDocumentsByTemplateHeadingAsync(_request, _options);
  }
  async _getProjectMemberDocumentsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetProjectMemberDocuments", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DocumentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getProjectMemberDocumentsAsync(personId, startTime, endTime, count, webapi_options) {
    let _request = null;
    let _options = null;
    const first = personId;
    if (typeof first === "object" && first && (typeof first.personId != "undefined" || typeof first.startTime != "undefined" || typeof first.endTime != "undefined" || typeof first.count != "undefined")) {
      _request = personId;
      _options = startTime;
    } else {
      _request = {
        personId,
        startTime,
        endTime,
        count
      };
      _options = webapi_options;
    }
    return this._getProjectMemberDocumentsAsync(_request, _options);
  }
  async _getProjectDocumentsByTemplateTypesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetProjectDocumentsByTemplateTypes", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DocumentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getProjectDocumentsByTemplateTypesAsync(projectId, startTime, endTime, count, documentTemplateIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = projectId;
    if (typeof first === "object" && first && (typeof first.projectId != "undefined" || typeof first.startTime != "undefined" || typeof first.endTime != "undefined" || typeof first.count != "undefined" || typeof first.documentTemplateIds != "undefined")) {
      _request = projectId;
      _options = startTime;
    } else {
      _request = {
        projectId,
        startTime,
        endTime,
        count,
        documentTemplateIds
      };
      _options = webapi_options;
    }
    return this._getProjectDocumentsByTemplateTypesAsync(_request, _options);
  }
  async _getProjectDocumentsByTemplateTypeAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetProjectDocumentsByTemplateType", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DocumentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getProjectDocumentsByTemplateTypeAsync(projectId, startTime, endTime, count, documentTemplateId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = projectId;
    if (typeof first === "object" && first && (typeof first.projectId != "undefined" || typeof first.startTime != "undefined" || typeof first.endTime != "undefined" || typeof first.count != "undefined" || typeof first.documentTemplateId != "undefined")) {
      _request = projectId;
      _options = startTime;
    } else {
      _request = {
        projectId,
        startTime,
        endTime,
        count,
        documentTemplateId
      };
      _options = webapi_options;
    }
    return this._getProjectDocumentsByTemplateTypeAsync(_request, _options);
  }
  async _getProjectDocumentsByTemplateHeadingAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetProjectDocumentsByTemplateHeading", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DocumentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getProjectDocumentsByTemplateHeadingAsync(projectId, startTime, endTime, count, templateHeadingId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = projectId;
    if (typeof first === "object" && first && (typeof first.projectId != "undefined" || typeof first.startTime != "undefined" || typeof first.endTime != "undefined" || typeof first.count != "undefined" || typeof first.templateHeadingId != "undefined")) {
      _request = projectId;
      _options = startTime;
    } else {
      _request = {
        projectId,
        startTime,
        endTime,
        count,
        templateHeadingId
      };
      _options = webapi_options;
    }
    return this._getProjectDocumentsByTemplateHeadingAsync(_request, _options);
  }
  async _getProjectDocumentsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetProjectDocuments", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DocumentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getProjectDocumentsAsync(projectId, startTime, endTime, count, webapi_options) {
    let _request = null;
    let _options = null;
    const first = projectId;
    if (typeof first === "object" && first && (typeof first.projectId != "undefined" || typeof first.startTime != "undefined" || typeof first.endTime != "undefined" || typeof first.count != "undefined")) {
      _request = projectId;
      _options = startTime;
    } else {
      _request = {
        projectId,
        startTime,
        endTime,
        count
      };
      _options = webapi_options;
    }
    return this._getProjectDocumentsAsync(_request, _options);
  }
  async _getPersonDocumentsByTemplateTypesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPersonDocumentsByTemplateTypes", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DocumentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getPersonDocumentsByTemplateTypesAsync(personId, includeProjectDocuments, startTime, endTime, count, documentTemplateIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = personId;
    if (typeof first === "object" && first && (typeof first.personId != "undefined" || typeof first.includeProjectDocuments != "undefined" || typeof first.startTime != "undefined" || typeof first.endTime != "undefined" || typeof first.count != "undefined" || typeof first.documentTemplateIds != "undefined")) {
      _request = personId;
      _options = includeProjectDocuments;
    } else {
      _request = {
        personId,
        includeProjectDocuments,
        startTime,
        endTime,
        count,
        documentTemplateIds
      };
      _options = webapi_options;
    }
    return this._getPersonDocumentsByTemplateTypesAsync(_request, _options);
  }
  async _getPersonDocumentsByTemplateTypeAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPersonDocumentsByTemplateType", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DocumentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getPersonDocumentsByTemplateTypeAsync(personId, includeProjectDocuments, startTime, endTime, count, documentTemplateId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = personId;
    if (typeof first === "object" && first && (typeof first.personId != "undefined" || typeof first.includeProjectDocuments != "undefined" || typeof first.startTime != "undefined" || typeof first.endTime != "undefined" || typeof first.count != "undefined" || typeof first.documentTemplateId != "undefined")) {
      _request = personId;
      _options = includeProjectDocuments;
    } else {
      _request = {
        personId,
        includeProjectDocuments,
        startTime,
        endTime,
        count,
        documentTemplateId
      };
      _options = webapi_options;
    }
    return this._getPersonDocumentsByTemplateTypeAsync(_request, _options);
  }
  async _getPersonDocumentsByTemplateHeadingAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPersonDocumentsByTemplateHeading", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DocumentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getPersonDocumentsByTemplateHeadingAsync(personId, includeProjectDocuments, startTime, endTime, count, templateHeadingId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = personId;
    if (typeof first === "object" && first && (typeof first.personId != "undefined" || typeof first.includeProjectDocuments != "undefined" || typeof first.startTime != "undefined" || typeof first.endTime != "undefined" || typeof first.count != "undefined" || typeof first.templateHeadingId != "undefined")) {
      _request = personId;
      _options = includeProjectDocuments;
    } else {
      _request = {
        personId,
        includeProjectDocuments,
        startTime,
        endTime,
        count,
        templateHeadingId
      };
      _options = webapi_options;
    }
    return this._getPersonDocumentsByTemplateHeadingAsync(_request, _options);
  }
  async _getPersonDocumentsByDateAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPersonDocumentsByDate", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DocumentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getPersonDocumentsByDateAsync(personId, includeProjectDocuments, startTime, endTime, count, webapi_options) {
    let _request = null;
    let _options = null;
    const first = personId;
    if (typeof first === "object" && first && (typeof first.personId != "undefined" || typeof first.includeProjectDocuments != "undefined" || typeof first.startTime != "undefined" || typeof first.endTime != "undefined" || typeof first.count != "undefined")) {
      _request = personId;
      _options = includeProjectDocuments;
    } else {
      _request = {
        personId,
        includeProjectDocuments,
        startTime,
        endTime,
        count
      };
      _options = webapi_options;
    }
    return this._getPersonDocumentsByDateAsync(_request, _options);
  }
  async _getDocumentsByTemplateHeadingAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetDocumentsByTemplateHeading", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DocumentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getDocumentsByTemplateHeadingAsync(templateHeadingId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = templateHeadingId;
    if (typeof first === "object" && first && typeof first.templateHeadingId != "undefined") {
      _request = templateHeadingId;
      _options = webapi_options;
    } else {
      _request = {
        templateHeadingId
      };
      _options = webapi_options;
    }
    return this._getDocumentsByTemplateHeadingAsync(_request, _options);
  }
  /*
   * Gets a SuggestedDocumentEntity object.
   * @param suggestedDocumentEntityId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single SuggestedDocumentEntity
   */
  async getSuggestedDocumentEntityAsync(suggestedDocumentEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetSuggestedDocumentEntity?suggestedDocumentEntityId=" + suggestedDocumentEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SuggestedDocumentEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
};

// server/node_modules/@superoffice/webapi/dist/esm/ListAgent.js
var ListAgent = class extends WebApiBase {
  constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
    const options = WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
    options.basePath = "v1/Agents/List/";
    super(options);
  }
  /**
   * Set default values into a new AmountClassEntity.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultAmountClassEntityAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultAmountClassEntity", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AmountClassEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing AmountClassEntity or creates a new AmountClassEntity if the id parameter is empty
   * @param entity - The AmountClassEntity to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated AmountClassEntity
   */
  async saveAmountClassEntityAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveAmountClassEntity", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AmountClassEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new TaskMenu.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultTaskMenuAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultTaskMenu", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TaskMenu_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing TaskMenu or creates a new TaskMenu if the id parameter is empty
   * @param entity - The TaskMenu to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated TaskMenu
   */
  async saveTaskMenuAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveTaskMenu", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TaskMenu_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Deletes the TaskMenu
   * @param TaskMenuId - The id of the TaskMenu to be deleted.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   */
  async deleteTaskMenuAsync(TaskMenuId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("DeleteTaskMenu?TaskMenuId=" + TaskMenuId, null, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new CurrencyEntity.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultCurrencyEntityAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultCurrencyEntity", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_CurrencyEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing CurrencyEntity or creates a new CurrencyEntity if the id parameter is empty
   * @param entity - The CurrencyEntity to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated CurrencyEntity
   */
  async saveCurrencyEntityAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveCurrencyEntity", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_CurrencyEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new DocumentTemplateEntity.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultDocumentTemplateEntityAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultDocumentTemplateEntity", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DocumentTemplateEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing DocumentTemplateEntity or creates a new DocumentTemplateEntity if the id parameter is empty
   * @param entity - The DocumentTemplateEntity to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated DocumentTemplateEntity
   */
  async saveDocumentTemplateEntityAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveDocumentTemplateEntity", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DocumentTemplateEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new ExtAppEntity.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultExtAppEntityAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultExtAppEntity", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ExtAppEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing ExtAppEntity or creates a new ExtAppEntity if the id parameter is empty
   * @param entity - The ExtAppEntity to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated ExtAppEntity
   */
  async saveExtAppEntityAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveExtAppEntity", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ExtAppEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new HeadingEntity.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultHeadingEntityAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultHeadingEntity", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_HeadingEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing HeadingEntity or creates a new HeadingEntity if the id parameter is empty
   * @param entity - The HeadingEntity to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated HeadingEntity
   */
  async saveHeadingEntityAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveHeadingEntity", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_HeadingEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new HierarchyEntity.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultHierarchyEntityAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultHierarchyEntity", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_HierarchyEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing HierarchyEntity or creates a new HierarchyEntity if the id parameter is empty
   * @param entity - The HierarchyEntity to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated HierarchyEntity
   */
  async saveHierarchyEntityAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveHierarchyEntity", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_HierarchyEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Deletes the HierarchyEntity
   * @param HierarchyEntityId - The id of the HierarchyEntity to be deleted.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   */
  async deleteHierarchyEntityAsync(HierarchyEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("DeleteHierarchyEntity?HierarchyEntityId=" + HierarchyEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new ListEntity.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultListEntityAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultListEntity", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ListEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing ListEntity or creates a new ListEntity if the id parameter is empty
   * @param entity - The ListEntity to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated ListEntity
   */
  async saveListEntityAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveListEntity", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ListEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Deletes the ListEntity
   * @param ListEntityId - The id of the ListEntity to be deleted.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   */
  async deleteListEntityAsync(ListEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("DeleteListEntity?ListEntityId=" + ListEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new ListItemEntity.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultListItemEntityAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultListItemEntity", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ListItemEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new ProjectTypeEntity.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultProjectTypeEntityAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultProjectTypeEntity", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ProjectTypeEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing ProjectTypeEntity or creates a new ProjectTypeEntity if the id parameter is empty
   * @param entity - The ProjectTypeEntity to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated ProjectTypeEntity
   */
  async saveProjectTypeEntityAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveProjectTypeEntity", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ProjectTypeEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new RelationDefinitionEntity.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultRelationDefinitionEntityAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultRelationDefinitionEntity", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_RelationDefinitionEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing RelationDefinitionEntity or creates a new RelationDefinitionEntity if the id parameter is empty
   * @param entity - The RelationDefinitionEntity to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated RelationDefinitionEntity
   */
  async saveRelationDefinitionEntityAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveRelationDefinitionEntity", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_RelationDefinitionEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new ResourceEntity.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultResourceEntityAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultResourceEntity", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ResourceEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing ResourceEntity or creates a new ResourceEntity if the id parameter is empty
   * @param entity - The ResourceEntity to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated ResourceEntity
   */
  async saveResourceEntityAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveResourceEntity", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ResourceEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Deletes the ResourceEntity
   * @param ResourceEntityId - The id of the ResourceEntity to be deleted.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   */
  async deleteResourceEntityAsync(ResourceEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("DeleteResourceEntity?ResourceEntityId=" + ResourceEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new SaleStageEntity.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultSaleStageEntityAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultSaleStageEntity", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SaleStageEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing SaleStageEntity or creates a new SaleStageEntity if the id parameter is empty
   * @param entity - The SaleStageEntity to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated SaleStageEntity
   */
  async saveSaleStageEntityAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveSaleStageEntity", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SaleStageEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new SaleTypeEntity.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultSaleTypeEntityAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultSaleTypeEntity", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SaleTypeEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing SaleTypeEntity or creates a new SaleTypeEntity if the id parameter is empty
   * @param entity - The SaleTypeEntity to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated SaleTypeEntity
   */
  async saveSaleTypeEntityAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveSaleTypeEntity", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SaleTypeEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new TicketCategoryEntity.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultTicketCategoryEntityAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultTicketCategoryEntity", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TicketCategoryEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing TicketCategoryEntity or creates a new TicketCategoryEntity if the id parameter is empty
   * @param entity - The TicketCategoryEntity to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated TicketCategoryEntity
   */
  async saveTicketCategoryEntityAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveTicketCategoryEntity", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TicketCategoryEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Deletes the TicketCategoryEntity
   * @param TicketCategoryEntityId - The id of the TicketCategoryEntity to be deleted.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   */
  async deleteTicketCategoryEntityAsync(TicketCategoryEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("DeleteTicketCategoryEntity?TicketCategoryEntityId=" + TicketCategoryEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new TicketPriorityEntity.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultTicketPriorityEntityAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultTicketPriorityEntity", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TicketPriorityEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing TicketPriorityEntity or creates a new TicketPriorityEntity if the id parameter is empty
   * @param entity - The TicketPriorityEntity to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated TicketPriorityEntity
   */
  async saveTicketPriorityEntityAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveTicketPriorityEntity", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TicketPriorityEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Deletes the TicketPriorityEntity
   * @param TicketPriorityEntityId - The id of the TicketPriorityEntity to be deleted.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   */
  async deleteTicketPriorityEntityAsync(TicketPriorityEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("DeleteTicketPriorityEntity?TicketPriorityEntityId=" + TicketPriorityEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new TicketStatusEntity.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultTicketStatusEntityAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultTicketStatusEntity", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TicketStatusEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing TicketStatusEntity or creates a new TicketStatusEntity if the id parameter is empty
   * @param entity - The TicketStatusEntity to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated TicketStatusEntity
   */
  async saveTicketStatusEntityAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveTicketStatusEntity", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TicketStatusEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Deletes the TicketStatusEntity
   * @param TicketStatusEntityId - The id of the TicketStatusEntity to be deleted.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   */
  async deleteTicketStatusEntityAsync(TicketStatusEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("DeleteTicketStatusEntity?TicketStatusEntityId=" + TicketStatusEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new TicketTypeEntity.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultTicketTypeEntityAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultTicketTypeEntity", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TicketTypeEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing TicketTypeEntity or creates a new TicketTypeEntity if the id parameter is empty
   * @param entity - The TicketTypeEntity to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated TicketTypeEntity
   */
  async saveTicketTypeEntityAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveTicketTypeEntity", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TicketTypeEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Deletes the TicketTypeEntity
   * @param TicketTypeEntityId - The id of the TicketTypeEntity to be deleted.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   */
  async deleteTicketTypeEntityAsync(TicketTypeEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("DeleteTicketTypeEntity?TicketTypeEntityId=" + TicketTypeEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new WebPanelEntity.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultWebPanelEntityAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultWebPanelEntity", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_WebPanelEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing WebPanelEntity or creates a new WebPanelEntity if the id parameter is empty
   * @param entity - The WebPanelEntity to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated WebPanelEntity
   */
  async saveWebPanelEntityAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveWebPanelEntity", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_WebPanelEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets a AmountClassEntity object.
   * @param amountClassEntityId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single AmountClassEntity
   */
  async getAmountClassEntityAsync(amountClassEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetAmountClassEntity?amountClassEntityId=" + amountClassEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AmountClassEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets a Business object.
   * @param businessId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single Business
   */
  async getBusinessAsync(businessId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetBusiness?businessId=" + businessId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Business_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets an array of Business objects.
   * @param businessIds - The primary keys.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns An array of Business
   */
  async getBusinessListAsync(businessIds, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetBusinessList", businessIds, config);
        WebApiBase.SetCompleted(options);
        const res = Create_BusinessArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getBusinessesAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetBusinesses", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_BusinessArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Returns all available businesses that a contact could have.
   * @returns An array of all available businesses
   */
  async getBusinessesAsync(webapi_options) {
    return this._getBusinessesAsync(webapi_options);
  }
  /*
   * Gets a Category object.
   * @param categoryId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single Category
   */
  async getCategoryAsync(categoryId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetCategory?categoryId=" + categoryId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Category_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets an array of Category objects.
   * @param categoryIds - The primary keys.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns An array of Category
   */
  async getCategoryListAsync(categoryIds, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetCategoryList", categoryIds, config);
        WebApiBase.SetCompleted(options);
        const res = Create_CategoryArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getCategoriesAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetCategories", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_CategoryArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Returns all categories a contact could belong to
   * @returns An array of all available categories
   */
  async getCategoriesAsync(webapi_options) {
    return this._getCategoriesAsync(webapi_options);
  }
  /*
   * Gets a Competitor object.
   * @param competitorId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single Competitor
   */
  async getCompetitorAsync(competitorId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetCompetitor?competitorId=" + competitorId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Competitor_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets an array of Competitor objects.
   * @param competitorIds - The primary keys.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns An array of Competitor
   */
  async getCompetitorListAsync(competitorIds, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetCompetitorList", competitorIds, config);
        WebApiBase.SetCompleted(options);
        const res = Create_CompetitorArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getCompetitorsAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetCompetitors", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_CompetitorArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Returns all competitors
   * @returns
   */
  async getCompetitorsAsync(webapi_options) {
    return this._getCompetitorsAsync(webapi_options);
  }
  /*
   * Gets a TaskMenu object.
   * @param taskMenuId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single TaskMenu
   */
  async getTaskMenuAsync(taskMenuId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetTaskMenu?taskMenuId=" + taskMenuId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TaskMenu_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getAppTaskMenusAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetAppTaskMenus", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TaskMenuArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Get all task menus owned by your app; works in Online only, for registered Apps that send a valid ApplicationToken
   * @returns List of all task menus owned by the current App
   */
  async getAppTaskMenusAsync(webapi_options) {
    return this._getAppTaskMenusAsync(webapi_options);
  }
  async _deleteAppTaskMenusAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeleteAppTaskMenus", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Permanentely delete all task menus owned by your app; works in Online only, for registered Apps that send a valid ApplicationToken; otherwise nothing happens
   * @returns This method has no return value
   */
  async deleteAppTaskMenusAsync(webapi_options) {
    return this._deleteAppTaskMenusAsync(webapi_options);
  }
  async _getTaskMenuByProgIdAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetTaskMenuByProgId", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TaskMenu_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getTaskMenuByProgIdAsync(progId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = progId;
    if (typeof first === "object" && first && typeof first.progId != "undefined") {
      _request = progId;
      _options = webapi_options;
    } else {
      _request = {
        progId
      };
      _options = webapi_options;
    }
    return this._getTaskMenuByProgIdAsync(_request, _options);
  }
  /*
   * Gets a ConsentPurpose object.
   * @param consentPurposeId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single ConsentPurpose
   */
  async getConsentPurposeAsync(consentPurposeId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetConsentPurpose?consentPurposeId=" + consentPurposeId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ConsentPurpose_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _saveConsentPurposeAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveConsentPurpose", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ConsentPurpose_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveConsentPurposeAsync(consentPurpose, webapi_options) {
    let _request = null;
    let _options = null;
    const first = consentPurpose;
    if (typeof first === "object" && first && typeof first.consentPurpose != "undefined") {
      _request = consentPurpose;
      _options = webapi_options;
    } else {
      _request = {
        consentPurpose
      };
      _options = webapi_options;
    }
    return this._saveConsentPurposeAsync(_request, _options);
  }
  async _setEmarketingStrictModeAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetEmarketingStrictMode", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setEmarketingStrictModeAsync(enable, webapi_options) {
    let _request = null;
    let _options = null;
    const first = enable;
    if (typeof first === "object" && first && typeof first.enable != "undefined") {
      _request = enable;
      _options = webapi_options;
    } else {
      _request = {
        enable
      };
      _options = webapi_options;
    }
    return this._setEmarketingStrictModeAsync(_request, _options);
  }
  async _getEmarketingStrictModeAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetEmarketingStrictMode", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Get the value of the Emarketing strict mode setting
   * @returns Returns true if Emarkerint strict mode is set, false otherwise
   */
  async getEmarketingStrictModeAsync(webapi_options) {
    return this._getEmarketingStrictModeAsync(webapi_options);
  }
  /*
   * Gets an array of ConsentPurpose objects.
   * @param consentPurposeIds - The primary keys.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns An array of ConsentPurpose
   */
  async getConsentPurposeListAsync(consentPurposeIds, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetConsentPurposeList", consentPurposeIds, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ConsentPurposeArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getConsentPurposesAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetConsentPurposes", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ConsentPurposeArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Returns all defined purposes.
   * @returns An array of all defined purposes
   */
  async getConsentPurposesAsync(webapi_options) {
    return this._getConsentPurposesAsync(webapi_options);
  }
  /*
   * Gets a ConsentSource object.
   * @param consentSourceId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single ConsentSource
   */
  async getConsentSourceAsync(consentSourceId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetConsentSource?consentSourceId=" + consentSourceId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ConsentSource_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _saveConsentSourceAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveConsentSource", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ConsentSource_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveConsentSourceAsync(consentSource, webapi_options) {
    let _request = null;
    let _options = null;
    const first = consentSource;
    if (typeof first === "object" && first && typeof first.consentSource != "undefined") {
      _request = consentSource;
      _options = webapi_options;
    } else {
      _request = {
        consentSource
      };
      _options = webapi_options;
    }
    return this._saveConsentSourceAsync(_request, _options);
  }
  /*
   * Gets an array of ConsentSource objects.
   * @param consentSourceIds - The primary keys.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns An array of ConsentSource
   */
  async getConsentSourceListAsync(consentSourceIds, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetConsentSourceList", consentSourceIds, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ConsentSourceArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getConsentSourcesAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetConsentSources", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ConsentSourceArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Returns all defined Sources.
   * @returns An array of all defined Sources
   */
  async getConsentSourcesAsync(webapi_options) {
    return this._getConsentSourcesAsync(webapi_options);
  }
  /*
   * Gets a Country object.
   * @param countryId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single Country
   */
  async getCountryAsync(countryId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetCountry?countryId=" + countryId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Country_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _saveCountryAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveCountry", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Country_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveCountryAsync(country, webapi_options) {
    let _request = null;
    let _options = null;
    const first = country;
    if (typeof first === "object" && first && typeof first.country != "undefined") {
      _request = country;
      _options = webapi_options;
    } else {
      _request = {
        country
      };
      _options = webapi_options;
    }
    return this._saveCountryAsync(_request, _options);
  }
  async _createDefaultCountryAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateDefaultCountry", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Country_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Gets a new country
   * @returns A new country with default values
   */
  async createDefaultCountryAsync(webapi_options) {
    return this._createDefaultCountryAsync(webapi_options);
  }
  /*
   * Gets an array of Country objects.
   * @param countryIds - The primary keys.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns An array of Country
   */
  async getCountryListAsync(countryIds, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetCountryList", countryIds, config);
        WebApiBase.SetCompleted(options);
        const res = Create_CountryArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getCountriesAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetCountries", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_CountryArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Returns all available countries a contact or person could belong to.
   * @returns An array of all available countries
   */
  async getCountriesAsync(webapi_options) {
    return this._getCountriesAsync(webapi_options);
  }
  async _getAllCountriesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetAllCountries", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_CountryArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getAllCountriesAsync(includeDeleted, webapi_options) {
    let _request = null;
    let _options = null;
    const first = includeDeleted;
    if (typeof first === "object" && first && typeof first.includeDeleted != "undefined") {
      _request = includeDeleted;
      _options = webapi_options;
    } else {
      _request = {
        includeDeleted
      };
      _options = webapi_options;
    }
    return this._getAllCountriesAsync(_request, _options);
  }
  /*
   * Gets a Credited object.
   * @param creditedId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single Credited
   */
  async getCreditedAsync(creditedId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetCredited?creditedId=" + creditedId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Credited_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets an array of Credited objects.
   * @param creditedIds - The primary keys.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns An array of Credited
   */
  async getCreditedListAsync(creditedIds, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetCreditedList", creditedIds, config);
        WebApiBase.SetCompleted(options);
        const res = Create_CreditedArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getCreditedsAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetCrediteds", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_CreditedArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Returns all credited
   * @returns
   */
  async getCreditedsAsync(webapi_options) {
    return this._getCreditedsAsync(webapi_options);
  }
  /*
   * Gets a Currency object.
   * @param currencyId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single Currency
   */
  async getCurrencyAsync(currencyId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetCurrency?currencyId=" + currencyId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Currency_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getOurCurrencyAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetOurCurrency", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Currency_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Gets the Our currency object if currency is enabled
   * @returns Our currency
   */
  async getOurCurrencyAsync(webapi_options) {
    return this._getOurCurrencyAsync(webapi_options);
  }
  async _changeCurrencyAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ChangeCurrency", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async changeCurrencyAsync(amount, fromCurrency, toCurrency, webapi_options) {
    let _request = null;
    let _options = null;
    const first = amount;
    if (typeof first === "object" && first && (typeof first.amount != "undefined" || typeof first.fromCurrency != "undefined" || typeof first.toCurrency != "undefined")) {
      _request = amount;
      _options = fromCurrency;
    } else {
      _request = {
        amount,
        fromCurrency,
        toCurrency
      };
      _options = webapi_options;
    }
    return this._changeCurrencyAsync(_request, _options);
  }
  async _getOwnerCompanysCurrencyAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetOwnerCompanysCurrency", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Currency_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Get the currency of the user&apos;s owner company
   * @returns Currency of the user's owner company
   */
  async getOwnerCompanysCurrencyAsync(webapi_options) {
    return this._getOwnerCompanysCurrencyAsync(webapi_options);
  }
  /*
   * Gets a CurrencyEntity object.
   * @param currencyEntityId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single CurrencyEntity
   */
  async getCurrencyEntityAsync(currencyEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetCurrencyEntity?currencyEntityId=" + currencyEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_CurrencyEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getBaseCurrencyAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetBaseCurrency", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_CurrencyEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Get the base currency, used for calculating exchange rates
   * @returns The base currency that other currencies are expressed in terms of
   */
  async getBaseCurrencyAsync(webapi_options) {
    return this._getBaseCurrencyAsync(webapi_options);
  }
  /*
   * Gets an array of Currency objects.
   * @param currencyIds - The primary keys.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns An array of Currency
   */
  async getCurrencyListAsync(currencyIds, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetCurrencyList", currencyIds, config);
        WebApiBase.SetCompleted(options);
        const res = Create_CurrencyArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getCurrenciesAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetCurrencies", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_CurrencyArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Returns all currencies
   * @returns Array of currencies
   */
  async getCurrenciesAsync(webapi_options) {
    return this._getCurrenciesAsync(webapi_options);
  }
  async _getAllCurrenciesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetAllCurrencies", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_CurrencyEntityArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getAllCurrenciesAsync(includeDeleted, webapi_options) {
    let _request = null;
    let _options = null;
    const first = includeDeleted;
    if (typeof first === "object" && first && typeof first.includeDeleted != "undefined") {
      _request = includeDeleted;
      _options = webapi_options;
    } else {
      _request = {
        includeDeleted
      };
      _options = webapi_options;
    }
    return this._getAllCurrenciesAsync(_request, _options);
  }
  /*
   * Gets a CustomerLanguage object.
   * @param customerLanguageId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single CustomerLanguage
   */
  async getCustomerLanguageAsync(customerLanguageId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetCustomerLanguage?customerLanguageId=" + customerLanguageId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_CustomerLanguage_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets an array of CustomerLanguage objects.
   * @param customerLanguageIds - The primary keys.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns An array of CustomerLanguage
   */
  async getCustomerLanguageListAsync(customerLanguageIds, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetCustomerLanguageList", customerLanguageIds, config);
        WebApiBase.SetCompleted(options);
        const res = Create_CustomerLanguageArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getCustomerLanguagesAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetCustomerLanguages", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_CustomerLanguageArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   *
   * @returns
   */
  async getCustomerLanguagesAsync(webapi_options) {
    return this._getCustomerLanguagesAsync(webapi_options);
  }
  /*
   * Gets a DeliveryTerm object.
   * @param deliveryTermId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single DeliveryTerm
   */
  async getDeliveryTermAsync(deliveryTermId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetDeliveryTerm?deliveryTermId=" + deliveryTermId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DeliveryTerm_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getDeliveryTermsAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetDeliveryTerms", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DeliveryTermArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Returns all DeliveryTerms in SuperOffice db.
   * @returns An array of all available DeliveryTerms
   */
  async getDeliveryTermsAsync(webapi_options) {
    return this._getDeliveryTermsAsync(webapi_options);
  }
  /*
   * Gets a DeliveryType object.
   * @param deliveryTypeId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single DeliveryType
   */
  async getDeliveryTypeAsync(deliveryTypeId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetDeliveryType?deliveryTypeId=" + deliveryTypeId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DeliveryType_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getDeliveryTypesAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetDeliveryTypes", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DeliveryTypeArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Returns all DeliveryTypes in SuperOffice db.
   * @returns An array of all available DeliveryType
   */
  async getDeliveryTypesAsync(webapi_options) {
    return this._getDeliveryTypesAsync(webapi_options);
  }
  /*
   * Gets a Department object.
   * @param departmentId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single Department
   */
  async getDepartmentAsync(departmentId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetDepartment?departmentId=" + departmentId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Department_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets an array of Department objects.
   * @param departmentIds - The primary keys.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns An array of Department
   */
  async getDepartmentListAsync(departmentIds, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetDepartmentList", departmentIds, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DepartmentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getDepartmentsAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetDepartments", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DepartmentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Getting all departments/user groups for the internal phone list with the user&apos;s colleagues.
   * @returns Returns all departments.
   */
  async getDepartmentsAsync(webapi_options) {
    return this._getDepartmentsAsync(webapi_options);
  }
  /*
   * Gets a DocumentTemplate object.
   * @param documentTemplateId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single DocumentTemplate
   */
  async getDocumentTemplateAsync(documentTemplateId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetDocumentTemplate?documentTemplateId=" + documentTemplateId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DocumentTemplate_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets a DocumentTemplateEntity object.
   * @param documentTemplateEntityId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single DocumentTemplateEntity
   */
  async getDocumentTemplateEntityAsync(documentTemplateEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetDocumentTemplateEntity?documentTemplateEntityId=" + documentTemplateEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DocumentTemplateEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _setDocumentTemplateStreamAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetDocumentTemplateStream", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DocumentTemplateEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setDocumentTemplateStreamAsync(documentTemplateEntity, stream, languageCode, pluginId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = documentTemplateEntity;
    if (typeof first === "object" && first && (typeof first.documentTemplateEntity != "undefined" || typeof first.stream != "undefined" || typeof first.languageCode != "undefined" || typeof first.pluginId != "undefined")) {
      _request = documentTemplateEntity;
      _options = stream;
    } else {
      _request = {
        documentTemplateEntity,
        stream,
        languageCode,
        pluginId
      };
      _options = webapi_options;
    }
    _request.stream = ToBase64(_request.stream);
    return this._setDocumentTemplateStreamAsync(_request, _options);
  }
  async _getDocumentTemplateUsedInSalesStageAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetDocumentTemplateUsedInSalesStage", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getDocumentTemplateUsedInSalesStageAsync(documentTemplateId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = documentTemplateId;
    if (typeof first === "object" && first && typeof first.documentTemplateId != "undefined") {
      _request = documentTemplateId;
      _options = webapi_options;
    } else {
      _request = {
        documentTemplateId
      };
      _options = webapi_options;
    }
    return this._getDocumentTemplateUsedInSalesStageAsync(_request, _options);
  }
  async _getDocumentTemplateUsedInProjectStageAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetDocumentTemplateUsedInProjectStage", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getDocumentTemplateUsedInProjectStageAsync(documentTemplateId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = documentTemplateId;
    if (typeof first === "object" && first && typeof first.documentTemplateId != "undefined") {
      _request = documentTemplateId;
      _options = webapi_options;
    } else {
      _request = {
        documentTemplateId
      };
      _options = webapi_options;
    }
    return this._getDocumentTemplateUsedInProjectStageAsync(_request, _options);
  }
  async _getDocumentTemplateUrlAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetDocumentTemplateUrl", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getDocumentTemplateUrlAsync(documentTemplateId, writableUrl, languageCode, webapi_options) {
    let _request = null;
    let _options = null;
    const first = documentTemplateId;
    if (typeof first === "object" && first && (typeof first.documentTemplateId != "undefined" || typeof first.writableUrl != "undefined" || typeof first.languageCode != "undefined")) {
      _request = documentTemplateId;
      _options = writableUrl;
    } else {
      _request = {
        documentTemplateId,
        writableUrl,
        languageCode
      };
      _options = webapi_options;
    }
    return this._getDocumentTemplateUrlAsync(_request, _options);
  }
  async _getDocumentTemplatePropertiesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetDocumentTemplateProperties", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_StringDictionary_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getDocumentTemplatePropertiesAsync(documentTemplateId, requestedProperties, webapi_options) {
    let _request = null;
    let _options = null;
    const first = documentTemplateId;
    if (typeof first === "object" && first && (typeof first.documentTemplateId != "undefined" || typeof first.requestedProperties != "undefined")) {
      _request = documentTemplateId;
      _options = requestedProperties;
    } else {
      _request = {
        documentTemplateId,
        requestedProperties
      };
      _options = webapi_options;
    }
    return this._getDocumentTemplatePropertiesAsync(_request, _options);
  }
  async _getDocumentTemplateLanguagesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetDocumentTemplateLanguages", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getDocumentTemplateLanguagesAsync(documentTemplateId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = documentTemplateId;
    if (typeof first === "object" && first && typeof first.documentTemplateId != "undefined") {
      _request = documentTemplateId;
      _options = webapi_options;
    } else {
      _request = {
        documentTemplateId
      };
      _options = webapi_options;
    }
    return this._getDocumentTemplateLanguagesAsync(_request, _options);
  }
  async _createDefaultDocumentTemplateLanguageAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateDefaultDocumentTemplateLanguage", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createDefaultDocumentTemplateLanguageAsync(documentTemplateId, languageCode, webapi_options) {
    let _request = null;
    let _options = null;
    const first = documentTemplateId;
    if (typeof first === "object" && first && (typeof first.documentTemplateId != "undefined" || typeof first.languageCode != "undefined")) {
      _request = documentTemplateId;
      _options = languageCode;
    } else {
      _request = {
        documentTemplateId,
        languageCode
      };
      _options = webapi_options;
    }
    return this._createDefaultDocumentTemplateLanguageAsync(_request, _options);
  }
  async _deleteDocumentTemplateLanguageAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeleteDocumentTemplateLanguage", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async deleteDocumentTemplateLanguageAsync(documentTemplateId, languageCode, webapi_options) {
    let _request = null;
    let _options = null;
    const first = documentTemplateId;
    if (typeof first === "object" && first && (typeof first.documentTemplateId != "undefined" || typeof first.languageCode != "undefined")) {
      _request = documentTemplateId;
      _options = languageCode;
    } else {
      _request = {
        documentTemplateId,
        languageCode
      };
      _options = webapi_options;
    }
    return this._deleteDocumentTemplateLanguageAsync(_request, _options);
  }
  async _getDocumentTemplateExtensionAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetDocumentTemplateExtension", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getDocumentTemplateExtensionAsync(documentTemplateId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = documentTemplateId;
    if (typeof first === "object" && first && typeof first.documentTemplateId != "undefined") {
      _request = documentTemplateId;
      _options = webapi_options;
    } else {
      _request = {
        documentTemplateId
      };
      _options = webapi_options;
    }
    return this._getDocumentTemplateExtensionAsync(_request, _options);
  }
  async _setDocumentTemplateFromDocumentTemplateAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetDocumentTemplateFromDocumentTemplate", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DocumentTemplateEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setDocumentTemplateFromDocumentTemplateAsync(sourceDocumentTemplateId, documentTemplateEntity, webapi_options) {
    let _request = null;
    let _options = null;
    const first = sourceDocumentTemplateId;
    if (typeof first === "object" && first && (typeof first.sourceDocumentTemplateId != "undefined" || typeof first.documentTemplateEntity != "undefined")) {
      _request = sourceDocumentTemplateId;
      _options = documentTemplateEntity;
    } else {
      _request = {
        sourceDocumentTemplateId,
        documentTemplateEntity
      };
      _options = webapi_options;
    }
    return this._setDocumentTemplateFromDocumentTemplateAsync(_request, _options);
  }
  async _getDocumentTemplateStreamFromIdAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        if (!options || options.returnBlobAs == ReturnBlobType.AsArrayBuffer) {
          config.responseType = "arraybuffer";
          config.headers = config.headers || {};
          config.headers["Accept"] = "application/octet-stream";
        }
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetDocumentTemplateStreamFromId", request, config);
        WebApiBase.SetCompleted(options);
        let res = null;
        if (options && options.returnBlobAs != ReturnBlobType.AsArrayBuffer) {
          res = response.data;
          if (options.returnBlobAs == ReturnBlobType.AsString) {
            res = FromBase64ToString(res);
          }
        } else {
          res = response.data;
        }
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getDocumentTemplateStreamFromIdAsync(documentTemplateId, languageCode, webapi_options) {
    let _request = null;
    let _options = null;
    const first = documentTemplateId;
    if (typeof first === "object" && first && (typeof first.documentTemplateId != "undefined" || typeof first.languageCode != "undefined")) {
      _request = documentTemplateId;
      _options = languageCode;
    } else {
      _request = {
        documentTemplateId,
        languageCode
      };
      _options = webapi_options;
    }
    return this._getDocumentTemplateStreamFromIdAsync(_request, _options);
  }
  async _saveDocumentTemplateStreamAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveDocumentTemplateStream", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TemplateInfo_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveDocumentTemplateStreamAsync(documentTemplateId, content, languageCode, pluginId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = documentTemplateId;
    if (typeof first === "object" && first && (typeof first.documentTemplateId != "undefined" || typeof first.content != "undefined" || typeof first.languageCode != "undefined" || typeof first.pluginId != "undefined")) {
      _request = documentTemplateId;
      _options = content;
    } else {
      _request = {
        documentTemplateId,
        content,
        languageCode,
        pluginId
      };
      _options = webapi_options;
    }
    _request.content = ToBase64(_request.content);
    return this._saveDocumentTemplateStreamAsync(_request, _options);
  }
  async _getPluginListAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPluginList", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_StringDictionary_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Get a list of installed document plugins
   * @returns Dictionary mapping plugin id=plugin name
   */
  async getPluginListAsync(webapi_options) {
    return this._getPluginListAsync(webapi_options);
  }
  async _getPluginCapabilitiesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPluginCapabilities", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_StringDictionary_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getPluginCapabilitiesAsync(pluginId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = pluginId;
    if (typeof first === "object" && first && typeof first.pluginId != "undefined") {
      _request = pluginId;
      _options = webapi_options;
    } else {
      _request = {
        pluginId
      };
      _options = webapi_options;
    }
    return this._getPluginCapabilitiesAsync(_request, _options);
  }
  async _getDocumentTypesForPluginAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetDocumentTypesForPlugin", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_IntStringDictionary_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getDocumentTypesForPluginAsync(pluginId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = pluginId;
    if (typeof first === "object" && first && typeof first.pluginId != "undefined") {
      _request = pluginId;
      _options = webapi_options;
    } else {
      _request = {
        pluginId
      };
      _options = webapi_options;
    }
    return this._getDocumentTypesForPluginAsync(_request, _options);
  }
  /*
   * Gets an array of DocumentTemplate objects.
   * @param documentTemplateIds - The primary keys.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns An array of DocumentTemplate
   */
  async getDocumentTemplateListAsync(documentTemplateIds, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetDocumentTemplateList", documentTemplateIds, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DocumentTemplateArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getDocumentTemplatesAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetDocumentTemplates", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DocumentTemplateArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Returns all available document templates
   * @returns Array of DocumentTemplates
   */
  async getDocumentTemplatesAsync(webapi_options) {
    return this._getDocumentTemplatesAsync(webapi_options);
  }
  async _getAllDocumentTemplatesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetAllDocumentTemplates", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DocumentTemplateEntityArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getAllDocumentTemplatesAsync(includeDeleted, webapi_options) {
    let _request = null;
    let _options = null;
    const first = includeDeleted;
    if (typeof first === "object" && first && typeof first.includeDeleted != "undefined") {
      _request = includeDeleted;
      _options = webapi_options;
    } else {
      _request = {
        includeDeleted
      };
      _options = webapi_options;
    }
    return this._getAllDocumentTemplatesAsync(_request, _options);
  }
  async _setDocumentPluginForAllDocumentTemplatesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetDocumentPluginForAllDocumentTemplates", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setDocumentPluginForAllDocumentTemplatesAsync(documentPluginId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = documentPluginId;
    if (typeof first === "object" && first && typeof first.documentPluginId != "undefined") {
      _request = documentPluginId;
      _options = webapi_options;
    } else {
      _request = {
        documentPluginId
      };
      _options = webapi_options;
    }
    return this._setDocumentPluginForAllDocumentTemplatesAsync(_request, _options);
  }
  /*
   * Gets a ExtAppEntity object.
   * @param extAppEntityId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single ExtAppEntity
   */
  async getExtAppEntityAsync(extAppEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetExtAppEntity?extAppEntityId=" + extAppEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ExtAppEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets a HeadingEntity object.
   * @param headingEntityId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single HeadingEntity
   */
  async getHeadingEntityAsync(headingEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetHeadingEntity?headingEntityId=" + headingEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_HeadingEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _createDefaultHeadingFromListDefinitionAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateDefaultHeadingFromListDefinition", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_HeadingEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createDefaultHeadingFromListDefinitionAsync(udListDefinitionId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = udListDefinitionId;
    if (typeof first === "object" && first && typeof first.udListDefinitionId != "undefined") {
      _request = udListDefinitionId;
      _options = webapi_options;
    } else {
      _request = {
        udListDefinitionId
      };
      _options = webapi_options;
    }
    return this._createDefaultHeadingFromListDefinitionAsync(_request, _options);
  }
  /*
   * Gets a HierarchyEntity object.
   * @param hierarchyEntityId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single HierarchyEntity
   */
  async getHierarchyEntityAsync(hierarchyEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetHierarchyEntity?hierarchyEntityId=" + hierarchyEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_HierarchyEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getAllDomainsAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetAllDomains", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Get list of all domains
   * @returns Domain types (scripts, extra tables, etc)
   */
  async getAllDomainsAsync(webapi_options) {
    return this._getAllDomainsAsync(webapi_options);
  }
  async _getAllInDomainAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetAllInDomain", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_HierarchyEntityArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getAllInDomainAsync(domain, children, webapi_options) {
    let _request = null;
    let _options = null;
    const first = domain;
    if (typeof first === "object" && first && (typeof first.domain != "undefined" || typeof first.children != "undefined")) {
      _request = domain;
      _options = children;
    } else {
      _request = {
        domain,
        children
      };
      _options = webapi_options;
    }
    return this._getAllInDomainAsync(_request, _options);
  }
  async _getHierarchyFromPathAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetHierarchyFromPath", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_HierarchyEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getHierarchyFromPathAsync(domain, path, children, webapi_options) {
    let _request = null;
    let _options = null;
    const first = domain;
    if (typeof first === "object" && first && (typeof first.domain != "undefined" || typeof first.path != "undefined" || typeof first.children != "undefined")) {
      _request = domain;
      _options = path;
    } else {
      _request = {
        domain,
        path,
        children
      };
      _options = webapi_options;
    }
    return this._getHierarchyFromPathAsync(_request, _options);
  }
  async _addHierarchyToPathAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("AddHierarchyToPath", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_HierarchyEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async addHierarchyToPathAsync(domain, path, name, webapi_options) {
    let _request = null;
    let _options = null;
    const first = domain;
    if (typeof first === "object" && first && (typeof first.domain != "undefined" || typeof first.path != "undefined" || typeof first.name != "undefined")) {
      _request = domain;
      _options = path;
    } else {
      _request = {
        domain,
        path,
        name
      };
      _options = webapi_options;
    }
    return this._addHierarchyToPathAsync(_request, _options);
  }
  async _updateHierarchyFromPathAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("UpdateHierarchyFromPath", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_HierarchyEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async updateHierarchyFromPathAsync(domain, path, entity, webapi_options) {
    let _request = null;
    let _options = null;
    const first = domain;
    if (typeof first === "object" && first && (typeof first.domain != "undefined" || typeof first.path != "undefined" || typeof first.entity != "undefined")) {
      _request = domain;
      _options = path;
    } else {
      _request = {
        domain,
        path,
        entity
      };
      _options = webapi_options;
    }
    return this._updateHierarchyFromPathAsync(_request, _options);
  }
  async _deleteHierarchyFromPathAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeleteHierarchyFromPath", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async deleteHierarchyFromPathAsync(domain, path, webapi_options) {
    let _request = null;
    let _options = null;
    const first = domain;
    if (typeof first === "object" && first && (typeof first.domain != "undefined" || typeof first.path != "undefined")) {
      _request = domain;
      _options = path;
    } else {
      _request = {
        domain,
        path
      };
      _options = webapi_options;
    }
    return this._deleteHierarchyFromPathAsync(_request, _options);
  }
  /*
   * Gets a LanguageInfo object.
   * @param languageInfoId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single LanguageInfo
   */
  async getLanguageInfoAsync(languageInfoId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetLanguageInfo?languageInfoId=" + languageInfoId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_LanguageInfo_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets an array of LanguageInfo objects.
   * @param languageInfoIds - The primary keys.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns An array of LanguageInfo
   */
  async getLanguageInfoListAsync(languageInfoIds, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetLanguageInfoList", languageInfoIds, config);
        WebApiBase.SetCompleted(options);
        const res = Create_LanguageInfoArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getInstalledLanguagesAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetInstalledLanguages", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_LanguageInfoArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Returns the list of all languages installed in this database.
   * @returns Array of installed languages
   */
  async getInstalledLanguagesAsync(webapi_options) {
    return this._getInstalledLanguagesAsync(webapi_options);
  }
  /*
   * Gets a LegalBase object.
   * @param legalBaseId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single LegalBase
   */
  async getLegalBaseAsync(legalBaseId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetLegalBase?legalBaseId=" + legalBaseId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_LegalBase_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _saveLegalBaseAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveLegalBase", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_LegalBase_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveLegalBaseAsync(legalBase, webapi_options) {
    let _request = null;
    let _options = null;
    const first = legalBase;
    if (typeof first === "object" && first && typeof first.legalBase != "undefined") {
      _request = legalBase;
      _options = webapi_options;
    } else {
      _request = {
        legalBase
      };
      _options = webapi_options;
    }
    return this._saveLegalBaseAsync(_request, _options);
  }
  /*
   * Gets an array of LegalBase objects.
   * @param legalBaseIds - The primary keys.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns An array of LegalBase
   */
  async getLegalBaseListAsync(legalBaseIds, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetLegalBaseList", legalBaseIds, config);
        WebApiBase.SetCompleted(options);
        const res = Create_LegalBaseArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getLegalBasesAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetLegalBases", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_LegalBaseArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Returns all defined bases.
   * @returns An array of all defined bases
   */
  async getLegalBasesAsync(webapi_options) {
    return this._getLegalBasesAsync(webapi_options);
  }
  /*
   * Gets a Link object.
   * @param linkId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single Link
   */
  async getLinkAsync(linkId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetLink?linkId=" + linkId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Link_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets an array of Link objects.
   * @param linkIds - The primary keys.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns An array of Link
   */
  async getLinkListAsync(linkIds, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetLinkList", linkIds, config);
        WebApiBase.SetCompleted(options);
        const res = Create_LinkArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets a ListEntity object.
   * @param listEntityId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single ListEntity
   */
  async getListEntityAsync(listEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetListEntity?listEntityId=" + listEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ListEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getListDefinitionsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetListDefinitions", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ListEntityArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getListDefinitionsAsync(includeDeleted, webapi_options) {
    let _request = null;
    let _options = null;
    const first = includeDeleted;
    if (typeof first === "object" && first && typeof first.includeDeleted != "undefined") {
      _request = includeDeleted;
      _options = webapi_options;
    } else {
      _request = {
        includeDeleted
      };
      _options = webapi_options;
    }
    return this._getListDefinitionsAsync(_request, _options);
  }
  async _getListEntityByNameAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetListEntityByName", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ListEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getListEntityByNameAsync(name, webapi_options) {
    let _request = null;
    let _options = null;
    const first = name;
    if (typeof first === "object" && first && typeof first.name != "undefined") {
      _request = name;
      _options = webapi_options;
    } else {
      _request = {
        name
      };
      _options = webapi_options;
    }
    return this._getListEntityByNameAsync(_request, _options);
  }
  async _saveListEntityByNameAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveListEntityByName", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ListEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveListEntityByNameAsync(name, listEntity, webapi_options) {
    let _request = null;
    let _options = null;
    const first = name;
    if (typeof first === "object" && first && (typeof first.name != "undefined" || typeof first.listEntity != "undefined")) {
      _request = name;
      _options = listEntity;
    } else {
      _request = {
        name,
        listEntity
      };
      _options = webapi_options;
    }
    return this._saveListEntityByNameAsync(_request, _options);
  }
  async _deleteListEntityByNameAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeleteListEntityByName", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async deleteListEntityByNameAsync(name, webapi_options) {
    let _request = null;
    let _options = null;
    const first = name;
    if (typeof first === "object" && first && typeof first.name != "undefined") {
      _request = name;
      _options = webapi_options;
    } else {
      _request = {
        name
      };
      _options = webapi_options;
    }
    return this._deleteListEntityByNameAsync(_request, _options);
  }
  async _saveListItemEntityAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveListItemEntity", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ListItemEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveListItemEntityAsync(listItemEntity, webapi_options) {
    let _request = null;
    let _options = null;
    const first = listItemEntity;
    if (typeof first === "object" && first && typeof first.listItemEntity != "undefined") {
      _request = listItemEntity;
      _options = webapi_options;
    } else {
      _request = {
        listItemEntity
      };
      _options = webapi_options;
    }
    return this._saveListItemEntityAsync(_request, _options);
  }
  async _sortListItemsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SortListItems", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async sortListItemsAsync(udListDefinitionId, cultureName, webapi_options) {
    let _request = null;
    let _options = null;
    const first = udListDefinitionId;
    if (typeof first === "object" && first && (typeof first.udListDefinitionId != "undefined" || typeof first.cultureName != "undefined")) {
      _request = udListDefinitionId;
      _options = cultureName;
    } else {
      _request = {
        udListDefinitionId,
        cultureName
      };
      _options = webapi_options;
    }
    return this._sortListItemsAsync(_request, _options);
  }
  async _moveListItemAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("MoveListItem", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async moveListItemAsync(udListDefinitionId, listItemId, direction, webapi_options) {
    let _request = null;
    let _options = null;
    const first = udListDefinitionId;
    if (typeof first === "object" && first && (typeof first.udListDefinitionId != "undefined" || typeof first.listItemId != "undefined" || typeof first.direction != "undefined")) {
      _request = udListDefinitionId;
      _options = listItemId;
    } else {
      _request = {
        udListDefinitionId,
        listItemId,
        direction
      };
      _options = webapi_options;
    }
    return this._moveListItemAsync(_request, _options);
  }
  async _getVisibleForUserGroupsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetVisibleForUserGroups", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SelectableMDOListItemArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getVisibleForUserGroupsAsync(udListDefinitionId, listItemId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = udListDefinitionId;
    if (typeof first === "object" && first && (typeof first.udListDefinitionId != "undefined" || typeof first.listItemId != "undefined")) {
      _request = udListDefinitionId;
      _options = listItemId;
    } else {
      _request = {
        udListDefinitionId,
        listItemId
      };
      _options = webapi_options;
    }
    return this._getVisibleForUserGroupsAsync(_request, _options);
  }
  async _getVisibleForUserGroupsFromListNameAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetVisibleForUserGroupsFromListName", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SelectableMDOListItemArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getVisibleForUserGroupsFromListNameAsync(udListDefinitionName, listItemId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = udListDefinitionName;
    if (typeof first === "object" && first && (typeof first.udListDefinitionName != "undefined" || typeof first.listItemId != "undefined")) {
      _request = udListDefinitionName;
      _options = listItemId;
    } else {
      _request = {
        udListDefinitionName,
        listItemId
      };
      _options = webapi_options;
    }
    return this._getVisibleForUserGroupsFromListNameAsync(_request, _options);
  }
  async _setVisibleForUserGroupsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetVisibleForUserGroups", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SelectableMDOListItemArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setVisibleForUserGroupsAsync(udListDefinitionId, listItemId, userGroups, webapi_options) {
    let _request = null;
    let _options = null;
    const first = udListDefinitionId;
    if (typeof first === "object" && first && (typeof first.udListDefinitionId != "undefined" || typeof first.listItemId != "undefined" || typeof first.userGroups != "undefined")) {
      _request = udListDefinitionId;
      _options = listItemId;
    } else {
      _request = {
        udListDefinitionId,
        listItemId,
        userGroups
      };
      _options = webapi_options;
    }
    return this._setVisibleForUserGroupsAsync(_request, _options);
  }
  async _setVisibleForUserGroupsFromListNameAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetVisibleForUserGroupsFromListName", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SelectableMDOListItemArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setVisibleForUserGroupsFromListNameAsync(udListDefinitionName, listItemId, userGroups, webapi_options) {
    let _request = null;
    let _options = null;
    const first = udListDefinitionName;
    if (typeof first === "object" && first && (typeof first.udListDefinitionName != "undefined" || typeof first.listItemId != "undefined" || typeof first.userGroups != "undefined")) {
      _request = udListDefinitionName;
      _options = listItemId;
    } else {
      _request = {
        udListDefinitionName,
        listItemId,
        userGroups
      };
      _options = webapi_options;
    }
    return this._setVisibleForUserGroupsFromListNameAsync(_request, _options);
  }
  async _setVisibleForUserGroupAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetVisibleForUserGroup", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setVisibleForUserGroupAsync(udListDefinitionId, listItemId, userGroupId, enable, webapi_options) {
    let _request = null;
    let _options = null;
    const first = udListDefinitionId;
    if (typeof first === "object" && first && (typeof first.udListDefinitionId != "undefined" || typeof first.listItemId != "undefined" || typeof first.userGroupId != "undefined" || typeof first.enable != "undefined")) {
      _request = udListDefinitionId;
      _options = listItemId;
    } else {
      _request = {
        udListDefinitionId,
        listItemId,
        userGroupId,
        enable
      };
      _options = webapi_options;
    }
    return this._setVisibleForUserGroupAsync(_request, _options);
  }
  async _getListItemsForUserGroupAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetListItemsForUserGroup", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SelectableMDOListItemArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getListItemsForUserGroupAsync(udListDefinitionId, groupId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = udListDefinitionId;
    if (typeof first === "object" && first && (typeof first.udListDefinitionId != "undefined" || typeof first.groupId != "undefined")) {
      _request = udListDefinitionId;
      _options = groupId;
    } else {
      _request = {
        udListDefinitionId,
        groupId
      };
      _options = webapi_options;
    }
    return this._getListItemsForUserGroupAsync(_request, _options);
  }
  async _getListItemsForUserGroupFromListNameAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetListItemsForUserGroupFromListName", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SelectableMDOListItemArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getListItemsForUserGroupFromListNameAsync(udListDefinitionName, groupId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = udListDefinitionName;
    if (typeof first === "object" && first && (typeof first.udListDefinitionName != "undefined" || typeof first.groupId != "undefined")) {
      _request = udListDefinitionName;
      _options = groupId;
    } else {
      _request = {
        udListDefinitionName,
        groupId
      };
      _options = webapi_options;
    }
    return this._getListItemsForUserGroupFromListNameAsync(_request, _options);
  }
  async _setListItemsForUserGroupAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetListItemsForUserGroup", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setListItemsForUserGroupAsync(udListDefinitionId, usergroupId, listItemIds, enable, webapi_options) {
    let _request = null;
    let _options = null;
    const first = udListDefinitionId;
    if (typeof first === "object" && first && (typeof first.udListDefinitionId != "undefined" || typeof first.usergroupId != "undefined" || typeof first.listItemIds != "undefined" || typeof first.enable != "undefined")) {
      _request = udListDefinitionId;
      _options = usergroupId;
    } else {
      _request = {
        udListDefinitionId,
        usergroupId,
        listItemIds,
        enable
      };
      _options = webapi_options;
    }
    return this._setListItemsForUserGroupAsync(_request, _options);
  }
  async _setListItemsForUserGroupFromListNameAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetListItemsForUserGroupFromListName", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setListItemsForUserGroupFromListNameAsync(udListDefinitionName, usergroupId, listItemsID, enable, webapi_options) {
    let _request = null;
    let _options = null;
    const first = udListDefinitionName;
    if (typeof first === "object" && first && (typeof first.udListDefinitionName != "undefined" || typeof first.usergroupId != "undefined" || typeof first.listItemsID != "undefined" || typeof first.enable != "undefined")) {
      _request = udListDefinitionName;
      _options = usergroupId;
    } else {
      _request = {
        udListDefinitionName,
        usergroupId,
        listItemsID,
        enable
      };
      _options = webapi_options;
    }
    return this._setListItemsForUserGroupFromListNameAsync(_request, _options);
  }
  async _getHeadingsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetHeadings", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SelectableMDOListItemArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getHeadingsAsync(udListDefinitionId, listItemId, showDeleted, webapi_options) {
    let _request = null;
    let _options = null;
    const first = udListDefinitionId;
    if (typeof first === "object" && first && (typeof first.udListDefinitionId != "undefined" || typeof first.listItemId != "undefined" || typeof first.showDeleted != "undefined")) {
      _request = udListDefinitionId;
      _options = listItemId;
    } else {
      _request = {
        udListDefinitionId,
        listItemId,
        showDeleted
      };
      _options = webapi_options;
    }
    return this._getHeadingsAsync(_request, _options);
  }
  async _getHeadingsForListItemFromListNameAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetHeadingsForListItemFromListName", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SelectableMDOListItemArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getHeadingsForListItemFromListNameAsync(udListDefinitionName, listItemId, showDeleted, webapi_options) {
    let _request = null;
    let _options = null;
    const first = udListDefinitionName;
    if (typeof first === "object" && first && (typeof first.udListDefinitionName != "undefined" || typeof first.listItemId != "undefined" || typeof first.showDeleted != "undefined")) {
      _request = udListDefinitionName;
      _options = listItemId;
    } else {
      _request = {
        udListDefinitionName,
        listItemId,
        showDeleted
      };
      _options = webapi_options;
    }
    return this._getHeadingsForListItemFromListNameAsync(_request, _options);
  }
  async _saveHeadingsForListItemFromListDefinitionAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveHeadingsForListItemFromListDefinition", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SelectableMDOListItemArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveHeadingsForListItemFromListDefinitionAsync(udListDefinitionId, listItemId, headings, webapi_options) {
    let _request = null;
    let _options = null;
    const first = udListDefinitionId;
    if (typeof first === "object" && first && (typeof first.udListDefinitionId != "undefined" || typeof first.listItemId != "undefined" || typeof first.headings != "undefined")) {
      _request = udListDefinitionId;
      _options = listItemId;
    } else {
      _request = {
        udListDefinitionId,
        listItemId,
        headings
      };
      _options = webapi_options;
    }
    return this._saveHeadingsForListItemFromListDefinitionAsync(_request, _options);
  }
  async _saveHeadingsForListItemFromListNameAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveHeadingsForListItemFromListName", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SelectableMDOListItemArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveHeadingsForListItemFromListNameAsync(udListDefinitionName, listItemId, headings, webapi_options) {
    let _request = null;
    let _options = null;
    const first = udListDefinitionName;
    if (typeof first === "object" && first && (typeof first.udListDefinitionName != "undefined" || typeof first.listItemId != "undefined" || typeof first.headings != "undefined")) {
      _request = udListDefinitionName;
      _options = listItemId;
    } else {
      _request = {
        udListDefinitionName,
        listItemId,
        headings
      };
      _options = webapi_options;
    }
    return this._saveHeadingsForListItemFromListNameAsync(_request, _options);
  }
  async _getListItemsForHeadingAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetListItemsForHeading", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SelectableMDOListItemArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getListItemsForHeadingAsync(udListDefinitionId, headingId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = udListDefinitionId;
    if (typeof first === "object" && first && (typeof first.udListDefinitionId != "undefined" || typeof first.headingId != "undefined")) {
      _request = udListDefinitionId;
      _options = headingId;
    } else {
      _request = {
        udListDefinitionId,
        headingId
      };
      _options = webapi_options;
    }
    return this._getListItemsForHeadingAsync(_request, _options);
  }
  async _getListItemsForHeadingFromListNameAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetListItemsForHeadingFromListName", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SelectableMDOListItemArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getListItemsForHeadingFromListNameAsync(udListDefinitionName, headingId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = udListDefinitionName;
    if (typeof first === "object" && first && (typeof first.udListDefinitionName != "undefined" || typeof first.headingId != "undefined")) {
      _request = udListDefinitionName;
      _options = headingId;
    } else {
      _request = {
        udListDefinitionName,
        headingId
      };
      _options = webapi_options;
    }
    return this._getListItemsForHeadingFromListNameAsync(_request, _options);
  }
  async _setListItemsForHeadingAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetListItemsForHeading", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setListItemsForHeadingAsync(udListDefinitionId, headingId, listItemIds, enable, webapi_options) {
    let _request = null;
    let _options = null;
    const first = udListDefinitionId;
    if (typeof first === "object" && first && (typeof first.udListDefinitionId != "undefined" || typeof first.headingId != "undefined" || typeof first.listItemIds != "undefined" || typeof first.enable != "undefined")) {
      _request = udListDefinitionId;
      _options = headingId;
    } else {
      _request = {
        udListDefinitionId,
        headingId,
        listItemIds,
        enable
      };
      _options = webapi_options;
    }
    return this._setListItemsForHeadingAsync(_request, _options);
  }
  async _setListItemsForHeadingFromListNameAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetListItemsForHeadingFromListName", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setListItemsForHeadingFromListNameAsync(udListDefinitionName, headingId, listItemIds, enable, webapi_options) {
    let _request = null;
    let _options = null;
    const first = udListDefinitionName;
    if (typeof first === "object" && first && (typeof first.udListDefinitionName != "undefined" || typeof first.headingId != "undefined" || typeof first.listItemIds != "undefined" || typeof first.enable != "undefined")) {
      _request = udListDefinitionName;
      _options = headingId;
    } else {
      _request = {
        udListDefinitionName,
        headingId,
        listItemIds,
        enable
      };
      _options = webapi_options;
    }
    return this._setListItemsForHeadingFromListNameAsync(_request, _options);
  }
  async _setHeadingsForListItemAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetHeadingsForListItem", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setHeadingsForListItemAsync(udListDefinitionId, listItemId, headingIds, enable, webapi_options) {
    let _request = null;
    let _options = null;
    const first = udListDefinitionId;
    if (typeof first === "object" && first && (typeof first.udListDefinitionId != "undefined" || typeof first.listItemId != "undefined" || typeof first.headingIds != "undefined" || typeof first.enable != "undefined")) {
      _request = udListDefinitionId;
      _options = listItemId;
    } else {
      _request = {
        udListDefinitionId,
        listItemId,
        headingIds,
        enable
      };
      _options = webapi_options;
    }
    return this._setHeadingsForListItemAsync(_request, _options);
  }
  async _setRankOnHeadingsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetRankOnHeadings", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setRankOnHeadingsAsync(udListDefinitionId, headingIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = udListDefinitionId;
    if (typeof first === "object" && first && (typeof first.udListDefinitionId != "undefined" || typeof first.headingIds != "undefined")) {
      _request = udListDefinitionId;
      _options = headingIds;
    } else {
      _request = {
        udListDefinitionId,
        headingIds
      };
      _options = webapi_options;
    }
    return this._setRankOnHeadingsAsync(_request, _options);
  }
  async _setRankOnSaleActivityAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetRankOnSaleActivity", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setRankOnSaleActivityAsync(saleTypeStageLinkId, itemsIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = saleTypeStageLinkId;
    if (typeof first === "object" && first && (typeof first.saleTypeStageLinkId != "undefined" || typeof first.itemsIds != "undefined")) {
      _request = saleTypeStageLinkId;
      _options = itemsIds;
    } else {
      _request = {
        saleTypeStageLinkId,
        itemsIds
      };
      _options = webapi_options;
    }
    return this._setRankOnSaleActivityAsync(_request, _options);
  }
  async _setRankOnSaleDocumentAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetRankOnSaleDocument", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setRankOnSaleDocumentAsync(saleTypeStageLinkId, itemsIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = saleTypeStageLinkId;
    if (typeof first === "object" && first && (typeof first.saleTypeStageLinkId != "undefined" || typeof first.itemsIds != "undefined")) {
      _request = saleTypeStageLinkId;
      _options = itemsIds;
    } else {
      _request = {
        saleTypeStageLinkId,
        itemsIds
      };
      _options = webapi_options;
    }
    return this._setRankOnSaleDocumentAsync(_request, _options);
  }
  async _setRankOnProjectActivityAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetRankOnProjectActivity", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setRankOnProjectActivityAsync(projectTypeStatusLinkId, itemsIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = projectTypeStatusLinkId;
    if (typeof first === "object" && first && (typeof first.projectTypeStatusLinkId != "undefined" || typeof first.itemsIds != "undefined")) {
      _request = projectTypeStatusLinkId;
      _options = itemsIds;
    } else {
      _request = {
        projectTypeStatusLinkId,
        itemsIds
      };
      _options = webapi_options;
    }
    return this._setRankOnProjectActivityAsync(_request, _options);
  }
  async _setRankOnProjectDocumentAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetRankOnProjectDocument", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setRankOnProjectDocumentAsync(projectTypeStatusLinkId, itemsIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = projectTypeStatusLinkId;
    if (typeof first === "object" && first && (typeof first.projectTypeStatusLinkId != "undefined" || typeof first.itemsIds != "undefined")) {
      _request = projectTypeStatusLinkId;
      _options = itemsIds;
    } else {
      _request = {
        projectTypeStatusLinkId,
        itemsIds
      };
      _options = webapi_options;
    }
    return this._setRankOnProjectDocumentAsync(_request, _options);
  }
  async _getAllFromListDefinitionAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetAllFromListDefinition", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ListItemEntityArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getAllFromListDefinitionAsync(udListDefinitionId, includeDeleted, webapi_options) {
    let _request = null;
    let _options = null;
    const first = udListDefinitionId;
    if (typeof first === "object" && first && (typeof first.udListDefinitionId != "undefined" || typeof first.includeDeleted != "undefined")) {
      _request = udListDefinitionId;
      _options = includeDeleted;
    } else {
      _request = {
        udListDefinitionId,
        includeDeleted
      };
      _options = webapi_options;
    }
    return this._getAllFromListDefinitionAsync(_request, _options);
  }
  async _getAllFromListNameAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetAllFromListName", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ListItemEntityArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getAllFromListNameAsync(udListDefinitionName, includeDeleted, webapi_options) {
    let _request = null;
    let _options = null;
    const first = udListDefinitionName;
    if (typeof first === "object" && first && (typeof first.udListDefinitionName != "undefined" || typeof first.includeDeleted != "undefined")) {
      _request = udListDefinitionName;
      _options = includeDeleted;
    } else {
      _request = {
        udListDefinitionName,
        includeDeleted
      };
      _options = webapi_options;
    }
    return this._getAllFromListNameAsync(_request, _options);
  }
  async _saveAllFromListDefinitionAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveAllFromListDefinition", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ListItemEntityArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveAllFromListDefinitionAsync(udListDefinitionId, items, webapi_options) {
    let _request = null;
    let _options = null;
    const first = udListDefinitionId;
    if (typeof first === "object" && first && (typeof first.udListDefinitionId != "undefined" || typeof first.items != "undefined")) {
      _request = udListDefinitionId;
      _options = items;
    } else {
      _request = {
        udListDefinitionId,
        items
      };
      _options = webapi_options;
    }
    return this._saveAllFromListDefinitionAsync(_request, _options);
  }
  async _saveAllFromListNameAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveAllFromListName", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ListItemEntityArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveAllFromListNameAsync(udListDefinitionName, items, webapi_options) {
    let _request = null;
    let _options = null;
    const first = udListDefinitionName;
    if (typeof first === "object" && first && (typeof first.udListDefinitionName != "undefined" || typeof first.items != "undefined")) {
      _request = udListDefinitionName;
      _options = items;
    } else {
      _request = {
        udListDefinitionName,
        items
      };
      _options = webapi_options;
    }
    return this._saveAllFromListNameAsync(_request, _options);
  }
  async _addFromListDefinitionAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("AddFromListDefinition", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ListItemEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async addFromListDefinitionAsync(udListDefinitionId, item, webapi_options) {
    let _request = null;
    let _options = null;
    const first = udListDefinitionId;
    if (typeof first === "object" && first && (typeof first.udListDefinitionId != "undefined" || typeof first.item != "undefined")) {
      _request = udListDefinitionId;
      _options = item;
    } else {
      _request = {
        udListDefinitionId,
        item
      };
      _options = webapi_options;
    }
    return this._addFromListDefinitionAsync(_request, _options);
  }
  async _addFromListNameAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("AddFromListName", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ListItemEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async addFromListNameAsync(udListDefinitionName, item, webapi_options) {
    let _request = null;
    let _options = null;
    const first = udListDefinitionName;
    if (typeof first === "object" && first && (typeof first.udListDefinitionName != "undefined" || typeof first.item != "undefined")) {
      _request = udListDefinitionName;
      _options = item;
    } else {
      _request = {
        udListDefinitionName,
        item
      };
      _options = webapi_options;
    }
    return this._addFromListNameAsync(_request, _options);
  }
  async _deleteAllFromListDefinitionAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeleteAllFromListDefinition", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async deleteAllFromListDefinitionAsync(udListDefinitionId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = udListDefinitionId;
    if (typeof first === "object" && first && typeof first.udListDefinitionId != "undefined") {
      _request = udListDefinitionId;
      _options = webapi_options;
    } else {
      _request = {
        udListDefinitionId
      };
      _options = webapi_options;
    }
    return this._deleteAllFromListDefinitionAsync(_request, _options);
  }
  async _deleteAllFromListNameAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeleteAllFromListName", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async deleteAllFromListNameAsync(udListDefinitionName, webapi_options) {
    let _request = null;
    let _options = null;
    const first = udListDefinitionName;
    if (typeof first === "object" && first && typeof first.udListDefinitionName != "undefined") {
      _request = udListDefinitionName;
      _options = webapi_options;
    } else {
      _request = {
        udListDefinitionName
      };
      _options = webapi_options;
    }
    return this._deleteAllFromListNameAsync(_request, _options);
  }
  async _getFromListDefinitionAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetFromListDefinition", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ListItemEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getFromListDefinitionAsync(id, udListDefinitionId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = id;
    if (typeof first === "object" && first && (typeof first.id != "undefined" || typeof first.udListDefinitionId != "undefined")) {
      _request = id;
      _options = udListDefinitionId;
    } else {
      _request = {
        id,
        udListDefinitionId
      };
      _options = webapi_options;
    }
    return this._getFromListDefinitionAsync(_request, _options);
  }
  async _getFromListNameAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetFromListName", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ListItemEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getFromListNameAsync(id, udListDefinitionName, webapi_options) {
    let _request = null;
    let _options = null;
    const first = id;
    if (typeof first === "object" && first && (typeof first.id != "undefined" || typeof first.udListDefinitionName != "undefined")) {
      _request = id;
      _options = udListDefinitionName;
    } else {
      _request = {
        id,
        udListDefinitionName
      };
      _options = webapi_options;
    }
    return this._getFromListNameAsync(_request, _options);
  }
  async _saveFromListDefinitionAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveFromListDefinition", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ListItemEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveFromListDefinitionAsync(id, udListDefinitionId, item, webapi_options) {
    let _request = null;
    let _options = null;
    const first = id;
    if (typeof first === "object" && first && (typeof first.id != "undefined" || typeof first.udListDefinitionId != "undefined" || typeof first.item != "undefined")) {
      _request = id;
      _options = udListDefinitionId;
    } else {
      _request = {
        id,
        udListDefinitionId,
        item
      };
      _options = webapi_options;
    }
    return this._saveFromListDefinitionAsync(_request, _options);
  }
  async _saveFromListNameAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveFromListName", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ListItemEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveFromListNameAsync(id, udListDefinitionName, item, webapi_options) {
    let _request = null;
    let _options = null;
    const first = id;
    if (typeof first === "object" && first && (typeof first.id != "undefined" || typeof first.udListDefinitionName != "undefined" || typeof first.item != "undefined")) {
      _request = id;
      _options = udListDefinitionName;
    } else {
      _request = {
        id,
        udListDefinitionName,
        item
      };
      _options = webapi_options;
    }
    return this._saveFromListNameAsync(_request, _options);
  }
  async _deleteFromListDefinitionAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeleteFromListDefinition", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async deleteFromListDefinitionAsync(id, udListDefinitionId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = id;
    if (typeof first === "object" && first && (typeof first.id != "undefined" || typeof first.udListDefinitionId != "undefined")) {
      _request = id;
      _options = udListDefinitionId;
    } else {
      _request = {
        id,
        udListDefinitionId
      };
      _options = webapi_options;
    }
    return this._deleteFromListDefinitionAsync(_request, _options);
  }
  async _deleteFromListNameAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeleteFromListName", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async deleteFromListNameAsync(id, udListDefinitionName, webapi_options) {
    let _request = null;
    let _options = null;
    const first = id;
    if (typeof first === "object" && first && (typeof first.id != "undefined" || typeof first.udListDefinitionName != "undefined")) {
      _request = id;
      _options = udListDefinitionName;
    } else {
      _request = {
        id,
        udListDefinitionName
      };
      _options = webapi_options;
    }
    return this._deleteFromListNameAsync(_request, _options);
  }
  async _getHeadingsFromNameAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetHeadingsFromName", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_HeadingEntityArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getHeadingsFromNameAsync(name, webapi_options) {
    let _request = null;
    let _options = null;
    const first = name;
    if (typeof first === "object" && first && typeof first.name != "undefined") {
      _request = name;
      _options = webapi_options;
    } else {
      _request = {
        name
      };
      _options = webapi_options;
    }
    return this._getHeadingsFromNameAsync(_request, _options);
  }
  async _getHeadingsFromListDefinitionAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetHeadingsFromListDefinition", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_HeadingEntityArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getHeadingsFromListDefinitionAsync(id, webapi_options) {
    let _request = null;
    let _options = null;
    const first = id;
    if (typeof first === "object" && first && typeof first.id != "undefined") {
      _request = id;
      _options = webapi_options;
    } else {
      _request = {
        id
      };
      _options = webapi_options;
    }
    return this._getHeadingsFromListDefinitionAsync(_request, _options);
  }
  async _saveHeadingsFromNameAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveHeadingsFromName", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_HeadingEntityArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveHeadingsFromNameAsync(name, entities, webapi_options) {
    let _request = null;
    let _options = null;
    const first = name;
    if (typeof first === "object" && first && (typeof first.name != "undefined" || typeof first.entities != "undefined")) {
      _request = name;
      _options = entities;
    } else {
      _request = {
        name,
        entities
      };
      _options = webapi_options;
    }
    return this._saveHeadingsFromNameAsync(_request, _options);
  }
  async _saveHeadingsFromListDefinitionAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveHeadingsFromListDefinition", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_HeadingEntityArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveHeadingsFromListDefinitionAsync(id, entities, webapi_options) {
    let _request = null;
    let _options = null;
    const first = id;
    if (typeof first === "object" && first && (typeof first.id != "undefined" || typeof first.entities != "undefined")) {
      _request = id;
      _options = entities;
    } else {
      _request = {
        id,
        entities
      };
      _options = webapi_options;
    }
    return this._saveHeadingsFromListDefinitionAsync(_request, _options);
  }
  async _saveHeadingFromNameAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveHeadingFromName", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_HeadingEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveHeadingFromNameAsync(name, entity, webapi_options) {
    let _request = null;
    let _options = null;
    const first = name;
    if (typeof first === "object" && first && (typeof first.name != "undefined" || typeof first.entity != "undefined")) {
      _request = name;
      _options = entity;
    } else {
      _request = {
        name,
        entity
      };
      _options = webapi_options;
    }
    return this._saveHeadingFromNameAsync(_request, _options);
  }
  async _saveHeadingFromListDefinitionAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveHeadingFromListDefinition", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_HeadingEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveHeadingFromListDefinitionAsync(id, entity, webapi_options) {
    let _request = null;
    let _options = null;
    const first = id;
    if (typeof first === "object" && first && (typeof first.id != "undefined" || typeof first.entity != "undefined")) {
      _request = id;
      _options = entity;
    } else {
      _request = {
        id,
        entity
      };
      _options = webapi_options;
    }
    return this._saveHeadingFromListDefinitionAsync(_request, _options);
  }
  async _deleteAllHeadingsFromNameAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeleteAllHeadingsFromName", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async deleteAllHeadingsFromNameAsync(name, webapi_options) {
    let _request = null;
    let _options = null;
    const first = name;
    if (typeof first === "object" && first && typeof first.name != "undefined") {
      _request = name;
      _options = webapi_options;
    } else {
      _request = {
        name
      };
      _options = webapi_options;
    }
    return this._deleteAllHeadingsFromNameAsync(_request, _options);
  }
  async _deleteAllHeadingsFromListDefinitionAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeleteAllHeadingsFromListDefinition", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async deleteAllHeadingsFromListDefinitionAsync(id, webapi_options) {
    let _request = null;
    let _options = null;
    const first = id;
    if (typeof first === "object" && first && typeof first.id != "undefined") {
      _request = id;
      _options = webapi_options;
    } else {
      _request = {
        id
      };
      _options = webapi_options;
    }
    return this._deleteAllHeadingsFromListDefinitionAsync(_request, _options);
  }
  /*
   * Gets a LocalizedText object.
   * @param localizedTextId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single LocalizedText
   */
  async getLocalizedTextAsync(localizedTextId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetLocalizedText?localizedTextId=" + localizedTextId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_LocalizedText_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getLocalizedTextByTypeAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetLocalizedTextByType", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_LocalizedText_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getLocalizedTextByTypeAsync(textType, resourceId, languageId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = textType;
    if (typeof first === "object" && first && (typeof first.textType != "undefined" || typeof first.resourceId != "undefined" || typeof first.languageId != "undefined")) {
      _request = textType;
      _options = resourceId;
    } else {
      _request = {
        textType,
        resourceId,
        languageId
      };
      _options = webapi_options;
    }
    return this._getLocalizedTextByTypeAsync(_request, _options);
  }
  /*
   * Gets an array of LocalizedText objects.
   * @param localizedTextIds - The primary keys.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns An array of LocalizedText
   */
  async getLocalizedTextListAsync(localizedTextIds, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetLocalizedTextList", localizedTextIds, config);
        WebApiBase.SetCompleted(options);
        const res = Create_LocalizedTextArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getLocalizedTextsAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetLocalizedTexts", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_LocalizedTextArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Gets all localized texts in the CRM database.
   * @returns Array of LocalizedText objects
   */
  async getLocalizedTextsAsync(webapi_options) {
    return this._getLocalizedTextsAsync(webapi_options);
  }
  async _getLocalizedTextsByLanguageIdAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetLocalizedTextsByLanguageId", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_LocalizedTextArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getLocalizedTextsByLanguageIdAsync(languageId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = languageId;
    if (typeof first === "object" && first && typeof first.languageId != "undefined") {
      _request = languageId;
      _options = webapi_options;
    } else {
      _request = {
        languageId
      };
      _options = webapi_options;
    }
    return this._getLocalizedTextsByLanguageIdAsync(_request, _options);
  }
  async _getLocalizedTextsByTypeAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetLocalizedTextsByType", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_LocalizedTextArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getLocalizedTextsByTypeAsync(textTypes, webapi_options) {
    let _request = null;
    let _options = null;
    const first = textTypes;
    if (typeof first === "object" && first && typeof first.textTypes != "undefined") {
      _request = textTypes;
      _options = webapi_options;
    } else {
      _request = {
        textTypes
      };
      _options = webapi_options;
    }
    return this._getLocalizedTextsByTypeAsync(_request, _options);
  }
  /*
   * Gets a MrMrs object.
   * @param mrMrsId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single MrMrs
   */
  async getMrMrsAsync(mrMrsId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetMrMrs?mrMrsId=" + mrMrsId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_MrMrs_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets an array of MrMrs objects.
   * @param mrMrsIds - The primary keys.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns An array of MrMrs
   */
  async getMrMrsListAsync(mrMrsIds, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetMrMrsList", mrMrsIds, config);
        WebApiBase.SetCompleted(options);
        const res = Create_MrMrsArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getMrMrsesAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetMrMrses", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_MrMrsArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Returns all Items from the MrMrs table sorted by their value.
   * @returns All items from the MrMrs table sorted by their value
   */
  async getMrMrsesAsync(webapi_options) {
    return this._getMrMrsesAsync(webapi_options);
  }
  /*
   * Gets a PaymentTerm object.
   * @param paymentTermId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single PaymentTerm
   */
  async getPaymentTermAsync(paymentTermId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetPaymentTerm?paymentTermId=" + paymentTermId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PaymentTerm_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getPaymentTermsAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPaymentTerms", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PaymentTermArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Returns all PaymentTerms in SuperOffice db.
   * @returns An array of all available PaymentTerms
   */
  async getPaymentTermsAsync(webapi_options) {
    return this._getPaymentTermsAsync(webapi_options);
  }
  /*
   * Gets a PaymentType object.
   * @param paymentTypeId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single PaymentType
   */
  async getPaymentTypeAsync(paymentTypeId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetPaymentType?paymentTypeId=" + paymentTypeId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PaymentType_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getPaymentTypesAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPaymentTypes", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PaymentTypeArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Returns all PaymentTypes in SuperOffice db.
   * @returns An array of all available PaymentTypes
   */
  async getPaymentTypesAsync(webapi_options) {
    return this._getPaymentTypesAsync(webapi_options);
  }
  /*
   * Gets a Position object.
   * @param positionId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single Position
   */
  async getPositionAsync(positionId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetPosition?positionId=" + positionId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Position_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets an array of Position objects.
   * @param positionIds - The primary keys.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns An array of Position
   */
  async getPositionListAsync(positionIds, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetPositionList", positionIds, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PositionArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getPositionsAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPositions", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PositionArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Returns all the positions a person could have.
   * @returns An array of all available positions
   */
  async getPositionsAsync(webapi_options) {
    return this._getPositionsAsync(webapi_options);
  }
  /*
   * Gets a Priority object.
   * @param priorityId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single Priority
   */
  async getPriorityAsync(priorityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetPriority?priorityId=" + priorityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Priority_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets an array of Priority objects.
   * @param priorityIds - The primary keys.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns An array of Priority
   */
  async getPriorityListAsync(priorityIds, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetPriorityList", priorityIds, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PriorityArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getPrioritiesAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPriorities", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PriorityArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Returns all priorities an appointment could have.
   * @returns An array of all available priorities
   */
  async getPrioritiesAsync(webapi_options) {
    return this._getPrioritiesAsync(webapi_options);
  }
  /*
   * Gets a ProductCategory object.
   * @param productCategoryId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single ProductCategory
   */
  async getProductCategoryAsync(productCategoryId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetProductCategory?productCategoryId=" + productCategoryId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ProductCategory_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getProductCategoriesAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetProductCategories", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ProductCategoryArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Returns all ProductCategories in SuperOffice list.
   * @returns An array of all available ProductCategory
   */
  async getProductCategoriesAsync(webapi_options) {
    return this._getProductCategoriesAsync(webapi_options);
  }
  /*
   * Gets a ProductFamily object.
   * @param productFamilyId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single ProductFamily
   */
  async getProductFamilyAsync(productFamilyId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetProductFamily?productFamilyId=" + productFamilyId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ProductFamily_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getProductFamiliesAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetProductFamilies", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ProductFamilyArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Returns all ProductFamily in SuperOffice list.
   * @returns An array of all available ProductFamilies
   */
  async getProductFamiliesAsync(webapi_options) {
    return this._getProductFamiliesAsync(webapi_options);
  }
  /*
   * Gets a ProductType object.
   * @param productTypeId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single ProductType
   */
  async getProductTypeAsync(productTypeId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetProductType?productTypeId=" + productTypeId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ProductType_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getProductTypesAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetProductTypes", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ProductTypeArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Returns all ProductTypes in SuperOffice list.
   * @returns An array of all available ProductTypes
   */
  async getProductTypesAsync(webapi_options) {
    return this._getProductTypesAsync(webapi_options);
  }
  /*
   * Gets a ProjectStatus object.
   * @param projectStatusId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single ProjectStatus
   */
  async getProjectStatusAsync(projectStatusId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetProjectStatus?projectStatusId=" + projectStatusId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ProjectStatus_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _deleteProjectStatusAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeleteProjectStatus", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async deleteProjectStatusAsync(projectStatusId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = projectStatusId;
    if (typeof first === "object" && first && typeof first.projectStatusId != "undefined") {
      _request = projectStatusId;
      _options = webapi_options;
    } else {
      _request = {
        projectStatusId
      };
      _options = webapi_options;
    }
    return this._deleteProjectStatusAsync(_request, _options);
  }
  /*
   * Gets an array of ProjectStatus objects.
   * @param projectStatusIds - The primary keys.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns An array of ProjectStatus
   */
  async getProjectStatusListAsync(projectStatusIds, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetProjectStatusList", projectStatusIds, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ProjectStatusArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getProjectStatusesAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetProjectStatuses", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ProjectStatusArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Gets all items from the Project Status (ProjStatus) table.
   * @returns List of all Project statuses.
   */
  async getProjectStatusesAsync(webapi_options) {
    return this._getProjectStatusesAsync(webapi_options);
  }
  /*
   * Gets a ProjectType object.
   * @param projectTypeId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single ProjectType
   */
  async getProjectTypeAsync(projectTypeId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetProjectType?projectTypeId=" + projectTypeId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ProjectType_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets a ProjectTypeEntity object.
   * @param projectTypeEntityId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single ProjectTypeEntity
   */
  async getProjectTypeEntityAsync(projectTypeEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetProjectTypeEntity?projectTypeEntityId=" + projectTypeEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ProjectTypeEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets an array of ProjectType objects.
   * @param projectTypeIds - The primary keys.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns An array of ProjectType
   */
  async getProjectTypeListAsync(projectTypeIds, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetProjectTypeList", projectTypeIds, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ProjectTypeArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getProjectTypesAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetProjectTypes", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ProjectTypeArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Gets all items from the Project Type (ProjType) table.
   * @returns List of all project types.
   */
  async getProjectTypesAsync(webapi_options) {
    return this._getProjectTypesAsync(webapi_options);
  }
  async _saveQuickRepliesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveQuickReplies", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveQuickRepliesAsync(quickReplies, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quickReplies;
    if (typeof first === "object" && first && typeof first.quickReplies != "undefined") {
      _request = quickReplies;
      _options = webapi_options;
    } else {
      _request = {
        quickReplies
      };
      _options = webapi_options;
    }
    return this._saveQuickRepliesAsync(_request, _options);
  }
  async _getQuickRepliesAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetQuickReplies", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_QuickReplyArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Method to return all quick replies for a given associate
   * @returns Array of quick replies
   */
  async getQuickRepliesAsync(webapi_options) {
    return this._getQuickRepliesAsync(webapi_options);
  }
  /*
   * Gets a Rating object.
   * @param ratingId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single Rating
   */
  async getRatingAsync(ratingId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetRating?ratingId=" + ratingId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Rating_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets an array of Rating objects.
   * @param ratingIds - The primary keys.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns An array of Rating
   */
  async getRatingListAsync(ratingIds, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetRatingList", ratingIds, config);
        WebApiBase.SetCompleted(options);
        const res = Create_RatingArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getRatingsAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetRatings", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_RatingArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Returns all ratings
   * @returns Array of ratings
   */
  async getRatingsAsync(webapi_options) {
    return this._getRatingsAsync(webapi_options);
  }
  async _getAllSaleStagesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetAllSaleStages", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SaleStageEntityArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getAllSaleStagesAsync(includeDeleted, webapi_options) {
    let _request = null;
    let _options = null;
    const first = includeDeleted;
    if (typeof first === "object" && first && typeof first.includeDeleted != "undefined") {
      _request = includeDeleted;
      _options = webapi_options;
    } else {
      _request = {
        includeDeleted
      };
      _options = webapi_options;
    }
    return this._getAllSaleStagesAsync(_request, _options);
  }
  /*
   * Gets a Reason object.
   * @param reasonId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single Reason
   */
  async getReasonAsync(reasonId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetReason?reasonId=" + reasonId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Reason_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets an array of Reason objects.
   * @param reasonIds - The primary keys.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns An array of Reason
   */
  async getReasonListAsync(reasonIds, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetReasonList", reasonIds, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ReasonArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getReasonsAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetReasons", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ReasonArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Returns all reasons
   * @returns Array of reasons
   */
  async getReasonsAsync(webapi_options) {
    return this._getReasonsAsync(webapi_options);
  }
  /*
   * Gets a QuoteApproveReason object.
   * @param quoteApproveReasonId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single QuoteApproveReason
   */
  async getQuoteApproveReasonAsync(quoteApproveReasonId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetQuoteApproveReason?quoteApproveReasonId=" + quoteApproveReasonId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_QuoteApproveReason_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets an array of QuoteApproveReason objects.
   * @param quoteApproveReasonIds - The primary keys.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns An array of QuoteApproveReason
   */
  async getQuoteApproveReasonListAsync(quoteApproveReasonIds, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetQuoteApproveReasonList", quoteApproveReasonIds, config);
        WebApiBase.SetCompleted(options);
        const res = Create_QuoteApproveReasonArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getQuoteApproveReasonsAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetQuoteApproveReasons", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_QuoteApproveReasonArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Returns all available QuoteApproveReasons.
   * @returns An array of all non-deleted QuoteApproveReason
   */
  async getQuoteApproveReasonsAsync(webapi_options) {
    return this._getQuoteApproveReasonsAsync(webapi_options);
  }
  /*
   * Gets a QuoteDenyReason object.
   * @param quoteDenyReasonId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single QuoteDenyReason
   */
  async getQuoteDenyReasonAsync(quoteDenyReasonId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetQuoteDenyReason?quoteDenyReasonId=" + quoteDenyReasonId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_QuoteDenyReason_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets an array of QuoteDenyReason objects.
   * @param quoteDenyReasonIds - The primary keys.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns An array of QuoteDenyReason
   */
  async getQuoteDenyReasonListAsync(quoteDenyReasonIds, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetQuoteDenyReasonList", quoteDenyReasonIds, config);
        WebApiBase.SetCompleted(options);
        const res = Create_QuoteDenyReasonArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getQuoteDenyReasonsAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetQuoteDenyReasons", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_QuoteDenyReasonArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Returns all available QuoteDenyReasons.
   * @returns An array of all non-deleted QuoteDenyReason
   */
  async getQuoteDenyReasonsAsync(webapi_options) {
    return this._getQuoteDenyReasonsAsync(webapi_options);
  }
  /*
   * Gets a ReasonSold object.
   * @param reasonSoldId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single ReasonSold
   */
  async getReasonSoldAsync(reasonSoldId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetReasonSold?reasonSoldId=" + reasonSoldId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ReasonSold_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets an array of ReasonSold objects.
   * @param reasonSoldIds - The primary keys.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns An array of ReasonSold
   */
  async getReasonSoldListAsync(reasonSoldIds, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetReasonSoldList", reasonSoldIds, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ReasonSoldArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets a ReasonStalled object.
   * @param reasonStalledId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single ReasonStalled
   */
  async getReasonStalledAsync(reasonStalledId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetReasonStalled?reasonStalledId=" + reasonStalledId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ReasonStalled_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets an array of ReasonStalled objects.
   * @param reasonStalledIds - The primary keys.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns An array of ReasonStalled
   */
  async getReasonStalledListAsync(reasonStalledIds, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetReasonStalledList", reasonStalledIds, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ReasonStalledArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets a RelationDefinitionEntity object.
   * @param relationDefinitionEntityId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single RelationDefinitionEntity
   */
  async getRelationDefinitionEntityAsync(relationDefinitionEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetRelationDefinitionEntity?relationDefinitionEntityId=" + relationDefinitionEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_RelationDefinitionEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets a ResourceEntity object.
   * @param resourceEntityId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single ResourceEntity
   */
  async getResourceEntityAsync(resourceEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetResourceEntity?resourceEntityId=" + resourceEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ResourceEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets a SaleStageEntity object.
   * @param saleStageEntityId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single SaleStageEntity
   */
  async getSaleStageEntityAsync(saleStageEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetSaleStageEntity?saleStageEntityId=" + saleStageEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SaleStageEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets a SaleType object.
   * @param saleTypeId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single SaleType
   */
  async getSaleTypeAsync(saleTypeId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetSaleType?saleTypeId=" + saleTypeId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SaleType_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets a SaleTypeEntity object.
   * @param saleTypeEntityId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single SaleTypeEntity
   */
  async getSaleTypeEntityAsync(saleTypeEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetSaleTypeEntity?saleTypeEntityId=" + saleTypeEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SaleTypeEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets an array of SaleType objects.
   * @param saleTypeIds - The primary keys.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns An array of SaleType
   */
  async getSaleTypeListAsync(saleTypeIds, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetSaleTypeList", saleTypeIds, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SaleTypeArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getAllSaleTypeAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetAllSaleType", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SaleTypeArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Returns all sale types as simple list items
   * @returns Array of simple sale type list items
   */
  async getAllSaleTypeAsync(webapi_options) {
    return this._getAllSaleTypeAsync(webapi_options);
  }
  async _getAllSaleTypeEntitiesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetAllSaleTypeEntities", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SaleTypeEntityArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getAllSaleTypeEntitiesAsync(includeDeleted, webapi_options) {
    let _request = null;
    let _options = null;
    const first = includeDeleted;
    if (typeof first === "object" && first && typeof first.includeDeleted != "undefined") {
      _request = includeDeleted;
      _options = webapi_options;
    } else {
      _request = {
        includeDeleted
      };
      _options = webapi_options;
    }
    return this._getAllSaleTypeEntitiesAsync(_request, _options);
  }
  /*
   * Gets a SelectionCategory object.
   * @param selectionCategoryId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single SelectionCategory
   */
  async getSelectionCategoryAsync(selectionCategoryId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetSelectionCategory?selectionCategoryId=" + selectionCategoryId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SelectionCategory_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets an array of SelectionCategory objects.
   * @param selectionCategoryIds - The primary keys.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns An array of SelectionCategory
   */
  async getSelectionCategoryListAsync(selectionCategoryIds, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetSelectionCategoryList", selectionCategoryIds, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SelectionCategoryArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets a Source object.
   * @param sourceId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single Source
   */
  async getSourceAsync(sourceId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetSource?sourceId=" + sourceId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Source_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets an array of Source objects.
   * @param sourceIds - The primary keys.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns An array of Source
   */
  async getSourceListAsync(sourceIds, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetSourceList", sourceIds, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SourceArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getSourcesAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetSources", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SourceArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Returns all sources
   * @returns Array of sources
   */
  async getSourcesAsync(webapi_options) {
    return this._getSourcesAsync(webapi_options);
  }
  /*
   * Gets a Task object.
   * @param taskId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single Task
   */
  async getTaskAsync(taskId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetTask?taskId=" + taskId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Task_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getDocumentTemplateTaskAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetDocumentTemplateTask", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Task_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getDocumentTemplateTaskAsync(documentTemplateId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = documentTemplateId;
    if (typeof first === "object" && first && typeof first.documentTemplateId != "undefined") {
      _request = documentTemplateId;
      _options = webapi_options;
    } else {
      _request = {
        documentTemplateId
      };
      _options = webapi_options;
    }
    return this._getDocumentTemplateTaskAsync(_request, _options);
  }
  /*
   * Gets an array of Task objects.
   * @param taskIds - The primary keys.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns An array of Task
   */
  async getTaskListAsync(taskIds, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetTaskList", taskIds, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TaskArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getTasksAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetTasks", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TaskArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Returns all appointment tasks
   * @returns An array of all available tasks
   */
  async getTasksAsync(webapi_options) {
    return this._getTasksAsync(webapi_options);
  }
  async _getDocumentTemplatesTasksAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetDocumentTemplatesTasks", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TaskArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * The appointment&apos;s task is a Document template item when the appointment is a document.
   * @returns Document Template list as a array of Tasks
   */
  async getDocumentTemplatesTasksAsync(webapi_options) {
    return this._getDocumentTemplatesTasksAsync(webapi_options);
  }
  async _getAllTasksAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetAllTasks", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TaskListItemArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getAllTasksAsync(includeDeleted, webapi_options) {
    let _request = null;
    let _options = null;
    const first = includeDeleted;
    if (typeof first === "object" && first && typeof first.includeDeleted != "undefined") {
      _request = includeDeleted;
      _options = webapi_options;
    } else {
      _request = {
        includeDeleted
      };
      _options = webapi_options;
    }
    return this._getAllTasksAsync(_request, _options);
  }
  /*
   * Gets a TicketCategory object.
   * @param ticketCategoryId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single TicketCategory
   */
  async getTicketCategoryAsync(ticketCategoryId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetTicketCategory?ticketCategoryId=" + ticketCategoryId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TicketCategory_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets a TicketCategoryEntity object.
   * @param ticketCategoryEntityId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single TicketCategoryEntity
   */
  async getTicketCategoryEntityAsync(ticketCategoryEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetTicketCategoryEntity?ticketCategoryEntityId=" + ticketCategoryEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TicketCategoryEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _moveAllTicketsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("MoveAllTickets", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async moveAllTicketsAsync(fromTicketCategoryId, toTicketCategoryId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = fromTicketCategoryId;
    if (typeof first === "object" && first && (typeof first.fromTicketCategoryId != "undefined" || typeof first.toTicketCategoryId != "undefined")) {
      _request = fromTicketCategoryId;
      _options = toTicketCategoryId;
    } else {
      _request = {
        fromTicketCategoryId,
        toTicketCategoryId
      };
      _options = webapi_options;
    }
    return this._moveAllTicketsAsync(_request, _options);
  }
  async _rebuildFullnamesAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("RebuildFullnames", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Update the fullname field of all categories. Use this e.g. when changing parentId or renaming a category with children.
   * @returns This method has no return value
   */
  async rebuildFullnamesAsync(webapi_options) {
    return this._rebuildFullnamesAsync(webapi_options);
  }
  /*
   * Gets an array of TicketCategoryEntity objects.
   * @param ticketCategoryEntityIds - The primary keys.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns An array of TicketCategoryEntity
   */
  async getTicketCategoryListAsync(ticketCategoryEntityIds, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetTicketCategoryList", ticketCategoryEntityIds, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TicketCategoryEntityArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getTicketCategoriesAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetTicketCategories", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TicketCategoryEntityArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   *
   * @returns
   */
  async getTicketCategoriesAsync(webapi_options) {
    return this._getTicketCategoriesAsync(webapi_options);
  }
  async _getTicketCategoriesForUserGroupsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetTicketCategoriesForUserGroups", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_MDOListItemArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getTicketCategoriesForUserGroupsAsync(userGroupIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = userGroupIds;
    if (typeof first === "object" && first && typeof first.userGroupIds != "undefined") {
      _request = userGroupIds;
      _options = webapi_options;
    } else {
      _request = {
        userGroupIds
      };
      _options = webapi_options;
    }
    return this._getTicketCategoriesForUserGroupsAsync(_request, _options);
  }
  async _setTicketCategoriesForUserGroupAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetTicketCategoriesForUserGroup", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setTicketCategoriesForUserGroupAsync(userGroupId, categoryIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = userGroupId;
    if (typeof first === "object" && first && (typeof first.userGroupId != "undefined" || typeof first.categoryIds != "undefined")) {
      _request = userGroupId;
      _options = categoryIds;
    } else {
      _request = {
        userGroupId,
        categoryIds
      };
      _options = webapi_options;
    }
    return this._setTicketCategoriesForUserGroupAsync(_request, _options);
  }
  async _updateCategoryMembershipsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("UpdateCategoryMemberships", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async updateCategoryMembershipsAsync(ticketCategoryId, membershipsToAdd, membershipsToUpdate, membershipsToDelete, webapi_options) {
    let _request = null;
    let _options = null;
    const first = ticketCategoryId;
    if (typeof first === "object" && first && (typeof first.ticketCategoryId != "undefined" || typeof first.membershipsToAdd != "undefined" || typeof first.membershipsToUpdate != "undefined" || typeof first.membershipsToDelete != "undefined")) {
      _request = ticketCategoryId;
      _options = membershipsToAdd;
    } else {
      _request = {
        ticketCategoryId,
        membershipsToAdd,
        membershipsToUpdate,
        membershipsToDelete
      };
      _options = webapi_options;
    }
    return this._updateCategoryMembershipsAsync(_request, _options);
  }
  /*
   * Gets a TicketPriority object.
   * @param ticketPriorityId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single TicketPriority
   */
  async getTicketPriorityAsync(ticketPriorityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetTicketPriority?ticketPriorityId=" + ticketPriorityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TicketPriority_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets a TicketPriorityEntity object.
   * @param ticketPriorityEntityId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single TicketPriorityEntity
   */
  async getTicketPriorityEntityAsync(ticketPriorityEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetTicketPriorityEntity?ticketPriorityEntityId=" + ticketPriorityEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TicketPriorityEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _setTicketPrioritySortOrderAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetTicketPrioritySortOrder", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setTicketPrioritySortOrderAsync(ticketPriorityId, sortOrder, webapi_options) {
    let _request = null;
    let _options = null;
    const first = ticketPriorityId;
    if (typeof first === "object" && first && (typeof first.ticketPriorityId != "undefined" || typeof first.sortOrder != "undefined")) {
      _request = ticketPriorityId;
      _options = sortOrder;
    } else {
      _request = {
        ticketPriorityId,
        sortOrder
      };
      _options = webapi_options;
    }
    return this._setTicketPrioritySortOrderAsync(_request, _options);
  }
  /*
   * Gets an array of TicketPriority objects.
   * @param ticketPriorityIds - The primary keys.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns An array of TicketPriority
   */
  async getTicketPriorityListAsync(ticketPriorityIds, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetTicketPriorityList", ticketPriorityIds, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TicketPriorityArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getTicketPrioritiesAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetTicketPriorities", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TicketPriorityArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   *
   * @returns
   */
  async getTicketPrioritiesAsync(webapi_options) {
    return this._getTicketPrioritiesAsync(webapi_options);
  }
  async _getAllTicketPrioritiesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetAllTicketPriorities", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TicketPriorityEntityArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getAllTicketPrioritiesAsync(includeDeleted, webapi_options) {
    let _request = null;
    let _options = null;
    const first = includeDeleted;
    if (typeof first === "object" && first && typeof first.includeDeleted != "undefined") {
      _request = includeDeleted;
      _options = webapi_options;
    } else {
      _request = {
        includeDeleted
      };
      _options = webapi_options;
    }
    return this._getAllTicketPrioritiesAsync(_request, _options);
  }
  /*
   * Gets a TicketStatusEntity object.
   * @param ticketStatusEntityId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single TicketStatusEntity
   */
  async getTicketStatusEntityAsync(ticketStatusEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetTicketStatusEntity?ticketStatusEntityId=" + ticketStatusEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TicketStatusEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _globalChangeTicketStatusAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GlobalChangeTicketStatus", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async globalChangeTicketStatusAsync(fromTicketStatusId, toTicketStatusId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = fromTicketStatusId;
    if (typeof first === "object" && first && (typeof first.fromTicketStatusId != "undefined" || typeof first.toTicketStatusId != "undefined")) {
      _request = fromTicketStatusId;
      _options = toTicketStatusId;
    } else {
      _request = {
        fromTicketStatusId,
        toTicketStatusId
      };
      _options = webapi_options;
    }
    return this._globalChangeTicketStatusAsync(_request, _options);
  }
  async _setTicketStatusSortOrderAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetTicketStatusSortOrder", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setTicketStatusSortOrderAsync(ticketStatusId, sortOrder, webapi_options) {
    let _request = null;
    let _options = null;
    const first = ticketStatusId;
    if (typeof first === "object" && first && (typeof first.ticketStatusId != "undefined" || typeof first.sortOrder != "undefined")) {
      _request = ticketStatusId;
      _options = sortOrder;
    } else {
      _request = {
        ticketStatusId,
        sortOrder
      };
      _options = webapi_options;
    }
    return this._setTicketStatusSortOrderAsync(_request, _options);
  }
  /*
   * Gets an array of TicketStatusEntity objects.
   * @param ticketStatusEntityIds - The primary keys.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns An array of TicketStatusEntity
   */
  async getTicketStatusListAsync(ticketStatusEntityIds, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetTicketStatusList", ticketStatusEntityIds, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TicketStatusEntityArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getTicketStatusesAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetTicketStatuses", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TicketStatusEntityArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   *
   * @returns
   */
  async getTicketStatusesAsync(webapi_options) {
    return this._getTicketStatusesAsync(webapi_options);
  }
  /*
   * Gets a TicketType object.
   * @param ticketTypeId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single TicketType
   */
  async getTicketTypeAsync(ticketTypeId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetTicketType?ticketTypeId=" + ticketTypeId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TicketType_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets a TicketTypeEntity object.
   * @param ticketTypeEntityId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single TicketTypeEntity
   */
  async getTicketTypeEntityAsync(ticketTypeEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetTicketTypeEntity?ticketTypeEntityId=" + ticketTypeEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TicketTypeEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getAllTicketTypeEntitiesAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetAllTicketTypeEntities", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TicketTypeEntityArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Get all TicketTypeEntities
   * @returns
   */
  async getAllTicketTypeEntitiesAsync(webapi_options) {
    return this._getAllTicketTypeEntitiesAsync(webapi_options);
  }
  /*
   * Gets an array of TicketType objects.
   * @param ticketTypeIds - The primary keys.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns An array of TicketType
   */
  async getTicketTypeListAsync(ticketTypeIds, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetTicketTypeList", ticketTypeIds, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TicketTypeArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getTicketTypesAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetTicketTypes", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TicketTypeArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Get all TicketTypes
   * @returns
   */
  async getTicketTypesAsync(webapi_options) {
    return this._getTicketTypesAsync(webapi_options);
  }
  /*
   * Gets a WebPanelEntity object.
   * @param webPanelEntityId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single WebPanelEntity
   */
  async getWebPanelEntityAsync(webPanelEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetWebPanelEntity?webPanelEntityId=" + webPanelEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_WebPanelEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _generateNavigationUrlAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GenerateNavigationUrl", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async generateNavigationUrlAsync(visibleIn, windowName, webapi_options) {
    let _request = null;
    let _options = null;
    const first = visibleIn;
    if (typeof first === "object" && first && (typeof first.visibleIn != "undefined" || typeof first.windowName != "undefined")) {
      _request = visibleIn;
      _options = windowName;
    } else {
      _request = {
        visibleIn,
        windowName
      };
      _options = webapi_options;
    }
    return this._generateNavigationUrlAsync(_request, _options);
  }
  async _getWebPanelListAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetWebPanelList", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_WebPanelEntityArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Return a list of all web panels.
   * @returns List of all web panels
   */
  async getWebPanelListAsync(webapi_options) {
    return this._getWebPanelListAsync(webapi_options);
  }
  async _deleteWebPanelAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeleteWebPanel", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async deleteWebPanelAsync(id, webapi_options) {
    let _request = null;
    let _options = null;
    const first = id;
    if (typeof first === "object" && first && typeof first.id != "undefined") {
      _request = id;
      _options = webapi_options;
    } else {
      _request = {
        id
      };
      _options = webapi_options;
    }
    return this._deleteWebPanelAsync(_request, _options);
  }
  async _getAppWebPanelsAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetAppWebPanels", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_WebPanelEntityArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Get all web panels owned by your app; works in Online only, for registered Apps that send a valid ApplicationToken
   * @returns List of all web panels owned by the current App
   */
  async getAppWebPanelsAsync(webapi_options) {
    return this._getAppWebPanelsAsync(webapi_options);
  }
  async _deleteAppWebPanelsAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeleteAppWebPanels", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Permanentely delete all web panels owned by your app; works in Online only, for registered Apps that send a valid ApplicationToken; otherwise nothing happens
   * @returns This method has no return value
   */
  async deleteAppWebPanelsAsync(webapi_options) {
    return this._deleteAppWebPanelsAsync(webapi_options);
  }
  async _getWebPanelByProgIdAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetWebPanelByProgId", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_WebPanelEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getWebPanelByProgIdAsync(progId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = progId;
    if (typeof first === "object" && first && typeof first.progId != "undefined") {
      _request = progId;
      _options = webapi_options;
    } else {
      _request = {
        progId
      };
      _options = webapi_options;
    }
    return this._getWebPanelByProgIdAsync(_request, _options);
  }
};

// server/node_modules/@superoffice/webapi/dist/esm/BLOBAgent.js
var BLOBAgent = class extends WebApiBase {
  constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
    const options = WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
    options.basePath = "v1/Agents/BLOB/";
    super(options);
  }
  /**
   * Set default values into a new BlobEntity.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultBlobEntityAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultBlobEntity", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_BlobEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing BlobEntity or creates a new BlobEntity if the id parameter is empty
   * @param entity - The BlobEntity to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated BlobEntity
   */
  async saveBlobEntityAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveBlobEntity", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_BlobEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Deletes the BlobEntity
   * @param BlobEntityId - The id of the BlobEntity to be deleted.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   */
  async deleteBlobEntityAsync(BlobEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("DeleteBlobEntity?BlobEntityId=" + BlobEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets a BlobEntity object.
   * @param blobEntityId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single BlobEntity
   */
  async getBlobEntityAsync(blobEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetBlobEntity?blobEntityId=" + blobEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_BlobEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _setBlobStreamAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetBlobStream", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setBlobStreamAsync(blobEntityId, stream, webapi_options) {
    let _request = null;
    let _options = null;
    const first = blobEntityId;
    if (typeof first === "object" && first && (typeof first.blobEntityId != "undefined" || typeof first.stream != "undefined")) {
      _request = blobEntityId;
      _options = stream;
    } else {
      _request = {
        blobEntityId,
        stream
      };
      _options = webapi_options;
    }
    _request.stream = ToBase64(_request.stream);
    return this._setBlobStreamAsync(_request, _options);
  }
  async _getBlobStreamAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        if (!options || options.returnBlobAs == ReturnBlobType.AsArrayBuffer) {
          config.responseType = "arraybuffer";
          config.headers = config.headers || {};
          config.headers["Accept"] = "application/octet-stream";
        }
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetBlobStream", request, config);
        WebApiBase.SetCompleted(options);
        let res = null;
        if (options && options.returnBlobAs != ReturnBlobType.AsArrayBuffer) {
          res = response.data;
          if (options.returnBlobAs == ReturnBlobType.AsString) {
            res = FromBase64ToString(res);
          }
        } else {
          res = response.data;
        }
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getBlobStreamAsync(blobEntityId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = blobEntityId;
    if (typeof first === "object" && first && typeof first.blobEntityId != "undefined") {
      _request = blobEntityId;
      _options = webapi_options;
    } else {
      _request = {
        blobEntityId
      };
      _options = webapi_options;
    }
    return this._getBlobStreamAsync(_request, _options);
  }
  async _getProjectImageAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        if (!options || options.returnBlobAs == ReturnBlobType.AsArrayBuffer) {
          config.responseType = "arraybuffer";
          config.headers = config.headers || {};
          config.headers["Accept"] = "application/octet-stream";
        }
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetProjectImage", request, config);
        WebApiBase.SetCompleted(options);
        let res = null;
        if (options && options.returnBlobAs != ReturnBlobType.AsArrayBuffer) {
          res = response.data;
          if (options.returnBlobAs == ReturnBlobType.AsString) {
            res = FromBase64ToString(res);
          }
        } else {
          res = response.data;
        }
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getProjectImageAsync(projectId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = projectId;
    if (typeof first === "object" && first && typeof first.projectId != "undefined") {
      _request = projectId;
      _options = webapi_options;
    } else {
      _request = {
        projectId
      };
      _options = webapi_options;
    }
    return this._getProjectImageAsync(_request, _options);
  }
  async _getPersonImageAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        if (!options || options.returnBlobAs == ReturnBlobType.AsArrayBuffer) {
          config.responseType = "arraybuffer";
          config.headers = config.headers || {};
          config.headers["Accept"] = "application/octet-stream";
        }
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPersonImage", request, config);
        WebApiBase.SetCompleted(options);
        let res = null;
        if (options && options.returnBlobAs != ReturnBlobType.AsArrayBuffer) {
          res = response.data;
          if (options.returnBlobAs == ReturnBlobType.AsString) {
            res = FromBase64ToString(res);
          }
        } else {
          res = response.data;
        }
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getPersonImageAsync(personId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = personId;
    if (typeof first === "object" && first && typeof first.personId != "undefined") {
      _request = personId;
      _options = webapi_options;
    } else {
      _request = {
        personId
      };
      _options = webapi_options;
    }
    return this._getPersonImageAsync(_request, _options);
  }
  async _setProjectImageAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetProjectImage", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setProjectImageAsync(projectId, image, webapi_options) {
    let _request = null;
    let _options = null;
    const first = projectId;
    if (typeof first === "object" && first && (typeof first.projectId != "undefined" || typeof first.image != "undefined")) {
      _request = projectId;
      _options = image;
    } else {
      _request = {
        projectId,
        image
      };
      _options = webapi_options;
    }
    _request.image = ToBase64(_request.image);
    return this._setProjectImageAsync(_request, _options);
  }
  async _setPersonImageAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetPersonImage", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setPersonImageAsync(personId, image, webapi_options) {
    let _request = null;
    let _options = null;
    const first = personId;
    if (typeof first === "object" && first && (typeof first.personId != "undefined" || typeof first.image != "undefined")) {
      _request = personId;
      _options = image;
    } else {
      _request = {
        personId,
        image
      };
      _options = webapi_options;
    }
    _request.image = ToBase64(_request.image);
    return this._setPersonImageAsync(_request, _options);
  }
  async _changeProjectImageAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ChangeProjectImage", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async changeProjectImageAsync(projectId, blobId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = projectId;
    if (typeof first === "object" && first && (typeof first.projectId != "undefined" || typeof first.blobId != "undefined")) {
      _request = projectId;
      _options = blobId;
    } else {
      _request = {
        projectId,
        blobId
      };
      _options = webapi_options;
    }
    return this._changeProjectImageAsync(_request, _options);
  }
  async _saveProjectImageAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveProjectImage", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveProjectImageAsync(description, image, webapi_options) {
    let _request = null;
    let _options = null;
    const first = description;
    if (typeof first === "object" && first && (typeof first.description != "undefined" || typeof first.image != "undefined")) {
      _request = description;
      _options = image;
    } else {
      _request = {
        description,
        image
      };
      _options = webapi_options;
    }
    _request.image = ToBase64(_request.image);
    return this._saveProjectImageAsync(_request, _options);
  }
  async _getBlobEntityOnProjectAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetBlobEntityOnProject", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_BlobEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getBlobEntityOnProjectAsync(projectId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = projectId;
    if (typeof first === "object" && first && typeof first.projectId != "undefined") {
      _request = projectId;
      _options = webapi_options;
    } else {
      _request = {
        projectId
      };
      _options = webapi_options;
    }
    return this._getBlobEntityOnProjectAsync(_request, _options);
  }
  async _getBlobEntityOnPersonAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetBlobEntityOnPerson", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_BlobEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getBlobEntityOnPersonAsync(personId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = personId;
    if (typeof first === "object" && first && typeof first.personId != "undefined") {
      _request = personId;
      _options = webapi_options;
    } else {
      _request = {
        personId
      };
      _options = webapi_options;
    }
    return this._getBlobEntityOnPersonAsync(_request, _options);
  }
  async _getBlobEntityOnCountryAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetBlobEntityOnCountry", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_BlobEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getBlobEntityOnCountryAsync(countryId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = countryId;
    if (typeof first === "object" && first && typeof first.countryId != "undefined") {
      _request = countryId;
      _options = webapi_options;
    } else {
      _request = {
        countryId
      };
      _options = webapi_options;
    }
    return this._getBlobEntityOnCountryAsync(_request, _options);
  }
  async _getBlobEntityOnProductAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetBlobEntityOnProduct", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_BlobEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getBlobEntityOnProductAsync(productId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = productId;
    if (typeof first === "object" && first && typeof first.productId != "undefined") {
      _request = productId;
      _options = webapi_options;
    } else {
      _request = {
        productId
      };
      _options = webapi_options;
    }
    return this._getBlobEntityOnProductAsync(_request, _options);
  }
  async _changePersonImageAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ChangePersonImage", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async changePersonImageAsync(personId, blobId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = personId;
    if (typeof first === "object" && first && (typeof first.personId != "undefined" || typeof first.blobId != "undefined")) {
      _request = personId;
      _options = blobId;
    } else {
      _request = {
        personId,
        blobId
      };
      _options = webapi_options;
    }
    return this._changePersonImageAsync(_request, _options);
  }
  async _saveImageStreamAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveImageStream", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveImageStreamAsync(type, image, description, webapi_options) {
    let _request = null;
    let _options = null;
    const first = type;
    if (typeof first === "object" && first && (typeof first.type != "undefined" || typeof first.image != "undefined" || typeof first.description != "undefined")) {
      _request = type;
      _options = image;
    } else {
      _request = {
        type,
        image,
        description
      };
      _options = webapi_options;
    }
    _request.image = ToBase64(_request.image);
    return this._saveImageStreamAsync(_request, _options);
  }
  async _getProductImageAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        if (!options || options.returnBlobAs == ReturnBlobType.AsArrayBuffer) {
          config.responseType = "arraybuffer";
          config.headers = config.headers || {};
          config.headers["Accept"] = "application/octet-stream";
        }
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetProductImage", request, config);
        WebApiBase.SetCompleted(options);
        let res = null;
        if (options && options.returnBlobAs != ReturnBlobType.AsArrayBuffer) {
          res = response.data;
          if (options.returnBlobAs == ReturnBlobType.AsString) {
            res = FromBase64ToString(res);
          }
        } else {
          res = response.data;
        }
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getProductImageAsync(productId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = productId;
    if (typeof first === "object" && first && typeof first.productId != "undefined") {
      _request = productId;
      _options = webapi_options;
    } else {
      _request = {
        productId
      };
      _options = webapi_options;
    }
    return this._getProductImageAsync(_request, _options);
  }
  async _setProductImageAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetProductImage", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setProductImageAsync(productId, image, webapi_options) {
    let _request = null;
    let _options = null;
    const first = productId;
    if (typeof first === "object" && first && (typeof first.productId != "undefined" || typeof first.image != "undefined")) {
      _request = productId;
      _options = image;
    } else {
      _request = {
        productId,
        image
      };
      _options = webapi_options;
    }
    _request.image = ToBase64(_request.image);
    return this._setProductImageAsync(_request, _options);
  }
  async _getProductThumbnailAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        if (!options || options.returnBlobAs == ReturnBlobType.AsArrayBuffer) {
          config.responseType = "arraybuffer";
          config.headers = config.headers || {};
          config.headers["Accept"] = "application/octet-stream";
        }
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetProductThumbnail", request, config);
        WebApiBase.SetCompleted(options);
        let res = null;
        if (options && options.returnBlobAs != ReturnBlobType.AsArrayBuffer) {
          res = response.data;
          if (options.returnBlobAs == ReturnBlobType.AsString) {
            res = FromBase64ToString(res);
          }
        } else {
          res = response.data;
        }
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getProductThumbnailAsync(productId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = productId;
    if (typeof first === "object" && first && typeof first.productId != "undefined") {
      _request = productId;
      _options = webapi_options;
    } else {
      _request = {
        productId
      };
      _options = webapi_options;
    }
    return this._getProductThumbnailAsync(_request, _options);
  }
  async _setProductThumbnailAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetProductThumbnail", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setProductThumbnailAsync(productId, image, webapi_options) {
    let _request = null;
    let _options = null;
    const first = productId;
    if (typeof first === "object" && first && (typeof first.productId != "undefined" || typeof first.image != "undefined")) {
      _request = productId;
      _options = image;
    } else {
      _request = {
        productId,
        image
      };
      _options = webapi_options;
    }
    _request.image = ToBase64(_request.image);
    return this._setProductThumbnailAsync(_request, _options);
  }
  async _changeProductImageAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ChangeProductImage", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async changeProductImageAsync(productId, blobId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = productId;
    if (typeof first === "object" && first && (typeof first.productId != "undefined" || typeof first.blobId != "undefined")) {
      _request = productId;
      _options = blobId;
    } else {
      _request = {
        productId,
        blobId
      };
      _options = webapi_options;
    }
    return this._changeProductImageAsync(_request, _options);
  }
  async _getQuoteLineImageAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        if (!options || options.returnBlobAs == ReturnBlobType.AsArrayBuffer) {
          config.responseType = "arraybuffer";
          config.headers = config.headers || {};
          config.headers["Accept"] = "application/octet-stream";
        }
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetQuoteLineImage", request, config);
        WebApiBase.SetCompleted(options);
        let res = null;
        if (options && options.returnBlobAs != ReturnBlobType.AsArrayBuffer) {
          res = response.data;
          if (options.returnBlobAs == ReturnBlobType.AsString) {
            res = FromBase64ToString(res);
          }
        } else {
          res = response.data;
        }
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getQuoteLineImageAsync(quoteLineId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quoteLineId;
    if (typeof first === "object" && first && typeof first.quoteLineId != "undefined") {
      _request = quoteLineId;
      _options = webapi_options;
    } else {
      _request = {
        quoteLineId
      };
      _options = webapi_options;
    }
    return this._getQuoteLineImageAsync(_request, _options);
  }
  async _getAppDataAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetAppData", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getAppDataAsync(key, webapi_options) {
    let _request = null;
    let _options = null;
    const first = key;
    if (typeof first === "object" && first && typeof first.key != "undefined") {
      _request = key;
      _options = webapi_options;
    } else {
      _request = {
        key
      };
      _options = webapi_options;
    }
    return this._getAppDataAsync(_request, _options);
  }
  async _setAppDataAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetAppData", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setAppDataAsync(key, data, webapi_options) {
    let _request = null;
    let _options = null;
    const first = key;
    if (typeof first === "object" && first && (typeof first.key != "undefined" || typeof first.data != "undefined")) {
      _request = key;
      _options = data;
    } else {
      _request = {
        key,
        data
      };
      _options = webapi_options;
    }
    return this._setAppDataAsync(_request, _options);
  }
  async _getPersonImageWithSizeAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        if (!options || options.returnBlobAs == ReturnBlobType.AsArrayBuffer) {
          config.responseType = "arraybuffer";
          config.headers = config.headers || {};
          config.headers["Accept"] = "application/octet-stream";
        }
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPersonImageWithSize", request, config);
        WebApiBase.SetCompleted(options);
        let res = null;
        if (options && options.returnBlobAs != ReturnBlobType.AsArrayBuffer) {
          res = response.data;
          if (options.returnBlobAs == ReturnBlobType.AsString) {
            res = FromBase64ToString(res);
          }
        } else {
          res = response.data;
        }
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getPersonImageWithSizeAsync(personId, width, height, webapi_options) {
    let _request = null;
    let _options = null;
    const first = personId;
    if (typeof first === "object" && first && (typeof first.personId != "undefined" || typeof first.width != "undefined" || typeof first.height != "undefined")) {
      _request = personId;
      _options = width;
    } else {
      _request = {
        personId,
        width,
        height
      };
      _options = webapi_options;
    }
    return this._getPersonImageWithSizeAsync(_request, _options);
  }
  async _getProjectImageWithSizeAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        if (!options || options.returnBlobAs == ReturnBlobType.AsArrayBuffer) {
          config.responseType = "arraybuffer";
          config.headers = config.headers || {};
          config.headers["Accept"] = "application/octet-stream";
        }
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetProjectImageWithSize", request, config);
        WebApiBase.SetCompleted(options);
        let res = null;
        if (options && options.returnBlobAs != ReturnBlobType.AsArrayBuffer) {
          res = response.data;
          if (options.returnBlobAs == ReturnBlobType.AsString) {
            res = FromBase64ToString(res);
          }
        } else {
          res = response.data;
        }
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getProjectImageWithSizeAsync(projectId, width, height, webapi_options) {
    let _request = null;
    let _options = null;
    const first = projectId;
    if (typeof first === "object" && first && (typeof first.projectId != "undefined" || typeof first.width != "undefined" || typeof first.height != "undefined")) {
      _request = projectId;
      _options = width;
    } else {
      _request = {
        projectId,
        width,
        height
      };
      _options = webapi_options;
    }
    return this._getProjectImageWithSizeAsync(_request, _options);
  }
  async _getChatImageWithSizeAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        if (!options || options.returnBlobAs == ReturnBlobType.AsArrayBuffer) {
          config.responseType = "arraybuffer";
          config.headers = config.headers || {};
          config.headers["Accept"] = "application/octet-stream";
        }
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetChatImageWithSize", request, config);
        WebApiBase.SetCompleted(options);
        let res = null;
        if (options && options.returnBlobAs != ReturnBlobType.AsArrayBuffer) {
          res = response.data;
          if (options.returnBlobAs == ReturnBlobType.AsString) {
            res = FromBase64ToString(res);
          }
        } else {
          res = response.data;
        }
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getChatImageWithSizeAsync(chatTopicId, width, height, webapi_options) {
    let _request = null;
    let _options = null;
    const first = chatTopicId;
    if (typeof first === "object" && first && (typeof first.chatTopicId != "undefined" || typeof first.width != "undefined" || typeof first.height != "undefined")) {
      _request = chatTopicId;
      _options = width;
    } else {
      _request = {
        chatTopicId,
        width,
        height
      };
      _options = webapi_options;
    }
    return this._getChatImageWithSizeAsync(_request, _options);
  }
  async _getContactImageAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        if (!options || options.returnBlobAs == ReturnBlobType.AsArrayBuffer) {
          config.responseType = "arraybuffer";
          config.headers = config.headers || {};
          config.headers["Accept"] = "application/octet-stream";
        }
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetContactImage", request, config);
        WebApiBase.SetCompleted(options);
        let res = null;
        if (options && options.returnBlobAs != ReturnBlobType.AsArrayBuffer) {
          res = response.data;
          if (options.returnBlobAs == ReturnBlobType.AsString) {
            res = FromBase64ToString(res);
          }
        } else {
          res = response.data;
        }
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getContactImageAsync(contactId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = contactId;
    if (typeof first === "object" && first && typeof first.contactId != "undefined") {
      _request = contactId;
      _options = webapi_options;
    } else {
      _request = {
        contactId
      };
      _options = webapi_options;
    }
    return this._getContactImageAsync(_request, _options);
  }
  async _setContactImageAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetContactImage", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setContactImageAsync(contactId, image, webapi_options) {
    let _request = null;
    let _options = null;
    const first = contactId;
    if (typeof first === "object" && first && (typeof first.contactId != "undefined" || typeof first.image != "undefined")) {
      _request = contactId;
      _options = image;
    } else {
      _request = {
        contactId,
        image
      };
      _options = webapi_options;
    }
    _request.image = ToBase64(_request.image);
    return this._setContactImageAsync(_request, _options);
  }
  async _changeContactImageAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ChangeContactImage", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async changeContactImageAsync(contactId, blobId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = contactId;
    if (typeof first === "object" && first && (typeof first.contactId != "undefined" || typeof first.blobId != "undefined")) {
      _request = contactId;
      _options = blobId;
    } else {
      _request = {
        contactId,
        blobId
      };
      _options = webapi_options;
    }
    return this._changeContactImageAsync(_request, _options);
  }
  async _getBlobEntityOnContactAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetBlobEntityOnContact", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_BlobEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getBlobEntityOnContactAsync(contactId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = contactId;
    if (typeof first === "object" && first && typeof first.contactId != "undefined") {
      _request = contactId;
      _options = webapi_options;
    } else {
      _request = {
        contactId
      };
      _options = webapi_options;
    }
    return this._getBlobEntityOnContactAsync(_request, _options);
  }
  async _getContactImageWithSizeAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        if (!options || options.returnBlobAs == ReturnBlobType.AsArrayBuffer) {
          config.responseType = "arraybuffer";
          config.headers = config.headers || {};
          config.headers["Accept"] = "application/octet-stream";
        }
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetContactImageWithSize", request, config);
        WebApiBase.SetCompleted(options);
        let res = null;
        if (options && options.returnBlobAs != ReturnBlobType.AsArrayBuffer) {
          res = response.data;
          if (options.returnBlobAs == ReturnBlobType.AsString) {
            res = FromBase64ToString(res);
          }
        } else {
          res = response.data;
        }
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getContactImageWithSizeAsync(contactId, width, height, webapi_options) {
    let _request = null;
    let _options = null;
    const first = contactId;
    if (typeof first === "object" && first && (typeof first.contactId != "undefined" || typeof first.width != "undefined" || typeof first.height != "undefined")) {
      _request = contactId;
      _options = width;
    } else {
      _request = {
        contactId,
        width,
        height
      };
      _options = webapi_options;
    }
    return this._getContactImageWithSizeAsync(_request, _options);
  }
  async _getOutputFromBatchAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        if (!options || options.returnBlobAs == ReturnBlobType.AsArrayBuffer) {
          config.responseType = "arraybuffer";
          config.headers = config.headers || {};
          config.headers["Accept"] = "application/octet-stream";
        }
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetOutputFromBatch", request, config);
        WebApiBase.SetCompleted(options);
        let res = null;
        if (options && options.returnBlobAs != ReturnBlobType.AsArrayBuffer) {
          res = response.data;
          if (options.returnBlobAs == ReturnBlobType.AsString) {
            res = FromBase64ToString(res);
          }
        } else {
          res = response.data;
        }
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getOutputFromBatchAsync(batchTaskId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = batchTaskId;
    if (typeof first === "object" && first && typeof first.batchTaskId != "undefined") {
      _request = batchTaskId;
      _options = webapi_options;
    } else {
      _request = {
        batchTaskId
      };
      _options = webapi_options;
    }
    return this._getOutputFromBatchAsync(_request, _options);
  }
  async _cleanupBatchTaskAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CleanupBatchTask", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async cleanupBatchTaskAsync(batchTaskId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = batchTaskId;
    if (typeof first === "object" && first && typeof first.batchTaskId != "undefined") {
      _request = batchTaskId;
      _options = webapi_options;
    } else {
      _request = {
        batchTaskId
      };
      _options = webapi_options;
    }
    return this._cleanupBatchTaskAsync(_request, _options);
  }
};

// server/node_modules/@superoffice/webapi/dist/esm/NavigatorAgent.js
var NavigatorAgent = class extends WebApiBase {
  constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
    const options = WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
    options.basePath = "v1/Agents/Navigator/";
    super(options);
  }
  /*
   * Gets a NavigatorCompany object.
   * @param navigatorCompanyId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single NavigatorCompany
   */
  async getNavigatorCompanyAsync(navigatorCompanyId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetNavigatorCompany?navigatorCompanyId=" + navigatorCompanyId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_NavigatorCompany_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets an array of NavigatorCompany objects.
   * @param navigatorCompanyIds - The primary keys.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns An array of NavigatorCompany
   */
  async getNavigatorCompanyListAsync(navigatorCompanyIds, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetNavigatorCompanyList", navigatorCompanyIds, config);
        WebApiBase.SetCompleted(options);
        const res = Create_NavigatorCompanyArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getNavigatorCompaniesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetNavigatorCompanies", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_NavigatorCompanyArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getNavigatorCompaniesAsync(name, webapi_options) {
    let _request = null;
    let _options = null;
    const first = name;
    if (typeof first === "object" && first && typeof first.name != "undefined") {
      _request = name;
      _options = webapi_options;
    } else {
      _request = {
        name
      };
      _options = webapi_options;
    }
    return this._getNavigatorCompaniesAsync(_request, _options);
  }
};

// server/node_modules/@superoffice/webapi/dist/esm/MDOAgent.js
var MDOAgent = class extends WebApiBase {
  constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
    const options = WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
    options.basePath = "v1/Agents/MDO/";
    super(options);
  }
  async _getListAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetList", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_MDOListItemArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getListAsync(name, forceFlatList, additionalInfo, onlyHistory, webapi_options) {
    let _request = null;
    let _options = null;
    const first = name;
    if (typeof first === "object" && first && (typeof first.name != "undefined" || typeof first.forceFlatList != "undefined" || typeof first.additionalInfo != "undefined" || typeof first.onlyHistory != "undefined")) {
      _request = name;
      _options = forceFlatList;
    } else {
      _request = {
        name,
        forceFlatList,
        additionalInfo,
        onlyHistory
      };
      _options = webapi_options;
    }
    return this._getListAsync(_request, _options);
  }
  async _getListWithHistoryAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetListWithHistory", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_MDOListItemArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getListWithHistoryAsync(name, forceFlatList, additionalInfo, historyItems, onlyHistory, webapi_options) {
    let _request = null;
    let _options = null;
    const first = name;
    if (typeof first === "object" && first && (typeof first.name != "undefined" || typeof first.forceFlatList != "undefined" || typeof first.additionalInfo != "undefined" || typeof first.historyItems != "undefined" || typeof first.onlyHistory != "undefined")) {
      _request = name;
      _options = forceFlatList;
    } else {
      _request = {
        name,
        forceFlatList,
        additionalInfo,
        historyItems,
        onlyHistory
      };
      _options = webapi_options;
    }
    return this._getListWithHistoryAsync(_request, _options);
  }
  async _getListWithRestrictionAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetListWithRestriction", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_MDOListItemArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getListWithRestrictionAsync(name, additionalInfo, searchValue, webapi_options) {
    let _request = null;
    let _options = null;
    const first = name;
    if (typeof first === "object" && first && (typeof first.name != "undefined" || typeof first.additionalInfo != "undefined" || typeof first.searchValue != "undefined")) {
      _request = name;
      _options = additionalInfo;
    } else {
      _request = {
        name,
        additionalInfo,
        searchValue
      };
      _options = webapi_options;
    }
    return this._getListWithRestrictionAsync(_request, _options);
  }
  async _getSimpleListAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetSimpleList", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_MDOListItemArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getSimpleListAsync(name, webapi_options) {
    let _request = null;
    let _options = null;
    const first = name;
    if (typeof first === "object" && first && typeof first.name != "undefined") {
      _request = name;
      _options = webapi_options;
    } else {
      _request = {
        name
      };
      _options = webapi_options;
    }
    return this._getSimpleListAsync(_request, _options);
  }
  async _getListItemAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetListItem", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_MDOListItem_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getListItemAsync(listName, id, webapi_options) {
    let _request = null;
    let _options = null;
    const first = listName;
    if (typeof first === "object" && first && (typeof first.listName != "undefined" || typeof first.id != "undefined")) {
      _request = listName;
      _options = id;
    } else {
      _request = {
        listName,
        id
      };
      _options = webapi_options;
    }
    return this._getListItemAsync(_request, _options);
  }
  async _getListNamesAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetListNames", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Returns a list of all MDO List names. These names can also be used with the Archive agent as ProviderNames.
   * @returns Array of list names.
   */
  async getListNamesAsync(webapi_options) {
    return this._getListNamesAsync(webapi_options);
  }
  async _getListIdByListNameAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetListIdByListName", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getListIdByListNameAsync(name, webapi_options) {
    let _request = null;
    let _options = null;
    const first = name;
    if (typeof first === "object" && first && typeof first.name != "undefined") {
      _request = name;
      _options = webapi_options;
    } else {
      _request = {
        name
      };
      _options = webapi_options;
    }
    return this._getListIdByListNameAsync(_request, _options);
  }
  async _getSelectableSimpleListAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetSelectableSimpleList", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SelectableMDOListItemArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getSelectableSimpleListAsync(name, webapi_options) {
    let _request = null;
    let _options = null;
    const first = name;
    if (typeof first === "object" && first && typeof first.name != "undefined") {
      _request = name;
      _options = webapi_options;
    } else {
      _request = {
        name
      };
      _options = webapi_options;
    }
    return this._getSelectableSimpleListAsync(_request, _options);
  }
  async _getSelectableListWithRestrictionAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetSelectableListWithRestriction", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SelectableMDOListItemArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getSelectableListWithRestrictionAsync(name, additionalInfo, searchValue, webapi_options) {
    let _request = null;
    let _options = null;
    const first = name;
    if (typeof first === "object" && first && (typeof first.name != "undefined" || typeof first.additionalInfo != "undefined" || typeof first.searchValue != "undefined")) {
      _request = name;
      _options = additionalInfo;
    } else {
      _request = {
        name,
        additionalInfo,
        searchValue
      };
      _options = webapi_options;
    }
    return this._getSelectableListWithRestrictionAsync(_request, _options);
  }
  async _getSelectableListWithHistoryAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetSelectableListWithHistory", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SelectableMDOListItemArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getSelectableListWithHistoryAsync(name, forceFlatList, additionalInfo, historyItems, onlyHistory, webapi_options) {
    let _request = null;
    let _options = null;
    const first = name;
    if (typeof first === "object" && first && (typeof first.name != "undefined" || typeof first.forceFlatList != "undefined" || typeof first.additionalInfo != "undefined" || typeof first.historyItems != "undefined" || typeof first.onlyHistory != "undefined")) {
      _request = name;
      _options = forceFlatList;
    } else {
      _request = {
        name,
        forceFlatList,
        additionalInfo,
        historyItems,
        onlyHistory
      };
      _options = webapi_options;
    }
    return this._getSelectableListWithHistoryAsync(_request, _options);
  }
  async _getSelectableListAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetSelectableList", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SelectableMDOListItemArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getSelectableListAsync(name, forceFlatList, additionalInfo, onlyHistory, webapi_options) {
    let _request = null;
    let _options = null;
    const first = name;
    if (typeof first === "object" && first && (typeof first.name != "undefined" || typeof first.forceFlatList != "undefined" || typeof first.additionalInfo != "undefined" || typeof first.onlyHistory != "undefined")) {
      _request = name;
      _options = forceFlatList;
    } else {
      _request = {
        name,
        forceFlatList,
        additionalInfo,
        onlyHistory
      };
      _options = webapi_options;
    }
    return this._getSelectableListAsync(_request, _options);
  }
  async _setSelectedAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetSelected", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SelectableMDOListItemArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setSelectedAsync(name, additionalInfo, selectableMDOList, webapi_options) {
    let _request = null;
    let _options = null;
    const first = name;
    if (typeof first === "object" && first && (typeof first.name != "undefined" || typeof first.additionalInfo != "undefined" || typeof first.selectableMDOList != "undefined")) {
      _request = name;
      _options = additionalInfo;
    } else {
      _request = {
        name,
        additionalInfo,
        selectableMDOList
      };
      _options = webapi_options;
    }
    return this._setSelectedAsync(_request, _options);
  }
};

// server/node_modules/@superoffice/webapi/dist/esm/ConfigurationAgent.js
var ConfigurationAgent = class extends WebApiBase {
  constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
    const options = WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
    options.basePath = "v1/Agents/Configuration/";
    super(options);
  }
  /**
   * Set default values into a new ConfigurableScreenDelta.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultConfigurableScreenDeltaAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultConfigurableScreenDelta", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ConfigurableScreenDelta_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing ConfigurableScreenDelta or creates a new ConfigurableScreenDelta if the id parameter is empty
   * @param entity - The ConfigurableScreenDelta to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated ConfigurableScreenDelta
   */
  async saveConfigurableScreenDeltaAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveConfigurableScreenDelta", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ConfigurableScreenDelta_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Deletes the ConfigurableScreenDelta
   * @param ConfigurableScreenDeltaId - The id of the ConfigurableScreenDelta to be deleted.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   */
  async deleteConfigurableScreenDeltaAsync(ConfigurableScreenDeltaId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("DeleteConfigurableScreenDelta?ConfigurableScreenDeltaId=" + ConfigurableScreenDeltaId, null, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new DiaryViewEntity.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultDiaryViewEntityAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultDiaryViewEntity", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DiaryViewEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing DiaryViewEntity or creates a new DiaryViewEntity if the id parameter is empty
   * @param entity - The DiaryViewEntity to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated DiaryViewEntity
   */
  async saveDiaryViewEntityAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveDiaryViewEntity", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DiaryViewEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Deletes the DiaryViewEntity
   * @param DiaryViewEntityId - The id of the DiaryViewEntity to be deleted.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   */
  async deleteDiaryViewEntityAsync(DiaryViewEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("DeleteDiaryViewEntity?DiaryViewEntityId=" + DiaryViewEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new SystemEventEntity.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultSystemEventEntityAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultSystemEventEntity", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SystemEventEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing SystemEventEntity or creates a new SystemEventEntity if the id parameter is empty
   * @param entity - The SystemEventEntity to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated SystemEventEntity
   */
  async saveSystemEventEntityAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveSystemEventEntity", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SystemEventEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Deletes the SystemEventEntity
   * @param SystemEventEntityId - The id of the SystemEventEntity to be deleted.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   */
  async deleteSystemEventEntityAsync(SystemEventEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("DeleteSystemEventEntity?SystemEventEntityId=" + SystemEventEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets a ConfigurableScreenDelta object.
   * @param configurableScreenDeltaId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single ConfigurableScreenDelta
   */
  async getConfigurableScreenDeltaAsync(configurableScreenDeltaId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetConfigurableScreenDelta?configurableScreenDeltaId=" + configurableScreenDeltaId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ConfigurableScreenDelta_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getScreenConfigurationDeltasAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetScreenConfigurationDeltas", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * This method will return a json with all deltas for screen
   * @returns A string with all recipe deltas in json for logged in associate
   */
  async getScreenConfigurationDeltasAsync(webapi_options) {
    return this._getScreenConfigurationDeltasAsync(webapi_options);
  }
  async _getScreenConfigurationDeltaAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetScreenConfigurationDelta", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getScreenConfigurationDeltaAsync(deltaType, deltaState, webapi_options) {
    let _request = null;
    let _options = null;
    const first = deltaType;
    if (typeof first === "object" && first && (typeof first.deltaType != "undefined" || typeof first.deltaState != "undefined")) {
      _request = deltaType;
      _options = deltaState;
    } else {
      _request = {
        deltaType,
        deltaState
      };
      _options = webapi_options;
    }
    return this._getScreenConfigurationDeltaAsync(_request, _options);
  }
  async _getConfigurableScreenDeltasByDeltaAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetConfigurableScreenDeltasByDelta", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ConfigurableScreenDeltaArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getConfigurableScreenDeltasByDeltaAsync(configurableScreenDelta, webapi_options) {
    let _request = null;
    let _options = null;
    const first = configurableScreenDelta;
    if (typeof first === "object" && first && typeof first.configurableScreenDelta != "undefined") {
      _request = configurableScreenDelta;
      _options = webapi_options;
    } else {
      _request = {
        configurableScreenDelta
      };
      _options = webapi_options;
    }
    return this._getConfigurableScreenDeltasByDeltaAsync(_request, _options);
  }
  async _getConfigurableScreenDeltasByQueryAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetConfigurableScreenDeltasByQuery", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ConfigurableScreenDeltaArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getConfigurableScreenDeltasByQueryAsync(deltaQuery, webapi_options) {
    let _request = null;
    let _options = null;
    const first = deltaQuery;
    if (typeof first === "object" && first && typeof first.deltaQuery != "undefined") {
      _request = deltaQuery;
      _options = webapi_options;
    } else {
      _request = {
        deltaQuery
      };
      _options = webapi_options;
    }
    return this._getConfigurableScreenDeltasByQueryAsync(_request, _options);
  }
  async _rebuildUdefDeltasAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("RebuildUdefDeltas", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Flush and rebuild userdefined field deltas. Mostly used after publishing udefs or adding/editing Customer Service extrafields
   * @returns No return value
   */
  async rebuildUdefDeltasAsync(webapi_options) {
    return this._rebuildUdefDeltasAsync(webapi_options);
  }
  async _rebuildWebpanelDeltasAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("RebuildWebpanelDeltas", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Flush and rebuild webpanel deltas. Mostly used after adding/editing webpanels or change group visibility of them
   * @returns No return value
   */
  async rebuildWebpanelDeltasAsync(webapi_options) {
    return this._rebuildWebpanelDeltasAsync(webapi_options);
  }
  async _saveAndPublishAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveAndPublish", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ConfigurableScreenDelta_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveAndPublishAsync(configurableScreenDelta, webapi_options) {
    let _request = null;
    let _options = null;
    const first = configurableScreenDelta;
    if (typeof first === "object" && first && typeof first.configurableScreenDelta != "undefined") {
      _request = configurableScreenDelta;
      _options = webapi_options;
    } else {
      _request = {
        configurableScreenDelta
      };
      _options = webapi_options;
    }
    return this._saveAndPublishAsync(_request, _options);
  }
  async _setAppliesToKeyAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetAppliesToKey", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setAppliesToKeyAsync(recipeId, appliesToKey, webapi_options) {
    let _request = null;
    let _options = null;
    const first = recipeId;
    if (typeof first === "object" && first && (typeof first.recipeId != "undefined" || typeof first.appliesToKey != "undefined")) {
      _request = recipeId;
      _options = appliesToKey;
    } else {
      _request = {
        recipeId,
        appliesToKey
      };
      _options = webapi_options;
    }
    return this._setAppliesToKeyAsync(_request, _options);
  }
  async _getRecipeAppliesToMappingsAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetRecipeAppliesToMappings", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_StringDictionary_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Return the a  dictionary with recipeId as key, and chosen appliesTo for that recipe, Like projecttype for projectcardrecipe
   * @returns Mapping of recipeId and selected appliesToKey
   */
  async getRecipeAppliesToMappingsAsync(webapi_options) {
    return this._getRecipeAppliesToMappingsAsync(webapi_options);
  }
  async _getApplicationConfigurationAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetApplicationConfiguration", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getApplicationConfigurationAsync(application, instance, webapi_options) {
    let _request = null;
    let _options = null;
    const first = application;
    if (typeof first === "object" && first && (typeof first.application != "undefined" || typeof first.instance != "undefined")) {
      _request = application;
      _options = instance;
    } else {
      _request = {
        application,
        instance
      };
      _options = webapi_options;
    }
    return this._getApplicationConfigurationAsync(_request, _options);
  }
  async _getPageConfigurationAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPageConfiguration", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getPageConfigurationAsync(application, instance, page, webapi_options) {
    let _request = null;
    let _options = null;
    const first = application;
    if (typeof first === "object" && first && (typeof first.application != "undefined" || typeof first.instance != "undefined" || typeof first.page != "undefined")) {
      _request = application;
      _options = instance;
    } else {
      _request = {
        application,
        instance,
        page
      };
      _options = webapi_options;
    }
    return this._getPageConfigurationAsync(_request, _options);
  }
  async _getObjectMappingAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetObjectMapping", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getObjectMappingAsync(application, instance, webapi_options) {
    let _request = null;
    let _options = null;
    const first = application;
    if (typeof first === "object" && first && (typeof first.application != "undefined" || typeof first.instance != "undefined")) {
      _request = application;
      _options = instance;
    } else {
      _request = {
        application,
        instance
      };
      _options = webapi_options;
    }
    return this._getObjectMappingAsync(_request, _options);
  }
  async _getFilterListAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetFilterList", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getFilterListAsync(application, instance, webapi_options) {
    let _request = null;
    let _options = null;
    const first = application;
    if (typeof first === "object" && first && (typeof first.application != "undefined" || typeof first.instance != "undefined")) {
      _request = application;
      _options = instance;
    } else {
      _request = {
        application,
        instance
      };
      _options = webapi_options;
    }
    return this._getFilterListAsync(_request, _options);
  }
  async _clearConfigurationCacheAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ClearConfigurationCache", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async clearConfigurationCacheAsync(application, instance, forAllAssociates, webapi_options) {
    let _request = null;
    let _options = null;
    const first = application;
    if (typeof first === "object" && first && (typeof first.application != "undefined" || typeof first.instance != "undefined" || typeof first.forAllAssociates != "undefined")) {
      _request = application;
      _options = instance;
    } else {
      _request = {
        application,
        instance,
        forAllAssociates
      };
      _options = webapi_options;
    }
    return this._clearConfigurationCacheAsync(_request, _options);
  }
  async _getAnyConfigurationAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetAnyConfiguration", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getAnyConfigurationAsync(application, instance, item, type, webapi_options) {
    let _request = null;
    let _options = null;
    const first = application;
    if (typeof first === "object" && first && (typeof first.application != "undefined" || typeof first.instance != "undefined" || typeof first.item != "undefined" || typeof first.type != "undefined")) {
      _request = application;
      _options = instance;
    } else {
      _request = {
        application,
        instance,
        item,
        type
      };
      _options = webapi_options;
    }
    return this._getAnyConfigurationAsync(_request, _options);
  }
  async _getEMarketingUrlAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetEMarketingUrl", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getEMarketingUrlAsync(language, webapi_options) {
    let _request = null;
    let _options = null;
    const first = language;
    if (typeof first === "object" && first && typeof first.language != "undefined") {
      _request = language;
      _options = webapi_options;
    } else {
      _request = {
        language
      };
      _options = webapi_options;
    }
    return this._getEMarketingUrlAsync(_request, _options);
  }
  async _getCsProgramUrlAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetCsProgramUrl", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getCsProgramUrlAsync(language, programName, action, extraParameters, webapi_options) {
    let _request = null;
    let _options = null;
    const first = language;
    if (typeof first === "object" && first && (typeof first.language != "undefined" || typeof first.programName != "undefined" || typeof first.action != "undefined" || typeof first.extraParameters != "undefined")) {
      _request = language;
      _options = programName;
    } else {
      _request = {
        language,
        programName,
        action,
        extraParameters
      };
      _options = webapi_options;
    }
    return this._getCsProgramUrlAsync(_request, _options);
  }
  async _getCSAuthUrlAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetCSAuthUrl", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getCSAuthUrlAsync(language, programName, action, extraParameters, webapi_options) {
    let _request = null;
    let _options = null;
    const first = language;
    if (typeof first === "object" && first && (typeof first.language != "undefined" || typeof first.programName != "undefined" || typeof first.action != "undefined" || typeof first.extraParameters != "undefined")) {
      _request = language;
      _options = programName;
    } else {
      _request = {
        language,
        programName,
        action,
        extraParameters
      };
      _options = webapi_options;
    }
    return this._getCSAuthUrlAsync(_request, _options);
  }
  async _getCSRegistryValueAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetCSRegistryValue", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getCSRegistryValueAsync(entry, webapi_options) {
    let _request = null;
    let _options = null;
    const first = entry;
    if (typeof first === "object" && first && typeof first.entry != "undefined") {
      _request = entry;
      _options = webapi_options;
    } else {
      _request = {
        entry
      };
      _options = webapi_options;
    }
    return this._getCSRegistryValueAsync(_request, _options);
  }
  async _getCSWwwFolderAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetCSWwwFolder", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * This method will get the www folder for CS
   * @returns The www folder for CS
   */
  async getCSWwwFolderAsync(webapi_options) {
    return this._getCSWwwFolderAsync(webapi_options);
  }
  async _getRefreshedPageConfigurationAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetRefreshedPageConfiguration", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getRefreshedPageConfigurationAsync(application, instance, page, webapi_options) {
    let _request = null;
    let _options = null;
    const first = application;
    if (typeof first === "object" && first && (typeof first.application != "undefined" || typeof first.instance != "undefined" || typeof first.page != "undefined")) {
      _request = application;
      _options = instance;
    } else {
      _request = {
        application,
        instance,
        page
      };
      _options = webapi_options;
    }
    return this._getRefreshedPageConfigurationAsync(_request, _options);
  }
  async _getWwwUrlAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetWwwUrl", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getWwwUrlAsync(client, webapi_options) {
    let _request = null;
    let _options = null;
    const first = client;
    if (typeof first === "object" && first && typeof first.client != "undefined") {
      _request = client;
      _options = webapi_options;
    } else {
      _request = {
        client
      };
      _options = webapi_options;
    }
    return this._getWwwUrlAsync(_request, _options);
  }
  async _getHelpDispatcherUrlAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetHelpDispatcherUrl", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Will get the GetHelpDispatcherUrl used by the help system
   * @returns URL to be used by the help system
   */
  async getHelpDispatcherUrlAsync(webapi_options) {
    return this._getHelpDispatcherUrlAsync(webapi_options);
  }
  async _getWwwUrlForSMWebAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetWwwUrlForSMWeb", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Returns the URL used for the logo by the SM.web client. Uses urldispatch.aspx
   * @returns Link to urldispatch.aspx tagged with [SOSITEURL]
   */
  async getWwwUrlForSMWebAsync(webapi_options) {
    return this._getWwwUrlForSMWebAsync(webapi_options);
  }
  async _getCsCgiUrlInternalAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetCsCgiUrlInternal", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * This method will get the host name for CS
   * @returns Will get the host name for where CS is installed
   */
  async getCsCgiUrlInternalAsync(webapi_options) {
    return this._getCsCgiUrlInternalAsync(webapi_options);
  }
  async _getCRMUrlAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetCRMUrl", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getCRMUrlAsync(soProtocol, currents, frameless, webapi_options) {
    let _request = null;
    let _options = null;
    const first = soProtocol;
    if (typeof first === "object" && first && (typeof first.soProtocol != "undefined" || typeof first.currents != "undefined" || typeof first.frameless != "undefined")) {
      _request = soProtocol;
      _options = currents;
    } else {
      _request = {
        soProtocol,
        currents,
        frameless
      };
      _options = webapi_options;
    }
    return this._getCRMUrlAsync(_request, _options);
  }
  async _getEmailNumberOfDaysAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetEmailNumberOfDays", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   *
   * @returns Number of days in the past for which we are fetching email
   */
  async getEmailNumberOfDaysAsync(webapi_options) {
    return this._getEmailNumberOfDaysAsync(webapi_options);
  }
  async _getCustomerUrlAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetCustomerUrl", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * This method will get the URL for the external access to the customer center
   * @returns The URL to the customer center, without any actions
   */
  async getCustomerUrlAsync(webapi_options) {
    return this._getCustomerUrlAsync(webapi_options);
  }
  async _getSpfDomainAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetSpfDomain", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Get the SPF domain defined for the mail cluster for this tenant (Online only)
   * @returns The configured SPF domain. Will return empty for Onsite installations or tenants in Online using custom SMTP
   */
  async getSpfDomainAsync(webapi_options) {
    return this._getSpfDomainAsync(webapi_options);
  }
  /*
   * Gets a DiaryViewEntity object.
   * @param diaryViewEntityId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single DiaryViewEntity
   */
  async getDiaryViewEntityAsync(diaryViewEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetDiaryViewEntity?diaryViewEntityId=" + diaryViewEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DiaryViewEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets a SystemEventEntity object.
   * @param systemEventEntityId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single SystemEventEntity
   */
  async getSystemEventEntityAsync(systemEventEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetSystemEventEntity?systemEventEntityId=" + systemEventEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SystemEventEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _existsSystemEventAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ExistsSystemEvent", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async existsSystemEventAsync(key, webapi_options) {
    let _request = null;
    let _options = null;
    const first = key;
    if (typeof first === "object" && first && typeof first.key != "undefined") {
      _request = key;
      _options = webapi_options;
    } else {
      _request = {
        key
      };
      _options = webapi_options;
    }
    return this._existsSystemEventAsync(_request, _options);
  }
  /*
   * Gets a WindowPosSize object.
   * @param windowPosSizeId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single WindowPosSize
   */
  async getWindowPosSizeAsync(windowPosSizeId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetWindowPosSize?windowPosSizeId=" + windowPosSizeId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_WindowPosSize_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _saveWindowPosSizeAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveWindowPosSize", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_WindowPosSize_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveWindowPosSizeAsync(windowPosSize, webapi_options) {
    let _request = null;
    let _options = null;
    const first = windowPosSize;
    if (typeof first === "object" && first && typeof first.windowPosSize != "undefined") {
      _request = windowPosSize;
      _options = webapi_options;
    } else {
      _request = {
        windowPosSize
      };
      _options = webapi_options;
    }
    return this._saveWindowPosSizeAsync(_request, _options);
  }
  async _deleteWindowPosSizeAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeleteWindowPosSize", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async deleteWindowPosSizeAsync(windowPosSizeId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = windowPosSizeId;
    if (typeof first === "object" && first && typeof first.windowPosSizeId != "undefined") {
      _request = windowPosSizeId;
      _options = webapi_options;
    } else {
      _request = {
        windowPosSizeId
      };
      _options = webapi_options;
    }
    return this._deleteWindowPosSizeAsync(_request, _options);
  }
  /*
   * Gets an array of WindowPosSize objects.
   * @param windowPosSizeIds - The primary keys.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns An array of WindowPosSize
   */
  async getWindowPosSizeListAsync(windowPosSizeIds, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetWindowPosSizeList", windowPosSizeIds, config);
        WebApiBase.SetCompleted(options);
        const res = Create_WindowPosSizeArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getMyWindowPosSizesAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetMyWindowPosSizes", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_WindowPosSizeArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Gets the window and dialog position and size settings belonging to the currently logged on user
   * @returns Array of window and dialog position and size settings
   */
  async getMyWindowPosSizesAsync(webapi_options) {
    return this._getMyWindowPosSizesAsync(webapi_options);
  }
  async _getWindowPosSizesOnPersonIdAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetWindowPosSizesOnPersonId", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_WindowPosSizeArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getWindowPosSizesOnPersonIdAsync(personId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = personId;
    if (typeof first === "object" && first && typeof first.personId != "undefined") {
      _request = personId;
      _options = webapi_options;
    } else {
      _request = {
        personId
      };
      _options = webapi_options;
    }
    return this._getWindowPosSizesOnPersonIdAsync(_request, _options);
  }
  async _getWindowPosSizesOnAssociateIdAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetWindowPosSizesOnAssociateId", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_WindowPosSizeArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getWindowPosSizesOnAssociateIdAsync(associateId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = associateId;
    if (typeof first === "object" && first && typeof first.associateId != "undefined") {
      _request = associateId;
      _options = webapi_options;
    } else {
      _request = {
        associateId
      };
      _options = webapi_options;
    }
    return this._getWindowPosSizesOnAssociateIdAsync(_request, _options);
  }
  async _saveWindowPosSizesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveWindowPosSizes", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_WindowPosSizeArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveWindowPosSizesAsync(windowPosSizes, webapi_options) {
    let _request = null;
    let _options = null;
    const first = windowPosSizes;
    if (typeof first === "object" && first && typeof first.windowPosSizes != "undefined") {
      _request = windowPosSizes;
      _options = webapi_options;
    } else {
      _request = {
        windowPosSizes
      };
      _options = webapi_options;
    }
    return this._saveWindowPosSizesAsync(_request, _options);
  }
};

// server/node_modules/@superoffice/webapi/dist/esm/ViewStateAgent.js
var ViewStateAgent = class extends WebApiBase {
  constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
    const options = WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
    options.basePath = "v1/Agents/ViewState/";
    super(options);
  }
  async _getLiveUiConfigAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetLiveUiConfig", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_LiveUiConfig_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Gets live UI configuration
   * @returns Live UI configuration containing the parameters needed for live UI functionality
   */
  async getLiveUiConfigAsync(webapi_options) {
    return this._getLiveUiConfigAsync(webapi_options);
  }
  /*
   * Gets a History object.
   * @param historyId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single History
   */
  async getHistoryAsync(historyId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetHistory?historyId=" + historyId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_History_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getCurrentAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetCurrent", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_History_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getCurrentAsync(historyName, webapi_options) {
    let _request = null;
    let _options = null;
    const first = historyName;
    if (typeof first === "object" && first && typeof first.historyName != "undefined") {
      _request = historyName;
      _options = webapi_options;
    } else {
      _request = {
        historyName
      };
      _options = webapi_options;
    }
    return this._getCurrentAsync(_request, _options);
  }
  async _saveCurrentAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveCurrent", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_History_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveCurrentAsync(current, webapi_options) {
    let _request = null;
    let _options = null;
    const first = current;
    if (typeof first === "object" && first && typeof first.current != "undefined") {
      _request = current;
      _options = webapi_options;
    } else {
      _request = {
        current
      };
      _options = webapi_options;
    }
    return this._saveCurrentAsync(_request, _options);
  }
  async _getNextCurrentAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetNextCurrent", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_History_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getNextCurrentAsync(historyName, id, webapi_options) {
    let _request = null;
    let _options = null;
    const first = historyName;
    if (typeof first === "object" && first && (typeof first.historyName != "undefined" || typeof first.id != "undefined")) {
      _request = historyName;
      _options = id;
    } else {
      _request = {
        historyName,
        id
      };
      _options = webapi_options;
    }
    return this._getNextCurrentAsync(_request, _options);
  }
  async _getPreviousCurrentAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPreviousCurrent", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_History_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getPreviousCurrentAsync(historyName, id, webapi_options) {
    let _request = null;
    let _options = null;
    const first = historyName;
    if (typeof first === "object" && first && (typeof first.historyName != "undefined" || typeof first.id != "undefined")) {
      _request = historyName;
      _options = id;
    } else {
      _request = {
        historyName,
        id
      };
      _options = webapi_options;
    }
    return this._getPreviousCurrentAsync(_request, _options);
  }
  async _deleteHistoryAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeleteHistory", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async deleteHistoryAsync(historyName, id, webapi_options) {
    let _request = null;
    let _options = null;
    const first = historyName;
    if (typeof first === "object" && first && (typeof first.historyName != "undefined" || typeof first.id != "undefined")) {
      _request = historyName;
      _options = id;
    } else {
      _request = {
        historyName,
        id
      };
      _options = webapi_options;
    }
    return this._deleteHistoryAsync(_request, _options);
  }
  async _getHistoriesAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetHistories", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_HistoryArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Returns all history items that belong to the currently logged in user
   * @returns Array of History items
   */
  async getHistoriesAsync(webapi_options) {
    return this._getHistoriesAsync(webapi_options);
  }
  async _getHistoriesByNameAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetHistoriesByName", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_HistoryArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getHistoriesByNameAsync(historyName, webapi_options) {
    let _request = null;
    let _options = null;
    const first = historyName;
    if (typeof first === "object" && first && typeof first.historyName != "undefined") {
      _request = historyName;
      _options = webapi_options;
    } else {
      _request = {
        historyName
      };
      _options = webapi_options;
    }
    return this._getHistoriesByNameAsync(_request, _options);
  }
  async _getHistoriesByNamesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetHistoriesByNames", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_HistoryArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getHistoriesByNamesAsync(historyNames, webapi_options) {
    let _request = null;
    let _options = null;
    const first = historyNames;
    if (typeof first === "object" && first && typeof first.historyNames != "undefined") {
      _request = historyNames;
      _options = webapi_options;
    } else {
      _request = {
        historyNames
      };
      _options = webapi_options;
    }
    return this._getHistoriesByNamesAsync(_request, _options);
  }
  async _saveHistoriesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveHistories", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_HistoryArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveHistoriesAsync(historyName, history, webapi_options) {
    let _request = null;
    let _options = null;
    const first = historyName;
    if (typeof first === "object" && first && (typeof first.historyName != "undefined" || typeof first.history != "undefined")) {
      _request = historyName;
      _options = history;
    } else {
      _request = {
        historyName,
        history
      };
      _options = webapi_options;
    }
    return this._saveHistoriesAsync(_request, _options);
  }
  async _getHistoryLengthPrefValueAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetHistoryLengthPrefValue", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Get the logged on user&apos;s preferred history list length. Will return the system preference if no user preferences are available.
   * @returns The history list lenght
   */
  async getHistoryLengthPrefValueAsync(webapi_options) {
    return this._getHistoryLengthPrefValueAsync(webapi_options);
  }
  async _setHistoryLengthPrefValueAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetHistoryLengthPrefValue", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setHistoryLengthPrefValueAsync(length, webapi_options) {
    let _request = null;
    let _options = null;
    const first = length;
    if (typeof first === "object" && first && typeof first.length != "undefined") {
      _request = length;
      _options = webapi_options;
    } else {
      _request = {
        length
      };
      _options = webapi_options;
    }
    return this._setHistoryLengthPrefValueAsync(_request, _options);
  }
  async _saveCurrentsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveCurrents", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_HistoryArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveCurrentsAsync(currents, webapi_options) {
    let _request = null;
    let _options = null;
    const first = currents;
    if (typeof first === "object" && first && typeof first.currents != "undefined") {
      _request = currents;
      _options = webapi_options;
    } else {
      _request = {
        currents
      };
      _options = webapi_options;
    }
    return this._saveCurrentsAsync(_request, _options);
  }
  async _getHistoriesByNamesAndIdsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetHistoriesByNamesAndIds", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_HistoryArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getHistoriesByNamesAndIdsAsync(requests, webapi_options) {
    let _request = null;
    let _options = null;
    const first = requests;
    if (typeof first === "object" && first && typeof first.requests != "undefined") {
      _request = requests;
      _options = webapi_options;
    } else {
      _request = {
        requests
      };
      _options = webapi_options;
    }
    return this._getHistoriesByNamesAndIdsAsync(_request, _options);
  }
  async _publishAndRetrieveUiEventsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("PublishAndRetrieveUiEvents", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_UiEventArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async publishAndRetrieveUiEventsAsync(latestKnownEventId, publishEvents, metrics, webapi_options) {
    let _request = null;
    let _options = null;
    const first = latestKnownEventId;
    if (typeof first === "object" && first && (typeof first.latestKnownEventId != "undefined" || typeof first.publishEvents != "undefined" || typeof first.metrics != "undefined")) {
      _request = latestKnownEventId;
      _options = publishEvents;
    } else {
      _request = {
        latestKnownEventId,
        publishEvents,
        metrics
      };
      _options = webapi_options;
    }
    return this._publishAndRetrieveUiEventsAsync(_request, _options);
  }
};

// server/node_modules/@superoffice/webapi/dist/esm/AssociateAgent.js
var AssociateAgent = class extends WebApiBase {
  constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
    const options = WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
    options.basePath = "v1/Agents/Associate/";
    super(options);
  }
  /*
   * Gets a Associate object.
   * @param associateId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single Associate
   */
  async getAssociateAsync(associateId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetAssociate?associateId=" + associateId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Associate_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getAssociateByPersonIdAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetAssociateByPersonId", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Associate_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getAssociateByPersonIdAsync(personId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = personId;
    if (typeof first === "object" && first && typeof first.personId != "undefined") {
      _request = personId;
      _options = webapi_options;
    } else {
      _request = {
        personId
      };
      _options = webapi_options;
    }
    return this._getAssociateByPersonIdAsync(_request, _options);
  }
  async _getNoteAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetNote", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getNoteAsync(associateId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = associateId;
    if (typeof first === "object" && first && typeof first.associateId != "undefined") {
      _request = associateId;
      _options = webapi_options;
    } else {
      _request = {
        associateId
      };
      _options = webapi_options;
    }
    return this._getNoteAsync(_request, _options);
  }
  async _saveNoteAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveNote", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveNoteAsync(associateId, note, webapi_options) {
    let _request = null;
    let _options = null;
    const first = associateId;
    if (typeof first === "object" && first && (typeof first.associateId != "undefined" || typeof first.note != "undefined")) {
      _request = associateId;
      _options = note;
    } else {
      _request = {
        associateId,
        note
      };
      _options = webapi_options;
    }
    return this._saveNoteAsync(_request, _options);
  }
  async _getEncryptionKeyAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetEncryptionKey", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Get unique key made from AssociateId and dbTag used for local storage encryption operations.
   * @returns encryptionKey
   */
  async getEncryptionKeyAsync(webapi_options) {
    return this._getEncryptionKeyAsync(webapi_options);
  }
  /*
   * Gets an array of Associate objects.
   * @param associateIds - The primary keys.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns An array of Associate
   */
  async getAssociateListAsync(associateIds, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetAssociateList", associateIds, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AssociateArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getAssociatesByGroupAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetAssociatesByGroup", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AssociateArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getAssociatesByGroupAsync(groupId, type, webapi_options) {
    let _request = null;
    let _options = null;
    const first = groupId;
    if (typeof first === "object" && first && (typeof first.groupId != "undefined" || typeof first.type != "undefined")) {
      _request = groupId;
      _options = type;
    } else {
      _request = {
        groupId,
        type
      };
      _options = webapi_options;
    }
    return this._getAssociatesByGroupAsync(_request, _options);
  }
  async _logOffWindowsUsersAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("LogOffWindowsUsers", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async logOffWindowsUsersAsync(associateIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = associateIds;
    if (typeof first === "object" && first && typeof first.associateIds != "undefined") {
      _request = associateIds;
      _options = webapi_options;
    } else {
      _request = {
        associateIds
      };
      _options = webapi_options;
    }
    return this._logOffWindowsUsersAsync(_request, _options);
  }
};

// server/node_modules/@superoffice/webapi/dist/esm/DiagnosticsAgent.js
var DiagnosticsAgent = class extends WebApiBase {
  constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
    const options = WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
    options.basePath = "v1/Agents/Diagnostics/";
    super(options);
  }
  async _flushCachesAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("FlushCaches", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Flushes all NetServer caches
   * @returns
   */
  async flushCachesAsync(webapi_options) {
    return this._flushCachesAsync(webapi_options);
  }
  async _getCacheNamesAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetCacheNames", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Get the name of the caches that can be flushed
   * @returns Name of the caches that can be flusehd
   */
  async getCacheNamesAsync(webapi_options) {
    return this._getCacheNamesAsync(webapi_options);
  }
  async _flushCachesByNameAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("FlushCachesByName", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async flushCachesByNameAsync(cacheNames, webapi_options) {
    let _request = null;
    let _options = null;
    const first = cacheNames;
    if (typeof first === "object" && first && typeof first.cacheNames != "undefined") {
      _request = cacheNames;
      _options = webapi_options;
    } else {
      _request = {
        cacheNames
      };
      _options = webapi_options;
    }
    return this._flushCachesByNameAsync(_request, _options);
  }
  async _getCacheStateAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetCacheState", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getCacheStateAsync(cacheNames, webapi_options) {
    let _request = null;
    let _options = null;
    const first = cacheNames;
    if (typeof first === "object" && first && typeof first.cacheNames != "undefined") {
      _request = cacheNames;
      _options = webapi_options;
    } else {
      _request = {
        cacheNames
      };
      _options = webapi_options;
    }
    return this._getCacheStateAsync(_request, _options);
  }
  async _getEntityCountsForCurrentUserAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetEntityCountsForCurrentUser", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_EntityCountsArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Get an array of entities and number of entities created for the current associate
   * @returns Array of EntityCounts[] for the current associate
   */
  async getEntityCountsForCurrentUserAsync(webapi_options) {
    return this._getEntityCountsForCurrentUserAsync(webapi_options);
  }
  async _logViewStateAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("LogViewState", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async logViewStateAsync(viewState, webapi_options) {
    let _request = null;
    let _options = null;
    const first = viewState;
    if (typeof first === "object" && first && typeof first.viewState != "undefined") {
      _request = viewState;
      _options = webapi_options;
    } else {
      _request = {
        viewState
      };
      _options = webapi_options;
    }
    return this._logViewStateAsync(_request, _options);
  }
  async _changeLogSettingsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ChangeLogSettings", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async changeLogSettingsAsync(logWarning, logInformation, logSuccessAudit, logFailureAudit, logToEventLog, logToSuperOffice, logToFile, logToTrace, webapi_options) {
    let _request = null;
    let _options = null;
    const first = logWarning;
    if (typeof first === "object" && first && (typeof first.logWarning != "undefined" || typeof first.logInformation != "undefined" || typeof first.logSuccessAudit != "undefined" || typeof first.logFailureAudit != "undefined" || typeof first.logToEventLog != "undefined" || typeof first.logToSuperOffice != "undefined" || typeof first.logToFile != "undefined" || typeof first.logToTrace != "undefined")) {
      _request = logWarning;
      _options = logInformation;
    } else {
      _request = {
        logWarning,
        logInformation,
        logSuccessAudit,
        logFailureAudit,
        logToEventLog,
        logToSuperOffice,
        logToFile,
        logToTrace
      };
      _options = webapi_options;
    }
    return this._changeLogSettingsAsync(_request, _options);
  }
  async _collectDataAdditionsAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CollectDataAdditions", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Collect and transmit usage statistics: Database Additions. If opted-out then this call does nothing. The call returns immediately (starting a background thread), and updates CS scheduler table to set the next run time.
   * @returns This method has no return value
   */
  async collectDataAdditionsAsync(webapi_options) {
    return this._collectDataAdditionsAsync(webapi_options);
  }
  async _collectWinUsageAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CollectWinUsage", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Collect and transmit usage statistics: Windows CRM Client Usage. If opted-out then this call does nothing. The call returns immediately (starting a background thread), and updates CS scheduler table to set the next run time.
   * @returns This method has no return value
   */
  async collectWinUsageAsync(webapi_options) {
    return this._collectWinUsageAsync(webapi_options);
  }
  async _collectWebUsageAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CollectWebUsage", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Collect and transmit usage statistics: Web-based clients Usage. If opted-out then this call does nothing. The call returns immediately (starting a background thread), and updates CS scheduler table to set the next run time.
   * @returns This method has no return value
   */
  async collectWebUsageAsync(webapi_options) {
    return this._collectWebUsageAsync(webapi_options);
  }
  async _collectTableSizesAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CollectTableSizes", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Collect and transmit usage statistics: Table Sizes. If opted-out then this call does nothing. The call returns immediately (starting a background thread), and updates CS scheduler table to set the next run time.
   * @returns This method has no return value
   */
  async collectTableSizesAsync(webapi_options) {
    return this._collectTableSizesAsync(webapi_options);
  }
  async _resyncUsersAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ResyncUsers", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Resynchronize user information with SuperOffice Community, if opted-out then this call does nothing. The call returns immediately (starting a background thread), and updates CS scheduler table to set the next run time.
   * @returns This method has no return value
   */
  async resyncUsersAsync(webapi_options) {
    return this._resyncUsersAsync(webapi_options);
  }
  async _performTasksAfterUpgradeAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("PerformTasksAfterUpgrade", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * After upgrading to a new fileset, there may be tasks that need to be done. Examples - import new TypicalSearches, if present. Tasks performed here need to be idempotent and independent of the actual upgrade jump (what was the previous version). They should complete in a reasonable time, not more than a few minutes maximum.
   * @returns Message that can be shown to the user, summarizing what has been done, if anything.
   */
  async performTasksAfterUpgradeAsync(webapi_options) {
    return this._performTasksAfterUpgradeAsync(webapi_options);
  }
  async _addWebAppUsageAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("AddWebAppUsage", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async addWebAppUsageAsync(webAppUsages, webapi_options) {
    let _request = null;
    let _options = null;
    const first = webAppUsages;
    if (typeof first === "object" && first && typeof first.webAppUsages != "undefined") {
      _request = webAppUsages;
      _options = webapi_options;
    } else {
      _request = {
        webAppUsages
      };
      _options = webapi_options;
    }
    return this._addWebAppUsageAsync(_request, _options);
  }
  async _webAppUsageExistsInPeriodAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("WebAppUsageExistsInPeriod", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async webAppUsageExistsInPeriodAsync(associateId, viewState, fromDate, webapi_options) {
    let _request = null;
    let _options = null;
    const first = associateId;
    if (typeof first === "object" && first && (typeof first.associateId != "undefined" || typeof first.viewState != "undefined" || typeof first.fromDate != "undefined")) {
      _request = associateId;
      _options = viewState;
    } else {
      _request = {
        associateId,
        viewState,
        fromDate
      };
      _options = webapi_options;
    }
    return this._webAppUsageExistsInPeriodAsync(_request, _options);
  }
  async _getWebAppUsagesForPeriodAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetWebAppUsagesForPeriod", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_WebAppUsageArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getWebAppUsagesForPeriodAsync(fromDate, toDate, searchTerm, webapi_options) {
    let _request = null;
    let _options = null;
    const first = fromDate;
    if (typeof first === "object" && first && (typeof first.fromDate != "undefined" || typeof first.toDate != "undefined" || typeof first.searchTerm != "undefined")) {
      _request = fromDate;
      _options = toDate;
    } else {
      _request = {
        fromDate,
        toDate,
        searchTerm
      };
      _options = webapi_options;
    }
    return this._getWebAppUsagesForPeriodAsync(_request, _options);
  }
};

// server/node_modules/@superoffice/webapi/dist/esm/TooltipsAgent.js
var TooltipsAgent = class extends WebApiBase {
  constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
    const options = WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
    options.basePath = "v1/Agents/Tooltips/";
    super(options);
  }
  async _getTooltipAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetTooltip", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getTooltipAsync(tooltipHint, webapi_options) {
    let _request = null;
    let _options = null;
    const first = tooltipHint;
    if (typeof first === "object" && first && typeof first.tooltipHint != "undefined") {
      _request = tooltipHint;
      _options = webapi_options;
    } else {
      _request = {
        tooltipHint
      };
      _options = webapi_options;
    }
    return this._getTooltipAsync(_request, _options);
  }
};

// server/node_modules/@superoffice/webapi/dist/esm/PreviewsAgent.js
var PreviewsAgent = class extends WebApiBase {
  constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
    const options = WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
    options.basePath = "v1/Agents/Previews/";
    super(options);
  }
  async _getPreviewAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPreview", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getPreviewAsync(previewHint, webapi_options) {
    let _request = null;
    let _options = null;
    const first = previewHint;
    if (typeof first === "object" && first && typeof first.previewHint != "undefined") {
      _request = previewHint;
      _options = webapi_options;
    } else {
      _request = {
        previewHint
      };
      _options = webapi_options;
    }
    return this._getPreviewAsync(_request, _options);
  }
};

// server/node_modules/@superoffice/webapi/dist/esm/SelectionAgent.js
var SelectionAgent = class extends WebApiBase {
  constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
    const options = WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
    options.basePath = "v1/Agents/Selection/";
    super(options);
  }
  /**
   * Set default values into a new MailMergeSettings.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultMailMergeSettingsAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultMailMergeSettings", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_MailMergeSettings_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new MailMergeTask.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultMailMergeTaskAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultMailMergeTask", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_MailMergeTask_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new SelectionEntity.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultSelectionEntityAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultSelectionEntity", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SelectionEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing SelectionEntity or creates a new SelectionEntity if the id parameter is empty
   * @param entity - The SelectionEntity to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated SelectionEntity
   */
  async saveSelectionEntityAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveSelectionEntity", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SelectionEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Deletes the SelectionEntity
   * @param SelectionEntityId - The id of the SelectionEntity to be deleted.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   */
  async deleteSelectionEntityAsync(SelectionEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("DeleteSelectionEntity?SelectionEntityId=" + SelectionEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets a SelectionEntity object.
   * @param selectionEntityId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single SelectionEntity
   */
  async getSelectionEntityAsync(selectionEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetSelectionEntity?selectionEntityId=" + selectionEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SelectionEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _createSelectionEntityAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateSelectionEntity", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SelectionEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createSelectionEntityAsync(targetTableName, webapi_options) {
    let _request = null;
    let _options = null;
    const first = targetTableName;
    if (typeof first === "object" && first && typeof first.targetTableName != "undefined") {
      _request = targetTableName;
      _options = webapi_options;
    } else {
      _request = {
        targetTableName
      };
      _options = webapi_options;
    }
    return this._createSelectionEntityAsync(_request, _options);
  }
  async _createContactSelectionFromSelectionAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateContactSelectionFromSelection", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SelectionEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createContactSelectionFromSelectionAsync(selectionId, name, targetSelectionType, copyMembers, webapi_options) {
    let _request = null;
    let _options = null;
    const first = selectionId;
    if (typeof first === "object" && first && (typeof first.selectionId != "undefined" || typeof first.name != "undefined" || typeof first.targetSelectionType != "undefined" || typeof first.copyMembers != "undefined")) {
      _request = selectionId;
      _options = name;
    } else {
      _request = {
        selectionId,
        name,
        targetSelectionType,
        copyMembers
      };
      _options = webapi_options;
    }
    return this._createContactSelectionFromSelectionAsync(_request, _options);
  }
  async _createTemporaryContactSelectionFromContactPersonIdsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateTemporaryContactSelectionFromContactPersonIds", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SelectionEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createTemporaryContactSelectionFromContactPersonIdsAsync(contactPersonIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = contactPersonIds;
    if (typeof first === "object" && first && typeof first.contactPersonIds != "undefined") {
      _request = contactPersonIds;
      _options = webapi_options;
    } else {
      _request = {
        contactPersonIds
      };
      _options = webapi_options;
    }
    return this._createTemporaryContactSelectionFromContactPersonIdsAsync(_request, _options);
  }
  async _createTemporaryContactSelectionFromProjectMembersAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateTemporaryContactSelectionFromProjectMembers", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SelectionEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createTemporaryContactSelectionFromProjectMembersAsync(projectId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = projectId;
    if (typeof first === "object" && first && typeof first.projectId != "undefined") {
      _request = projectId;
      _options = webapi_options;
    } else {
      _request = {
        projectId
      };
      _options = webapi_options;
    }
    return this._createTemporaryContactSelectionFromProjectMembersAsync(_request, _options);
  }
  async _copyContactSelectionMembersAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CopyContactSelectionMembers", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async copyContactSelectionMembersAsync(fromSelectionId, toSelectionId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = fromSelectionId;
    if (typeof first === "object" && first && (typeof first.fromSelectionId != "undefined" || typeof first.toSelectionId != "undefined")) {
      _request = fromSelectionId;
      _options = toSelectionId;
    } else {
      _request = {
        fromSelectionId,
        toSelectionId
      };
      _options = webapi_options;
    }
    return this._copyContactSelectionMembersAsync(_request, _options);
  }
  async _getRecipientStatisticsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetRecipientStatistics", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_RecipientStatistics_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getRecipientStatisticsAsync(selectionId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = selectionId;
    if (typeof first === "object" && first && typeof first.selectionId != "undefined") {
      _request = selectionId;
      _options = webapi_options;
    } else {
      _request = {
        selectionId
      };
      _options = webapi_options;
    }
    return this._getRecipientStatisticsAsync(_request, _options);
  }
  async _getRecipientStatisticsFromProjectMembersAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetRecipientStatisticsFromProjectMembers", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_RecipientStatistics_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getRecipientStatisticsFromProjectMembersAsync(projectId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = projectId;
    if (typeof first === "object" && first && typeof first.projectId != "undefined") {
      _request = projectId;
      _options = webapi_options;
    } else {
      _request = {
        projectId
      };
      _options = webapi_options;
    }
    return this._getRecipientStatisticsFromProjectMembersAsync(_request, _options);
  }
  async _getRecipientStatisticsFromContactPersonIdsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetRecipientStatisticsFromContactPersonIds", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_RecipientStatistics_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getRecipientStatisticsFromContactPersonIdsAsync(contactPersonIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = contactPersonIds;
    if (typeof first === "object" && first && typeof first.contactPersonIds != "undefined") {
      _request = contactPersonIds;
      _options = webapi_options;
    } else {
      _request = {
        contactPersonIds
      };
      _options = webapi_options;
    }
    return this._getRecipientStatisticsFromContactPersonIdsAsync(_request, _options);
  }
  async _addContactSelectionMembersAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("AddContactSelectionMembers", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async addContactSelectionMembersAsync(selectionId, contactPersonIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = selectionId;
    if (typeof first === "object" && first && (typeof first.selectionId != "undefined" || typeof first.contactPersonIds != "undefined")) {
      _request = selectionId;
      _options = contactPersonIds;
    } else {
      _request = {
        selectionId,
        contactPersonIds
      };
      _options = webapi_options;
    }
    return this._addContactSelectionMembersAsync(_request, _options);
  }
  async _removeContactSelectionMembersAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("RemoveContactSelectionMembers", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async removeContactSelectionMembersAsync(selectionId, contactPersonIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = selectionId;
    if (typeof first === "object" && first && (typeof first.selectionId != "undefined" || typeof first.contactPersonIds != "undefined")) {
      _request = selectionId;
      _options = contactPersonIds;
    } else {
      _request = {
        selectionId,
        contactPersonIds
      };
      _options = webapi_options;
    }
    return this._removeContactSelectionMembersAsync(_request, _options);
  }
  async _removeContactSelectionMembersFromIdsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("RemoveContactSelectionMembersFromIds", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async removeContactSelectionMembersFromIdsAsync(selectionId, selectionMembersIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = selectionId;
    if (typeof first === "object" && first && (typeof first.selectionId != "undefined" || typeof first.selectionMembersIds != "undefined")) {
      _request = selectionId;
      _options = selectionMembersIds;
    } else {
      _request = {
        selectionId,
        selectionMembersIds
      };
      _options = webapi_options;
    }
    return this._removeContactSelectionMembersFromIdsAsync(_request, _options);
  }
  async _addContactSelectionMembersFromSearchAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("AddContactSelectionMembersFromSearch", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async addContactSelectionMembersFromSearchAsync(selectionId, storageKey, webapi_options) {
    let _request = null;
    let _options = null;
    const first = selectionId;
    if (typeof first === "object" && first && (typeof first.selectionId != "undefined" || typeof first.storageKey != "undefined")) {
      _request = selectionId;
      _options = storageKey;
    } else {
      _request = {
        selectionId,
        storageKey
      };
      _options = webapi_options;
    }
    return this._addContactSelectionMembersFromSearchAsync(_request, _options);
  }
  async _removeContactSelectionMembersFromSearchAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("RemoveContactSelectionMembersFromSearch", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async removeContactSelectionMembersFromSearchAsync(selectionId, storageKey, webapi_options) {
    let _request = null;
    let _options = null;
    const first = selectionId;
    if (typeof first === "object" && first && (typeof first.selectionId != "undefined" || typeof first.storageKey != "undefined")) {
      _request = selectionId;
      _options = storageKey;
    } else {
      _request = {
        selectionId,
        storageKey
      };
      _options = webapi_options;
    }
    return this._removeContactSelectionMembersFromSearchAsync(_request, _options);
  }
  async _createTemporaryContactSelectionAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateTemporaryContactSelection", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SelectionEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Creates a temporary selection.
   * @returns Returns the newly created SelectionEntity.
   */
  async createTemporaryContactSelectionAsync(webapi_options) {
    return this._createTemporaryContactSelectionAsync(webapi_options);
  }
  async _createTemporaryContactSelectionFromSelectionMemberIdsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateTemporaryContactSelectionFromSelectionMemberIds", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SelectionEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createTemporaryContactSelectionFromSelectionMemberIdsAsync(selectionId, selectionMemberIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = selectionId;
    if (typeof first === "object" && first && (typeof first.selectionId != "undefined" || typeof first.selectionMemberIds != "undefined")) {
      _request = selectionId;
      _options = selectionMemberIds;
    } else {
      _request = {
        selectionId,
        selectionMemberIds
      };
      _options = webapi_options;
    }
    return this._createTemporaryContactSelectionFromSelectionMemberIdsAsync(_request, _options);
  }
  async _addRemoveContactSelectionMemberInterestsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("AddRemoveContactSelectionMemberInterests", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async addRemoveContactSelectionMemberInterestsAsync(selectionId, addCompanyInterests, removeCompanyInterests, addContactInterests, removeContactInterests, webapi_options) {
    let _request = null;
    let _options = null;
    const first = selectionId;
    if (typeof first === "object" && first && (typeof first.selectionId != "undefined" || typeof first.addCompanyInterests != "undefined" || typeof first.removeCompanyInterests != "undefined" || typeof first.addContactInterests != "undefined" || typeof first.removeContactInterests != "undefined")) {
      _request = selectionId;
      _options = addCompanyInterests;
    } else {
      _request = {
        selectionId,
        addCompanyInterests,
        removeCompanyInterests,
        addContactInterests,
        removeContactInterests
      };
      _options = webapi_options;
    }
    return this._addRemoveContactSelectionMemberInterestsAsync(_request, _options);
  }
  async _editContactSelectionMemberDetailsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("EditContactSelectionMemberDetails", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async editContactSelectionMemberDetailsAsync(selectionId, selectionMemberEditValues, webapi_options) {
    let _request = null;
    let _options = null;
    const first = selectionId;
    if (typeof first === "object" && first && (typeof first.selectionId != "undefined" || typeof first.selectionMemberEditValues != "undefined")) {
      _request = selectionId;
      _options = selectionMemberEditValues;
    } else {
      _request = {
        selectionId,
        selectionMemberEditValues
      };
      _options = webapi_options;
    }
    return this._editContactSelectionMemberDetailsAsync(_request, _options);
  }
  async _generateFollowUpsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GenerateFollowUps", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async generateFollowUpsAsync(selectionId, appointmentEntity, associateId, saveOnContactOwner, uniqueContact, webapi_options) {
    let _request = null;
    let _options = null;
    const first = selectionId;
    if (typeof first === "object" && first && (typeof first.selectionId != "undefined" || typeof first.appointmentEntity != "undefined" || typeof first.associateId != "undefined" || typeof first.saveOnContactOwner != "undefined" || typeof first.uniqueContact != "undefined")) {
      _request = selectionId;
      _options = appointmentEntity;
    } else {
      _request = {
        selectionId,
        appointmentEntity,
        associateId,
        saveOnContactOwner,
        uniqueContact
      };
      _options = webapi_options;
    }
    return this._generateFollowUpsAsync(_request, _options);
  }
  async _exportSelectionMembersAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ExportSelectionMembers", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async exportSelectionMembersAsync(selectionId, templateName, useContacts, webapi_options) {
    let _request = null;
    let _options = null;
    const first = selectionId;
    if (typeof first === "object" && first && (typeof first.selectionId != "undefined" || typeof first.templateName != "undefined" || typeof first.useContacts != "undefined")) {
      _request = selectionId;
      _options = templateName;
    } else {
      _request = {
        selectionId,
        templateName,
        useContacts
      };
      _options = webapi_options;
    }
    return this._exportSelectionMembersAsync(_request, _options);
  }
  async _exportSelectionMembersWithOrderByAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ExportSelectionMembersWithOrderBy", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async exportSelectionMembersWithOrderByAsync(selectionId, templateName, useContacts, orderBy, webapi_options) {
    let _request = null;
    let _options = null;
    const first = selectionId;
    if (typeof first === "object" && first && (typeof first.selectionId != "undefined" || typeof first.templateName != "undefined" || typeof first.useContacts != "undefined" || typeof first.orderBy != "undefined")) {
      _request = selectionId;
      _options = templateName;
    } else {
      _request = {
        selectionId,
        templateName,
        useContacts,
        orderBy
      };
      _options = webapi_options;
    }
    return this._exportSelectionMembersWithOrderByAsync(_request, _options);
  }
  async _startMailMergeAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("StartMailMerge", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async startMailMergeAsync(settings, webapi_options) {
    let _request = null;
    let _options = null;
    const first = settings;
    if (typeof first === "object" && first && typeof first.settings != "undefined") {
      _request = settings;
      _options = webapi_options;
    } else {
      _request = {
        settings
      };
      _options = webapi_options;
    }
    return this._startMailMergeAsync(_request, _options);
  }
  async _setDuplicateRulesStatusAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetDuplicateRulesStatus", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setDuplicateRulesStatusAsync(rules, webapi_options) {
    let _request = null;
    let _options = null;
    const first = rules;
    if (typeof first === "object" && first && typeof first.rules != "undefined") {
      _request = rules;
      _options = webapi_options;
    } else {
      _request = {
        rules
      };
      _options = webapi_options;
    }
    return this._setDuplicateRulesStatusAsync(_request, _options);
  }
  async _getDuplicatesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetDuplicates", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DuplicateEntryArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getDuplicatesAsync(name, webapi_options) {
    let _request = null;
    let _options = null;
    const first = name;
    if (typeof first === "object" && first && typeof first.name != "undefined") {
      _request = name;
      _options = webapi_options;
    } else {
      _request = {
        name
      };
      _options = webapi_options;
    }
    return this._getDuplicatesAsync(_request, _options);
  }
  async _getDuplicateRulesAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetDuplicateRules", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DuplicateRuleArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Retrieve all available duplicate rules for selection
   * @returns All available duplicate rules
   */
  async getDuplicateRulesAsync(webapi_options) {
    return this._getDuplicateRulesAsync(webapi_options);
  }
  async _createNewEntryAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateNewEntry", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createNewEntryAsync(duplicate, webapi_options) {
    let _request = null;
    let _options = null;
    const first = duplicate;
    if (typeof first === "object" && first && typeof first.duplicate != "undefined") {
      _request = duplicate;
      _options = webapi_options;
    } else {
      _request = {
        duplicate
      };
      _options = webapi_options;
    }
    return this._createNewEntryAsync(_request, _options);
  }
  async _deleteContactsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeleteContacts", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async deleteContactsAsync(selectionId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = selectionId;
    if (typeof first === "object" && first && typeof first.selectionId != "undefined") {
      _request = selectionId;
      _options = webapi_options;
    } else {
      _request = {
        selectionId
      };
      _options = webapi_options;
    }
    return this._deleteContactsAsync(_request, _options);
  }
  async _addSelectionMembersAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("AddSelectionMembers", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async addSelectionMembersAsync(selectionId, ids, webapi_options) {
    let _request = null;
    let _options = null;
    const first = selectionId;
    if (typeof first === "object" && first && (typeof first.selectionId != "undefined" || typeof first.ids != "undefined")) {
      _request = selectionId;
      _options = ids;
    } else {
      _request = {
        selectionId,
        ids
      };
      _options = webapi_options;
    }
    return this._addSelectionMembersAsync(_request, _options);
  }
  async _removeSelectionMembersAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("RemoveSelectionMembers", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async removeSelectionMembersAsync(selectionId, selectionMemberIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = selectionId;
    if (typeof first === "object" && first && (typeof first.selectionId != "undefined" || typeof first.selectionMemberIds != "undefined")) {
      _request = selectionId;
      _options = selectionMemberIds;
    } else {
      _request = {
        selectionId,
        selectionMemberIds
      };
      _options = webapi_options;
    }
    return this._removeSelectionMembersAsync(_request, _options);
  }
  async _removeSelectionMembersByIdAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("RemoveSelectionMembersById", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async removeSelectionMembersByIdAsync(selectionId, ids, webapi_options) {
    let _request = null;
    let _options = null;
    const first = selectionId;
    if (typeof first === "object" && first && (typeof first.selectionId != "undefined" || typeof first.ids != "undefined")) {
      _request = selectionId;
      _options = ids;
    } else {
      _request = {
        selectionId,
        ids
      };
      _options = webapi_options;
    }
    return this._removeSelectionMembersByIdAsync(_request, _options);
  }
  async _addSelectionMembersFromSearchAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("AddSelectionMembersFromSearch", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async addSelectionMembersFromSearchAsync(selectionId, storageKey, webapi_options) {
    let _request = null;
    let _options = null;
    const first = selectionId;
    if (typeof first === "object" && first && (typeof first.selectionId != "undefined" || typeof first.storageKey != "undefined")) {
      _request = selectionId;
      _options = storageKey;
    } else {
      _request = {
        selectionId,
        storageKey
      };
      _options = webapi_options;
    }
    return this._addSelectionMembersFromSearchAsync(_request, _options);
  }
  async _removeSelectionMembersFromSearchAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("RemoveSelectionMembersFromSearch", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async removeSelectionMembersFromSearchAsync(selectionId, storageKey, webapi_options) {
    let _request = null;
    let _options = null;
    const first = selectionId;
    if (typeof first === "object" && first && (typeof first.selectionId != "undefined" || typeof first.storageKey != "undefined")) {
      _request = selectionId;
      _options = storageKey;
    } else {
      _request = {
        selectionId,
        storageKey
      };
      _options = webapi_options;
    }
    return this._removeSelectionMembersFromSearchAsync(_request, _options);
  }
  async _copySelectionMembersAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CopySelectionMembers", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async copySelectionMembersAsync(fromSelectionId, toSelectionId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = fromSelectionId;
    if (typeof first === "object" && first && (typeof first.fromSelectionId != "undefined" || typeof first.toSelectionId != "undefined")) {
      _request = fromSelectionId;
      _options = toSelectionId;
    } else {
      _request = {
        fromSelectionId,
        toSelectionId
      };
      _options = webapi_options;
    }
    return this._copySelectionMembersAsync(_request, _options);
  }
  async _createTemporarySelectionFromIdsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateTemporarySelectionFromIds", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SelectionEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createTemporarySelectionFromIdsAsync(ids, targetTableNumber, webapi_options) {
    let _request = null;
    let _options = null;
    const first = ids;
    if (typeof first === "object" && first && (typeof first.ids != "undefined" || typeof first.targetTableNumber != "undefined")) {
      _request = ids;
      _options = targetTableNumber;
    } else {
      _request = {
        ids,
        targetTableNumber
      };
      _options = webapi_options;
    }
    return this._createTemporarySelectionFromIdsAsync(_request, _options);
  }
  async _createSelectionFromSelectionAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateSelectionFromSelection", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SelectionEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createSelectionFromSelectionAsync(selectionId, name, targetSelectionType, copyMembers, webapi_options) {
    let _request = null;
    let _options = null;
    const first = selectionId;
    if (typeof first === "object" && first && (typeof first.selectionId != "undefined" || typeof first.name != "undefined" || typeof first.targetSelectionType != "undefined" || typeof first.copyMembers != "undefined")) {
      _request = selectionId;
      _options = name;
    } else {
      _request = {
        selectionId,
        name,
        targetSelectionType,
        copyMembers
      };
      _options = webapi_options;
    }
    return this._createSelectionFromSelectionAsync(_request, _options);
  }
  async _createContactSelectionFromShadowSelectionAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateContactSelectionFromShadowSelection", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SelectionEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createContactSelectionFromShadowSelectionAsync(selectionId, name, webapi_options) {
    let _request = null;
    let _options = null;
    const first = selectionId;
    if (typeof first === "object" && first && (typeof first.selectionId != "undefined" || typeof first.name != "undefined")) {
      _request = selectionId;
      _options = name;
    } else {
      _request = {
        selectionId,
        name
      };
      _options = webapi_options;
    }
    return this._createContactSelectionFromShadowSelectionAsync(_request, _options);
  }
  async _deleteEntitiesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeleteEntities", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async deleteEntitiesAsync(selectionId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = selectionId;
    if (typeof first === "object" && first && typeof first.selectionId != "undefined") {
      _request = selectionId;
      _options = webapi_options;
    } else {
      _request = {
        selectionId
      };
      _options = webapi_options;
    }
    return this._deleteEntitiesAsync(_request, _options);
  }
  async _getParentCombinedSelectionsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetParentCombinedSelections", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getParentCombinedSelectionsAsync(selectionId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = selectionId;
    if (typeof first === "object" && first && typeof first.selectionId != "undefined") {
      _request = selectionId;
      _options = webapi_options;
    } else {
      _request = {
        selectionId
      };
      _options = webapi_options;
    }
    return this._getParentCombinedSelectionsAsync(_request, _options);
  }
  async _getSelectionMembersArchiveRowsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetSelectionMembersArchiveRows", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ArchiveListItemArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getSelectionMembersArchiveRowsAsync(selectionId, select, webapi_options) {
    let _request = null;
    let _options = null;
    const first = selectionId;
    if (typeof first === "object" && first && (typeof first.selectionId != "undefined" || typeof first.select != "undefined")) {
      _request = selectionId;
      _options = select;
    } else {
      _request = {
        selectionId,
        select
      };
      _options = webapi_options;
    }
    return this._getSelectionMembersArchiveRowsAsync(_request, _options);
  }
  async _getSelectionShadowMembersArchiveRowsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetSelectionShadowMembersArchiveRows", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ArchiveListItemArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getSelectionShadowMembersArchiveRowsAsync(selectionId, select, webapi_options) {
    let _request = null;
    let _options = null;
    const first = selectionId;
    if (typeof first === "object" && first && (typeof first.selectionId != "undefined" || typeof first.select != "undefined")) {
      _request = selectionId;
      _options = select;
    } else {
      _request = {
        selectionId,
        select
      };
      _options = webapi_options;
    }
    return this._getSelectionShadowMembersArchiveRowsAsync(_request, _options);
  }
  async _getDynamicSelectionCriteriaAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetDynamicSelectionCriteria", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ArchiveRestrictionInfoArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getDynamicSelectionCriteriaAsync(selectionId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = selectionId;
    if (typeof first === "object" && first && typeof first.selectionId != "undefined") {
      _request = selectionId;
      _options = webapi_options;
    } else {
      _request = {
        selectionId
      };
      _options = webapi_options;
    }
    return this._getDynamicSelectionCriteriaAsync(_request, _options);
  }
  async _setDynamicSelectionCriteriaAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetDynamicSelectionCriteria", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ArchiveRestrictionInfoArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setDynamicSelectionCriteriaAsync(selectionId, criteria, webapi_options) {
    let _request = null;
    let _options = null;
    const first = selectionId;
    if (typeof first === "object" && first && (typeof first.selectionId != "undefined" || typeof first.criteria != "undefined")) {
      _request = selectionId;
      _options = criteria;
    } else {
      _request = {
        selectionId,
        criteria
      };
      _options = webapi_options;
    }
    return this._setDynamicSelectionCriteriaAsync(_request, _options);
  }
  async _setDynamicSelectionCriteria2Async(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetDynamicSelectionCriteria2", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ArchiveRestrictionInfoArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setDynamicSelectionCriteria2Async(selectionId, filter2, webapi_options) {
    let _request = null;
    let _options = null;
    const first = selectionId;
    if (typeof first === "object" && first && (typeof first.selectionId != "undefined" || typeof first.filter != "undefined")) {
      _request = selectionId;
      _options = filter2;
    } else {
      _request = {
        selectionId,
        filter: filter2
      };
      _options = webapi_options;
    }
    return this._setDynamicSelectionCriteria2Async(_request, _options);
  }
  async _setDynamicSelectionCriteria3Async(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetDynamicSelectionCriteria3", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ArchiveRestrictionInfoArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setDynamicSelectionCriteria3Async(selectionId, criteria, filter2, webapi_options) {
    let _request = null;
    let _options = null;
    const first = selectionId;
    if (typeof first === "object" && first && (typeof first.selectionId != "undefined" || typeof first.criteria != "undefined" || typeof first.filter != "undefined")) {
      _request = selectionId;
      _options = criteria;
    } else {
      _request = {
        selectionId,
        criteria,
        filter: filter2
      };
      _options = webapi_options;
    }
    return this._setDynamicSelectionCriteria3Async(_request, _options);
  }
  async _deletePersonsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeletePersons", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async deletePersonsAsync(selectionId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = selectionId;
    if (typeof first === "object" && first && typeof first.selectionId != "undefined") {
      _request = selectionId;
      _options = webapi_options;
    } else {
      _request = {
        selectionId
      };
      _options = webapi_options;
    }
    return this._deletePersonsAsync(_request, _options);
  }
  async _getDynamicSelectionCriteriaGroupsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetDynamicSelectionCriteriaGroups", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ArchiveRestrictionGroupArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getDynamicSelectionCriteriaGroupsAsync(selectionId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = selectionId;
    if (typeof first === "object" && first && typeof first.selectionId != "undefined") {
      _request = selectionId;
      _options = webapi_options;
    } else {
      _request = {
        selectionId
      };
      _options = webapi_options;
    }
    return this._getDynamicSelectionCriteriaGroupsAsync(_request, _options);
  }
  async _setDynamicSelectionCriteriaGroupsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetDynamicSelectionCriteriaGroups", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ArchiveRestrictionGroupArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setDynamicSelectionCriteriaGroupsAsync(selectionId, criteria, webapi_options) {
    let _request = null;
    let _options = null;
    const first = selectionId;
    if (typeof first === "object" && first && (typeof first.selectionId != "undefined" || typeof first.criteria != "undefined")) {
      _request = selectionId;
      _options = criteria;
    } else {
      _request = {
        selectionId,
        criteria
      };
      _options = webapi_options;
    }
    return this._setDynamicSelectionCriteriaGroupsAsync(_request, _options);
  }
  async _getSelectionForFindAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetSelectionForFind", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SelectionForFind_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getSelectionForFindAsync(entityName, typicalSearchId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = entityName;
    if (typeof first === "object" && first && (typeof first.entityName != "undefined" || typeof first.typicalSearchId != "undefined")) {
      _request = entityName;
      _options = typicalSearchId;
    } else {
      _request = {
        entityName,
        typicalSearchId
      };
      _options = webapi_options;
    }
    return this._getSelectionForFindAsync(_request, _options);
  }
  async _getSelectionSummariesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetSelectionSummaries", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SelectionSummaryItemArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getSelectionSummariesAsync(selectionIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = selectionIds;
    if (typeof first === "object" && first && typeof first.selectionIds != "undefined") {
      _request = selectionIds;
      _options = webapi_options;
    } else {
      _request = {
        selectionIds
      };
      _options = webapi_options;
    }
    return this._getSelectionSummariesAsync(_request, _options);
  }
  async _updateTypicalSearchAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("UpdateTypicalSearch", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async updateTypicalSearchAsync(searches, webapi_options) {
    let _request = null;
    let _options = null;
    const first = searches;
    if (typeof first === "object" && first && typeof first.searches != "undefined") {
      _request = searches;
      _options = webapi_options;
    } else {
      _request = {
        searches
      };
      _options = webapi_options;
    }
    return this._updateTypicalSearchAsync(_request, _options);
  }
};

// server/node_modules/@superoffice/webapi/dist/esm/EMailAgent.js
var EMailAgent = class extends WebApiBase {
  constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
    const options = WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
    options.basePath = "v1/Agents/EMail/";
    super(options);
  }
  /**
   * Set default values into a new EMailAccount.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultEMailAccountAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultEMailAccount", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_EMailAccount_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing EMailAccount or creates a new EMailAccount if the id parameter is empty
   * @param entity - The EMailAccount to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated EMailAccount
   */
  async saveEMailAccountAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveEMailAccount", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_EMailAccount_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Deletes the EMailAccount
   * @param EMailAccountId - The id of the EMailAccount to be deleted.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   */
  async deleteEMailAccountAsync(EMailAccountId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("DeleteEMailAccount?EMailAccountId=" + EMailAccountId, null, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new EMailAddress.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultEMailAddressAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultEMailAddress", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_EMailAddress_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new EMailAppointment.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultEMailAppointmentAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultEMailAppointment", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_EMailAppointment_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new EMailAttachment.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultEMailAttachmentAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultEMailAttachment", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_EMailAttachment_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new EMailConnectionInfo.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultEMailConnectionInfoAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultEMailConnectionInfo", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_EMailConnectionInfo_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new EMailConnectionInfoExtended.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultEMailConnectionInfoExtendedAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultEMailConnectionInfoExtended", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_EMailConnectionInfoExtended_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new EMailCustomHeader.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultEMailCustomHeaderAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultEMailCustomHeader", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_EMailCustomHeader_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new EMailEntity.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultEMailEntityAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultEMailEntity", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_EMailEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new EMailEnvelope.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultEMailEnvelopeAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultEMailEnvelope", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_EMailEnvelope_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new EMailFolder.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultEMailFolderAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultEMailFolder", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_EMailFolder_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new EMailSOInfo.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultEMailSOInfoAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultEMailSOInfo", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_EMailSOInfo_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets a EMailAccount object.
   * @param eMailAccountId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single EMailAccount
   */
  async getEMailAccountAsync(eMailAccountId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetEMailAccount?eMailAccountId=" + eMailAccountId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_EMailAccount_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getEMailAccountFromEMailAddressAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetEMailAccountFromEMailAddress", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_EMailAccount_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getEMailAccountFromEMailAddressAsync(fromAddress, webapi_options) {
    let _request = null;
    let _options = null;
    const first = fromAddress;
    if (typeof first === "object" && first && typeof first.fromAddress != "undefined") {
      _request = fromAddress;
      _options = webapi_options;
    } else {
      _request = {
        fromAddress
      };
      _options = webapi_options;
    }
    return this._getEMailAccountFromEMailAddressAsync(_request, _options);
  }
  async _getCurrentAccountIdAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetCurrentAccountId", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Get current accountId (last logged into should normally be current) for logged in associate
   * @returns Id of current account
   */
  async getCurrentAccountIdAsync(webapi_options) {
    return this._getCurrentAccountIdAsync(webapi_options);
  }
  async _getCurrentAccountAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetCurrentAccount", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_EMailAccount_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Get current account (last logged into should normally be current) for logged in associate
   * @returns Id of current account
   */
  async getCurrentAccountAsync(webapi_options) {
    return this._getCurrentAccountAsync(webapi_options);
  }
  async _getPersonEntitiesFromEmailAddressAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPersonEntitiesFromEmailAddress", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PersonEntityArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getPersonEntitiesFromEmailAddressAsync(emailAddress, webapi_options) {
    let _request = null;
    let _options = null;
    const first = emailAddress;
    if (typeof first === "object" && first && typeof first.emailAddress != "undefined") {
      _request = emailAddress;
      _options = webapi_options;
    } else {
      _request = {
        emailAddress
      };
      _options = webapi_options;
    }
    return this._getPersonEntitiesFromEmailAddressAsync(_request, _options);
  }
  async _getPersonsFromEmailAddressAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPersonsFromEmailAddress", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PersonArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getPersonsFromEmailAddressAsync(emailAddress, webapi_options) {
    let _request = null;
    let _options = null;
    const first = emailAddress;
    if (typeof first === "object" && first && typeof first.emailAddress != "undefined") {
      _request = emailAddress;
      _options = webapi_options;
    } else {
      _request = {
        emailAddress
      };
      _options = webapi_options;
    }
    return this._getPersonsFromEmailAddressAsync(_request, _options);
  }
  async _hasMXRecordAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("HasMXRecord", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async hasMXRecordAsync(mailDomain, webapi_options) {
    let _request = null;
    let _options = null;
    const first = mailDomain;
    if (typeof first === "object" && first && typeof first.mailDomain != "undefined") {
      _request = mailDomain;
      _options = webapi_options;
    } else {
      _request = {
        mailDomain
      };
      _options = webapi_options;
    }
    return this._hasMXRecordAsync(_request, _options);
  }
  async _hasSPFRecordAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("HasSPFRecord", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async hasSPFRecordAsync(sourceSpf, targetDomain, webapi_options) {
    let _request = null;
    let _options = null;
    const first = sourceSpf;
    if (typeof first === "object" && first && (typeof first.sourceSpf != "undefined" || typeof first.targetDomain != "undefined")) {
      _request = sourceSpf;
      _options = targetDomain;
    } else {
      _request = {
        sourceSpf,
        targetDomain
      };
      _options = webapi_options;
    }
    return this._hasSPFRecordAsync(_request, _options);
  }
  async _resolveEMailRecipientsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ResolveEMailRecipients", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_EMailAddressArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async resolveEMailRecipientsAsync(emailAddress, webapi_options) {
    let _request = null;
    let _options = null;
    const first = emailAddress;
    if (typeof first === "object" && first && typeof first.emailAddress != "undefined") {
      _request = emailAddress;
      _options = webapi_options;
    } else {
      _request = {
        emailAddress
      };
      _options = webapi_options;
    }
    return this._resolveEMailRecipientsAsync(_request, _options);
  }
  async _getEMailFromIdAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetEMailFromId", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_EMailEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getEMailFromIdAsync(connectionInfo, messageServerId, lookupAddresses, flags, includeAttachments, webapi_options) {
    let _request = null;
    let _options = null;
    const first = connectionInfo;
    if (typeof first === "object" && first && (typeof first.connectionInfo != "undefined" || typeof first.messageServerId != "undefined" || typeof first.lookupAddresses != "undefined" || typeof first.flags != "undefined" || typeof first.includeAttachments != "undefined")) {
      _request = connectionInfo;
      _options = messageServerId;
    } else {
      _request = {
        connectionInfo,
        messageServerId,
        lookupAddresses,
        flags,
        includeAttachments
      };
      _options = webapi_options;
    }
    return this._getEMailFromIdAsync(_request, _options);
  }
  async _sendEMailsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SendEMails", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_EMailEntityArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async sendEMailsAsync(outgoingConnectionInfo, emails, sentItemsConnectionInfo, webapi_options) {
    let _request = null;
    let _options = null;
    const first = outgoingConnectionInfo;
    if (typeof first === "object" && first && (typeof first.outgoingConnectionInfo != "undefined" || typeof first.emails != "undefined" || typeof first.sentItemsConnectionInfo != "undefined")) {
      _request = outgoingConnectionInfo;
      _options = emails;
    } else {
      _request = {
        outgoingConnectionInfo,
        emails,
        sentItemsConnectionInfo
      };
      _options = webapi_options;
    }
    return this._sendEMailsAsync(_request, _options);
  }
  async _saveEMailAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveEMail", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_EMailEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveEMailAsync(connectionInfo, email, webapi_options) {
    let _request = null;
    let _options = null;
    const first = connectionInfo;
    if (typeof first === "object" && first && (typeof first.connectionInfo != "undefined" || typeof first.email != "undefined")) {
      _request = connectionInfo;
      _options = email;
    } else {
      _request = {
        connectionInfo,
        email
      };
      _options = webapi_options;
    }
    return this._saveEMailAsync(_request, _options);
  }
  async _authenticateIncomingAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("AuthenticateIncoming", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async authenticateIncomingAsync(connectionInfo, webapi_options) {
    let _request = null;
    let _options = null;
    const first = connectionInfo;
    if (typeof first === "object" && first && typeof first.connectionInfo != "undefined") {
      _request = connectionInfo;
      _options = webapi_options;
    } else {
      _request = {
        connectionInfo
      };
      _options = webapi_options;
    }
    return this._authenticateIncomingAsync(_request, _options);
  }
  async _authenticateOutgoingAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("AuthenticateOutgoing", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async authenticateOutgoingAsync(connectionInfo, webapi_options) {
    let _request = null;
    let _options = null;
    const first = connectionInfo;
    if (typeof first === "object" && first && typeof first.connectionInfo != "undefined") {
      _request = connectionInfo;
      _options = webapi_options;
    } else {
      _request = {
        connectionInfo
      };
      _options = webapi_options;
    }
    return this._authenticateOutgoingAsync(_request, _options);
  }
  async _getFolderListAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetFolderList", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getFolderListAsync(connectionInfo, includeItemCount, webapi_options) {
    let _request = null;
    let _options = null;
    const first = connectionInfo;
    if (typeof first === "object" && first && (typeof first.connectionInfo != "undefined" || typeof first.includeItemCount != "undefined")) {
      _request = connectionInfo;
      _options = includeItemCount;
    } else {
      _request = {
        connectionInfo,
        includeItemCount
      };
      _options = webapi_options;
    }
    return this._getFolderListAsync(_request, _options);
  }
  async _getAttachmentAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetAttachment", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_EMailAttachment_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getAttachmentAsync(connectionInfo, messageServerId, attachmentId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = connectionInfo;
    if (typeof first === "object" && first && (typeof first.connectionInfo != "undefined" || typeof first.messageServerId != "undefined" || typeof first.attachmentId != "undefined")) {
      _request = connectionInfo;
      _options = messageServerId;
    } else {
      _request = {
        connectionInfo,
        messageServerId,
        attachmentId
      };
      _options = webapi_options;
    }
    return this._getAttachmentAsync(_request, _options);
  }
  async _markAsReadAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("MarkAsRead", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async markAsReadAsync(connectionInfo, messageServerIds, read, webapi_options) {
    let _request = null;
    let _options = null;
    const first = connectionInfo;
    if (typeof first === "object" && first && (typeof first.connectionInfo != "undefined" || typeof first.messageServerIds != "undefined" || typeof first.read != "undefined")) {
      _request = connectionInfo;
      _options = messageServerIds;
    } else {
      _request = {
        connectionInfo,
        messageServerIds,
        read
      };
      _options = webapi_options;
    }
    return this._markAsReadAsync(_request, _options);
  }
  async _getFolderEMailCountAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetFolderEMailCount", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getFolderEMailCountAsync(connectionInfo, onlyUnread, webapi_options) {
    let _request = null;
    let _options = null;
    const first = connectionInfo;
    if (typeof first === "object" && first && (typeof first.connectionInfo != "undefined" || typeof first.onlyUnread != "undefined")) {
      _request = connectionInfo;
      _options = onlyUnread;
    } else {
      _request = {
        connectionInfo,
        onlyUnread
      };
      _options = webapi_options;
    }
    return this._getFolderEMailCountAsync(_request, _options);
  }
  async _deleteAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("Delete", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async deleteAsync(connectionInfo, messageServerIds, moveToFolder, webapi_options) {
    let _request = null;
    let _options = null;
    const first = connectionInfo;
    if (typeof first === "object" && first && (typeof first.connectionInfo != "undefined" || typeof first.messageServerIds != "undefined" || typeof first.moveToFolder != "undefined")) {
      _request = connectionInfo;
      _options = messageServerIds;
    } else {
      _request = {
        connectionInfo,
        messageServerIds,
        moveToFolder
      };
      _options = webapi_options;
    }
    return this._deleteAsync(_request, _options);
  }
  async _moveToFolderAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("MoveToFolder", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async moveToFolderAsync(connectionInfo, messageServerIds, targetFolder, webapi_options) {
    let _request = null;
    let _options = null;
    const first = connectionInfo;
    if (typeof first === "object" && first && (typeof first.connectionInfo != "undefined" || typeof first.messageServerIds != "undefined" || typeof first.targetFolder != "undefined")) {
      _request = connectionInfo;
      _options = messageServerIds;
    } else {
      _request = {
        connectionInfo,
        messageServerIds,
        targetFolder
      };
      _options = webapi_options;
    }
    return this._moveToFolderAsync(_request, _options);
  }
  async _emptyFolderAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("EmptyFolder", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async emptyFolderAsync(connectionInfo, moveToFolder, webapi_options) {
    let _request = null;
    let _options = null;
    const first = connectionInfo;
    if (typeof first === "object" && first && (typeof first.connectionInfo != "undefined" || typeof first.moveToFolder != "undefined")) {
      _request = connectionInfo;
      _options = moveToFolder;
    } else {
      _request = {
        connectionInfo,
        moveToFolder
      };
      _options = webapi_options;
    }
    return this._emptyFolderAsync(_request, _options);
  }
  async _getEMailAsStreamAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        if (!options || options.returnBlobAs == ReturnBlobType.AsArrayBuffer) {
          config.responseType = "arraybuffer";
          config.headers = config.headers || {};
          config.headers["Accept"] = "application/octet-stream";
        }
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetEMailAsStream", request, config);
        WebApiBase.SetCompleted(options);
        let res = null;
        if (options && options.returnBlobAs != ReturnBlobType.AsArrayBuffer) {
          res = response.data;
          if (options.returnBlobAs == ReturnBlobType.AsString) {
            res = FromBase64ToString(res);
          }
        } else {
          res = response.data;
        }
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getEMailAsStreamAsync(connectionInfo, messageServerId, stripAttachments, webapi_options) {
    let _request = null;
    let _options = null;
    const first = connectionInfo;
    if (typeof first === "object" && first && (typeof first.connectionInfo != "undefined" || typeof first.messageServerId != "undefined" || typeof first.stripAttachments != "undefined")) {
      _request = connectionInfo;
      _options = messageServerId;
    } else {
      _request = {
        connectionInfo,
        messageServerId,
        stripAttachments
      };
      _options = webapi_options;
    }
    return this._getEMailAsStreamAsync(_request, _options);
  }
  async _findAddressAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("FindAddress", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_EMailAddressArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async findAddressAsync(address, webapi_options) {
    let _request = null;
    let _options = null;
    const first = address;
    if (typeof first === "object" && first && typeof first.address != "undefined") {
      _request = address;
      _options = webapi_options;
    } else {
      _request = {
        address
      };
      _options = webapi_options;
    }
    return this._findAddressAsync(_request, _options);
  }
  async _getEMailFromDocumentIdAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetEMailFromDocumentId", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_EMailEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getEMailFromDocumentIdAsync(documentId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = documentId;
    if (typeof first === "object" && first && typeof first.documentId != "undefined") {
      _request = documentId;
      _options = webapi_options;
    } else {
      _request = {
        documentId
      };
      _options = webapi_options;
    }
    return this._getEMailFromDocumentIdAsync(_request, _options);
  }
  async _getUnsanitizedEMailFromDocumentIdAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetUnsanitizedEMailFromDocumentId", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_EMailEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getUnsanitizedEMailFromDocumentIdAsync(documentId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = documentId;
    if (typeof first === "object" && first && typeof first.documentId != "undefined") {
      _request = documentId;
      _options = webapi_options;
    } else {
      _request = {
        documentId
      };
      _options = webapi_options;
    }
    return this._getUnsanitizedEMailFromDocumentIdAsync(_request, _options);
  }
  async _getEMailFromAttachmentIdAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetEMailFromAttachmentId", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_EMailEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getEMailFromAttachmentIdAsync(emailId, attachmentIds, includeAttachments, webapi_options) {
    let _request = null;
    let _options = null;
    const first = emailId;
    if (typeof first === "object" && first && (typeof first.emailId != "undefined" || typeof first.attachmentIds != "undefined" || typeof first.includeAttachments != "undefined")) {
      _request = emailId;
      _options = attachmentIds;
    } else {
      _request = {
        emailId,
        attachmentIds,
        includeAttachments
      };
      _options = webapi_options;
    }
    return this._getEMailFromAttachmentIdAsync(_request, _options);
  }
  async _getUnsanitizedEMailFromAttachmentIdAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetUnsanitizedEMailFromAttachmentId", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_EMailEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getUnsanitizedEMailFromAttachmentIdAsync(emailId, attachmentIds, includeAttachments, webapi_options) {
    let _request = null;
    let _options = null;
    const first = emailId;
    if (typeof first === "object" && first && (typeof first.emailId != "undefined" || typeof first.attachmentIds != "undefined" || typeof first.includeAttachments != "undefined")) {
      _request = emailId;
      _options = attachmentIds;
    } else {
      _request = {
        emailId,
        attachmentIds,
        includeAttachments
      };
      _options = webapi_options;
    }
    return this._getUnsanitizedEMailFromAttachmentIdAsync(_request, _options);
  }
  async _getEMailFromDocumentAttachmentIdAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetEMailFromDocumentAttachmentId", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_EMailEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getEMailFromDocumentAttachmentIdAsync(docId, attachmentIds, includeAttachments, webapi_options) {
    let _request = null;
    let _options = null;
    const first = docId;
    if (typeof first === "object" && first && (typeof first.docId != "undefined" || typeof first.attachmentIds != "undefined" || typeof first.includeAttachments != "undefined")) {
      _request = docId;
      _options = attachmentIds;
    } else {
      _request = {
        docId,
        attachmentIds,
        includeAttachments
      };
      _options = webapi_options;
    }
    return this._getEMailFromDocumentAttachmentIdAsync(_request, _options);
  }
  async _getUnsanitizedEMailFromDocumentAttachmentIdAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetUnsanitizedEMailFromDocumentAttachmentId", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_EMailEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getUnsanitizedEMailFromDocumentAttachmentIdAsync(docId, attachmentIds, includeAttachments, webapi_options) {
    let _request = null;
    let _options = null;
    const first = docId;
    if (typeof first === "object" && first && (typeof first.docId != "undefined" || typeof first.attachmentIds != "undefined" || typeof first.includeAttachments != "undefined")) {
      _request = docId;
      _options = attachmentIds;
    } else {
      _request = {
        docId,
        attachmentIds,
        includeAttachments
      };
      _options = webapi_options;
    }
    return this._getUnsanitizedEMailFromDocumentAttachmentIdAsync(_request, _options);
  }
  async _getEMailEnvelopesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetEMailEnvelopes", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_EMailEnvelopeArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getEMailEnvelopesAsync(connectionInfo, messageServerIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = connectionInfo;
    if (typeof first === "object" && first && (typeof first.connectionInfo != "undefined" || typeof first.messageServerIds != "undefined")) {
      _request = connectionInfo;
      _options = messageServerIds;
    } else {
      _request = {
        connectionInfo,
        messageServerIds
      };
      _options = webapi_options;
    }
    return this._getEMailEnvelopesAsync(_request, _options);
  }
  async _setSubscriptionAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetSubscription", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setSubscriptionAsync(connectionInfo, folders, webapi_options) {
    let _request = null;
    let _options = null;
    const first = connectionInfo;
    if (typeof first === "object" && first && (typeof first.connectionInfo != "undefined" || typeof first.folders != "undefined")) {
      _request = connectionInfo;
      _options = folders;
    } else {
      _request = {
        connectionInfo,
        folders
      };
      _options = webapi_options;
    }
    return this._setSubscriptionAsync(_request, _options);
  }
  async _createFolderAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateFolder", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createFolderAsync(connectionInfo, webapi_options) {
    let _request = null;
    let _options = null;
    const first = connectionInfo;
    if (typeof first === "object" && first && typeof first.connectionInfo != "undefined") {
      _request = connectionInfo;
      _options = webapi_options;
    } else {
      _request = {
        connectionInfo
      };
      _options = webapi_options;
    }
    return this._createFolderAsync(_request, _options);
  }
  async _deleteFolderAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeleteFolder", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async deleteFolderAsync(connectionInfo, webapi_options) {
    let _request = null;
    let _options = null;
    const first = connectionInfo;
    if (typeof first === "object" && first && typeof first.connectionInfo != "undefined") {
      _request = connectionInfo;
      _options = webapi_options;
    } else {
      _request = {
        connectionInfo
      };
      _options = webapi_options;
    }
    return this._deleteFolderAsync(_request, _options);
  }
  async _createEMailFromDocumentEntityAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateEMailFromDocumentEntity", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_EMailEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createEMailFromDocumentEntityAsync(documentEntity, webapi_options) {
    let _request = null;
    let _options = null;
    const first = documentEntity;
    if (typeof first === "object" && first && typeof first.documentEntity != "undefined") {
      _request = documentEntity;
      _options = webapi_options;
    } else {
      _request = {
        documentEntity
      };
      _options = webapi_options;
    }
    return this._createEMailFromDocumentEntityAsync(_request, _options);
  }
  async _createEMailFromMimeMessageAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateEMailFromMimeMessage", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_EMailEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createEMailFromMimeMessageAsync(mimeMessage, webapi_options) {
    let _request = null;
    let _options = null;
    const first = mimeMessage;
    if (typeof first === "object" && first && typeof first.mimeMessage != "undefined") {
      _request = mimeMessage;
      _options = webapi_options;
    } else {
      _request = {
        mimeMessage
      };
      _options = webapi_options;
    }
    return this._createEMailFromMimeMessageAsync(_request, _options);
  }
  async _getFolderInfoAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetFolderInfo", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_EMailFolderArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getFolderInfoAsync(connectionInfo, folders, webapi_options) {
    let _request = null;
    let _options = null;
    const first = connectionInfo;
    if (typeof first === "object" && first && (typeof first.connectionInfo != "undefined" || typeof first.folders != "undefined")) {
      _request = connectionInfo;
      _options = folders;
    } else {
      _request = {
        connectionInfo,
        folders
      };
      _options = webapi_options;
    }
    return this._getFolderInfoAsync(_request, _options);
  }
  async _getFolderHasNewEMailAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetFolderHasNewEMail", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getFolderHasNewEMailAsync(connectionInfo, webapi_options) {
    let _request = null;
    let _options = null;
    const first = connectionInfo;
    if (typeof first === "object" && first && typeof first.connectionInfo != "undefined") {
      _request = connectionInfo;
      _options = webapi_options;
    } else {
      _request = {
        connectionInfo
      };
      _options = webapi_options;
    }
    return this._getFolderHasNewEMailAsync(_request, _options);
  }
  async _getEMailAddressesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetEMailAddresses", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_EMailAddressArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getEMailAddressesAsync(emailIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = emailIds;
    if (typeof first === "object" && first && typeof first.emailIds != "undefined") {
      _request = emailIds;
      _options = webapi_options;
    } else {
      _request = {
        emailIds
      };
      _options = webapi_options;
    }
    return this._getEMailAddressesAsync(_request, _options);
  }
  async _refreshFolderAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("RefreshFolder", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async refreshFolderAsync(connectionInfo, folders, webapi_options) {
    let _request = null;
    let _options = null;
    const first = connectionInfo;
    if (typeof first === "object" && first && (typeof first.connectionInfo != "undefined" || typeof first.folders != "undefined")) {
      _request = connectionInfo;
      _options = folders;
    } else {
      _request = {
        connectionInfo,
        folders
      };
      _options = webapi_options;
    }
    return this._refreshFolderAsync(_request, _options);
  }
  async _getEMailFromTempAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetEMailFromTemp", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_EMailEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getEMailFromTempAsync(fileName, webapi_options) {
    let _request = null;
    let _options = null;
    const first = fileName;
    if (typeof first === "object" && first && typeof first.fileName != "undefined") {
      _request = fileName;
      _options = webapi_options;
    } else {
      _request = {
        fileName
      };
      _options = webapi_options;
    }
    return this._getEMailFromTempAsync(_request, _options);
  }
  async _authenticateAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("Authenticate", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async authenticateAsync(connectionInfoExtended, webapi_options) {
    let _request = null;
    let _options = null;
    const first = connectionInfoExtended;
    if (typeof first === "object" && first && typeof first.connectionInfoExtended != "undefined") {
      _request = connectionInfoExtended;
      _options = webapi_options;
    } else {
      _request = {
        connectionInfoExtended
      };
      _options = webapi_options;
    }
    return this._authenticateAsync(_request, _options);
  }
  async _getEmailMessageIdsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetEmailMessageIds", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getEmailMessageIdsAsync(connectionInfoExtended, webapi_options) {
    let _request = null;
    let _options = null;
    const first = connectionInfoExtended;
    if (typeof first === "object" && first && typeof first.connectionInfoExtended != "undefined") {
      _request = connectionInfoExtended;
      _options = webapi_options;
    } else {
      _request = {
        connectionInfoExtended
      };
      _options = webapi_options;
    }
    return this._getEmailMessageIdsAsync(_request, _options);
  }
  async _getExtendedEmailMessageIdsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetExtendedEmailMessageIds", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getExtendedEmailMessageIdsAsync(connectionInfoExtended, webapi_options) {
    let _request = null;
    let _options = null;
    const first = connectionInfoExtended;
    if (typeof first === "object" && first && typeof first.connectionInfoExtended != "undefined") {
      _request = connectionInfoExtended;
      _options = webapi_options;
    } else {
      _request = {
        connectionInfoExtended
      };
      _options = webapi_options;
    }
    return this._getExtendedEmailMessageIdsAsync(_request, _options);
  }
  async _getEmailsAsStringAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetEmailsAsString", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getEmailsAsStringAsync(connectionInfoExtended, messageIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = connectionInfoExtended;
    if (typeof first === "object" && first && (typeof first.connectionInfoExtended != "undefined" || typeof first.messageIds != "undefined")) {
      _request = connectionInfoExtended;
      _options = messageIds;
    } else {
      _request = {
        connectionInfoExtended,
        messageIds
      };
      _options = webapi_options;
    }
    return this._getEmailsAsStringAsync(_request, _options);
  }
  async _deleteExtendedAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeleteExtended", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async deleteExtendedAsync(connectionInfoExtended, messageIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = connectionInfoExtended;
    if (typeof first === "object" && first && (typeof first.connectionInfoExtended != "undefined" || typeof first.messageIds != "undefined")) {
      _request = connectionInfoExtended;
      _options = messageIds;
    } else {
      _request = {
        connectionInfoExtended,
        messageIds
      };
      _options = webapi_options;
    }
    return this._deleteExtendedAsync(_request, _options);
  }
  async _relayMessageAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("RelayMessage", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async relayMessageAsync(connectionInfoExtended, rfc822, from, recipients, webapi_options) {
    let _request = null;
    let _options = null;
    const first = connectionInfoExtended;
    if (typeof first === "object" && first && (typeof first.connectionInfoExtended != "undefined" || typeof first.rfc822 != "undefined" || typeof first.from != "undefined" || typeof first.recipients != "undefined")) {
      _request = connectionInfoExtended;
      _options = rfc822;
    } else {
      _request = {
        connectionInfoExtended,
        rfc822,
        from,
        recipients
      };
      _options = webapi_options;
    }
    return this._relayMessageAsync(_request, _options);
  }
  async _getEMailAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetEMail", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_EMailEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getEMailAsync(id, includeAttachments, webapi_options) {
    let _request = null;
    let _options = null;
    const first = id;
    if (typeof first === "object" && first && (typeof first.id != "undefined" || typeof first.includeAttachments != "undefined")) {
      _request = id;
      _options = includeAttachments;
    } else {
      _request = {
        id,
        includeAttachments
      };
      _options = webapi_options;
    }
    return this._getEMailAsync(_request, _options);
  }
  async _getUnsanitizedEMailAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetUnsanitizedEMail", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_EMailEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getUnsanitizedEMailAsync(id, includeAttachments, webapi_options) {
    let _request = null;
    let _options = null;
    const first = id;
    if (typeof first === "object" && first && (typeof first.id != "undefined" || typeof first.includeAttachments != "undefined")) {
      _request = id;
      _options = includeAttachments;
    } else {
      _request = {
        id,
        includeAttachments
      };
      _options = webapi_options;
    }
    return this._getUnsanitizedEMailAsync(_request, _options);
  }
  async _markEmailsAsReadAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("MarkEmailsAsRead", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async markEmailsAsReadAsync(ids, read, webapi_options) {
    let _request = null;
    let _options = null;
    const first = ids;
    if (typeof first === "object" && first && (typeof first.ids != "undefined" || typeof first.read != "undefined")) {
      _request = ids;
      _options = read;
    } else {
      _request = {
        ids,
        read
      };
      _options = webapi_options;
    }
    return this._markEmailsAsReadAsync(_request, _options);
  }
  async _deleteEmailsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeleteEmails", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async deleteEmailsAsync(ids, moveToFolder, webapi_options) {
    let _request = null;
    let _options = null;
    const first = ids;
    if (typeof first === "object" && first && (typeof first.ids != "undefined" || typeof first.moveToFolder != "undefined")) {
      _request = ids;
      _options = moveToFolder;
    } else {
      _request = {
        ids,
        moveToFolder
      };
      _options = webapi_options;
    }
    return this._deleteEmailsAsync(_request, _options);
  }
  async _moveEmailsToTrashAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("MoveEmailsToTrash", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async moveEmailsToTrashAsync(ids, webapi_options) {
    let _request = null;
    let _options = null;
    const first = ids;
    if (typeof first === "object" && first && typeof first.ids != "undefined") {
      _request = ids;
      _options = webapi_options;
    } else {
      _request = {
        ids
      };
      _options = webapi_options;
    }
    return this._moveEmailsToTrashAsync(_request, _options);
  }
  async _saveAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("Save", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_EMailEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveAsync(email, webapi_options) {
    let _request = null;
    let _options = null;
    const first = email;
    if (typeof first === "object" && first && typeof first.email != "undefined") {
      _request = email;
      _options = webapi_options;
    } else {
      _request = {
        email
      };
      _options = webapi_options;
    }
    return this._saveAsync(_request, _options);
  }
  async _saveToMailServerAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveToMailServer", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_EMailEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveToMailServerAsync(email, webapi_options) {
    let _request = null;
    let _options = null;
    const first = email;
    if (typeof first === "object" && first && typeof first.email != "undefined") {
      _request = email;
      _options = webapi_options;
    } else {
      _request = {
        email
      };
      _options = webapi_options;
    }
    return this._saveToMailServerAsync(_request, _options);
  }
  async _sendAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("Send", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_EMailEntityArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async sendAsync(emails, webapi_options) {
    let _request = null;
    let _options = null;
    const first = emails;
    if (typeof first === "object" && first && typeof first.emails != "undefined") {
      _request = emails;
      _options = webapi_options;
    } else {
      _request = {
        emails
      };
      _options = webapi_options;
    }
    return this._sendAsync(_request, _options);
  }
  async _createForwardEmailAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateForwardEmail", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_EMailEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createForwardEmailAsync(email, webapi_options) {
    let _request = null;
    let _options = null;
    const first = email;
    if (typeof first === "object" && first && typeof first.email != "undefined") {
      _request = email;
      _options = webapi_options;
    } else {
      _request = {
        email
      };
      _options = webapi_options;
    }
    return this._createForwardEmailAsync(_request, _options);
  }
  async _findContactOrPersonByEmailNameAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("FindContactOrPersonByEmailName", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ContactOrPersonFromEmailArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async findContactOrPersonByEmailNameAsync(name, emailAddress, webapi_options) {
    let _request = null;
    let _options = null;
    const first = name;
    if (typeof first === "object" && first && (typeof first.name != "undefined" || typeof first.emailAddress != "undefined")) {
      _request = name;
      _options = emailAddress;
    } else {
      _request = {
        name,
        emailAddress
      };
      _options = webapi_options;
    }
    return this._findContactOrPersonByEmailNameAsync(_request, _options);
  }
  async _findContactOrPersonByEmailNameWithLimitAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("FindContactOrPersonByEmailNameWithLimit", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ContactOrPersonFromEmailArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async findContactOrPersonByEmailNameWithLimitAsync(name, emailAddress, numberOfContacts, numberOfPersons, webapi_options) {
    let _request = null;
    let _options = null;
    const first = name;
    if (typeof first === "object" && first && (typeof first.name != "undefined" || typeof first.emailAddress != "undefined" || typeof first.numberOfContacts != "undefined" || typeof first.numberOfPersons != "undefined")) {
      _request = name;
      _options = emailAddress;
    } else {
      _request = {
        name,
        emailAddress,
        numberOfContacts,
        numberOfPersons
      };
      _options = webapi_options;
    }
    return this._findContactOrPersonByEmailNameWithLimitAsync(_request, _options);
  }
  async _refreshFolderForAssociateAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("RefreshFolderForAssociate", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async refreshFolderForAssociateAsync(folders, webapi_options) {
    let _request = null;
    let _options = null;
    const first = folders;
    if (typeof first === "object" && first && typeof first.folders != "undefined") {
      _request = folders;
      _options = webapi_options;
    } else {
      _request = {
        folders
      };
      _options = webapi_options;
    }
    return this._refreshFolderForAssociateAsync(_request, _options);
  }
  async _getNewMailAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetNewMail", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_EMailEnvelopeArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getNewMailAsync(folders, webapi_options) {
    let _request = null;
    let _options = null;
    const first = folders;
    if (typeof first === "object" && first && typeof first.folders != "undefined") {
      _request = folders;
      _options = webapi_options;
    } else {
      _request = {
        folders
      };
      _options = webapi_options;
    }
    return this._getNewMailAsync(_request, _options);
  }
  async _cacheFolderListAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CacheFolderList", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_EMailFolderArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Fetch list of folders from email server for the current account, and cache in DB
   * @returns List of folders from mail server
   */
  async cacheFolderListAsync(webapi_options) {
    return this._cacheFolderListAsync(webapi_options);
  }
  async _moveEmailsToFolderAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("MoveEmailsToFolder", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async moveEmailsToFolderAsync(folderId, emailItemIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = folderId;
    if (typeof first === "object" && first && (typeof first.folderId != "undefined" || typeof first.emailItemIds != "undefined")) {
      _request = folderId;
      _options = emailItemIds;
    } else {
      _request = {
        folderId,
        emailItemIds
      };
      _options = webapi_options;
    }
    return this._moveEmailsToFolderAsync(_request, _options);
  }
  async _getMailFromMessageIdAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetMailFromMessageId", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_EMailEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getMailFromMessageIdAsync(messageId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = messageId;
    if (typeof first === "object" && first && typeof first.messageId != "undefined") {
      _request = messageId;
      _options = webapi_options;
    } else {
      _request = {
        messageId
      };
      _options = webapi_options;
    }
    return this._getMailFromMessageIdAsync(_request, _options);
  }
  async _getMailFromInReplyToAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetMailFromInReplyTo", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_EMailEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getMailFromInReplyToAsync(messageId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = messageId;
    if (typeof first === "object" && first && typeof first.messageId != "undefined") {
      _request = messageId;
      _options = webapi_options;
    } else {
      _request = {
        messageId
      };
      _options = webapi_options;
    }
    return this._getMailFromInReplyToAsync(_request, _options);
  }
  async _sendAndSaveEmailToTmpDocumentAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SendAndSaveEmailToTmpDocument", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async sendAndSaveEmailToTmpDocumentAsync(email, stripAttachments, webapi_options) {
    let _request = null;
    let _options = null;
    const first = email;
    if (typeof first === "object" && first && (typeof first.email != "undefined" || typeof first.stripAttachments != "undefined")) {
      _request = email;
      _options = stripAttachments;
    } else {
      _request = {
        email,
        stripAttachments
      };
      _options = webapi_options;
    }
    return this._sendAndSaveEmailToTmpDocumentAsync(_request, _options);
  }
  async _saveEmailToTmpDocumentAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveEmailToTmpDocument", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveEmailToTmpDocumentAsync(email, folderId, stripAttachments, webapi_options) {
    let _request = null;
    let _options = null;
    const first = email;
    if (typeof first === "object" && first && (typeof first.email != "undefined" || typeof first.folderId != "undefined" || typeof first.stripAttachments != "undefined")) {
      _request = email;
      _options = folderId;
    } else {
      _request = {
        email,
        folderId,
        stripAttachments
      };
      _options = webapi_options;
    }
    return this._saveEmailToTmpDocumentAsync(_request, _options);
  }
  async _saveDraftAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveDraft", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_EMailEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveDraftAsync(entity, webapi_options) {
    let _request = null;
    let _options = null;
    const first = entity;
    if (typeof first === "object" && first && typeof first.entity != "undefined") {
      _request = entity;
      _options = webapi_options;
    } else {
      _request = {
        entity
      };
      _options = webapi_options;
    }
    return this._saveDraftAsync(_request, _options);
  }
  async _setRepliedAtAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetRepliedAt", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setRepliedAtAsync(messageId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = messageId;
    if (typeof first === "object" && first && typeof first.messageId != "undefined") {
      _request = messageId;
      _options = webapi_options;
    } else {
      _request = {
        messageId
      };
      _options = webapi_options;
    }
    return this._setRepliedAtAsync(_request, _options);
  }
  async _getEMailFromDocumentIdWithoutAttachmentStreamAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetEMailFromDocumentIdWithoutAttachmentStream", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_EMailEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getEMailFromDocumentIdWithoutAttachmentStreamAsync(documentId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = documentId;
    if (typeof first === "object" && first && typeof first.documentId != "undefined") {
      _request = documentId;
      _options = webapi_options;
    } else {
      _request = {
        documentId
      };
      _options = webapi_options;
    }
    return this._getEMailFromDocumentIdWithoutAttachmentStreamAsync(_request, _options);
  }
  async _getUnsanitizedEMailFromDocumentIdWithoutAttachmentStreamAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetUnsanitizedEMailFromDocumentIdWithoutAttachmentStream", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_EMailEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getUnsanitizedEMailFromDocumentIdWithoutAttachmentStreamAsync(documentId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = documentId;
    if (typeof first === "object" && first && typeof first.documentId != "undefined") {
      _request = documentId;
      _options = webapi_options;
    } else {
      _request = {
        documentId
      };
      _options = webapi_options;
    }
    return this._getUnsanitizedEMailFromDocumentIdWithoutAttachmentStreamAsync(_request, _options);
  }
  async _getAttachmentFromIdAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetAttachmentFromId", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_EMailAttachment_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getAttachmentFromIdAsync(mailItemId, attachmentId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = mailItemId;
    if (typeof first === "object" && first && (typeof first.mailItemId != "undefined" || typeof first.attachmentId != "undefined")) {
      _request = mailItemId;
      _options = attachmentId;
    } else {
      _request = {
        mailItemId,
        attachmentId
      };
      _options = webapi_options;
    }
    return this._getAttachmentFromIdAsync(_request, _options);
  }
  async _getPreviewAttachmentFromIdAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPreviewAttachmentFromId", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_EMailAttachment_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getPreviewAttachmentFromIdAsync(mailItemId, attachmentId, attachmentType, attachmentFilename, webapi_options) {
    let _request = null;
    let _options = null;
    const first = mailItemId;
    if (typeof first === "object" && first && (typeof first.mailItemId != "undefined" || typeof first.attachmentId != "undefined" || typeof first.attachmentType != "undefined" || typeof first.attachmentFilename != "undefined")) {
      _request = mailItemId;
      _options = attachmentId;
    } else {
      _request = {
        mailItemId,
        attachmentId,
        attachmentType,
        attachmentFilename
      };
      _options = webapi_options;
    }
    return this._getPreviewAttachmentFromIdAsync(_request, _options);
  }
  async _getUnsanitizedPreviewAttachmentFromIdAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetUnsanitizedPreviewAttachmentFromId", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_EMailAttachment_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getUnsanitizedPreviewAttachmentFromIdAsync(mailItemId, attachmentId, attachmentType, attachmentFilename, webapi_options) {
    let _request = null;
    let _options = null;
    const first = mailItemId;
    if (typeof first === "object" && first && (typeof first.mailItemId != "undefined" || typeof first.attachmentId != "undefined" || typeof first.attachmentType != "undefined" || typeof first.attachmentFilename != "undefined")) {
      _request = mailItemId;
      _options = attachmentId;
    } else {
      _request = {
        mailItemId,
        attachmentId,
        attachmentType,
        attachmentFilename
      };
      _options = webapi_options;
    }
    return this._getUnsanitizedPreviewAttachmentFromIdAsync(_request, _options);
  }
  async _getPreviewAttachmentFromDocIdAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPreviewAttachmentFromDocId", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_EMailAttachment_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getPreviewAttachmentFromDocIdAsync(docId, attachmentId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = docId;
    if (typeof first === "object" && first && (typeof first.docId != "undefined" || typeof first.attachmentId != "undefined")) {
      _request = docId;
      _options = attachmentId;
    } else {
      _request = {
        docId,
        attachmentId
      };
      _options = webapi_options;
    }
    return this._getPreviewAttachmentFromDocIdAsync(_request, _options);
  }
  async _getUnsanitizedPreviewAttachmentFromDocIdAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetUnsanitizedPreviewAttachmentFromDocId", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_EMailAttachment_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getUnsanitizedPreviewAttachmentFromDocIdAsync(docId, attachmentId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = docId;
    if (typeof first === "object" && first && (typeof first.docId != "undefined" || typeof first.attachmentId != "undefined")) {
      _request = docId;
      _options = attachmentId;
    } else {
      _request = {
        docId,
        attachmentId
      };
      _options = webapi_options;
    }
    return this._getUnsanitizedPreviewAttachmentFromDocIdAsync(_request, _options);
  }
  async _testAuthenticateAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("TestAuthenticate", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Test if logged-in user has a working mail account
   * @returns
   */
  async testAuthenticateAsync(webapi_options) {
    return this._testAuthenticateAsync(webapi_options);
  }
  async _toggleSubscriptionAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ToggleSubscription", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async toggleSubscriptionAsync(folderId, subscriptionStatus, webapi_options) {
    let _request = null;
    let _options = null;
    const first = folderId;
    if (typeof first === "object" && first && (typeof first.folderId != "undefined" || typeof first.subscriptionStatus != "undefined")) {
      _request = folderId;
      _options = subscriptionStatus;
    } else {
      _request = {
        folderId,
        subscriptionStatus
      };
      _options = webapi_options;
    }
    return this._toggleSubscriptionAsync(_request, _options);
  }
  async _hasNewMailAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("HasNewMail", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async hasNewMailAsync(mailItemId, folderId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = mailItemId;
    if (typeof first === "object" && first && (typeof first.mailItemId != "undefined" || typeof first.folderId != "undefined")) {
      _request = mailItemId;
      _options = folderId;
    } else {
      _request = {
        mailItemId,
        folderId
      };
      _options = webapi_options;
    }
    return this._hasNewMailAsync(_request, _options);
  }
  async _latestItemIdByFolderAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("LatestItemIdByFolder", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async latestItemIdByFolderAsync(folderId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = folderId;
    if (typeof first === "object" && first && typeof first.folderId != "undefined") {
      _request = folderId;
      _options = webapi_options;
    } else {
      _request = {
        folderId
      };
      _options = webapi_options;
    }
    return this._latestItemIdByFolderAsync(_request, _options);
  }
  async _createInlineHtmlHeaderAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateInlineHtmlHeader", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createInlineHtmlHeaderAsync(email, webapi_options) {
    let _request = null;
    let _options = null;
    const first = email;
    if (typeof first === "object" && first && typeof first.email != "undefined") {
      _request = email;
      _options = webapi_options;
    } else {
      _request = {
        email
      };
      _options = webapi_options;
    }
    return this._createInlineHtmlHeaderAsync(_request, _options);
  }
  async _getEmailAppointmentAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetEmailAppointment", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_EMailAppointment_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getEmailAppointmentAsync(mailItemId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = mailItemId;
    if (typeof first === "object" && first && typeof first.mailItemId != "undefined") {
      _request = mailItemId;
      _options = webapi_options;
    } else {
      _request = {
        mailItemId
      };
      _options = webapi_options;
    }
    return this._getEmailAppointmentAsync(_request, _options);
  }
  async _getEmailAppointmentRecurrenceAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetEmailAppointmentRecurrence", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_RecurrenceInfo_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getEmailAppointmentRecurrenceAsync(mailItemId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = mailItemId;
    if (typeof first === "object" && first && typeof first.mailItemId != "undefined") {
      _request = mailItemId;
      _options = webapi_options;
    } else {
      _request = {
        mailItemId
      };
      _options = webapi_options;
    }
    return this._getEmailAppointmentRecurrenceAsync(_request, _options);
  }
  async _getParticipantInfoFromEmailAddressAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetParticipantInfoFromEmailAddress", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Person_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getParticipantInfoFromEmailAddressAsync(emailAddress, appointmentId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = emailAddress;
    if (typeof first === "object" && first && (typeof first.emailAddress != "undefined" || typeof first.appointmentId != "undefined")) {
      _request = emailAddress;
      _options = appointmentId;
    } else {
      _request = {
        emailAddress,
        appointmentId
      };
      _options = webapi_options;
    }
    return this._getParticipantInfoFromEmailAddressAsync(_request, _options);
  }
  async _getEmailDocumentAsMimeStreamAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        if (!options || options.returnBlobAs == ReturnBlobType.AsArrayBuffer) {
          config.responseType = "arraybuffer";
          config.headers = config.headers || {};
          config.headers["Accept"] = "application/octet-stream";
        }
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetEmailDocumentAsMimeStream", request, config);
        WebApiBase.SetCompleted(options);
        let res = null;
        if (options && options.returnBlobAs != ReturnBlobType.AsArrayBuffer) {
          res = response.data;
          if (options.returnBlobAs == ReturnBlobType.AsString) {
            res = FromBase64ToString(res);
          }
        } else {
          res = response.data;
        }
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getEmailDocumentAsMimeStreamAsync(documentId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = documentId;
    if (typeof first === "object" && first && typeof first.documentId != "undefined") {
      _request = documentId;
      _options = webapi_options;
    } else {
      _request = {
        documentId
      };
      _options = webapi_options;
    }
    return this._getEmailDocumentAsMimeStreamAsync(_request, _options);
  }
  /*
   * Gets a EMailSOInfo object.
   * @param eMailSOInfoId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single EMailSOInfo
   */
  async getEMailSOInfoAsync(eMailSOInfoId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetEMailSOInfo?eMailSOInfoId=" + eMailSOInfoId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_EMailSOInfo_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getReadySyncEmailAccountsAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetReadySyncEmailAccounts", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SyncUserAccountArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Gets the list of SyncUserAccounts that should be synced.
   * @returns List of accounts to sync
   */
  async getReadySyncEmailAccountsAsync(webapi_options) {
    return this._getReadySyncEmailAccountsAsync(webapi_options);
  }
  async _syncEmailAccountAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SyncEmailAccount", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async syncEmailAccountAsync(syncUserAccount, webapi_options) {
    let _request = null;
    let _options = null;
    const first = syncUserAccount;
    if (typeof first === "object" && first && typeof first.syncUserAccount != "undefined") {
      _request = syncUserAccount;
      _options = webapi_options;
    } else {
      _request = {
        syncUserAccount
      };
      _options = webapi_options;
    }
    return this._syncEmailAccountAsync(_request, _options);
  }
  async _syncEmailAccountsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SyncEmailAccounts", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async syncEmailAccountsAsync(syncUserAccounts, webapi_options) {
    let _request = null;
    let _options = null;
    const first = syncUserAccounts;
    if (typeof first === "object" && first && typeof first.syncUserAccounts != "undefined") {
      _request = syncUserAccounts;
      _options = webapi_options;
    } else {
      _request = {
        syncUserAccounts
      };
      _options = webapi_options;
    }
    return this._syncEmailAccountsAsync(_request, _options);
  }
};

// server/node_modules/@superoffice/webapi/dist/esm/FindAgent.js
var FindAgent = class extends WebApiBase {
  constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
    const options = WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
    options.basePath = "v1/Agents/Find/";
    super(options);
  }
  async _getCriteriaInformationAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetCriteriaInformation", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_CriteriaInformation_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getCriteriaInformationAsync(storageType, providerName, storageKey, staticColumns, webapi_options) {
    let _request = null;
    let _options = null;
    const first = storageType;
    if (typeof first === "object" && first && (typeof first.storageType != "undefined" || typeof first.providerName != "undefined" || typeof first.storageKey != "undefined" || typeof first.staticColumns != "undefined")) {
      _request = storageType;
      _options = providerName;
    } else {
      _request = {
        storageType,
        providerName,
        storageKey,
        staticColumns
      };
      _options = webapi_options;
    }
    return this._getCriteriaInformationAsync(_request, _options);
  }
  async _getCriteriaInformationWithContextAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetCriteriaInformationWithContext", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_CriteriaInformation_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getCriteriaInformationWithContextAsync(storageType, providerName, storageKey, staticColumns, context, webapi_options) {
    let _request = null;
    let _options = null;
    const first = storageType;
    if (typeof first === "object" && first && (typeof first.storageType != "undefined" || typeof first.providerName != "undefined" || typeof first.storageKey != "undefined" || typeof first.staticColumns != "undefined" || typeof first.context != "undefined")) {
      _request = storageType;
      _options = providerName;
    } else {
      _request = {
        storageType,
        providerName,
        storageKey,
        staticColumns,
        context
      };
      _options = webapi_options;
    }
    return this._getCriteriaInformationWithContextAsync(_request, _options);
  }
  async _saveRestrictionsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveRestrictions", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveRestrictionsAsync(storageType, providerName, storageKey, restrictions, webapi_options) {
    let _request = null;
    let _options = null;
    const first = storageType;
    if (typeof first === "object" && first && (typeof first.storageType != "undefined" || typeof first.providerName != "undefined" || typeof first.storageKey != "undefined" || typeof first.restrictions != "undefined")) {
      _request = storageType;
      _options = providerName;
    } else {
      _request = {
        storageType,
        providerName,
        storageKey,
        restrictions
      };
      _options = webapi_options;
    }
    return this._saveRestrictionsAsync(_request, _options);
  }
  async _saveRestrictionsWithContextAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveRestrictionsWithContext", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveRestrictionsWithContextAsync(storageType, providerName, storageKey, restrictions, context, webapi_options) {
    let _request = null;
    let _options = null;
    const first = storageType;
    if (typeof first === "object" && first && (typeof first.storageType != "undefined" || typeof first.providerName != "undefined" || typeof first.storageKey != "undefined" || typeof first.restrictions != "undefined" || typeof first.context != "undefined")) {
      _request = storageType;
      _options = providerName;
    } else {
      _request = {
        storageType,
        providerName,
        storageKey,
        restrictions,
        context
      };
      _options = webapi_options;
    }
    return this._saveRestrictionsWithContextAsync(_request, _options);
  }
  async _saveRestrictionGroupAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveRestrictionGroup", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveRestrictionGroupAsync(storageType, providerName, storageKey, restrictionGroup, context, webapi_options) {
    let _request = null;
    let _options = null;
    const first = storageType;
    if (typeof first === "object" && first && (typeof first.storageType != "undefined" || typeof first.providerName != "undefined" || typeof first.storageKey != "undefined" || typeof first.restrictionGroup != "undefined" || typeof first.context != "undefined")) {
      _request = storageType;
      _options = providerName;
    } else {
      _request = {
        storageType,
        providerName,
        storageKey,
        restrictionGroup,
        context
      };
      _options = webapi_options;
    }
    return this._saveRestrictionGroupAsync(_request, _options);
  }
  async _saveRestrictionGroupsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveRestrictionGroups", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ArchiveRestrictionGroupArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveRestrictionGroupsAsync(storageType, providerName, storageKey, restrictionGroups, context, webapi_options) {
    let _request = null;
    let _options = null;
    const first = storageType;
    if (typeof first === "object" && first && (typeof first.storageType != "undefined" || typeof first.providerName != "undefined" || typeof first.storageKey != "undefined" || typeof first.restrictionGroups != "undefined" || typeof first.context != "undefined")) {
      _request = storageType;
      _options = providerName;
    } else {
      _request = {
        storageType,
        providerName,
        storageKey,
        restrictionGroups,
        context
      };
      _options = webapi_options;
    }
    return this._saveRestrictionGroupsAsync(_request, _options);
  }
  async _getRestrictionGroupsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetRestrictionGroups", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ArchiveRestrictionGroupArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getRestrictionGroupsAsync(storageType, providerName, storageKey, context, webapi_options) {
    let _request = null;
    let _options = null;
    const first = storageType;
    if (typeof first === "object" && first && (typeof first.storageType != "undefined" || typeof first.providerName != "undefined" || typeof first.storageKey != "undefined" || typeof first.context != "undefined")) {
      _request = storageType;
      _options = providerName;
    } else {
      _request = {
        storageType,
        providerName,
        storageKey,
        context
      };
      _options = webapi_options;
    }
    return this._getRestrictionGroupsAsync(_request, _options);
  }
  async _getRestrictionGroupAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetRestrictionGroup", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ArchiveRestrictionGroup_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getRestrictionGroupAsync(storageType, providerName, storageKey, rank, context, webapi_options) {
    let _request = null;
    let _options = null;
    const first = storageType;
    if (typeof first === "object" && first && (typeof first.storageType != "undefined" || typeof first.providerName != "undefined" || typeof first.storageKey != "undefined" || typeof first.rank != "undefined" || typeof first.context != "undefined")) {
      _request = storageType;
      _options = providerName;
    } else {
      _request = {
        storageType,
        providerName,
        storageKey,
        rank,
        context
      };
      _options = webapi_options;
    }
    return this._getRestrictionGroupAsync(_request, _options);
  }
  async _createRestrictionGroupAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateRestrictionGroup", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ArchiveRestrictionGroup_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createRestrictionGroupAsync(storageType, providerName, storageKey, context, webapi_options) {
    let _request = null;
    let _options = null;
    const first = storageType;
    if (typeof first === "object" && first && (typeof first.storageType != "undefined" || typeof first.providerName != "undefined" || typeof first.storageKey != "undefined" || typeof first.context != "undefined")) {
      _request = storageType;
      _options = providerName;
    } else {
      _request = {
        storageType,
        providerName,
        storageKey,
        context
      };
      _options = webapi_options;
    }
    return this._createRestrictionGroupAsync(_request, _options);
  }
  async _deleteRestrictionGroupAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeleteRestrictionGroup", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async deleteRestrictionGroupAsync(storageType, providerName, storageKey, rank, context, webapi_options) {
    let _request = null;
    let _options = null;
    const first = storageType;
    if (typeof first === "object" && first && (typeof first.storageType != "undefined" || typeof first.providerName != "undefined" || typeof first.storageKey != "undefined" || typeof first.rank != "undefined" || typeof first.context != "undefined")) {
      _request = storageType;
      _options = providerName;
    } else {
      _request = {
        storageType,
        providerName,
        storageKey,
        rank,
        context
      };
      _options = webapi_options;
    }
    return this._deleteRestrictionGroupAsync(_request, _options);
  }
  async _saveRestrictionsAndGetCriteriaInformationAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveRestrictionsAndGetCriteriaInformation", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_CriteriaInformation_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveRestrictionsAndGetCriteriaInformationAsync(storageType, providerName, storageKey, restrictions, staticColumns, webapi_options) {
    let _request = null;
    let _options = null;
    const first = storageType;
    if (typeof first === "object" && first && (typeof first.storageType != "undefined" || typeof first.providerName != "undefined" || typeof first.storageKey != "undefined" || typeof first.restrictions != "undefined" || typeof first.staticColumns != "undefined")) {
      _request = storageType;
      _options = providerName;
    } else {
      _request = {
        storageType,
        providerName,
        storageKey,
        restrictions,
        staticColumns
      };
      _options = webapi_options;
    }
    return this._saveRestrictionsAndGetCriteriaInformationAsync(_request, _options);
  }
  async _findAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("Find", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_FindResults_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async findAsync(storageType, providerName, storageKey, pageSize, pageNumber, webapi_options) {
    let _request = null;
    let _options = null;
    const first = storageType;
    if (typeof first === "object" && first && (typeof first.storageType != "undefined" || typeof first.providerName != "undefined" || typeof first.storageKey != "undefined" || typeof first.pageSize != "undefined" || typeof first.pageNumber != "undefined")) {
      _request = storageType;
      _options = providerName;
    } else {
      _request = {
        storageType,
        providerName,
        storageKey,
        pageSize,
        pageNumber
      };
      _options = webapi_options;
    }
    return this._findAsync(_request, _options);
  }
  async _findFromRestrictionsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("FindFromRestrictions", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_FindResults_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async findFromRestrictionsAsync(restrictions, providerName, pageSize, pageNumber, webapi_options) {
    let _request = null;
    let _options = null;
    const first = restrictions;
    if (typeof first === "object" && first && (typeof first.restrictions != "undefined" || typeof first.providerName != "undefined" || typeof first.pageSize != "undefined" || typeof first.pageNumber != "undefined")) {
      _request = restrictions;
      _options = providerName;
    } else {
      _request = {
        restrictions,
        providerName,
        pageSize,
        pageNumber
      };
      _options = webapi_options;
    }
    return this._findFromRestrictionsAsync(_request, _options);
  }
  async _findFromRestrictionsColumnsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("FindFromRestrictionsColumns", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_FindResults_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async findFromRestrictionsColumnsAsync(restrictions, providerName, desiredColumns, pageSize, pageNumber, webapi_options) {
    let _request = null;
    let _options = null;
    const first = restrictions;
    if (typeof first === "object" && first && (typeof first.restrictions != "undefined" || typeof first.providerName != "undefined" || typeof first.desiredColumns != "undefined" || typeof first.pageSize != "undefined" || typeof first.pageNumber != "undefined")) {
      _request = restrictions;
      _options = providerName;
    } else {
      _request = {
        restrictions,
        providerName,
        desiredColumns,
        pageSize,
        pageNumber
      };
      _options = webapi_options;
    }
    return this._findFromRestrictionsColumnsAsync(_request, _options);
  }
  async _getAvailableRestrictionColumnsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetAvailableRestrictionColumns", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getAvailableRestrictionColumnsAsync(storageType, providerName, webapi_options) {
    let _request = null;
    let _options = null;
    const first = storageType;
    if (typeof first === "object" && first && (typeof first.storageType != "undefined" || typeof first.providerName != "undefined")) {
      _request = storageType;
      _options = providerName;
    } else {
      _request = {
        storageType,
        providerName
      };
      _options = webapi_options;
    }
    return this._getAvailableRestrictionColumnsAsync(_request, _options);
  }
  async _getSpecifiedCriteriaInformationWithDefaultsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetSpecifiedCriteriaInformationWithDefaults", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_CriteriaInformation_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getSpecifiedCriteriaInformationWithDefaultsAsync(storageType, providerName, storageKey, desiredColumnNames, staticColumns, webapi_options) {
    let _request = null;
    let _options = null;
    const first = storageType;
    if (typeof first === "object" && first && (typeof first.storageType != "undefined" || typeof first.providerName != "undefined" || typeof first.storageKey != "undefined" || typeof first.desiredColumnNames != "undefined" || typeof first.staticColumns != "undefined")) {
      _request = storageType;
      _options = providerName;
    } else {
      _request = {
        storageType,
        providerName,
        storageKey,
        desiredColumnNames,
        staticColumns
      };
      _options = webapi_options;
    }
    return this._getSpecifiedCriteriaInformationWithDefaultsAsync(_request, _options);
  }
  async _getSpecifiedCriteriaInformationWithDefaultsWithContextAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetSpecifiedCriteriaInformationWithDefaultsWithContext", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_CriteriaInformation_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getSpecifiedCriteriaInformationWithDefaultsWithContextAsync(storageType, providerName, storageKey, desiredColumnNames, staticColumns, context, webapi_options) {
    let _request = null;
    let _options = null;
    const first = storageType;
    if (typeof first === "object" && first && (typeof first.storageType != "undefined" || typeof first.providerName != "undefined" || typeof first.storageKey != "undefined" || typeof first.desiredColumnNames != "undefined" || typeof first.staticColumns != "undefined" || typeof first.context != "undefined")) {
      _request = storageType;
      _options = providerName;
    } else {
      _request = {
        storageType,
        providerName,
        storageKey,
        desiredColumnNames,
        staticColumns,
        context
      };
      _options = webapi_options;
    }
    return this._getSpecifiedCriteriaInformationWithDefaultsWithContextAsync(_request, _options);
  }
  async _findFromRestrictionsColumnsOrderByAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("FindFromRestrictionsColumnsOrderBy", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_FindResults_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async findFromRestrictionsColumnsOrderByAsync(restrictions, providerName, desiredColumns, orderBy, pageSize, pageNumber, webapi_options) {
    let _request = null;
    let _options = null;
    const first = restrictions;
    if (typeof first === "object" && first && (typeof first.restrictions != "undefined" || typeof first.providerName != "undefined" || typeof first.desiredColumns != "undefined" || typeof first.orderBy != "undefined" || typeof first.pageSize != "undefined" || typeof first.pageNumber != "undefined")) {
      _request = restrictions;
      _options = providerName;
    } else {
      _request = {
        restrictions,
        providerName,
        desiredColumns,
        orderBy,
        pageSize,
        pageNumber
      };
      _options = webapi_options;
    }
    return this._findFromRestrictionsColumnsOrderByAsync(_request, _options);
  }
  async _getDefaultDesiredColumnsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetDefaultDesiredColumns", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ArchiveColumnInfoArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getDefaultDesiredColumnsAsync(storageType, providerName, storageKey, webapi_options) {
    let _request = null;
    let _options = null;
    const first = storageType;
    if (typeof first === "object" && first && (typeof first.storageType != "undefined" || typeof first.providerName != "undefined" || typeof first.storageKey != "undefined")) {
      _request = storageType;
      _options = providerName;
    } else {
      _request = {
        storageType,
        providerName,
        storageKey
      };
      _options = webapi_options;
    }
    return this._getDefaultDesiredColumnsAsync(_request, _options);
  }
  async _getDefaultOrderByAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetDefaultOrderBy", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ArchiveOrderByInfoArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getDefaultOrderByAsync(storageType, providerName, storageKey, webapi_options) {
    let _request = null;
    let _options = null;
    const first = storageType;
    if (typeof first === "object" && first && (typeof first.storageType != "undefined" || typeof first.providerName != "undefined" || typeof first.storageKey != "undefined")) {
      _request = storageType;
      _options = providerName;
    } else {
      _request = {
        storageType,
        providerName,
        storageKey
      };
      _options = webapi_options;
    }
    return this._getDefaultOrderByAsync(_request, _options);
  }
  async _populateRestrictionsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("PopulateRestrictions", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ArchiveRestrictionInfoArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async populateRestrictionsAsync(providerName, restrictions, webapi_options) {
    let _request = null;
    let _options = null;
    const first = providerName;
    if (typeof first === "object" && first && (typeof first.providerName != "undefined" || typeof first.restrictions != "undefined")) {
      _request = providerName;
      _options = restrictions;
    } else {
      _request = {
        providerName,
        restrictions
      };
      _options = webapi_options;
    }
    return this._populateRestrictionsAsync(_request, _options);
  }
  async _populateRestrictionValuesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("PopulateRestrictionValues", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ArchiveRestrictionInfoArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async populateRestrictionValuesAsync(restrictions, webapi_options) {
    let _request = null;
    let _options = null;
    const first = restrictions;
    if (typeof first === "object" && first && typeof first.restrictions != "undefined") {
      _request = restrictions;
      _options = webapi_options;
    } else {
      _request = {
        restrictions
      };
      _options = webapi_options;
    }
    return this._populateRestrictionValuesAsync(_request, _options);
  }
  async _getDefaultDesiredColumnsFromRestrictionsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetDefaultDesiredColumnsFromRestrictions", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ArchiveColumnInfoArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getDefaultDesiredColumnsFromRestrictionsAsync(providerName, restrictions, webapi_options) {
    let _request = null;
    let _options = null;
    const first = providerName;
    if (typeof first === "object" && first && (typeof first.providerName != "undefined" || typeof first.restrictions != "undefined")) {
      _request = providerName;
      _options = restrictions;
    } else {
      _request = {
        providerName,
        restrictions
      };
      _options = webapi_options;
    }
    return this._getDefaultDesiredColumnsFromRestrictionsAsync(_request, _options);
  }
  async _getDefaultOrderByFromDesiredColumnsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetDefaultOrderByFromDesiredColumns", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ArchiveOrderByInfoArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getDefaultOrderByFromDesiredColumnsAsync(providerName, desiredColumns, webapi_options) {
    let _request = null;
    let _options = null;
    const first = providerName;
    if (typeof first === "object" && first && (typeof first.providerName != "undefined" || typeof first.desiredColumns != "undefined")) {
      _request = providerName;
      _options = desiredColumns;
    } else {
      _request = {
        providerName,
        desiredColumns
      };
      _options = webapi_options;
    }
    return this._getDefaultOrderByFromDesiredColumnsAsync(_request, _options);
  }
  async _findOrderByAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("FindOrderBy", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_FindResults_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async findOrderByAsync(storageType, providerName, storageKey, pageSize, pageNumber, orderBy, webapi_options) {
    let _request = null;
    let _options = null;
    const first = storageType;
    if (typeof first === "object" && first && (typeof first.storageType != "undefined" || typeof first.providerName != "undefined" || typeof first.storageKey != "undefined" || typeof first.pageSize != "undefined" || typeof first.pageNumber != "undefined" || typeof first.orderBy != "undefined")) {
      _request = storageType;
      _options = providerName;
    } else {
      _request = {
        storageType,
        providerName,
        storageKey,
        pageSize,
        pageNumber,
        orderBy
      };
      _options = webapi_options;
    }
    return this._findOrderByAsync(_request, _options);
  }
  async _findWithExtraRestrictionsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("FindWithExtraRestrictions", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_FindResults_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async findWithExtraRestrictionsAsync(storageType, providerName, storageKey, extraRestrictions, orderBy, desiredColumns, pageSize, pageNumber, webapi_options) {
    let _request = null;
    let _options = null;
    const first = storageType;
    if (typeof first === "object" && first && (typeof first.storageType != "undefined" || typeof first.providerName != "undefined" || typeof first.storageKey != "undefined" || typeof first.extraRestrictions != "undefined" || typeof first.orderBy != "undefined" || typeof first.desiredColumns != "undefined" || typeof first.pageSize != "undefined" || typeof first.pageNumber != "undefined")) {
      _request = storageType;
      _options = providerName;
    } else {
      _request = {
        storageType,
        providerName,
        storageKey,
        extraRestrictions,
        orderBy,
        desiredColumns,
        pageSize,
        pageNumber
      };
      _options = webapi_options;
    }
    return this._findWithExtraRestrictionsAsync(_request, _options);
  }
  async _findWithColumnsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("FindWithColumns", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_FindResults_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async findWithColumnsAsync(storageType, providerName, storageKey, desiredColumns, pageSize, pageNumber, orderBy, webapi_options) {
    let _request = null;
    let _options = null;
    const first = storageType;
    if (typeof first === "object" && first && (typeof first.storageType != "undefined" || typeof first.providerName != "undefined" || typeof first.storageKey != "undefined" || typeof first.desiredColumns != "undefined" || typeof first.pageSize != "undefined" || typeof first.pageNumber != "undefined" || typeof first.orderBy != "undefined")) {
      _request = storageType;
      _options = providerName;
    } else {
      _request = {
        storageType,
        providerName,
        storageKey,
        desiredColumns,
        pageSize,
        pageNumber,
        orderBy
      };
      _options = webapi_options;
    }
    return this._findWithColumnsAsync(_request, _options);
  }
  async _saveRestrictions2Async(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveRestrictions2", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveRestrictions2Async(storageType, providerName, storageKey, restrictions, webapi_options) {
    let _request = null;
    let _options = null;
    const first = storageType;
    if (typeof first === "object" && first && (typeof first.storageType != "undefined" || typeof first.providerName != "undefined" || typeof first.storageKey != "undefined" || typeof first.restrictions != "undefined")) {
      _request = storageType;
      _options = providerName;
    } else {
      _request = {
        storageType,
        providerName,
        storageKey,
        restrictions
      };
      _options = webapi_options;
    }
    return this._saveRestrictions2Async(_request, _options);
  }
  async _saveRestrictionsWithContext2Async(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveRestrictionsWithContext2", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveRestrictionsWithContext2Async(storageType, providerName, storageKey, restrictions, context, webapi_options) {
    let _request = null;
    let _options = null;
    const first = storageType;
    if (typeof first === "object" && first && (typeof first.storageType != "undefined" || typeof first.providerName != "undefined" || typeof first.storageKey != "undefined" || typeof first.restrictions != "undefined" || typeof first.context != "undefined")) {
      _request = storageType;
      _options = providerName;
    } else {
      _request = {
        storageType,
        providerName,
        storageKey,
        restrictions,
        context
      };
      _options = webapi_options;
    }
    return this._saveRestrictionsWithContext2Async(_request, _options);
  }
  async _saveRestrictionsAndGetCriteriaInformation2Async(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveRestrictionsAndGetCriteriaInformation2", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_CriteriaInformation_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveRestrictionsAndGetCriteriaInformation2Async(storageType, providerName, storageKey, restrictions, staticColumns, webapi_options) {
    let _request = null;
    let _options = null;
    const first = storageType;
    if (typeof first === "object" && first && (typeof first.storageType != "undefined" || typeof first.providerName != "undefined" || typeof first.storageKey != "undefined" || typeof first.restrictions != "undefined" || typeof first.staticColumns != "undefined")) {
      _request = storageType;
      _options = providerName;
    } else {
      _request = {
        storageType,
        providerName,
        storageKey,
        restrictions,
        staticColumns
      };
      _options = webapi_options;
    }
    return this._saveRestrictionsAndGetCriteriaInformation2Async(_request, _options);
  }
  async _findFromRestrictions2Async(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("FindFromRestrictions2", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_FindResults_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async findFromRestrictions2Async(restrictions, providerName, pageSize, pageNumber, webapi_options) {
    let _request = null;
    let _options = null;
    const first = restrictions;
    if (typeof first === "object" && first && (typeof first.restrictions != "undefined" || typeof first.providerName != "undefined" || typeof first.pageSize != "undefined" || typeof first.pageNumber != "undefined")) {
      _request = restrictions;
      _options = providerName;
    } else {
      _request = {
        restrictions,
        providerName,
        pageSize,
        pageNumber
      };
      _options = webapi_options;
    }
    return this._findFromRestrictions2Async(_request, _options);
  }
  async _findFromRestrictionsColumns2Async(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("FindFromRestrictionsColumns2", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_FindResults_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async findFromRestrictionsColumns2Async(restrictions, providerName, desiredColumns, pageSize, pageNumber, webapi_options) {
    let _request = null;
    let _options = null;
    const first = restrictions;
    if (typeof first === "object" && first && (typeof first.restrictions != "undefined" || typeof first.providerName != "undefined" || typeof first.desiredColumns != "undefined" || typeof first.pageSize != "undefined" || typeof first.pageNumber != "undefined")) {
      _request = restrictions;
      _options = providerName;
    } else {
      _request = {
        restrictions,
        providerName,
        desiredColumns,
        pageSize,
        pageNumber
      };
      _options = webapi_options;
    }
    return this._findFromRestrictionsColumns2Async(_request, _options);
  }
  async _findFromRestrictionsColumnsOrderBy2Async(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("FindFromRestrictionsColumnsOrderBy2", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_FindResults_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async findFromRestrictionsColumnsOrderBy2Async(restrictions, providerName, desiredColumns, orderBy, pageSize, pageNumber, webapi_options) {
    let _request = null;
    let _options = null;
    const first = restrictions;
    if (typeof first === "object" && first && (typeof first.restrictions != "undefined" || typeof first.providerName != "undefined" || typeof first.desiredColumns != "undefined" || typeof first.orderBy != "undefined" || typeof first.pageSize != "undefined" || typeof first.pageNumber != "undefined")) {
      _request = restrictions;
      _options = providerName;
    } else {
      _request = {
        restrictions,
        providerName,
        desiredColumns,
        orderBy,
        pageSize,
        pageNumber
      };
      _options = webapi_options;
    }
    return this._findFromRestrictionsColumnsOrderBy2Async(_request, _options);
  }
  async _getDefaultDesiredColumnsFromRestrictions2Async(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetDefaultDesiredColumnsFromRestrictions2", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ArchiveColumnInfoArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getDefaultDesiredColumnsFromRestrictions2Async(providerName, restrictions, webapi_options) {
    let _request = null;
    let _options = null;
    const first = providerName;
    if (typeof first === "object" && first && (typeof first.providerName != "undefined" || typeof first.restrictions != "undefined")) {
      _request = providerName;
      _options = restrictions;
    } else {
      _request = {
        providerName,
        restrictions
      };
      _options = webapi_options;
    }
    return this._getDefaultDesiredColumnsFromRestrictions2Async(_request, _options);
  }
  async _findOrderBy2Async(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("FindOrderBy2", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_FindResults_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async findOrderBy2Async(storageType, providerName, storageKey, pageSize, pageNumber, orderBy, webapi_options) {
    let _request = null;
    let _options = null;
    const first = storageType;
    if (typeof first === "object" && first && (typeof first.storageType != "undefined" || typeof first.providerName != "undefined" || typeof first.storageKey != "undefined" || typeof first.pageSize != "undefined" || typeof first.pageNumber != "undefined" || typeof first.orderBy != "undefined")) {
      _request = storageType;
      _options = providerName;
    } else {
      _request = {
        storageType,
        providerName,
        storageKey,
        pageSize,
        pageNumber,
        orderBy
      };
      _options = webapi_options;
    }
    return this._findOrderBy2Async(_request, _options);
  }
  async _findWithExtraRestrictions2Async(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("FindWithExtraRestrictions2", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_FindResults_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async findWithExtraRestrictions2Async(storageType, providerName, storageKey, extraRestrictions, orderBy, desiredColumns, pageSize, pageNumber, webapi_options) {
    let _request = null;
    let _options = null;
    const first = storageType;
    if (typeof first === "object" && first && (typeof first.storageType != "undefined" || typeof first.providerName != "undefined" || typeof first.storageKey != "undefined" || typeof first.extraRestrictions != "undefined" || typeof first.orderBy != "undefined" || typeof first.desiredColumns != "undefined" || typeof first.pageSize != "undefined" || typeof first.pageNumber != "undefined")) {
      _request = storageType;
      _options = providerName;
    } else {
      _request = {
        storageType,
        providerName,
        storageKey,
        extraRestrictions,
        orderBy,
        desiredColumns,
        pageSize,
        pageNumber
      };
      _options = webapi_options;
    }
    return this._findWithExtraRestrictions2Async(_request, _options);
  }
};

// server/node_modules/@superoffice/webapi/dist/esm/WebhookAgent.js
var WebhookAgent = class extends WebApiBase {
  constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
    const options = WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
    options.basePath = "v1/Agents/Webhook/";
    super(options);
  }
  /**
   * Set default values into a new Webhook.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultWebhookAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultWebhook", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Webhook_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing Webhook or creates a new Webhook if the id parameter is empty
   * @param entity - The Webhook to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated Webhook
   */
  async saveWebhookAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveWebhook", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Webhook_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Deletes the Webhook
   * @param WebhookId - The id of the Webhook to be deleted.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   */
  async deleteWebhookAsync(WebhookId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("DeleteWebhook?WebhookId=" + WebhookId, null, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets a Webhook object.
   * @param webhookId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single Webhook
   */
  async getWebhookAsync(webhookId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetWebhook?webhookId=" + webhookId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Webhook_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getAllWebhooksAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetAllWebhooks", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_WebhookArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getAllWebhooksAsync(nameFilter, eventFilter, statusFilter, webapi_options) {
    let _request = null;
    let _options = null;
    const first = nameFilter;
    if (typeof first === "object" && first && (typeof first.nameFilter != "undefined" || typeof first.eventFilter != "undefined" || typeof first.statusFilter != "undefined")) {
      _request = nameFilter;
      _options = eventFilter;
    } else {
      _request = {
        nameFilter,
        eventFilter,
        statusFilter
      };
      _options = webapi_options;
    }
    return this._getAllWebhooksAsync(_request, _options);
  }
  async _testWebhookAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("TestWebhook", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_WebhookResult_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async testWebhookAsync(webhook, webapi_options) {
    let _request = null;
    let _options = null;
    const first = webhook;
    if (typeof first === "object" && first && typeof first.webhook != "undefined") {
      _request = webhook;
      _options = webapi_options;
    } else {
      _request = {
        webhook
      };
      _options = webapi_options;
    }
    return this._testWebhookAsync(_request, _options);
  }
  async _signalEventAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SignalEvent", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async signalEventAsync(eventName, primaryKey, data, webapi_options) {
    let _request = null;
    let _options = null;
    const first = eventName;
    if (typeof first === "object" && first && (typeof first.eventName != "undefined" || typeof first.primaryKey != "undefined" || typeof first.data != "undefined")) {
      _request = eventName;
      _options = primaryKey;
    } else {
      _request = {
        eventName,
        primaryKey,
        data
      };
      _options = webapi_options;
    }
    return this._signalEventAsync(_request, _options);
  }
  async _getLastErrorAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetLastError", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getLastErrorAsync(webhookId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = webhookId;
    if (typeof first === "object" && first && typeof first.webhookId != "undefined") {
      _request = webhookId;
      _options = webapi_options;
    } else {
      _request = {
        webhookId
      };
      _options = webapi_options;
    }
    return this._getLastErrorAsync(_request, _options);
  }
};

// server/node_modules/@superoffice/webapi/dist/esm/SentryAgent.js
var SentryAgent = class extends WebApiBase {
  constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
    const options = WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
    options.basePath = "v1/Agents/Sentry/";
    super(options);
  }
  async _getNewTableRightAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetNewTableRight", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TableRight_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getNewTableRightAsync(tableName, webapi_options) {
    let _request = null;
    let _options = null;
    const first = tableName;
    if (typeof first === "object" && first && typeof first.tableName != "undefined") {
      _request = tableName;
      _options = webapi_options;
    } else {
      _request = {
        tableName
      };
      _options = webapi_options;
    }
    return this._getNewTableRightAsync(_request, _options);
  }
  async _getTableRightByOwnershipAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetTableRightByOwnership", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TableRight_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getTableRightByOwnershipAsync(tableName, contactGroupId, contactAssociateId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = tableName;
    if (typeof first === "object" && first && (typeof first.tableName != "undefined" || typeof first.contactGroupId != "undefined" || typeof first.contactAssociateId != "undefined")) {
      _request = tableName;
      _options = contactGroupId;
    } else {
      _request = {
        tableName,
        contactGroupId,
        contactAssociateId
      };
      _options = webapi_options;
    }
    return this._getTableRightByOwnershipAsync(_request, _options);
  }
  async _getFunctionRightsAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetFunctionRights", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Get a string array of all functions rights for the role of the current associate.
   * @returns String array with the technical names of assigned function rights
   */
  async getFunctionRightsAsync(webapi_options) {
    return this._getFunctionRightsAsync(webapi_options);
  }
  async _hasFunctionRightAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("HasFunctionRight", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async hasFunctionRightAsync(functionRight, webapi_options) {
    let _request = null;
    let _options = null;
    const first = functionRight;
    if (typeof first === "object" && first && typeof first.functionRight != "undefined") {
      _request = functionRight;
      _options = webapi_options;
    } else {
      _request = {
        functionRight
      };
      _options = webapi_options;
    }
    return this._hasFunctionRightAsync(_request, _options);
  }
  async _canCreateAppointmentInAssociateDiariesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CanCreateAppointmentInAssociateDiaries", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async canCreateAppointmentInAssociateDiariesAsync(associateIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = associateIds;
    if (typeof first === "object" && first && typeof first.associateIds != "undefined") {
      _request = associateIds;
      _options = webapi_options;
    } else {
      _request = {
        associateIds
      };
      _options = webapi_options;
    }
    return this._canCreateAppointmentInAssociateDiariesAsync(_request, _options);
  }
  async _canCreateAppointmentInAllDiariesAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CanCreateAppointmentInAllDiaries", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * CanCreateAppointmentInAllDiaries will check if the current associate can create appointments in diaries belonging all other associates. CanCreateAppointmentInAssociateDiaries will only check against associates that are diary owners.
   * @returns Returns true if the current associate can create appointments in the diary of all the other associates, otherwise false.
   */
  async canCreateAppointmentInAllDiariesAsync(webapi_options) {
    return this._canCreateAppointmentInAllDiariesAsync(webapi_options);
  }
  async _getTableRightByContactOwnershipAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetTableRightByContactOwnership", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TableRight_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getTableRightByContactOwnershipAsync(tableName, contactId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = tableName;
    if (typeof first === "object" && first && (typeof first.tableName != "undefined" || typeof first.contactId != "undefined")) {
      _request = tableName;
      _options = contactId;
    } else {
      _request = {
        tableName,
        contactId
      };
      _options = webapi_options;
    }
    return this._getTableRightByContactOwnershipAsync(_request, _options);
  }
};

// server/node_modules/@superoffice/webapi/dist/esm/UserDefinedFieldInfoAgent.js
var UserDefinedFieldInfoAgent = class extends WebApiBase {
  constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
    const options = WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
    options.basePath = "v1/Agents/UserDefinedFieldInfo/";
    super(options);
  }
  /**
   * Set default values into a new UserDefinedFieldInfo.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultUserDefinedFieldInfoAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultUserDefinedFieldInfo", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_UserDefinedFieldInfo_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing UserDefinedFieldInfo or creates a new UserDefinedFieldInfo if the id parameter is empty
   * @param entity - The UserDefinedFieldInfo to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated UserDefinedFieldInfo
   */
  async saveUserDefinedFieldInfoAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveUserDefinedFieldInfo", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_UserDefinedFieldInfo_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Deletes the UserDefinedFieldInfo
   * @param UserDefinedFieldInfoId - The id of the UserDefinedFieldInfo to be deleted.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   */
  async deleteUserDefinedFieldInfoAsync(UserDefinedFieldInfoId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("DeleteUserDefinedFieldInfo?UserDefinedFieldInfoId=" + UserDefinedFieldInfoId, null, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getCustomFieldInfoListAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetCustomFieldInfoList", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_FieldInfoBaseArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getCustomFieldInfoListAsync(tableName, includeStandard, webapi_options) {
    let _request = null;
    let _options = null;
    const first = tableName;
    if (typeof first === "object" && first && (typeof first.tableName != "undefined" || typeof first.includeStandard != "undefined")) {
      _request = tableName;
      _options = includeStandard;
    } else {
      _request = {
        tableName,
        includeStandard
      };
      _options = webapi_options;
    }
    return this._getCustomFieldInfoListAsync(_request, _options);
  }
  async _getCustomFieldInfoAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetCustomFieldInfo", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_FieldInfoBase_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getCustomFieldInfoAsync(tableName, fieldName, webapi_options) {
    let _request = null;
    let _options = null;
    const first = tableName;
    if (typeof first === "object" && first && (typeof first.tableName != "undefined" || typeof first.fieldName != "undefined")) {
      _request = tableName;
      _options = fieldName;
    } else {
      _request = {
        tableName,
        fieldName
      };
      _options = webapi_options;
    }
    return this._getCustomFieldInfoAsync(_request, _options);
  }
  /*
   * Gets a UserDefinedFieldInfo object.
   * @param userDefinedFieldInfoId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single UserDefinedFieldInfo
   */
  async getUserDefinedFieldInfoAsync(userDefinedFieldInfoId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetUserDefinedFieldInfo?userDefinedFieldInfoId=" + userDefinedFieldInfoId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_UserDefinedFieldInfo_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getUserDefinedFieldListAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetUserDefinedFieldList", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_UserDefinedFieldInfoArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getUserDefinedFieldListAsync(ownerType, webapi_options) {
    let _request = null;
    let _options = null;
    const first = ownerType;
    if (typeof first === "object" && first && typeof first.ownerType != "undefined") {
      _request = ownerType;
      _options = webapi_options;
    } else {
      _request = {
        ownerType
      };
      _options = webapi_options;
    }
    return this._getUserDefinedFieldListAsync(_request, _options);
  }
  async _getPublishedUserDefinedFieldListAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPublishedUserDefinedFieldList", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_UserDefinedFieldInfoArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getPublishedUserDefinedFieldListAsync(ownerType, webapi_options) {
    let _request = null;
    let _options = null;
    const first = ownerType;
    if (typeof first === "object" && first && typeof first.ownerType != "undefined") {
      _request = ownerType;
      _options = webapi_options;
    } else {
      _request = {
        ownerType
      };
      _options = webapi_options;
    }
    return this._getPublishedUserDefinedFieldListAsync(_request, _options);
  }
  async _getUserDefinedFieldFromFieldLabelAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetUserDefinedFieldFromFieldLabel", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_UserDefinedFieldInfo_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getUserDefinedFieldFromFieldLabelAsync(fieldLabel, ownerType, webapi_options) {
    let _request = null;
    let _options = null;
    const first = fieldLabel;
    if (typeof first === "object" && first && (typeof first.fieldLabel != "undefined" || typeof first.ownerType != "undefined")) {
      _request = fieldLabel;
      _options = ownerType;
    } else {
      _request = {
        fieldLabel,
        ownerType
      };
      _options = webapi_options;
    }
    return this._getUserDefinedFieldFromFieldLabelAsync(_request, _options);
  }
  async _getPublishedUserDefinedFieldFromFieldLabelAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPublishedUserDefinedFieldFromFieldLabel", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_UserDefinedFieldInfo_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getPublishedUserDefinedFieldFromFieldLabelAsync(fieldLabel, ownerType, webapi_options) {
    let _request = null;
    let _options = null;
    const first = fieldLabel;
    if (typeof first === "object" && first && (typeof first.fieldLabel != "undefined" || typeof first.ownerType != "undefined")) {
      _request = fieldLabel;
      _options = ownerType;
    } else {
      _request = {
        fieldLabel,
        ownerType
      };
      _options = webapi_options;
    }
    return this._getPublishedUserDefinedFieldFromFieldLabelAsync(_request, _options);
  }
  async _getUserDefinedFieldFromProgIdAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetUserDefinedFieldFromProgId", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_UserDefinedFieldInfo_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getUserDefinedFieldFromProgIdAsync(progId, ownerType, webapi_options) {
    let _request = null;
    let _options = null;
    const first = progId;
    if (typeof first === "object" && first && (typeof first.progId != "undefined" || typeof first.ownerType != "undefined")) {
      _request = progId;
      _options = ownerType;
    } else {
      _request = {
        progId,
        ownerType
      };
      _options = webapi_options;
    }
    return this._getUserDefinedFieldFromProgIdAsync(_request, _options);
  }
  async _getPublishedUserDefinedFieldFromProgIdAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPublishedUserDefinedFieldFromProgId", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_UserDefinedFieldInfo_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getPublishedUserDefinedFieldFromProgIdAsync(progId, ownerType, webapi_options) {
    let _request = null;
    let _options = null;
    const first = progId;
    if (typeof first === "object" && first && (typeof first.progId != "undefined" || typeof first.ownerType != "undefined")) {
      _request = progId;
      _options = ownerType;
    } else {
      _request = {
        progId,
        ownerType
      };
      _options = webapi_options;
    }
    return this._getPublishedUserDefinedFieldFromProgIdAsync(_request, _options);
  }
  async _getUserDefinedFieldFromIdsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetUserDefinedFieldFromIds", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_UserDefinedFieldInfoArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getUserDefinedFieldFromIdsAsync(ids, webapi_options) {
    let _request = null;
    let _options = null;
    const first = ids;
    if (typeof first === "object" && first && typeof first.ids != "undefined") {
      _request = ids;
      _options = webapi_options;
    } else {
      _request = {
        ids
      };
      _options = webapi_options;
    }
    return this._getUserDefinedFieldFromIdsAsync(_request, _options);
  }
  async _getUserDefinedFieldFromProgIdsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetUserDefinedFieldFromProgIds", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_UserDefinedFieldInfoArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getUserDefinedFieldFromProgIdsAsync(progIds, ownerType, webapi_options) {
    let _request = null;
    let _options = null;
    const first = progIds;
    if (typeof first === "object" && first && (typeof first.progIds != "undefined" || typeof first.ownerType != "undefined")) {
      _request = progIds;
      _options = ownerType;
    } else {
      _request = {
        progIds,
        ownerType
      };
      _options = webapi_options;
    }
    return this._getUserDefinedFieldFromProgIdsAsync(_request, _options);
  }
  async _createUserDefinedFieldInfoAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateUserDefinedFieldInfo", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_UserDefinedFieldInfo_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createUserDefinedFieldInfoAsync(ownerType, fieldType, webapi_options) {
    let _request = null;
    let _options = null;
    const first = ownerType;
    if (typeof first === "object" && first && (typeof first.ownerType != "undefined" || typeof first.fieldType != "undefined")) {
      _request = ownerType;
      _options = fieldType;
    } else {
      _request = {
        ownerType,
        fieldType
      };
      _options = webapi_options;
    }
    return this._createUserDefinedFieldInfoAsync(_request, _options);
  }
  async _changeFieldTypeAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ChangeFieldType", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_UserDefinedFieldInfo_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async changeFieldTypeAsync(info, fieldType, isIndexed, webapi_options) {
    let _request = null;
    let _options = null;
    const first = info;
    if (typeof first === "object" && first && (typeof first.info != "undefined" || typeof first.fieldType != "undefined" || typeof first.isIndexed != "undefined")) {
      _request = info;
      _options = fieldType;
    } else {
      _request = {
        info,
        fieldType,
        isIndexed
      };
      _options = webapi_options;
    }
    return this._changeFieldTypeAsync(_request, _options);
  }
  async _getUserDefinedPageOneFieldsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetUserDefinedPageOneFields", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_UserDefinedFieldInfoArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getUserDefinedPageOneFieldsAsync(ownerType, userGroupId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = ownerType;
    if (typeof first === "object" && first && (typeof first.ownerType != "undefined" || typeof first.userGroupId != "undefined")) {
      _request = ownerType;
      _options = userGroupId;
    } else {
      _request = {
        ownerType,
        userGroupId
      };
      _options = webapi_options;
    }
    return this._getUserDefinedPageOneFieldsAsync(_request, _options);
  }
  async _getPublishedUserDefinedPageOneFieldsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPublishedUserDefinedPageOneFields", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_UserDefinedFieldInfoArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getPublishedUserDefinedPageOneFieldsAsync(ownerType, userGroupId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = ownerType;
    if (typeof first === "object" && first && (typeof first.ownerType != "undefined" || typeof first.userGroupId != "undefined")) {
      _request = ownerType;
      _options = userGroupId;
    } else {
      _request = {
        ownerType,
        userGroupId
      };
      _options = webapi_options;
    }
    return this._getPublishedUserDefinedPageOneFieldsAsync(_request, _options);
  }
  async _publishAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("Publish", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async publishAsync(ownerType, webapi_options) {
    let _request = null;
    let _options = null;
    const first = ownerType;
    if (typeof first === "object" && first && typeof first.ownerType != "undefined") {
      _request = ownerType;
      _options = webapi_options;
    } else {
      _request = {
        ownerType
      };
      _options = webapi_options;
    }
    return this._publishAsync(_request, _options);
  }
  async _revertAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("Revert", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async revertAsync(ownerType, webapi_options) {
    let _request = null;
    let _options = null;
    const first = ownerType;
    if (typeof first === "object" && first && typeof first.ownerType != "undefined") {
      _request = ownerType;
      _options = webapi_options;
    } else {
      _request = {
        ownerType
      };
      _options = webapi_options;
    }
    return this._revertAsync(_request, _options);
  }
  async _saveUserDefinedFieldInfosAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveUserDefinedFieldInfos", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveUserDefinedFieldInfosAsync(infos, webapi_options) {
    let _request = null;
    let _options = null;
    const first = infos;
    if (typeof first === "object" && first && typeof first.infos != "undefined") {
      _request = infos;
      _options = webapi_options;
    } else {
      _request = {
        infos
      };
      _options = webapi_options;
    }
    return this._saveUserDefinedFieldInfosAsync(_request, _options);
  }
  async _detectUnpublishedChangesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DetectUnpublishedChanges", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async detectUnpublishedChangesAsync(ownerType, webapi_options) {
    let _request = null;
    let _options = null;
    const first = ownerType;
    if (typeof first === "object" && first && typeof first.ownerType != "undefined") {
      _request = ownerType;
      _options = webapi_options;
    } else {
      _request = {
        ownerType
      };
      _options = webapi_options;
    }
    return this._detectUnpublishedChangesAsync(_request, _options);
  }
  async _detectColumnIdChangesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DetectColumnIdChanges", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async detectColumnIdChangesAsync(ownerType, webapi_options) {
    let _request = null;
    let _options = null;
    const first = ownerType;
    if (typeof first === "object" && first && typeof first.ownerType != "undefined") {
      _request = ownerType;
      _options = webapi_options;
    } else {
      _request = {
        ownerType
      };
      _options = webapi_options;
    }
    return this._detectColumnIdChangesAsync(_request, _options);
  }
  async _setUserDefinedPageOneFieldAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetUserDefinedPageOneField", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setUserDefinedPageOneFieldAsync(ownerType, udefFieldId, userGroupId, fieldLineNo, webapi_options) {
    let _request = null;
    let _options = null;
    const first = ownerType;
    if (typeof first === "object" && first && (typeof first.ownerType != "undefined" || typeof first.udefFieldId != "undefined" || typeof first.userGroupId != "undefined" || typeof first.fieldLineNo != "undefined")) {
      _request = ownerType;
      _options = udefFieldId;
    } else {
      _request = {
        ownerType,
        udefFieldId,
        userGroupId,
        fieldLineNo
      };
      _options = webapi_options;
    }
    return this._setUserDefinedPageOneFieldAsync(_request, _options);
  }
  async _isPublishEventActiveAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("IsPublishEventActive", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async isPublishEventActiveAsync(type, webapi_options) {
    let _request = null;
    let _options = null;
    const first = type;
    if (typeof first === "object" && first && typeof first.type != "undefined") {
      _request = type;
      _options = webapi_options;
    } else {
      _request = {
        type
      };
      _options = webapi_options;
    }
    return this._isPublishEventActiveAsync(_request, _options);
  }
  async _isAnyPublishEventActiveAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("IsAnyPublishEventActive", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Check if any publish events are active
   * @returns
   */
  async isAnyPublishEventActiveAsync(webapi_options) {
    return this._isAnyPublishEventActiveAsync(webapi_options);
  }
  async _getChangedPageOneFieldsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetChangedPageOneFields", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getChangedPageOneFieldsAsync(ownerType, userGroupId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = ownerType;
    if (typeof first === "object" && first && (typeof first.ownerType != "undefined" || typeof first.userGroupId != "undefined")) {
      _request = ownerType;
      _options = userGroupId;
    } else {
      _request = {
        ownerType,
        userGroupId
      };
      _options = webapi_options;
    }
    return this._getChangedPageOneFieldsAsync(_request, _options);
  }
  async _setPageOneFieldGroupingAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetPageOneFieldGrouping", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setPageOneFieldGroupingAsync(ownerType, active, webapi_options) {
    let _request = null;
    let _options = null;
    const first = ownerType;
    if (typeof first === "object" && first && (typeof first.ownerType != "undefined" || typeof first.active != "undefined")) {
      _request = ownerType;
      _options = active;
    } else {
      _request = {
        ownerType,
        active
      };
      _options = webapi_options;
    }
    return this._setPageOneFieldGroupingAsync(_request, _options);
  }
  async _setListTableIdAndUDListDefinitionIdFromSelectedListIdAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetListTableIdAndUDListDefinitionIdFromSelectedListId", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_UserDefinedFieldInfo_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setListTableIdAndUDListDefinitionIdFromSelectedListIdAsync(info, selectedListId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = info;
    if (typeof first === "object" && first && (typeof first.info != "undefined" || typeof first.selectedListId != "undefined")) {
      _request = info;
      _options = selectedListId;
    } else {
      _request = {
        info,
        selectedListId
      };
      _options = webapi_options;
    }
    return this._setListTableIdAndUDListDefinitionIdFromSelectedListIdAsync(_request, _options);
  }
  async _figureOutListIdFromListTableIdAndUDListDefinitionIdAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("FigureOutListIdFromListTableIdAndUDListDefinitionId", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async figureOutListIdFromListTableIdAndUDListDefinitionIdAsync(info, webapi_options) {
    let _request = null;
    let _options = null;
    const first = info;
    if (typeof first === "object" && first && typeof first.info != "undefined") {
      _request = info;
      _options = webapi_options;
    } else {
      _request = {
        info
      };
      _options = webapi_options;
    }
    return this._figureOutListIdFromListTableIdAndUDListDefinitionIdAsync(_request, _options);
  }
  async _setRankOnFieldsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetRankOnFields", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setRankOnFieldsAsync(ownerType, rankedFieldsIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = ownerType;
    if (typeof first === "object" && first && (typeof first.ownerType != "undefined" || typeof first.rankedFieldsIds != "undefined")) {
      _request = ownerType;
      _options = rankedFieldsIds;
    } else {
      _request = {
        ownerType,
        rankedFieldsIds
      };
      _options = webapi_options;
    }
    return this._setRankOnFieldsAsync(_request, _options);
  }
  async _setPublishStartSystemEventAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetPublishStartSystemEvent", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setPublishStartSystemEventAsync(ownerType, webapi_options) {
    let _request = null;
    let _options = null;
    const first = ownerType;
    if (typeof first === "object" && first && typeof first.ownerType != "undefined") {
      _request = ownerType;
      _options = webapi_options;
    } else {
      _request = {
        ownerType
      };
      _options = webapi_options;
    }
    return this._setPublishStartSystemEventAsync(_request, _options);
  }
  async _clearCachesAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ClearCaches", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Clear all relevant caches. This is normally done automatically but can be useful in certain circumstances.
   * @returns
   */
  async clearCachesAsync(webapi_options) {
    return this._clearCachesAsync(webapi_options);
  }
};

// server/node_modules/@superoffice/webapi/dist/esm/ReportAgent.js
var ReportAgent = class extends WebApiBase {
  constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
    const options = WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
    options.basePath = "v1/Agents/Report/";
    super(options);
  }
  /**
   * Set default values into a new ReportEntity.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultReportEntityAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultReportEntity", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ReportEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing ReportEntity or creates a new ReportEntity if the id parameter is empty
   * @param entity - The ReportEntity to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated ReportEntity
   */
  async saveReportEntityAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveReportEntity", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ReportEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new ReportLabelLayoutEntity.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultReportLabelLayoutEntityAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultReportLabelLayoutEntity", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ReportLabelLayoutEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing ReportLabelLayoutEntity or creates a new ReportLabelLayoutEntity if the id parameter is empty
   * @param entity - The ReportLabelLayoutEntity to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated ReportLabelLayoutEntity
   */
  async saveReportLabelLayoutEntityAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveReportLabelLayoutEntity", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ReportLabelLayoutEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Deletes the ReportLabelLayoutEntity
   * @param ReportLabelLayoutEntityId - The id of the ReportLabelLayoutEntity to be deleted.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   */
  async deleteReportLabelLayoutEntityAsync(ReportLabelLayoutEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("DeleteReportLabelLayoutEntity?ReportLabelLayoutEntityId=" + ReportLabelLayoutEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets a ReportEntity object.
   * @param reportEntityId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single ReportEntity
   */
  async getReportEntityAsync(reportEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetReportEntity?reportEntityId=" + reportEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ReportEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _createFavoriteAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateFavorite", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ReportEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createFavoriteAsync(sourceId, name, description, webapi_options) {
    let _request = null;
    let _options = null;
    const first = sourceId;
    if (typeof first === "object" && first && (typeof first.sourceId != "undefined" || typeof first.name != "undefined" || typeof first.description != "undefined")) {
      _request = sourceId;
      _options = name;
    } else {
      _request = {
        sourceId,
        name,
        description
      };
      _options = webapi_options;
    }
    return this._createFavoriteAsync(_request, _options);
  }
  async _deleteFavoriteAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeleteFavorite", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async deleteFavoriteAsync(reportEntityId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = reportEntityId;
    if (typeof first === "object" && first && typeof first.reportEntityId != "undefined") {
      _request = reportEntityId;
      _options = webapi_options;
    } else {
      _request = {
        reportEntityId
      };
      _options = webapi_options;
    }
    return this._deleteFavoriteAsync(_request, _options);
  }
  async _updateFavoriteAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("UpdateFavorite", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ReportEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async updateFavoriteAsync(reportEntity, webapi_options) {
    let _request = null;
    let _options = null;
    const first = reportEntity;
    if (typeof first === "object" && first && typeof first.reportEntity != "undefined") {
      _request = reportEntity;
      _options = webapi_options;
    } else {
      _request = {
        reportEntity
      };
      _options = webapi_options;
    }
    return this._updateFavoriteAsync(_request, _options);
  }
  async _generateReportAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GenerateReport", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async generateReportAsync(reportId, labelLayoutId, filename, language, fileType, restrictions, webapi_options) {
    let _request = null;
    let _options = null;
    const first = reportId;
    if (typeof first === "object" && first && (typeof first.reportId != "undefined" || typeof first.labelLayoutId != "undefined" || typeof first.filename != "undefined" || typeof first.language != "undefined" || typeof first.fileType != "undefined" || typeof first.restrictions != "undefined")) {
      _request = reportId;
      _options = labelLayoutId;
    } else {
      _request = {
        reportId,
        labelLayoutId,
        filename,
        language,
        fileType,
        restrictions
      };
      _options = webapi_options;
    }
    return this._generateReportAsync(_request, _options);
  }
  async _importReportAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ImportReport", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async importReportAsync(report, webapi_options) {
    let _request = null;
    let _options = null;
    const first = report;
    if (typeof first === "object" && first && typeof first.report != "undefined") {
      _request = report;
      _options = webapi_options;
    } else {
      _request = {
        report
      };
      _options = webapi_options;
    }
    return this._importReportAsync(_request, _options);
  }
  async _deleteReportAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeleteReport", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async deleteReportAsync(reportId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = reportId;
    if (typeof first === "object" && first && typeof first.reportId != "undefined") {
      _request = reportId;
      _options = webapi_options;
    } else {
      _request = {
        reportId
      };
      _options = webapi_options;
    }
    return this._deleteReportAsync(_request, _options);
  }
  /*
   * Gets a ReportLabelLayoutEntity object.
   * @param reportLabelLayoutEntityId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single ReportLabelLayoutEntity
   */
  async getReportLabelLayoutEntityAsync(reportLabelLayoutEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetReportLabelLayoutEntity?reportLabelLayoutEntityId=" + reportLabelLayoutEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ReportLabelLayoutEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
};

// server/node_modules/@superoffice/webapi/dist/esm/SaintAgent.js
var SaintAgent = class extends WebApiBase {
  constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
    const options = WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
    options.basePath = "v1/Agents/Saint/";
    super(options);
  }
  /**
   * Set default values into a new SaintConfiguration.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultSaintConfigurationAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultSaintConfiguration", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SaintConfiguration_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing SaintConfiguration or creates a new SaintConfiguration if the id parameter is empty
   * @param entity - The SaintConfiguration to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated SaintConfiguration
   */
  async saveSaintConfigurationAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveSaintConfiguration", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SaintConfiguration_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new StatusMonitor.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultStatusMonitorAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultStatusMonitor", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_StatusMonitor_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing StatusMonitor or creates a new StatusMonitor if the id parameter is empty
   * @param entity - The StatusMonitor to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated StatusMonitor
   */
  async saveStatusMonitorAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveStatusMonitor", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_StatusMonitor_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new StatusMonitorPeriods.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultStatusMonitorPeriodsAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultStatusMonitorPeriods", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_StatusMonitorPeriods_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing StatusMonitorPeriods or creates a new StatusMonitorPeriods if the id parameter is empty
   * @param entity - The StatusMonitorPeriods to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated StatusMonitorPeriods
   */
  async saveStatusMonitorPeriodsAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveStatusMonitorPeriods", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_StatusMonitorPeriods_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getSaintConfigurationsAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetSaintConfigurations", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SaintConfigurationArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Returns the StatusMonitorPeriods entity.
   * @returns The SaintConfiguration for all entities
   */
  async getSaintConfigurationsAsync(webapi_options) {
    return this._getSaintConfigurationsAsync(webapi_options);
  }
  async _getStatusMonitorsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetStatusMonitors", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_StatusMonitorArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getStatusMonitorsAsync(id, type, webapi_options) {
    let _request = null;
    let _options = null;
    const first = id;
    if (typeof first === "object" && first && (typeof first.id != "undefined" || typeof first.type != "undefined")) {
      _request = id;
      _options = type;
    } else {
      _request = {
        id,
        type
      };
      _options = webapi_options;
    }
    return this._getStatusMonitorsAsync(_request, _options);
  }
  async _getStatusMonitorAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetStatusMonitor", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_StatusMonitor_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getStatusMonitorAsync(id, webapi_options) {
    let _request = null;
    let _options = null;
    const first = id;
    if (typeof first === "object" && first && typeof first.id != "undefined") {
      _request = id;
      _options = webapi_options;
    } else {
      _request = {
        id
      };
      _options = webapi_options;
    }
    return this._getStatusMonitorAsync(_request, _options);
  }
  async _regenerateStatusMonitorsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("RegenerateStatusMonitors", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_BatchTaskInfo_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async regenerateStatusMonitorsAsync(runAsBatch, webapi_options) {
    let _request = null;
    let _options = null;
    const first = runAsBatch;
    if (typeof first === "object" && first && typeof first.runAsBatch != "undefined") {
      _request = runAsBatch;
      _options = webapi_options;
    } else {
      _request = {
        runAsBatch
      };
      _options = webapi_options;
    }
    return this._regenerateStatusMonitorsAsync(_request, _options);
  }
  async _setRankOnStatusMonitorsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetRankOnStatusMonitors", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setRankOnStatusMonitorsAsync(type, itemsIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = type;
    if (typeof first === "object" && first && (typeof first.type != "undefined" || typeof first.itemsIds != "undefined")) {
      _request = type;
      _options = itemsIds;
    } else {
      _request = {
        type,
        itemsIds
      };
      _options = webapi_options;
    }
    return this._setRankOnStatusMonitorsAsync(_request, _options);
  }
  async _regenerateStatusMonitorAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("RegenerateStatusMonitor", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async regenerateStatusMonitorAsync(statusMonitorId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = statusMonitorId;
    if (typeof first === "object" && first && typeof first.statusMonitorId != "undefined") {
      _request = statusMonitorId;
      _options = webapi_options;
    } else {
      _request = {
        statusMonitorId
      };
      _options = webapi_options;
    }
    return this._regenerateStatusMonitorAsync(_request, _options);
  }
  async _regenerateCountersAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("RegenerateCounters", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_BatchTaskInfo_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async regenerateCountersAsync(runAsBatch, webapi_options) {
    let _request = null;
    let _options = null;
    const first = runAsBatch;
    if (typeof first === "object" && first && typeof first.runAsBatch != "undefined") {
      _request = runAsBatch;
      _options = webapi_options;
    } else {
      _request = {
        runAsBatch
      };
      _options = webapi_options;
    }
    return this._regenerateCountersAsync(_request, _options);
  }
  async _getStatusMonitorPeriodsAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetStatusMonitorPeriods", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_StatusMonitorPeriods_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Returns the StatusMonitorPeriods entity.
   * @returns The StatusMonitorEntity
   */
  async getStatusMonitorPeriodsAsync(webapi_options) {
    return this._getStatusMonitorPeriodsAsync(webapi_options);
  }
};

// server/node_modules/@superoffice/webapi/dist/esm/BatchAgent.js
var BatchAgent = class extends WebApiBase {
  constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
    const options = WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
    options.basePath = "v1/Agents/Batch/";
    super(options);
  }
  async _getBatchTaskInfoAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetBatchTaskInfo", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_BatchTaskInfo_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getBatchTaskInfoAsync(id, webapi_options) {
    let _request = null;
    let _options = null;
    const first = id;
    if (typeof first === "object" && first && typeof first.id != "undefined") {
      _request = id;
      _options = webapi_options;
    } else {
      _request = {
        id
      };
      _options = webapi_options;
    }
    return this._getBatchTaskInfoAsync(_request, _options);
  }
  async _getBatchTaskInfosByAssociatesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetBatchTaskInfosByAssociates", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_BatchTaskInfoArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getBatchTaskInfosByAssociatesAsync(associateIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = associateIds;
    if (typeof first === "object" && first && typeof first.associateIds != "undefined") {
      _request = associateIds;
      _options = webapi_options;
    } else {
      _request = {
        associateIds
      };
      _options = webapi_options;
    }
    return this._getBatchTaskInfosByAssociatesAsync(_request, _options);
  }
  async _startBatchJobAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("StartBatchJob", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async startBatchJobAsync(batchTaskInfo, webapi_options) {
    let _request = null;
    let _options = null;
    const first = batchTaskInfo;
    if (typeof first === "object" && first && typeof first.batchTaskInfo != "undefined") {
      _request = batchTaskInfo;
      _options = webapi_options;
    } else {
      _request = {
        batchTaskInfo
      };
      _options = webapi_options;
    }
    return this._startBatchJobAsync(_request, _options);
  }
  async _stopBatchJobAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("StopBatchJob", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async stopBatchJobAsync(id, webapi_options) {
    let _request = null;
    let _options = null;
    const first = id;
    if (typeof first === "object" && first && typeof first.id != "undefined") {
      _request = id;
      _options = webapi_options;
    } else {
      _request = {
        id
      };
      _options = webapi_options;
    }
    return this._stopBatchJobAsync(_request, _options);
  }
  async _getBatchTaskInfosByStateAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetBatchTaskInfosByState", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_BatchTaskInfoArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getBatchTaskInfosByStateAsync(state, webapi_options) {
    let _request = null;
    let _options = null;
    const first = state;
    if (typeof first === "object" && first && typeof first.state != "undefined") {
      _request = state;
      _options = webapi_options;
    } else {
      _request = {
        state
      };
      _options = webapi_options;
    }
    return this._getBatchTaskInfosByStateAsync(_request, _options);
  }
  async _updateBatchTaskAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("UpdateBatchTask", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_BatchTaskInfo_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async updateBatchTaskAsync(batchTaskInfo, webapi_options) {
    let _request = null;
    let _options = null;
    const first = batchTaskInfo;
    if (typeof first === "object" && first && typeof first.batchTaskInfo != "undefined") {
      _request = batchTaskInfo;
      _options = webapi_options;
    } else {
      _request = {
        batchTaskInfo
      };
      _options = webapi_options;
    }
    return this._updateBatchTaskAsync(_request, _options);
  }
  async _getBatchTaskInfosByNameAndStateAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetBatchTaskInfosByNameAndState", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_BatchTaskInfoArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getBatchTaskInfosByNameAndStateAsync(name, state, webapi_options) {
    let _request = null;
    let _options = null;
    const first = name;
    if (typeof first === "object" && first && (typeof first.name != "undefined" || typeof first.state != "undefined")) {
      _request = name;
      _options = state;
    } else {
      _request = {
        name,
        state
      };
      _options = webapi_options;
    }
    return this._getBatchTaskInfosByNameAndStateAsync(_request, _options);
  }
  async _getBatchTaskInfosByNameAndAssociatesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetBatchTaskInfosByNameAndAssociates", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_BatchTaskInfoArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getBatchTaskInfosByNameAndAssociatesAsync(name, associateIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = name;
    if (typeof first === "object" && first && (typeof first.name != "undefined" || typeof first.associateIds != "undefined")) {
      _request = name;
      _options = associateIds;
    } else {
      _request = {
        name,
        associateIds
      };
      _options = webapi_options;
    }
    return this._getBatchTaskInfosByNameAndAssociatesAsync(_request, _options);
  }
  async _getBatchTaskInfosByAssociatesAndStateAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetBatchTaskInfosByAssociatesAndState", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_BatchTaskInfoArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getBatchTaskInfosByAssociatesAndStateAsync(associateIds, state, webapi_options) {
    let _request = null;
    let _options = null;
    const first = associateIds;
    if (typeof first === "object" && first && (typeof first.associateIds != "undefined" || typeof first.state != "undefined")) {
      _request = associateIds;
      _options = state;
    } else {
      _request = {
        associateIds,
        state
      };
      _options = webapi_options;
    }
    return this._getBatchTaskInfosByAssociatesAndStateAsync(_request, _options);
  }
  async _deleteBatchTasksAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeleteBatchTasks", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async deleteBatchTasksAsync(batchTaskIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = batchTaskIds;
    if (typeof first === "object" && first && typeof first.batchTaskIds != "undefined") {
      _request = batchTaskIds;
      _options = webapi_options;
    } else {
      _request = {
        batchTaskIds
      };
      _options = webapi_options;
    }
    return this._deleteBatchTasksAsync(_request, _options);
  }
  async _deleteBatchTaskAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeleteBatchTask", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async deleteBatchTaskAsync(batchTaskId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = batchTaskId;
    if (typeof first === "object" && first && typeof first.batchTaskId != "undefined") {
      _request = batchTaskId;
      _options = webapi_options;
    } else {
      _request = {
        batchTaskId
      };
      _options = webapi_options;
    }
    return this._deleteBatchTaskAsync(_request, _options);
  }
  async _getAllBatchTaskInfosByNameAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetAllBatchTaskInfosByName", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_BatchTaskInfoArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getAllBatchTaskInfosByNameAsync(taskName, webapi_options) {
    let _request = null;
    let _options = null;
    const first = taskName;
    if (typeof first === "object" && first && typeof first.taskName != "undefined") {
      _request = taskName;
      _options = webapi_options;
    } else {
      _request = {
        taskName
      };
      _options = webapi_options;
    }
    return this._getAllBatchTaskInfosByNameAsync(_request, _options);
  }
  async _getAllBatchTaskInfosByNameAndStateAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetAllBatchTaskInfosByNameAndState", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_BatchTaskInfoArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getAllBatchTaskInfosByNameAndStateAsync(taskName, state, webapi_options) {
    let _request = null;
    let _options = null;
    const first = taskName;
    if (typeof first === "object" && first && (typeof first.taskName != "undefined" || typeof first.state != "undefined")) {
      _request = taskName;
      _options = state;
    } else {
      _request = {
        taskName,
        state
      };
      _options = webapi_options;
    }
    return this._getAllBatchTaskInfosByNameAndStateAsync(_request, _options);
  }
  async _getSystemBatchTaskInfosByNameAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetSystemBatchTaskInfosByName", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_BatchTaskInfoArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getSystemBatchTaskInfosByNameAsync(taskName, webapi_options) {
    let _request = null;
    let _options = null;
    const first = taskName;
    if (typeof first === "object" && first && typeof first.taskName != "undefined") {
      _request = taskName;
      _options = webapi_options;
    } else {
      _request = {
        taskName
      };
      _options = webapi_options;
    }
    return this._getSystemBatchTaskInfosByNameAsync(_request, _options);
  }
  async _getSystemBatchTaskInfosByNameAndStateAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetSystemBatchTaskInfosByNameAndState", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_BatchTaskInfoArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getSystemBatchTaskInfosByNameAndStateAsync(taskName, state, webapi_options) {
    let _request = null;
    let _options = null;
    const first = taskName;
    if (typeof first === "object" && first && (typeof first.taskName != "undefined" || typeof first.state != "undefined")) {
      _request = taskName;
      _options = state;
    } else {
      _request = {
        taskName,
        state
      };
      _options = webapi_options;
    }
    return this._getSystemBatchTaskInfosByNameAndStateAsync(_request, _options);
  }
};

// server/node_modules/@superoffice/webapi/dist/esm/RelationAgent.js
var RelationAgent = class extends WebApiBase {
  constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
    const options = WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
    options.basePath = "v1/Agents/Relation/";
    super(options);
  }
  /**
   * Set default values into a new ContactRelationEntity.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultContactRelationEntityAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultContactRelationEntity", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ContactRelationEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets a ContactRelationEntity object.
   * @param contactRelationEntityId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single ContactRelationEntity
   */
  async getContactRelationEntityAsync(contactRelationEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetContactRelationEntity?contactRelationEntityId=" + contactRelationEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ContactRelationEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _saveContactRelationAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveContactRelation", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ContactRelationEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveContactRelationAsync(contactRelationEntity, webapi_options) {
    let _request = null;
    let _options = null;
    const first = contactRelationEntity;
    if (typeof first === "object" && first && typeof first.contactRelationEntity != "undefined") {
      _request = contactRelationEntity;
      _options = webapi_options;
    } else {
      _request = {
        contactRelationEntity
      };
      _options = webapi_options;
    }
    return this._saveContactRelationAsync(_request, _options);
  }
  async _deleteContactRelationAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeleteContactRelation", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async deleteContactRelationAsync(contactRelationEntityId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = contactRelationEntityId;
    if (typeof first === "object" && first && typeof first.contactRelationEntityId != "undefined") {
      _request = contactRelationEntityId;
      _options = webapi_options;
    } else {
      _request = {
        contactRelationEntityId
      };
      _options = webapi_options;
    }
    return this._deleteContactRelationAsync(_request, _options);
  }
};

// server/node_modules/@superoffice/webapi/dist/esm/ArchiveAgent.js
var ArchiveAgent = class extends WebApiBase {
  constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
    const options = WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
    options.basePath = "v1/Agents/Archive/";
    super(options);
  }
  /**
   * Set default values into a new ArchiveListResult.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultArchiveListResultAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultArchiveListResult", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ArchiveListResult_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getActivityFilterAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetActivityFilter", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ActivityFilter_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Get activity filter for the specified list.
   * @returns The activity filter for the specified list
   */
  async getActivityFilterAsync(webapi_options) {
    return this._getActivityFilterAsync(webapi_options);
  }
  async _setActivityFilterAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetActivityFilter", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setActivityFilterAsync(activityFilter, webapi_options) {
    let _request = null;
    let _options = null;
    const first = activityFilter;
    if (typeof first === "object" && first && typeof first.activityFilter != "undefined") {
      _request = activityFilter;
      _options = webapi_options;
    } else {
      _request = {
        activityFilter
      };
      _options = webapi_options;
    }
    return this._setActivityFilterAsync(_request, _options);
  }
  async _getGroupAssociateIdsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetGroupAssociateIds", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getGroupAssociateIdsAsync(groupIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = groupIds;
    if (typeof first === "object" && first && typeof first.groupIds != "undefined") {
      _request = groupIds;
      _options = webapi_options;
    } else {
      _request = {
        groupIds
      };
      _options = webapi_options;
    }
    return this._getGroupAssociateIdsAsync(_request, _options);
  }
  async _getArchiveConfigurationAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetArchiveConfiguration", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ArchiveConfiguration_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getArchiveConfigurationAsync(guiName, providerName, webapi_options) {
    let _request = null;
    let _options = null;
    const first = guiName;
    if (typeof first === "object" && first && (typeof first.guiName != "undefined" || typeof first.providerName != "undefined")) {
      _request = guiName;
      _options = providerName;
    } else {
      _request = {
        guiName,
        providerName
      };
      _options = webapi_options;
    }
    return this._getArchiveConfigurationAsync(_request, _options);
  }
  async _getArchiveConfigurationWithContextAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetArchiveConfigurationWithContext", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ArchiveConfiguration_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getArchiveConfigurationWithContextAsync(guiName, providerName, context, webapi_options) {
    let _request = null;
    let _options = null;
    const first = guiName;
    if (typeof first === "object" && first && (typeof first.guiName != "undefined" || typeof first.providerName != "undefined" || typeof first.context != "undefined")) {
      _request = guiName;
      _options = providerName;
    } else {
      _request = {
        guiName,
        providerName,
        context
      };
      _options = webapi_options;
    }
    return this._getArchiveConfigurationWithContextAsync(_request, _options);
  }
  async _setColumnWidthsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetColumnWidths", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setColumnWidthsAsync(guiName, columnWidths, webapi_options) {
    let _request = null;
    let _options = null;
    const first = guiName;
    if (typeof first === "object" && first && (typeof first.guiName != "undefined" || typeof first.columnWidths != "undefined")) {
      _request = guiName;
      _options = columnWidths;
    } else {
      _request = {
        guiName,
        columnWidths
      };
      _options = webapi_options;
    }
    return this._setColumnWidthsAsync(_request, _options);
  }
  async _setChosenEntitiesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetChosenEntities", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setChosenEntitiesAsync(guiName, providerName, entities, webapi_options) {
    let _request = null;
    let _options = null;
    const first = guiName;
    if (typeof first === "object" && first && (typeof first.guiName != "undefined" || typeof first.providerName != "undefined" || typeof first.entities != "undefined")) {
      _request = guiName;
      _options = providerName;
    } else {
      _request = {
        guiName,
        providerName,
        entities
      };
      _options = webapi_options;
    }
    return this._setChosenEntitiesAsync(_request, _options);
  }
  async _setChosenColumnsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetChosenColumns", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setChosenColumnsAsync(guiName, providerName, chosenColumns, webapi_options) {
    let _request = null;
    let _options = null;
    const first = guiName;
    if (typeof first === "object" && first && (typeof first.guiName != "undefined" || typeof first.providerName != "undefined" || typeof first.chosenColumns != "undefined")) {
      _request = guiName;
      _options = providerName;
    } else {
      _request = {
        guiName,
        providerName,
        chosenColumns
      };
      _options = webapi_options;
    }
    return this._setChosenColumnsAsync(_request, _options);
  }
  async _getArchiveConfigurationV2Async(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetArchiveConfigurationV2", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ArchiveConfiguration_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getArchiveConfigurationV2Async(guiName, providerName, context, ownerKeys, webapi_options) {
    let _request = null;
    let _options = null;
    const first = guiName;
    if (typeof first === "object" && first && (typeof first.guiName != "undefined" || typeof first.providerName != "undefined" || typeof first.context != "undefined" || typeof first.ownerKeys != "undefined")) {
      _request = guiName;
      _options = providerName;
    } else {
      _request = {
        guiName,
        providerName,
        context,
        ownerKeys
      };
      _options = webapi_options;
    }
    return this._getArchiveConfigurationV2Async(_request, _options);
  }
  async _setColumnWidthsV2Async(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetColumnWidthsV2", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setColumnWidthsV2Async(guiName, providerName, context, ownerKeys, columnWidths, webapi_options) {
    let _request = null;
    let _options = null;
    const first = guiName;
    if (typeof first === "object" && first && (typeof first.guiName != "undefined" || typeof first.providerName != "undefined" || typeof first.context != "undefined" || typeof first.ownerKeys != "undefined" || typeof first.columnWidths != "undefined")) {
      _request = guiName;
      _options = providerName;
    } else {
      _request = {
        guiName,
        providerName,
        context,
        ownerKeys,
        columnWidths
      };
      _options = webapi_options;
    }
    return this._setColumnWidthsV2Async(_request, _options);
  }
  async _setChosenEntitiesV2Async(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetChosenEntitiesV2", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setChosenEntitiesV2Async(guiName, providerName, context, ownerKeys, entities, webapi_options) {
    let _request = null;
    let _options = null;
    const first = guiName;
    if (typeof first === "object" && first && (typeof first.guiName != "undefined" || typeof first.providerName != "undefined" || typeof first.context != "undefined" || typeof first.ownerKeys != "undefined" || typeof first.entities != "undefined")) {
      _request = guiName;
      _options = providerName;
    } else {
      _request = {
        guiName,
        providerName,
        context,
        ownerKeys,
        entities
      };
      _options = webapi_options;
    }
    return this._setChosenEntitiesV2Async(_request, _options);
  }
  async _setChosenColumnsV2Async(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetChosenColumnsV2", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setChosenColumnsV2Async(guiName, providerName, context, ownerKeys, chosenColumns, webapi_options) {
    let _request = null;
    let _options = null;
    const first = guiName;
    if (typeof first === "object" && first && (typeof first.guiName != "undefined" || typeof first.providerName != "undefined" || typeof first.context != "undefined" || typeof first.ownerKeys != "undefined" || typeof first.chosenColumns != "undefined")) {
      _request = guiName;
      _options = providerName;
    } else {
      _request = {
        guiName,
        providerName,
        context,
        ownerKeys,
        chosenColumns
      };
      _options = webapi_options;
    }
    return this._setChosenColumnsV2Async(_request, _options);
  }
  async _getArchiveListByColumnsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetArchiveListByColumns", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ArchiveListItemArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getArchiveListByColumnsAsync(providerName, columns, sortOrder, restriction, entities, page, pageSize, webapi_options) {
    let _request = null;
    let _options = null;
    const first = providerName;
    if (typeof first === "object" && first && (typeof first.providerName != "undefined" || typeof first.columns != "undefined" || typeof first.sortOrder != "undefined" || typeof first.restriction != "undefined" || typeof first.entities != "undefined" || typeof first.page != "undefined" || typeof first.pageSize != "undefined")) {
      _request = providerName;
      _options = columns;
    } else {
      _request = {
        providerName,
        columns,
        sortOrder,
        restriction,
        entities,
        page,
        pageSize
      };
      _options = webapi_options;
    }
    return this._getArchiveListByColumnsAsync(_request, _options);
  }
  async _getArchiveListByColumnsWithContextAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetArchiveListByColumnsWithContext", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ArchiveListItemArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getArchiveListByColumnsWithContextAsync(providerName, columns, sortOrder, restriction, entities, page, pageSize, context, webapi_options) {
    let _request = null;
    let _options = null;
    const first = providerName;
    if (typeof first === "object" && first && (typeof first.providerName != "undefined" || typeof first.columns != "undefined" || typeof first.sortOrder != "undefined" || typeof first.restriction != "undefined" || typeof first.entities != "undefined" || typeof first.page != "undefined" || typeof first.pageSize != "undefined" || typeof first.context != "undefined")) {
      _request = providerName;
      _options = columns;
    } else {
      _request = {
        providerName,
        columns,
        sortOrder,
        restriction,
        entities,
        page,
        pageSize,
        context
      };
      _options = webapi_options;
    }
    return this._getArchiveListByColumnsWithContextAsync(_request, _options);
  }
  async _getArchiveListAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetArchiveList", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ArchiveListItemArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getArchiveListAsync(guiName, providerName, sortOrder, restriction, entities, page, pageSize, webapi_options) {
    let _request = null;
    let _options = null;
    const first = guiName;
    if (typeof first === "object" && first && (typeof first.guiName != "undefined" || typeof first.providerName != "undefined" || typeof first.sortOrder != "undefined" || typeof first.restriction != "undefined" || typeof first.entities != "undefined" || typeof first.page != "undefined" || typeof first.pageSize != "undefined")) {
      _request = guiName;
      _options = providerName;
    } else {
      _request = {
        guiName,
        providerName,
        sortOrder,
        restriction,
        entities,
        page,
        pageSize
      };
      _options = webapi_options;
    }
    return this._getArchiveListAsync(_request, _options);
  }
  async _getArchiveListWithContextAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetArchiveListWithContext", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ArchiveListItemArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getArchiveListWithContextAsync(guiName, providerName, sortOrder, restriction, entities, page, pageSize, context, webapi_options) {
    let _request = null;
    let _options = null;
    const first = guiName;
    if (typeof first === "object" && first && (typeof first.guiName != "undefined" || typeof first.providerName != "undefined" || typeof first.sortOrder != "undefined" || typeof first.restriction != "undefined" || typeof first.entities != "undefined" || typeof first.page != "undefined" || typeof first.pageSize != "undefined" || typeof first.context != "undefined")) {
      _request = guiName;
      _options = providerName;
    } else {
      _request = {
        guiName,
        providerName,
        sortOrder,
        restriction,
        entities,
        page,
        pageSize,
        context
      };
      _options = webapi_options;
    }
    return this._getArchiveListWithContextAsync(_request, _options);
  }
  async _getArchiveListByColumnsWithHeaderAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetArchiveListByColumnsWithHeader", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ArchiveListResult_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getArchiveListByColumnsWithHeaderAsync(providerName, columns, sortOrder, restriction, entities, page, pageSize, options, webapi_options) {
    let _request = null;
    let _options = null;
    const first = providerName;
    if (typeof first === "object" && first && (typeof first.providerName != "undefined" || typeof first.columns != "undefined" || typeof first.sortOrder != "undefined" || typeof first.restriction != "undefined" || typeof first.entities != "undefined" || typeof first.page != "undefined" || typeof first.pageSize != "undefined" || typeof first.options != "undefined")) {
      _request = providerName;
      _options = columns;
    } else {
      _request = {
        providerName,
        columns,
        sortOrder,
        restriction,
        entities,
        page,
        pageSize,
        options
      };
      _options = webapi_options;
    }
    return this._getArchiveListByColumnsWithHeaderAsync(_request, _options);
  }
  async _getProviderNamesAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetProviderNames", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Return list of all archive provider names
   * @returns Array of all archive provider names.
   */
  async getProviderNamesAsync(webapi_options) {
    return this._getProviderNamesAsync(webapi_options);
  }
  async _getArchiveListByColumnsWithHeaderWithContextAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetArchiveListByColumnsWithHeaderWithContext", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ArchiveListResult_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getArchiveListByColumnsWithHeaderWithContextAsync(providerName, columns, sortOrder, restriction, entities, page, pageSize, options, context, webapi_options) {
    let _request = null;
    let _options = null;
    const first = providerName;
    if (typeof first === "object" && first && (typeof first.providerName != "undefined" || typeof first.columns != "undefined" || typeof first.sortOrder != "undefined" || typeof first.restriction != "undefined" || typeof first.entities != "undefined" || typeof first.page != "undefined" || typeof first.pageSize != "undefined" || typeof first.options != "undefined" || typeof first.context != "undefined")) {
      _request = providerName;
      _options = columns;
    } else {
      _request = {
        providerName,
        columns,
        sortOrder,
        restriction,
        entities,
        page,
        pageSize,
        options,
        context
      };
      _options = webapi_options;
    }
    return this._getArchiveListByColumnsWithHeaderWithContextAsync(_request, _options);
  }
  async _getAvailableColumnsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetAvailableColumns", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ArchiveColumnInfoArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getAvailableColumnsAsync(providerName, context, webapi_options) {
    let _request = null;
    let _options = null;
    const first = providerName;
    if (typeof first === "object" && first && (typeof first.providerName != "undefined" || typeof first.context != "undefined")) {
      _request = providerName;
      _options = context;
    } else {
      _request = {
        providerName,
        context
      };
      _options = webapi_options;
    }
    return this._getAvailableColumnsAsync(_request, _options);
  }
  async _getAvailableEntitiesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetAvailableEntities", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_MDOListItemArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getAvailableEntitiesAsync(providerName, context, webapi_options) {
    let _request = null;
    let _options = null;
    const first = providerName;
    if (typeof first === "object" && first && (typeof first.providerName != "undefined" || typeof first.context != "undefined")) {
      _request = providerName;
      _options = context;
    } else {
      _request = {
        providerName,
        context
      };
      _options = webapi_options;
    }
    return this._getAvailableEntitiesAsync(_request, _options);
  }
  async _getArchiveListByColumns2Async(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetArchiveListByColumns2", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ArchiveListItemArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getArchiveListByColumns2Async(providerName, columns, sortOrder, restrictions, entities, page, pageSize, webapi_options) {
    let _request = null;
    let _options = null;
    const first = providerName;
    if (typeof first === "object" && first && (typeof first.providerName != "undefined" || typeof first.columns != "undefined" || typeof first.sortOrder != "undefined" || typeof first.restrictions != "undefined" || typeof first.entities != "undefined" || typeof first.page != "undefined" || typeof first.pageSize != "undefined")) {
      _request = providerName;
      _options = columns;
    } else {
      _request = {
        providerName,
        columns,
        sortOrder,
        restrictions,
        entities,
        page,
        pageSize
      };
      _options = webapi_options;
    }
    return this._getArchiveListByColumns2Async(_request, _options);
  }
  async _getArchiveListByColumnsWithContext2Async(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetArchiveListByColumnsWithContext2", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ArchiveListItemArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getArchiveListByColumnsWithContext2Async(providerName, columns, sortOrder, restriction, entities, page, pageSize, context, webapi_options) {
    let _request = null;
    let _options = null;
    const first = providerName;
    if (typeof first === "object" && first && (typeof first.providerName != "undefined" || typeof first.columns != "undefined" || typeof first.sortOrder != "undefined" || typeof first.restriction != "undefined" || typeof first.entities != "undefined" || typeof first.page != "undefined" || typeof first.pageSize != "undefined" || typeof first.context != "undefined")) {
      _request = providerName;
      _options = columns;
    } else {
      _request = {
        providerName,
        columns,
        sortOrder,
        restriction,
        entities,
        page,
        pageSize,
        context
      };
      _options = webapi_options;
    }
    return this._getArchiveListByColumnsWithContext2Async(_request, _options);
  }
  async _getArchiveList2Async(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetArchiveList2", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ArchiveListItemArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getArchiveList2Async(guiName, providerName, sortOrder, restriction, entities, page, pageSize, webapi_options) {
    let _request = null;
    let _options = null;
    const first = guiName;
    if (typeof first === "object" && first && (typeof first.guiName != "undefined" || typeof first.providerName != "undefined" || typeof first.sortOrder != "undefined" || typeof first.restriction != "undefined" || typeof first.entities != "undefined" || typeof first.page != "undefined" || typeof first.pageSize != "undefined")) {
      _request = guiName;
      _options = providerName;
    } else {
      _request = {
        guiName,
        providerName,
        sortOrder,
        restriction,
        entities,
        page,
        pageSize
      };
      _options = webapi_options;
    }
    return this._getArchiveList2Async(_request, _options);
  }
  async _getArchiveListWithContext2Async(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetArchiveListWithContext2", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ArchiveListItemArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getArchiveListWithContext2Async(guiName, providerName, sortOrder, restriction, entities, page, pageSize, context, webapi_options) {
    let _request = null;
    let _options = null;
    const first = guiName;
    if (typeof first === "object" && first && (typeof first.guiName != "undefined" || typeof first.providerName != "undefined" || typeof first.sortOrder != "undefined" || typeof first.restriction != "undefined" || typeof first.entities != "undefined" || typeof first.page != "undefined" || typeof first.pageSize != "undefined" || typeof first.context != "undefined")) {
      _request = guiName;
      _options = providerName;
    } else {
      _request = {
        guiName,
        providerName,
        sortOrder,
        restriction,
        entities,
        page,
        pageSize,
        context
      };
      _options = webapi_options;
    }
    return this._getArchiveListWithContext2Async(_request, _options);
  }
  async _getArchiveListByColumnsWithHeader2Async(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetArchiveListByColumnsWithHeader2", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ArchiveListResult_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getArchiveListByColumnsWithHeader2Async(providerName, columns, sortOrder, restriction, entities, page, pageSize, options, webapi_options) {
    let _request = null;
    let _options = null;
    const first = providerName;
    if (typeof first === "object" && first && (typeof first.providerName != "undefined" || typeof first.columns != "undefined" || typeof first.sortOrder != "undefined" || typeof first.restriction != "undefined" || typeof first.entities != "undefined" || typeof first.page != "undefined" || typeof first.pageSize != "undefined" || typeof first.options != "undefined")) {
      _request = providerName;
      _options = columns;
    } else {
      _request = {
        providerName,
        columns,
        sortOrder,
        restriction,
        entities,
        page,
        pageSize,
        options
      };
      _options = webapi_options;
    }
    return this._getArchiveListByColumnsWithHeader2Async(_request, _options);
  }
  async _getArchiveListByColumnsWithHeaderWithContext2Async(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetArchiveListByColumnsWithHeaderWithContext2", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ArchiveListResult_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getArchiveListByColumnsWithHeaderWithContext2Async(providerName, columns, sortOrder, restriction, entities, page, pageSize, options, context, webapi_options) {
    let _request = null;
    let _options = null;
    const first = providerName;
    if (typeof first === "object" && first && (typeof first.providerName != "undefined" || typeof first.columns != "undefined" || typeof first.sortOrder != "undefined" || typeof first.restriction != "undefined" || typeof first.entities != "undefined" || typeof first.page != "undefined" || typeof first.pageSize != "undefined" || typeof first.options != "undefined" || typeof first.context != "undefined")) {
      _request = providerName;
      _options = columns;
    } else {
      _request = {
        providerName,
        columns,
        sortOrder,
        restriction,
        entities,
        page,
        pageSize,
        options,
        context
      };
      _options = webapi_options;
    }
    return this._getArchiveListByColumnsWithHeaderWithContext2Async(_request, _options);
  }
  async _exportArchiveAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ExportArchive", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ExportArchiveResult_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async exportArchiveAsync(providerName, context, desiredEntities, columns, sortOrder, restrictions, exportType, selectedRowIds, estimatedRowCount, webapi_options) {
    let _request = null;
    let _options = null;
    const first = providerName;
    if (typeof first === "object" && first && (typeof first.providerName != "undefined" || typeof first.context != "undefined" || typeof first.desiredEntities != "undefined" || typeof first.columns != "undefined" || typeof first.sortOrder != "undefined" || typeof first.restrictions != "undefined" || typeof first.exportType != "undefined" || typeof first.selectedRowIds != "undefined" || typeof first.estimatedRowCount != "undefined")) {
      _request = providerName;
      _options = context;
    } else {
      _request = {
        providerName,
        context,
        desiredEntities,
        columns,
        sortOrder,
        restrictions,
        exportType,
        selectedRowIds,
        estimatedRowCount
      };
      _options = webapi_options;
    }
    return this._exportArchiveAsync(_request, _options);
  }
  async _getRelatedDataAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetRelatedData", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_RelatedDataArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getRelatedDataAsync(table, recordId, fields, webapi_options) {
    let _request = null;
    let _options = null;
    const first = table;
    if (typeof first === "object" && first && (typeof first.table != "undefined" || typeof first.recordId != "undefined" || typeof first.fields != "undefined")) {
      _request = table;
      _options = recordId;
    } else {
      _request = {
        table,
        recordId,
        fields
      };
      _options = webapi_options;
    }
    return this._getRelatedDataAsync(_request, _options);
  }
  async _getRelatedData2Async(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetRelatedData2", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_RelatedDataArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getRelatedData2Async(table, recordId, fields, webapi_options) {
    let _request = null;
    let _options = null;
    const first = table;
    if (typeof first === "object" && first && (typeof first.table != "undefined" || typeof first.recordId != "undefined" || typeof first.fields != "undefined")) {
      _request = table;
      _options = recordId;
    } else {
      _request = {
        table,
        recordId,
        fields
      };
      _options = webapi_options;
    }
    return this._getRelatedData2Async(_request, _options);
  }
};

// server/node_modules/@superoffice/webapi/dist/esm/AudienceAgent.js
var AudienceAgent = class extends WebApiBase {
  constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
    const options = WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
    options.basePath = "v1/Agents/Audience/";
    super(options);
  }
  /**
   * Set default values into a new AudienceLayoutEntity.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultAudienceLayoutEntityAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultAudienceLayoutEntity", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AudienceLayoutEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing AudienceLayoutEntity or creates a new AudienceLayoutEntity if the id parameter is empty
   * @param entity - The AudienceLayoutEntity to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated AudienceLayoutEntity
   */
  async saveAudienceLayoutEntityAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveAudienceLayoutEntity", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AudienceLayoutEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Deletes the AudienceLayoutEntity
   * @param AudienceLayoutEntityId - The id of the AudienceLayoutEntity to be deleted.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   */
  async deleteAudienceLayoutEntityAsync(AudienceLayoutEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("DeleteAudienceLayoutEntity?AudienceLayoutEntityId=" + AudienceLayoutEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _saveConfigParameterAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveConfigParameter", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AudienceConfigParameter_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveConfigParameterAsync(layoutName, configParameter, webapi_options) {
    let _request = null;
    let _options = null;
    const first = layoutName;
    if (typeof first === "object" && first && (typeof first.layoutName != "undefined" || typeof first.configParameter != "undefined")) {
      _request = layoutName;
      _options = configParameter;
    } else {
      _request = {
        layoutName,
        configParameter
      };
      _options = webapi_options;
    }
    return this._saveConfigParameterAsync(_request, _options);
  }
  async _getConfigParameterValueAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetConfigParameterValue", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getConfigParameterValueAsync(layoutName, parameterName, webapi_options) {
    let _request = null;
    let _options = null;
    const first = layoutName;
    if (typeof first === "object" && first && (typeof first.layoutName != "undefined" || typeof first.parameterName != "undefined")) {
      _request = layoutName;
      _options = parameterName;
    } else {
      _request = {
        layoutName,
        parameterName
      };
      _options = webapi_options;
    }
    return this._getConfigParameterValueAsync(_request, _options);
  }
  async _getConfigParameterAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetConfigParameter", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AudienceConfigParameter_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getConfigParameterAsync(layoutName, parameterName, webapi_options) {
    let _request = null;
    let _options = null;
    const first = layoutName;
    if (typeof first === "object" && first && (typeof first.layoutName != "undefined" || typeof first.parameterName != "undefined")) {
      _request = layoutName;
      _options = parameterName;
    } else {
      _request = {
        layoutName,
        parameterName
      };
      _options = webapi_options;
    }
    return this._getConfigParameterAsync(_request, _options);
  }
  async _deleteConfigParameterAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeleteConfigParameter", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async deleteConfigParameterAsync(layoutName, parameterName, webapi_options) {
    let _request = null;
    let _options = null;
    const first = layoutName;
    if (typeof first === "object" && first && (typeof first.layoutName != "undefined" || typeof first.parameterName != "undefined")) {
      _request = layoutName;
      _options = parameterName;
    } else {
      _request = {
        layoutName,
        parameterName
      };
      _options = webapi_options;
    }
    return this._deleteConfigParameterAsync(_request, _options);
  }
  async _getMyConfigParameterAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetMyConfigParameter", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AudienceConfigParameter_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getMyConfigParameterAsync(parameterName, webapi_options) {
    let _request = null;
    let _options = null;
    const first = parameterName;
    if (typeof first === "object" && first && typeof first.parameterName != "undefined") {
      _request = parameterName;
      _options = webapi_options;
    } else {
      _request = {
        parameterName
      };
      _options = webapi_options;
    }
    return this._getMyConfigParameterAsync(_request, _options);
  }
  async _getMyConfigParameterValueAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetMyConfigParameterValue", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getMyConfigParameterValueAsync(parameterName, webapi_options) {
    let _request = null;
    let _options = null;
    const first = parameterName;
    if (typeof first === "object" && first && typeof first.parameterName != "undefined") {
      _request = parameterName;
      _options = webapi_options;
    } else {
      _request = {
        parameterName
      };
      _options = webapi_options;
    }
    return this._getMyConfigParameterValueAsync(_request, _options);
  }
  async _getConfigParameterValueOnPersonAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetConfigParameterValueOnPerson", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getConfigParameterValueOnPersonAsync(parameterName, personId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = parameterName;
    if (typeof first === "object" && first && (typeof first.parameterName != "undefined" || typeof first.personId != "undefined")) {
      _request = parameterName;
      _options = personId;
    } else {
      _request = {
        parameterName,
        personId
      };
      _options = webapi_options;
    }
    return this._getConfigParameterValueOnPersonAsync(_request, _options);
  }
  async _getConfigParameterOnPersonAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetConfigParameterOnPerson", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AudienceConfigParameter_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getConfigParameterOnPersonAsync(parameterName, personId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = parameterName;
    if (typeof first === "object" && first && (typeof first.parameterName != "undefined" || typeof first.personId != "undefined")) {
      _request = parameterName;
      _options = personId;
    } else {
      _request = {
        parameterName,
        personId
      };
      _options = webapi_options;
    }
    return this._getConfigParameterOnPersonAsync(_request, _options);
  }
  async _getConfigParametersByLayoutNameAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetConfigParametersByLayoutName", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AudienceConfigParameterArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getConfigParametersByLayoutNameAsync(layoutName, webapi_options) {
    let _request = null;
    let _options = null;
    const first = layoutName;
    if (typeof first === "object" && first && typeof first.layoutName != "undefined") {
      _request = layoutName;
      _options = webapi_options;
    } else {
      _request = {
        layoutName
      };
      _options = webapi_options;
    }
    return this._getConfigParametersByLayoutNameAsync(_request, _options);
  }
  async _getMyConfigParametersAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetMyConfigParameters", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AudienceConfigParameterArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Gets the Audience configuration parameters belonging to the currently logged on user.
   * @returns Array of Audience configuration parameters.
   */
  async getMyConfigParametersAsync(webapi_options) {
    return this._getMyConfigParametersAsync(webapi_options);
  }
  async _getConfigParametersOnPersonAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetConfigParametersOnPerson", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AudienceConfigParameterArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getConfigParametersOnPersonAsync(personId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = personId;
    if (typeof first === "object" && first && typeof first.personId != "undefined") {
      _request = personId;
      _options = webapi_options;
    } else {
      _request = {
        personId
      };
      _options = webapi_options;
    }
    return this._getConfigParametersOnPersonAsync(_request, _options);
  }
  /*
   * Gets a AudienceLayoutEntity object.
   * @param audienceLayoutEntityId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single AudienceLayoutEntity
   */
  async getAudienceLayoutEntityAsync(audienceLayoutEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetAudienceLayoutEntity?audienceLayoutEntityId=" + audienceLayoutEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AudienceLayoutEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getAudienceLayoutByNameAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetAudienceLayoutByName", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AudienceLayoutEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getAudienceLayoutByNameAsync(layoutName, webapi_options) {
    let _request = null;
    let _options = null;
    const first = layoutName;
    if (typeof first === "object" && first && typeof first.layoutName != "undefined") {
      _request = layoutName;
      _options = webapi_options;
    } else {
      _request = {
        layoutName
      };
      _options = webapi_options;
    }
    return this._getAudienceLayoutByNameAsync(_request, _options);
  }
  async _getMyAudienceLayoutAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetMyAudienceLayout", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AudienceLayoutEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Gets the Audience layout belonging to the currently logged on user.
   * @returns Audience layout entity
   */
  async getMyAudienceLayoutAsync(webapi_options) {
    return this._getMyAudienceLayoutAsync(webapi_options);
  }
  async _getAudienceLayoutOnPersonAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetAudienceLayoutOnPerson", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AudienceLayoutEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getAudienceLayoutOnPersonAsync(personId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = personId;
    if (typeof first === "object" && first && typeof first.personId != "undefined") {
      _request = personId;
      _options = webapi_options;
    } else {
      _request = {
        personId
      };
      _options = webapi_options;
    }
    return this._getAudienceLayoutOnPersonAsync(_request, _options);
  }
  async _getDefaultProjectImageAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        if (!options || options.returnBlobAs == ReturnBlobType.AsArrayBuffer) {
          config.responseType = "arraybuffer";
          config.headers = config.headers || {};
          config.headers["Accept"] = "application/octet-stream";
        }
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetDefaultProjectImage", request, config);
        WebApiBase.SetCompleted(options);
        let res = null;
        if (options && options.returnBlobAs != ReturnBlobType.AsArrayBuffer) {
          res = response.data;
          if (options.returnBlobAs == ReturnBlobType.AsString) {
            res = FromBase64ToString(res);
          }
        } else {
          res = response.data;
        }
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getDefaultProjectImageAsync(layoutName, webapi_options) {
    let _request = null;
    let _options = null;
    const first = layoutName;
    if (typeof first === "object" && first && typeof first.layoutName != "undefined") {
      _request = layoutName;
      _options = webapi_options;
    } else {
      _request = {
        layoutName
      };
      _options = webapi_options;
    }
    return this._getDefaultProjectImageAsync(_request, _options);
  }
  async _setDefaultProjectImageAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetDefaultProjectImage", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setDefaultProjectImageAsync(layoutName, image, webapi_options) {
    let _request = null;
    let _options = null;
    const first = layoutName;
    if (typeof first === "object" && first && (typeof first.layoutName != "undefined" || typeof first.image != "undefined")) {
      _request = layoutName;
      _options = image;
    } else {
      _request = {
        layoutName,
        image
      };
      _options = webapi_options;
    }
    _request.image = ToBase64(_request.image);
    return this._setDefaultProjectImageAsync(_request, _options);
  }
  async _setDefaultPersonImageAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetDefaultPersonImage", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setDefaultPersonImageAsync(layoutName, image, webapi_options) {
    let _request = null;
    let _options = null;
    const first = layoutName;
    if (typeof first === "object" && first && (typeof first.layoutName != "undefined" || typeof first.image != "undefined")) {
      _request = layoutName;
      _options = image;
    } else {
      _request = {
        layoutName,
        image
      };
      _options = webapi_options;
    }
    _request.image = ToBase64(_request.image);
    return this._setDefaultPersonImageAsync(_request, _options);
  }
  async _getDefaultPersonImageAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        if (!options || options.returnBlobAs == ReturnBlobType.AsArrayBuffer) {
          config.responseType = "arraybuffer";
          config.headers = config.headers || {};
          config.headers["Accept"] = "application/octet-stream";
        }
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetDefaultPersonImage", request, config);
        WebApiBase.SetCompleted(options);
        let res = null;
        if (options && options.returnBlobAs != ReturnBlobType.AsArrayBuffer) {
          res = response.data;
          if (options.returnBlobAs == ReturnBlobType.AsString) {
            res = FromBase64ToString(res);
          }
        } else {
          res = response.data;
        }
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getDefaultPersonImageAsync(layoutName, webapi_options) {
    let _request = null;
    let _options = null;
    const first = layoutName;
    if (typeof first === "object" && first && typeof first.layoutName != "undefined") {
      _request = layoutName;
      _options = webapi_options;
    } else {
      _request = {
        layoutName
      };
      _options = webapi_options;
    }
    return this._getDefaultPersonImageAsync(_request, _options);
  }
  async _setDefaultCountryFlagAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetDefaultCountryFlag", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setDefaultCountryFlagAsync(layoutName, image, webapi_options) {
    let _request = null;
    let _options = null;
    const first = layoutName;
    if (typeof first === "object" && first && (typeof first.layoutName != "undefined" || typeof first.image != "undefined")) {
      _request = layoutName;
      _options = image;
    } else {
      _request = {
        layoutName,
        image
      };
      _options = webapi_options;
    }
    _request.image = ToBase64(_request.image);
    return this._setDefaultCountryFlagAsync(_request, _options);
  }
  async _getDefaultCountryFlagAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        if (!options || options.returnBlobAs == ReturnBlobType.AsArrayBuffer) {
          config.responseType = "arraybuffer";
          config.headers = config.headers || {};
          config.headers["Accept"] = "application/octet-stream";
        }
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetDefaultCountryFlag", request, config);
        WebApiBase.SetCompleted(options);
        let res = null;
        if (options && options.returnBlobAs != ReturnBlobType.AsArrayBuffer) {
          res = response.data;
          if (options.returnBlobAs == ReturnBlobType.AsString) {
            res = FromBase64ToString(res);
          }
        } else {
          res = response.data;
        }
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getDefaultCountryFlagAsync(layoutName, webapi_options) {
    let _request = null;
    let _options = null;
    const first = layoutName;
    if (typeof first === "object" && first && typeof first.layoutName != "undefined") {
      _request = layoutName;
      _options = webapi_options;
    } else {
      _request = {
        layoutName
      };
      _options = webapi_options;
    }
    return this._getDefaultCountryFlagAsync(_request, _options);
  }
  async _getLogoImageAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        if (!options || options.returnBlobAs == ReturnBlobType.AsArrayBuffer) {
          config.responseType = "arraybuffer";
          config.headers = config.headers || {};
          config.headers["Accept"] = "application/octet-stream";
        }
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetLogoImage", request, config);
        WebApiBase.SetCompleted(options);
        let res = null;
        if (options && options.returnBlobAs != ReturnBlobType.AsArrayBuffer) {
          res = response.data;
          if (options.returnBlobAs == ReturnBlobType.AsString) {
            res = FromBase64ToString(res);
          }
        } else {
          res = response.data;
        }
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getLogoImageAsync(layoutName, webapi_options) {
    let _request = null;
    let _options = null;
    const first = layoutName;
    if (typeof first === "object" && first && typeof first.layoutName != "undefined") {
      _request = layoutName;
      _options = webapi_options;
    } else {
      _request = {
        layoutName
      };
      _options = webapi_options;
    }
    return this._getLogoImageAsync(_request, _options);
  }
  async _setLogoImageAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetLogoImage", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setLogoImageAsync(layoutName, image, webapi_options) {
    let _request = null;
    let _options = null;
    const first = layoutName;
    if (typeof first === "object" && first && (typeof first.layoutName != "undefined" || typeof first.image != "undefined")) {
      _request = layoutName;
      _options = image;
    } else {
      _request = {
        layoutName,
        image
      };
      _options = webapi_options;
    }
    _request.image = ToBase64(_request.image);
    return this._setLogoImageAsync(_request, _options);
  }
};

// server/node_modules/@superoffice/webapi/dist/esm/PreferenceAgent.js
var PreferenceAgent = class extends WebApiBase {
  constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
    const options = WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
    options.basePath = "v1/Agents/Preference/";
    super(options);
  }
  /**
   * Set default values into a new Preference.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultPreferenceAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultPreference", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Preference_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new PreferenceDescription.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultPreferenceDescriptionAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultPreferenceDescription", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PreferenceDescription_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing PreferenceDescription or creates a new PreferenceDescription if the id parameter is empty
   * @param entity - The PreferenceDescription to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated PreferenceDescription
   */
  async savePreferenceDescriptionAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SavePreferenceDescription", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PreferenceDescription_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Deletes the PreferenceDescription
   * @param PreferenceDescriptionId - The id of the PreferenceDescription to be deleted.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   */
  async deletePreferenceDescriptionAsync(PreferenceDescriptionId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("DeletePreferenceDescription?PreferenceDescriptionId=" + PreferenceDescriptionId, null, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new PreferenceDescriptionLine.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultPreferenceDescriptionLineAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultPreferenceDescriptionLine", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PreferenceDescriptionLine_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing PreferenceDescriptionLine or creates a new PreferenceDescriptionLine if the id parameter is empty
   * @param entity - The PreferenceDescriptionLine to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated PreferenceDescriptionLine
   */
  async savePreferenceDescriptionLineAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SavePreferenceDescriptionLine", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PreferenceDescriptionLine_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Deletes the PreferenceDescriptionLine
   * @param PreferenceDescriptionLineId - The id of the PreferenceDescriptionLine to be deleted.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   */
  async deletePreferenceDescriptionLineAsync(PreferenceDescriptionLineId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("DeletePreferenceDescriptionLine?PreferenceDescriptionLineId=" + PreferenceDescriptionLineId, null, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _savePreferenceAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SavePreference", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async savePreferenceAsync(preference, webapi_options) {
    let _request = null;
    let _options = null;
    const first = preference;
    if (typeof first === "object" && first && typeof first.preference != "undefined") {
      _request = preference;
      _options = webapi_options;
    } else {
      _request = {
        preference
      };
      _options = webapi_options;
    }
    return this._savePreferenceAsync(_request, _options);
  }
  async _saveTabOrderAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveTabOrder", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveTabOrderAsync(tabOrder, webapi_options) {
    let _request = null;
    let _options = null;
    const first = tabOrder;
    if (typeof first === "object" && first && typeof first.tabOrder != "undefined") {
      _request = tabOrder;
      _options = webapi_options;
    } else {
      _request = {
        tabOrder
      };
      _options = webapi_options;
    }
    return this._saveTabOrderAsync(_request, _options);
  }
  async _getTabOrderAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetTabOrder", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TabOrder_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getTabOrderAsync(tabName, webapi_options) {
    let _request = null;
    let _options = null;
    const first = tabName;
    if (typeof first === "object" && first && typeof first.tabName != "undefined") {
      _request = tabName;
      _options = webapi_options;
    } else {
      _request = {
        tabName
      };
      _options = webapi_options;
    }
    return this._getTabOrderAsync(_request, _options);
  }
  async _getPreferenceAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPreference", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Preference_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getPreferenceAsync(id, webapi_options) {
    let _request = null;
    let _options = null;
    const first = id;
    if (typeof first === "object" && first && typeof first.id != "undefined") {
      _request = id;
      _options = webapi_options;
    } else {
      _request = {
        id
      };
      _options = webapi_options;
    }
    return this._getPreferenceAsync(_request, _options);
  }
  async _savePreferenceEntityAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SavePreferenceEntity", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Preference_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async savePreferenceEntityAsync(preference, removeLowerLevels, webapi_options) {
    let _request = null;
    let _options = null;
    const first = preference;
    if (typeof first === "object" && first && (typeof first.preference != "undefined" || typeof first.removeLowerLevels != "undefined")) {
      _request = preference;
      _options = removeLowerLevels;
    } else {
      _request = {
        preference,
        removeLowerLevels
      };
      _options = webapi_options;
    }
    return this._savePreferenceEntityAsync(_request, _options);
  }
  async _deletePreferenceAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeletePreference", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async deletePreferenceAsync(id, webapi_options) {
    let _request = null;
    let _options = null;
    const first = id;
    if (typeof first === "object" && first && typeof first.id != "undefined") {
      _request = id;
      _options = webapi_options;
    } else {
      _request = {
        id
      };
      _options = webapi_options;
    }
    return this._deletePreferenceAsync(_request, _options);
  }
  async _deletePreferencesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeletePreferences", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async deletePreferencesAsync(ids, webapi_options) {
    let _request = null;
    let _options = null;
    const first = ids;
    if (typeof first === "object" && first && typeof first.ids != "undefined") {
      _request = ids;
      _options = webapi_options;
    } else {
      _request = {
        ids
      };
      _options = webapi_options;
    }
    return this._deletePreferencesAsync(_request, _options);
  }
  async _getPreferenceByNameAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPreferenceByName", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Preference_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getPreferenceByNameAsync(prefSection, prefKey, prefLevel, webapi_options) {
    let _request = null;
    let _options = null;
    const first = prefSection;
    if (typeof first === "object" && first && (typeof first.prefSection != "undefined" || typeof first.prefKey != "undefined" || typeof first.prefLevel != "undefined")) {
      _request = prefSection;
      _options = prefKey;
    } else {
      _request = {
        prefSection,
        prefKey,
        prefLevel
      };
      _options = webapi_options;
    }
    return this._getPreferenceByNameAsync(_request, _options);
  }
  async _getPreferenceByNameAndIdAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPreferenceByNameAndId", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Preference_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getPreferenceByNameAndIdAsync(prefSection, prefKey, prefLevel, ownerId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = prefSection;
    if (typeof first === "object" && first && (typeof first.prefSection != "undefined" || typeof first.prefKey != "undefined" || typeof first.prefLevel != "undefined" || typeof first.ownerId != "undefined")) {
      _request = prefSection;
      _options = prefKey;
    } else {
      _request = {
        prefSection,
        prefKey,
        prefLevel,
        ownerId
      };
      _options = webapi_options;
    }
    return this._getPreferenceByNameAndIdAsync(_request, _options);
  }
  async _getNetServicesStatusUrlAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetNetServicesStatusUrl", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Returns URL to status service. e.g. &apos;https://help.superoffice.com/sodispatcher/v1/status&apos; Returns NULL if status does not need to be checked yet.
   * @returns NULL or URL of the status service that returns an XML or JSON block.
   */
  async getNetServicesStatusUrlAsync(webapi_options) {
    return this._getNetServicesStatusUrlAsync(webapi_options);
  }
  async _updateNetServicesStatusAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("UpdateNetServicesStatus", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async updateNetServicesStatusAsync(xmlOrJson, webapi_options) {
    let _request = null;
    let _options = null;
    const first = xmlOrJson;
    if (typeof first === "object" && first && typeof first.xmlOrJson != "undefined") {
      _request = xmlOrJson;
      _options = webapi_options;
    } else {
      _request = {
        xmlOrJson
      };
      _options = webapi_options;
    }
    return this._updateNetServicesStatusAsync(_request, _options);
  }
  async _getXsrfPathsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetXsrfPaths", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getXsrfPathsAsync(hostname, webapi_options) {
    let _request = null;
    let _options = null;
    const first = hostname;
    if (typeof first === "object" && first && typeof first.hostname != "undefined") {
      _request = hostname;
      _options = webapi_options;
    } else {
      _request = {
        hostname
      };
      _options = webapi_options;
    }
    return this._getXsrfPathsAsync(_request, _options);
  }
  async _setXsrfPathsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetXsrfPaths", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setXsrfPathsAsync(hostname, paths, webapi_options) {
    let _request = null;
    let _options = null;
    const first = hostname;
    if (typeof first === "object" && first && (typeof first.hostname != "undefined" || typeof first.paths != "undefined")) {
      _request = hostname;
      _options = paths;
    } else {
      _request = {
        hostname,
        paths
      };
      _options = webapi_options;
    }
    return this._setXsrfPathsAsync(_request, _options);
  }
  /*
   * Gets a PreferenceDescription object.
   * @param preferenceDescriptionId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single PreferenceDescription
   */
  async getPreferenceDescriptionAsync(preferenceDescriptionId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetPreferenceDescription?preferenceDescriptionId=" + preferenceDescriptionId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PreferenceDescription_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getFromSectionAndKeyAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetFromSectionAndKey", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PreferenceDescription_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getFromSectionAndKeyAsync(section, key, webapi_options) {
    let _request = null;
    let _options = null;
    const first = section;
    if (typeof first === "object" && first && (typeof first.section != "undefined" || typeof first.key != "undefined")) {
      _request = section;
      _options = key;
    } else {
      _request = {
        section,
        key
      };
      _options = webapi_options;
    }
    return this._getFromSectionAndKeyAsync(_request, _options);
  }
  async _getAllAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetAll", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PreferenceDescriptionArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Gets a list of all PreferenceDescriptions in the system.
   * @returns All PreferenceDescriptions in the system
   */
  async getAllAsync(webapi_options) {
    return this._getAllAsync(webapi_options);
  }
  async _getAllFromSectionAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetAllFromSection", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PreferenceDescriptionArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getAllFromSectionAsync(section, webapi_options) {
    let _request = null;
    let _options = null;
    const first = section;
    if (typeof first === "object" && first && typeof first.section != "undefined") {
      _request = section;
      _options = webapi_options;
    } else {
      _request = {
        section
      };
      _options = webapi_options;
    }
    return this._getAllFromSectionAsync(_request, _options);
  }
  async _saveFromSectionAndKeyAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveFromSectionAndKey", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PreferenceDescription_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveFromSectionAndKeyAsync(section, key, preferenceDescription, webapi_options) {
    let _request = null;
    let _options = null;
    const first = section;
    if (typeof first === "object" && first && (typeof first.section != "undefined" || typeof first.key != "undefined" || typeof first.preferenceDescription != "undefined")) {
      _request = section;
      _options = key;
    } else {
      _request = {
        section,
        key,
        preferenceDescription
      };
      _options = webapi_options;
    }
    return this._saveFromSectionAndKeyAsync(_request, _options);
  }
  async _deleteFromSectionAndKeyAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeleteFromSectionAndKey", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async deleteFromSectionAndKeyAsync(section, key, webapi_options) {
    let _request = null;
    let _options = null;
    const first = section;
    if (typeof first === "object" && first && (typeof first.section != "undefined" || typeof first.key != "undefined")) {
      _request = section;
      _options = key;
    } else {
      _request = {
        section,
        key
      };
      _options = webapi_options;
    }
    return this._deleteFromSectionAndKeyAsync(_request, _options);
  }
  /*
   * Gets a PreferenceDescriptionLine object.
   * @param preferenceDescriptionLineId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single PreferenceDescriptionLine
   */
  async getPreferenceDescriptionLineAsync(preferenceDescriptionLineId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetPreferenceDescriptionLine?preferenceDescriptionLineId=" + preferenceDescriptionLineId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PreferenceDescriptionLine_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getPreferenceDescriptionLineFromIdAndValueAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPreferenceDescriptionLineFromIdAndValue", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PreferenceDescriptionLine_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getPreferenceDescriptionLineFromIdAndValueAsync(prefDescId, prefValue, webapi_options) {
    let _request = null;
    let _options = null;
    const first = prefDescId;
    if (typeof first === "object" && first && (typeof first.prefDescId != "undefined" || typeof first.prefValue != "undefined")) {
      _request = prefDescId;
      _options = prefValue;
    } else {
      _request = {
        prefDescId,
        prefValue
      };
      _options = webapi_options;
    }
    return this._getPreferenceDescriptionLineFromIdAndValueAsync(_request, _options);
  }
  async _getPreferenceDescriptionLinesByPrefDescIdAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPreferenceDescriptionLinesByPrefDescId", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PreferenceDescriptionLineArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getPreferenceDescriptionLinesByPrefDescIdAsync(prefDescId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = prefDescId;
    if (typeof first === "object" && first && typeof first.prefDescId != "undefined") {
      _request = prefDescId;
      _options = webapi_options;
    } else {
      _request = {
        prefDescId
      };
      _options = webapi_options;
    }
    return this._getPreferenceDescriptionLinesByPrefDescIdAsync(_request, _options);
  }
  async _savePreferenceDescriptionLinesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SavePreferenceDescriptionLines", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PreferenceDescriptionLineArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async savePreferenceDescriptionLinesAsync(preferenceDescriptionLines, webapi_options) {
    let _request = null;
    let _options = null;
    const first = preferenceDescriptionLines;
    if (typeof first === "object" && first && typeof first.preferenceDescriptionLines != "undefined") {
      _request = preferenceDescriptionLines;
      _options = webapi_options;
    } else {
      _request = {
        preferenceDescriptionLines
      };
      _options = webapi_options;
    }
    return this._savePreferenceDescriptionLinesAsync(_request, _options);
  }
  async _deletePreferenceDescriptionLinesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeletePreferenceDescriptionLines", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async deletePreferenceDescriptionLinesAsync(prefDescLineIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = prefDescLineIds;
    if (typeof first === "object" && first && typeof first.prefDescLineIds != "undefined") {
      _request = prefDescLineIds;
      _options = webapi_options;
    } else {
      _request = {
        prefDescLineIds
      };
      _options = webapi_options;
    }
    return this._deletePreferenceDescriptionLinesAsync(_request, _options);
  }
  async _deletePrefDescLinesByPrefDescIdAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeletePrefDescLinesByPrefDescId", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async deletePrefDescLinesByPrefDescIdAsync(prefDescId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = prefDescId;
    if (typeof first === "object" && first && typeof first.prefDescId != "undefined") {
      _request = prefDescId;
      _options = webapi_options;
    } else {
      _request = {
        prefDescId
      };
      _options = webapi_options;
    }
    return this._deletePrefDescLinesByPrefDescIdAsync(_request, _options);
  }
  async _deletePrefDescLinesByPrefDescIdsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeletePrefDescLinesByPrefDescIds", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async deletePrefDescLinesByPrefDescIdsAsync(prefDescIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = prefDescIds;
    if (typeof first === "object" && first && typeof first.prefDescIds != "undefined") {
      _request = prefDescIds;
      _options = webapi_options;
    } else {
      _request = {
        prefDescIds
      };
      _options = webapi_options;
    }
    return this._deletePrefDescLinesByPrefDescIdsAsync(_request, _options);
  }
  async _getPreferencesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPreferences", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PreferenceArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getPreferencesAsync(specifications, webapi_options) {
    let _request = null;
    let _options = null;
    const first = specifications;
    if (typeof first === "object" && first && typeof first.specifications != "undefined") {
      _request = specifications;
      _options = webapi_options;
    } else {
      _request = {
        specifications
      };
      _options = webapi_options;
    }
    return this._getPreferencesAsync(_request, _options);
  }
  async _savePreferencesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SavePreferences", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async savePreferencesAsync(preferences, webapi_options) {
    let _request = null;
    let _options = null;
    const first = preferences;
    if (typeof first === "object" && first && typeof first.preferences != "undefined") {
      _request = preferences;
      _options = webapi_options;
    } else {
      _request = {
        preferences
      };
      _options = webapi_options;
    }
    return this._savePreferencesAsync(_request, _options);
  }
  async _getPreferencesWithDisplayValuesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPreferencesWithDisplayValues", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PreferenceArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getPreferencesWithDisplayValuesAsync(specifications, webapi_options) {
    let _request = null;
    let _options = null;
    const first = specifications;
    if (typeof first === "object" && first && typeof first.specifications != "undefined") {
      _request = specifications;
      _options = webapi_options;
    } else {
      _request = {
        specifications
      };
      _options = webapi_options;
    }
    return this._getPreferencesWithDisplayValuesAsync(_request, _options);
  }
  async _getTabOrdersAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetTabOrders", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TabOrderArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   *
   * @returns
   */
  async getTabOrdersAsync(webapi_options) {
    return this._getTabOrdersAsync(webapi_options);
  }
  async _saveTabOrdersAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveTabOrders", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveTabOrdersAsync(tabOrders, webapi_options) {
    let _request = null;
    let _options = null;
    const first = tabOrders;
    if (typeof first === "object" && first && typeof first.tabOrders != "undefined") {
      _request = tabOrders;
      _options = webapi_options;
    } else {
      _request = {
        tabOrders
      };
      _options = webapi_options;
    }
    return this._saveTabOrdersAsync(_request, _options);
  }
  async _savePreferenceEntitiesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SavePreferenceEntities", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async savePreferenceEntitiesAsync(preferences, removeLowerLevels, webapi_options) {
    let _request = null;
    let _options = null;
    const first = preferences;
    if (typeof first === "object" && first && (typeof first.preferences != "undefined" || typeof first.removeLowerLevels != "undefined")) {
      _request = preferences;
      _options = removeLowerLevels;
    } else {
      _request = {
        preferences,
        removeLowerLevels
      };
      _options = webapi_options;
    }
    return this._savePreferenceEntitiesAsync(_request, _options);
  }
};

// server/node_modules/@superoffice/webapi/dist/esm/LicenseAgent.js
var LicenseAgent = class extends WebApiBase {
  constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
    const options = WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
    options.basePath = "v1/Agents/License/";
    super(options);
  }
  async _getLicenseForAllOwnersFromDBAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetLicenseForAllOwnersFromDB", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ExtendedLicenseInfoArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Get all licenses, with usage, from all module owners as they are stored in the database
   * @returns
   */
  async getLicenseForAllOwnersFromDBAsync(webapi_options) {
    return this._getLicenseForAllOwnersFromDBAsync(webapi_options);
  }
  async _getLicenseFromLicenseServerAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetLicenseFromLicenseServer", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ExtendedLicenseInfo_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getLicenseFromLicenseServerAsync(ownerName, webapi_options) {
    let _request = null;
    let _options = null;
    const first = ownerName;
    if (typeof first === "object" && first && typeof first.ownerName != "undefined") {
      _request = ownerName;
      _options = webapi_options;
    } else {
      _request = {
        ownerName
      };
      _options = webapi_options;
    }
    return this._getLicenseFromLicenseServerAsync(_request, _options);
  }
  async _getModuleLicenseHistoryFromLicenseServerAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetModuleLicenseHistoryFromLicenseServer", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getModuleLicenseHistoryFromLicenseServerAsync(licenseInfo, moduleLicense, webapi_options) {
    let _request = null;
    let _options = null;
    const first = licenseInfo;
    if (typeof first === "object" && first && (typeof first.licenseInfo != "undefined" || typeof first.moduleLicense != "undefined")) {
      _request = licenseInfo;
      _options = moduleLicense;
    } else {
      _request = {
        licenseInfo,
        moduleLicense
      };
      _options = webapi_options;
    }
    return this._getModuleLicenseHistoryFromLicenseServerAsync(_request, _options);
  }
  async _validateLicenseInfoAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ValidateLicenseInfo", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_LicenseResult_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async validateLicenseInfoAsync(licenseInfo, webapi_options) {
    let _request = null;
    let _options = null;
    const first = licenseInfo;
    if (typeof first === "object" && first && typeof first.licenseInfo != "undefined") {
      _request = licenseInfo;
      _options = webapi_options;
    } else {
      _request = {
        licenseInfo
      };
      _options = webapi_options;
    }
    return this._validateLicenseInfoAsync(_request, _options);
  }
  async _activateLicenseInfoAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ActivateLicenseInfo", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_LicenseResult_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async activateLicenseInfoAsync(newLicense, webapi_options) {
    let _request = null;
    let _options = null;
    const first = newLicense;
    if (typeof first === "object" && first && typeof first.newLicense != "undefined") {
      _request = newLicense;
      _options = webapi_options;
    } else {
      _request = {
        newLicense
      };
      _options = webapi_options;
    }
    return this._activateLicenseInfoAsync(_request, _options);
  }
  async _getLicenseStatusFromLicenseServerAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetLicenseStatusFromLicenseServer", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_CheckLicenseStatusResult_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getLicenseStatusFromLicenseServerAsync(ownerName, webapi_options) {
    let _request = null;
    let _options = null;
    const first = ownerName;
    if (typeof first === "object" && first && typeof first.ownerName != "undefined") {
      _request = ownerName;
      _options = webapi_options;
    } else {
      _request = {
        ownerName
      };
      _options = webapi_options;
    }
    return this._getLicenseStatusFromLicenseServerAsync(_request, _options);
  }
  async _getLicenseFromDBAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetLicenseFromDB", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ExtendedLicenseInfo_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getLicenseFromDBAsync(ownerName, webapi_options) {
    let _request = null;
    let _options = null;
    const first = ownerName;
    if (typeof first === "object" && first && typeof first.ownerName != "undefined") {
      _request = ownerName;
      _options = webapi_options;
    } else {
      _request = {
        ownerName
      };
      _options = webapi_options;
    }
    return this._getLicenseFromDBAsync(_request, _options);
  }
  async _changeSerialNumberAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ChangeSerialNumber", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_LicenseResult_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async changeSerialNumberAsync(newCompanyName, newSerialNumber, webapi_options) {
    let _request = null;
    let _options = null;
    const first = newCompanyName;
    if (typeof first === "object" && first && (typeof first.newCompanyName != "undefined" || typeof first.newSerialNumber != "undefined")) {
      _request = newCompanyName;
      _options = newSerialNumber;
    } else {
      _request = {
        newCompanyName,
        newSerialNumber
      };
      _options = webapi_options;
    }
    return this._changeSerialNumberAsync(_request, _options);
  }
  async _getUserLicensesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetUserLicenses", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_LicenseOwnerArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getUserLicensesAsync(associateId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = associateId;
    if (typeof first === "object" && first && typeof first.associateId != "undefined") {
      _request = associateId;
      _options = webapi_options;
    } else {
      _request = {
        associateId
      };
      _options = webapi_options;
    }
    return this._getUserLicensesAsync(_request, _options);
  }
  async _getSatelliteLicensesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetSatelliteLicenses", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_LicenseOwnerArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getSatelliteLicensesAsync(satelliteId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = satelliteId;
    if (typeof first === "object" && first && typeof first.satelliteId != "undefined") {
      _request = satelliteId;
      _options = webapi_options;
    } else {
      _request = {
        satelliteId
      };
      _options = webapi_options;
    }
    return this._getSatelliteLicensesAsync(_request, _options);
  }
  async _removeLicenseFromDBAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("RemoveLicenseFromDB", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_LicenseResult_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async removeLicenseFromDBAsync(moduleOwner, webapi_options) {
    let _request = null;
    let _options = null;
    const first = moduleOwner;
    if (typeof first === "object" && first && typeof first.moduleOwner != "undefined") {
      _request = moduleOwner;
      _options = webapi_options;
    } else {
      _request = {
        moduleOwner
      };
      _options = webapi_options;
    }
    return this._removeLicenseFromDBAsync(_request, _options);
  }
  async _getLicenseFromFileAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetLicenseFromFile", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ExtendedLicenseInfo_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getLicenseFromFileAsync(fileContent, webapi_options) {
    let _request = null;
    let _options = null;
    const first = fileContent;
    if (typeof first === "object" && first && typeof first.fileContent != "undefined") {
      _request = fileContent;
      _options = webapi_options;
    } else {
      _request = {
        fileContent
      };
      _options = webapi_options;
    }
    return this._getLicenseFromFileAsync(_request, _options);
  }
  async _getShopUrlAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetShopUrl", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getShopUrlAsync(ownerName, webapi_options) {
    let _request = null;
    let _options = null;
    const first = ownerName;
    if (typeof first === "object" && first && typeof first.ownerName != "undefined") {
      _request = ownerName;
      _options = webapi_options;
    } else {
      _request = {
        ownerName
      };
      _options = webapi_options;
    }
    return this._getShopUrlAsync(_request, _options);
  }
  async _getUserLicensesMDOListAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetUserLicensesMDOList", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SelectableMDOListItemArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Get all licenses in a MDOListItem structure.
   * @returns Hierarchical structure of user licenses.
   */
  async getUserLicensesMDOListAsync(webapi_options) {
    return this._getUserLicensesMDOListAsync(webapi_options);
  }
  async _getModuleLicenseFromDBAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetModuleLicenseFromDB", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ModuleLicense_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getModuleLicenseFromDBAsync(ownerName, moduleName, webapi_options) {
    let _request = null;
    let _options = null;
    const first = ownerName;
    if (typeof first === "object" && first && (typeof first.ownerName != "undefined" || typeof first.moduleName != "undefined")) {
      _request = ownerName;
      _options = moduleName;
    } else {
      _request = {
        ownerName,
        moduleName
      };
      _options = webapi_options;
    }
    return this._getModuleLicenseFromDBAsync(_request, _options);
  }
  async _addLicenseFromFileAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("AddLicenseFromFile", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ExtendedLicenseInfo_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async addLicenseFromFileAsync(fileContent, webapi_options) {
    let _request = null;
    let _options = null;
    const first = fileContent;
    if (typeof first === "object" && first && typeof first.fileContent != "undefined") {
      _request = fileContent;
      _options = webapi_options;
    } else {
      _request = {
        fileContent
      };
      _options = webapi_options;
    }
    return this._addLicenseFromFileAsync(_request, _options);
  }
  async _getThirdPartyLicenseAssignmentsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetThirdPartyLicenseAssignments", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ModuleLicenseLinkArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getThirdPartyLicenseAssignmentsAsync(associateId, moduleOwner, webapi_options) {
    let _request = null;
    let _options = null;
    const first = associateId;
    if (typeof first === "object" && first && (typeof first.associateId != "undefined" || typeof first.moduleOwner != "undefined")) {
      _request = associateId;
      _options = moduleOwner;
    } else {
      _request = {
        associateId,
        moduleOwner
      };
      _options = webapi_options;
    }
    return this._getThirdPartyLicenseAssignmentsAsync(_request, _options);
  }
  async _assignThirdPartyLicensesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("AssignThirdPartyLicenses", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ModuleLicenseLinkArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async assignThirdPartyLicensesAsync(associateId, moduleOwner, moduleLicenseNames, webapi_options) {
    let _request = null;
    let _options = null;
    const first = associateId;
    if (typeof first === "object" && first && (typeof first.associateId != "undefined" || typeof first.moduleOwner != "undefined" || typeof first.moduleLicenseNames != "undefined")) {
      _request = associateId;
      _options = moduleOwner;
    } else {
      _request = {
        associateId,
        moduleOwner,
        moduleLicenseNames
      };
      _options = webapi_options;
    }
    return this._assignThirdPartyLicensesAsync(_request, _options);
  }
  async _unassignThirdPartyLicensesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("UnassignThirdPartyLicenses", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ModuleLicenseLinkArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async unassignThirdPartyLicensesAsync(associateId, moduleOwner, moduleLicenseNames, webapi_options) {
    let _request = null;
    let _options = null;
    const first = associateId;
    if (typeof first === "object" && first && (typeof first.associateId != "undefined" || typeof first.moduleOwner != "undefined" || typeof first.moduleLicenseNames != "undefined")) {
      _request = associateId;
      _options = moduleOwner;
    } else {
      _request = {
        associateId,
        moduleOwner,
        moduleLicenseNames
      };
      _options = webapi_options;
    }
    return this._unassignThirdPartyLicensesAsync(_request, _options);
  }
};

// server/node_modules/@superoffice/webapi/dist/esm/UserAgent.js
var UserAgent = class extends WebApiBase {
  constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
    const options = WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
    options.basePath = "v1/Agents/User/";
    super(options);
  }
  /**
   * Set default values into a new RoleEntity.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultRoleEntityAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultRoleEntity", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_RoleEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing RoleEntity or creates a new RoleEntity if the id parameter is empty
   * @param entity - The RoleEntity to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated RoleEntity
   */
  async saveRoleEntityAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveRoleEntity", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_RoleEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new ServiceAuth.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultServiceAuthAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultServiceAuth", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ServiceAuth_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing ServiceAuth or creates a new ServiceAuth if the id parameter is empty
   * @param entity - The ServiceAuth to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated ServiceAuth
   */
  async saveServiceAuthAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveServiceAuth", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ServiceAuth_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Deletes the ServiceAuth
   * @param ServiceAuthId - The id of the ServiceAuth to be deleted.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   */
  async deleteServiceAuthAsync(ServiceAuthId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("DeleteServiceAuth?ServiceAuthId=" + ServiceAuthId, null, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new UntrustedCredentials.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultUntrustedCredentialsAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultUntrustedCredentials", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_UntrustedCredentials_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new User.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultUserAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultUser", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_User_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing User or creates a new User if the id parameter is empty
   * @param entity - The User to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated User
   */
  async saveUserAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveUser", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_User_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Get registered custom commands for User
   * @param request - The User entity to get commands for.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns Custom commands for the requested User.
   */
  async getUserCommandsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetUserCommands", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_CustomCommandArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Executes the custom command for User
   * @param request - The name of the command to execute. The User to execute commands on.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns Result of the executed command: Success + Message + CommandActionResult
   */
  async ExecuteUserCommandAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("ExecuteUserCommand", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_CommandResult_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Deletes the User
   * @param UserId - The id of the User to be deleted.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   */
  async deleteUserAsync(UserId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("DeleteUser?UserId=" + UserId, null, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getAccessGatewayInfoAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetAccessGatewayInfo", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AccessGatewayInfo_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Returns accessgateway registration info
   * @returns
   */
  async getAccessGatewayInfoAsync(webapi_options) {
    return this._getAccessGatewayInfoAsync(webapi_options);
  }
  async _getOrRegisterAccessGatewayInfoAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetOrRegisterAccessGatewayInfo", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AccessGatewayInfo_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getOrRegisterAccessGatewayInfoAsync(redirectUri, webapi_options) {
    let _request = null;
    let _options = null;
    const first = redirectUri;
    if (typeof first === "object" && first && typeof first.redirectUri != "undefined") {
      _request = redirectUri;
      _options = webapi_options;
    } else {
      _request = {
        redirectUri
      };
      _options = webapi_options;
    }
    return this._getOrRegisterAccessGatewayInfoAsync(_request, _options);
  }
  async _registerWithAccessGatewayAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("RegisterWithAccessGateway", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AccessGatewayInfo_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async registerWithAccessGatewayAsync(redirectUri, webapi_options) {
    let _request = null;
    let _options = null;
    const first = redirectUri;
    if (typeof first === "object" && first && typeof first.redirectUri != "undefined") {
      _request = redirectUri;
      _options = webapi_options;
    } else {
      _request = {
        redirectUri
      };
      _options = webapi_options;
    }
    return this._registerWithAccessGatewayAsync(_request, _options);
  }
  async _checkAccessGatewayRegistrationAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CheckAccessGatewayRegistration", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Checks if AccessGatewayRegistration is valid
   * @returns True if the registration is usable
   */
  async checkAccessGatewayRegistrationAsync(webapi_options) {
    return this._checkAccessGatewayRegistrationAsync(webapi_options);
  }
  async _saveCredentialAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveCredential", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveCredentialAsync(userId, credential, webapi_options) {
    let _request = null;
    let _options = null;
    const first = userId;
    if (typeof first === "object" && first && (typeof first.userId != "undefined" || typeof first.credential != "undefined")) {
      _request = userId;
      _options = credential;
    } else {
      _request = {
        userId,
        credential
      };
      _options = webapi_options;
    }
    return this._saveCredentialAsync(_request, _options);
  }
  async _deleteCredentialAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeleteCredential", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async deleteCredentialAsync(userId, credentialType, webapi_options) {
    let _request = null;
    let _options = null;
    const first = userId;
    if (typeof first === "object" && first && (typeof first.userId != "undefined" || typeof first.credentialType != "undefined")) {
      _request = userId;
      _options = credentialType;
    } else {
      _request = {
        userId,
        credentialType
      };
      _options = webapi_options;
    }
    return this._deleteCredentialAsync(_request, _options);
  }
  async _findCredentialsGroupsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("FindCredentialsGroups", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_CredentialsGroupArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async findCredentialsGroupsAsync(type, searchString, webapi_options) {
    let _request = null;
    let _options = null;
    const first = type;
    if (typeof first === "object" && first && (typeof first.type != "undefined" || typeof first.searchString != "undefined")) {
      _request = type;
      _options = searchString;
    } else {
      _request = {
        type,
        searchString
      };
      _options = webapi_options;
    }
    return this._findCredentialsGroupsAsync(_request, _options);
  }
  async _findCredentialUsersAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("FindCredentialUsers", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_CredentialsGroupUsers_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async findCredentialUsersAsync(type, searchString, webapi_options) {
    let _request = null;
    let _options = null;
    const first = type;
    if (typeof first === "object" && first && (typeof first.type != "undefined" || typeof first.searchString != "undefined")) {
      _request = type;
      _options = searchString;
    } else {
      _request = {
        type,
        searchString
      };
      _options = webapi_options;
    }
    return this._findCredentialUsersAsync(_request, _options);
  }
  async _getCredentialUsersInGroupAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetCredentialUsersInGroup", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_CredentialsGroupUsers_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getCredentialUsersInGroupAsync(type, groupName, webapi_options) {
    let _request = null;
    let _options = null;
    const first = type;
    if (typeof first === "object" && first && (typeof first.type != "undefined" || typeof first.groupName != "undefined")) {
      _request = type;
      _options = groupName;
    } else {
      _request = {
        type,
        groupName
      };
      _options = webapi_options;
    }
    return this._getCredentialUsersInGroupAsync(_request, _options);
  }
  /*
   * Gets a Role object.
   * @param roleId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single Role
   */
  async getRoleAsync(roleId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetRole?roleId=" + roleId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Role_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets a RoleEntity object.
   * @param roleEntityId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single RoleEntity
   */
  async getRoleEntityAsync(roleEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetRoleEntity?roleEntityId=" + roleEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_RoleEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _deleteRoleAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeleteRole", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async deleteRoleAsync(roleIdToDelete, replacingRoleId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = roleIdToDelete;
    if (typeof first === "object" && first && (typeof first.roleIdToDelete != "undefined" || typeof first.replacingRoleId != "undefined")) {
      _request = roleIdToDelete;
      _options = replacingRoleId;
    } else {
      _request = {
        roleIdToDelete,
        replacingRoleId
      };
      _options = webapi_options;
    }
    return this._deleteRoleAsync(_request, _options);
  }
  async _getAllRolesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetAllRoles", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SelectableMDOListItemArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getAllRolesAsync(roleType, webapi_options) {
    let _request = null;
    let _options = null;
    const first = roleType;
    if (typeof first === "object" && first && typeof first.roleType != "undefined") {
      _request = roleType;
      _options = webapi_options;
    } else {
      _request = {
        roleType
      };
      _options = webapi_options;
    }
    return this._getAllRolesAsync(_request, _options);
  }
  async _getAllFunctionalRightsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetAllFunctionalRights", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SelectableMDOListItemArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getAllFunctionalRightsAsync(roleType, webapi_options) {
    let _request = null;
    let _options = null;
    const first = roleType;
    if (typeof first === "object" && first && typeof first.roleType != "undefined") {
      _request = roleType;
      _options = webapi_options;
    } else {
      _request = {
        roleType
      };
      _options = webapi_options;
    }
    return this._getAllFunctionalRightsAsync(_request, _options);
  }
  async _getFunctionalRightsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetFunctionalRights", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SelectableMDOListItemArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getFunctionalRightsAsync(roleId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = roleId;
    if (typeof first === "object" && first && typeof first.roleId != "undefined") {
      _request = roleId;
      _options = webapi_options;
    } else {
      _request = {
        roleId
      };
      _options = webapi_options;
    }
    return this._getFunctionalRightsAsync(_request, _options);
  }
  async _setFunctionalRightsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetFunctionalRights", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setFunctionalRightsAsync(roleId, functionalRightIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = roleId;
    if (typeof first === "object" && first && (typeof first.roleId != "undefined" || typeof first.functionalRightIds != "undefined")) {
      _request = roleId;
      _options = functionalRightIds;
    } else {
      _request = {
        roleId,
        functionalRightIds
      };
      _options = webapi_options;
    }
    return this._setFunctionalRightsAsync(_request, _options);
  }
  async _setDataRightAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetDataRight", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setDataRightAsync(roleId, tableName, relationToOwner, dataRightValue, webapi_options) {
    let _request = null;
    let _options = null;
    const first = roleId;
    if (typeof first === "object" && first && (typeof first.roleId != "undefined" || typeof first.tableName != "undefined" || typeof first.relationToOwner != "undefined" || typeof first.dataRightValue != "undefined")) {
      _request = roleId;
      _options = tableName;
    } else {
      _request = {
        roleId,
        tableName,
        relationToOwner,
        dataRightValue
      };
      _options = webapi_options;
    }
    return this._setDataRightAsync(_request, _options);
  }
  async _getDataRightAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetDataRight", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getDataRightAsync(roleId, tableName, relationToOwner, webapi_options) {
    let _request = null;
    let _options = null;
    const first = roleId;
    if (typeof first === "object" && first && (typeof first.roleId != "undefined" || typeof first.tableName != "undefined" || typeof first.relationToOwner != "undefined")) {
      _request = roleId;
      _options = tableName;
    } else {
      _request = {
        roleId,
        tableName,
        relationToOwner
      };
      _options = webapi_options;
    }
    return this._getDataRightAsync(_request, _options);
  }
  async _getDataRightsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetDataRights", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_StringDictionary_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getDataRightsAsync(roleId, tableName, webapi_options) {
    let _request = null;
    let _options = null;
    const first = roleId;
    if (typeof first === "object" && first && (typeof first.roleId != "undefined" || typeof first.tableName != "undefined")) {
      _request = roleId;
      _options = tableName;
    } else {
      _request = {
        roleId,
        tableName
      };
      _options = webapi_options;
    }
    return this._getDataRightsAsync(_request, _options);
  }
  async _createDefaultRoleEntityFromTypeAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateDefaultRoleEntityFromType", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_RoleEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createDefaultRoleEntityFromTypeAsync(type, webapi_options) {
    let _request = null;
    let _options = null;
    const first = type;
    if (typeof first === "object" && first && typeof first.type != "undefined") {
      _request = type;
      _options = webapi_options;
    } else {
      _request = {
        type
      };
      _options = webapi_options;
    }
    return this._createDefaultRoleEntityFromTypeAsync(_request, _options);
  }
  async _findRolesWithFunctionalRightAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("FindRolesWithFunctionalRight", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_MDOListItemArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async findRolesWithFunctionalRightAsync(functionalRightName, webapi_options) {
    let _request = null;
    let _options = null;
    const first = functionalRightName;
    if (typeof first === "object" && first && typeof first.functionalRightName != "undefined") {
      _request = functionalRightName;
      _options = webapi_options;
    } else {
      _request = {
        functionalRightName
      };
      _options = webapi_options;
    }
    return this._findRolesWithFunctionalRightAsync(_request, _options);
  }
  async _findRolesWithFunctionalRightsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("FindRolesWithFunctionalRights", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async findRolesWithFunctionalRightsAsync(functionalRightNames, webapi_options) {
    let _request = null;
    let _options = null;
    const first = functionalRightNames;
    if (typeof first === "object" && first && typeof first.functionalRightNames != "undefined") {
      _request = functionalRightNames;
      _options = webapi_options;
    } else {
      _request = {
        functionalRightNames
      };
      _options = webapi_options;
    }
    return this._findRolesWithFunctionalRightsAsync(_request, _options);
  }
  async _findRolesWithoutFunctionalRightsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("FindRolesWithoutFunctionalRights", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async findRolesWithoutFunctionalRightsAsync(functionalRightNames, webapi_options) {
    let _request = null;
    let _options = null;
    const first = functionalRightNames;
    if (typeof first === "object" && first && typeof first.functionalRightNames != "undefined") {
      _request = functionalRightNames;
      _options = webapi_options;
    } else {
      _request = {
        functionalRightNames
      };
      _options = webapi_options;
    }
    return this._findRolesWithoutFunctionalRightsAsync(_request, _options);
  }
  /*
   * Gets a ServiceAuth object.
   * @param serviceAuthId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single ServiceAuth
   */
  async getServiceAuthAsync(serviceAuthId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetServiceAuth?serviceAuthId=" + serviceAuthId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ServiceAuth_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _saveExternalTokensAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveExternalTokens", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveExternalTokensAsync(tokenManagementInfo, webapi_options) {
    let _request = null;
    let _options = null;
    const first = tokenManagementInfo;
    if (typeof first === "object" && first && typeof first.tokenManagementInfo != "undefined") {
      _request = tokenManagementInfo;
      _options = webapi_options;
    } else {
      _request = {
        tokenManagementInfo
      };
      _options = webapi_options;
    }
    return this._saveExternalTokensAsync(_request, _options);
  }
  async _decryptAndSaveExternalTokensAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DecryptAndSaveExternalTokens", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async decryptAndSaveExternalTokensAsync(tokenManagementInfo, webapi_options) {
    let _request = null;
    let _options = null;
    const first = tokenManagementInfo;
    if (typeof first === "object" && first && typeof first.tokenManagementInfo != "undefined") {
      _request = tokenManagementInfo;
      _options = webapi_options;
    } else {
      _request = {
        tokenManagementInfo
      };
      _options = webapi_options;
    }
    return this._decryptAndSaveExternalTokensAsync(_request, _options);
  }
  async _getExternalTokensAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetExternalTokens", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TokenManagementInfo_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getExternalTokensAsync(key, webapi_options) {
    let _request = null;
    let _options = null;
    const first = key;
    if (typeof first === "object" && first && typeof first.key != "undefined") {
      _request = key;
      _options = webapi_options;
    } else {
      _request = {
        key
      };
      _options = webapi_options;
    }
    return this._getExternalTokensAsync(_request, _options);
  }
  /*
   * Gets a User object.
   * @param userId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single User
   */
  async getUserAsync(userId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetUser?userId=" + userId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_User_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getUserFromNameAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetUserFromName", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_User_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getUserFromNameAsync(userName, webapi_options) {
    let _request = null;
    let _options = null;
    const first = userName;
    if (typeof first === "object" && first && typeof first.userName != "undefined") {
      _request = userName;
      _options = webapi_options;
    } else {
      _request = {
        userName
      };
      _options = webapi_options;
    }
    return this._getUserFromNameAsync(_request, _options);
  }
  async _saveUserFromNameAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveUserFromName", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_User_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveUserFromNameAsync(userName, user, webapi_options) {
    let _request = null;
    let _options = null;
    const first = userName;
    if (typeof first === "object" && first && (typeof first.userName != "undefined" || typeof first.user != "undefined")) {
      _request = userName;
      _options = user;
    } else {
      _request = {
        userName,
        user
      };
      _options = webapi_options;
    }
    return this._saveUserFromNameAsync(_request, _options);
  }
  async _deleteUserFromNameAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeleteUserFromName", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async deleteUserFromNameAsync(userName, webapi_options) {
    let _request = null;
    let _options = null;
    const first = userName;
    if (typeof first === "object" && first && typeof first.userName != "undefined") {
      _request = userName;
      _options = webapi_options;
    } else {
      _request = {
        userName
      };
      _options = webapi_options;
    }
    return this._deleteUserFromNameAsync(_request, _options);
  }
  async _getCredentialTypesAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetCredentialTypes", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_CredentialTypeArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Get available credential types that can be used for authentication
   * @returns Credential types that can be used for authentication
   */
  async getCredentialTypesAsync(webapi_options) {
    return this._getCredentialTypesAsync(webapi_options);
  }
  async _getCredentialTypesForUserTypeAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetCredentialTypesForUserType", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_CredentialTypeArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getCredentialTypesForUserTypeAsync(userType, webapi_options) {
    let _request = null;
    let _options = null;
    const first = userType;
    if (typeof first === "object" && first && typeof first.userType != "undefined") {
      _request = userType;
      _options = webapi_options;
    } else {
      _request = {
        userType
      };
      _options = webapi_options;
    }
    return this._getCredentialTypesForUserTypeAsync(_request, _options);
  }
  async _saveUntrustedCredentialsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveUntrustedCredentials", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveUntrustedCredentialsAsync(type, credentials, webapi_options) {
    let _request = null;
    let _options = null;
    const first = type;
    if (typeof first === "object" && first && (typeof first.type != "undefined" || typeof first.credentials != "undefined")) {
      _request = type;
      _options = credentials;
    } else {
      _request = {
        type,
        credentials
      };
      _options = webapi_options;
    }
    return this._saveUntrustedCredentialsAsync(_request, _options);
  }
  async _getUntrustedCredentialsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetUntrustedCredentials", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_UntrustedCredentialsArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getUntrustedCredentialsAsync(type, webapi_options) {
    let _request = null;
    let _options = null;
    const first = type;
    if (typeof first === "object" && first && typeof first.type != "undefined") {
      _request = type;
      _options = webapi_options;
    } else {
      _request = {
        type
      };
      _options = webapi_options;
    }
    return this._getUntrustedCredentialsAsync(_request, _options);
  }
  async _getUntrustedCredentialsForAssociateAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetUntrustedCredentialsForAssociate", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_UntrustedCredentialsArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getUntrustedCredentialsForAssociateAsync(associateId, type, webapi_options) {
    let _request = null;
    let _options = null;
    const first = associateId;
    if (typeof first === "object" && first && (typeof first.associateId != "undefined" || typeof first.type != "undefined")) {
      _request = associateId;
      _options = type;
    } else {
      _request = {
        associateId,
        type
      };
      _options = webapi_options;
    }
    return this._getUntrustedCredentialsForAssociateAsync(_request, _options);
  }
  async _saveUntrustedCredentialsForAssociateAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveUntrustedCredentialsForAssociate", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveUntrustedCredentialsForAssociateAsync(associateId, type, credentials, webapi_options) {
    let _request = null;
    let _options = null;
    const first = associateId;
    if (typeof first === "object" && first && (typeof first.associateId != "undefined" || typeof first.type != "undefined" || typeof first.credentials != "undefined")) {
      _request = associateId;
      _options = type;
    } else {
      _request = {
        associateId,
        type,
        credentials
      };
      _options = webapi_options;
    }
    return this._saveUntrustedCredentialsForAssociateAsync(_request, _options);
  }
  async _removeUntrustedCredentialsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("RemoveUntrustedCredentials", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async removeUntrustedCredentialsAsync(type, publicValue, webapi_options) {
    let _request = null;
    let _options = null;
    const first = type;
    if (typeof first === "object" && first && (typeof first.type != "undefined" || typeof first.publicValue != "undefined")) {
      _request = type;
      _options = publicValue;
    } else {
      _request = {
        type,
        publicValue
      };
      _options = webapi_options;
    }
    return this._removeUntrustedCredentialsAsync(_request, _options);
  }
  async _removeUntrustedCredentialsForAssociateAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("RemoveUntrustedCredentialsForAssociate", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async removeUntrustedCredentialsForAssociateAsync(associateId, type, publicValue, webapi_options) {
    let _request = null;
    let _options = null;
    const first = associateId;
    if (typeof first === "object" && first && (typeof first.associateId != "undefined" || typeof first.type != "undefined" || typeof first.publicValue != "undefined")) {
      _request = associateId;
      _options = type;
    } else {
      _request = {
        associateId,
        type,
        publicValue
      };
      _options = webapi_options;
    }
    return this._removeUntrustedCredentialsForAssociateAsync(_request, _options);
  }
  async _createExternalUserAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateExternalUser", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createExternalUserAsync(personId, userName, password, roleId, isActive, webapi_options) {
    let _request = null;
    let _options = null;
    const first = personId;
    if (typeof first === "object" && first && (typeof first.personId != "undefined" || typeof first.userName != "undefined" || typeof first.password != "undefined" || typeof first.roleId != "undefined" || typeof first.isActive != "undefined")) {
      _request = personId;
      _options = userName;
    } else {
      _request = {
        personId,
        userName,
        password,
        roleId,
        isActive
      };
      _options = webapi_options;
    }
    return this._createExternalUserAsync(_request, _options);
  }
  async _deleteExternalUserAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeleteExternalUser", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async deleteExternalUserAsync(associateId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = associateId;
    if (typeof first === "object" && first && typeof first.associateId != "undefined") {
      _request = associateId;
      _options = webapi_options;
    } else {
      _request = {
        associateId
      };
      _options = webapi_options;
    }
    return this._deleteExternalUserAsync(_request, _options);
  }
  async _setExternalUserInfoAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetExternalUserInfo", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setExternalUserInfoAsync(associateId, userName, password, isActive, roleId, externalUserInfoModification, webapi_options) {
    let _request = null;
    let _options = null;
    const first = associateId;
    if (typeof first === "object" && first && (typeof first.associateId != "undefined" || typeof first.userName != "undefined" || typeof first.password != "undefined" || typeof first.isActive != "undefined" || typeof first.roleId != "undefined" || typeof first.externalUserInfoModification != "undefined")) {
      _request = associateId;
      _options = userName;
    } else {
      _request = {
        associateId,
        userName,
        password,
        isActive,
        roleId,
        externalUserInfoModification
      };
      _options = webapi_options;
    }
    return this._setExternalUserInfoAsync(_request, _options);
  }
  async _generateNewPasswordForExternalUserAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GenerateNewPasswordForExternalUser", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async generateNewPasswordForExternalUserAsync(associateName, webapi_options) {
    let _request = null;
    let _options = null;
    const first = associateName;
    if (typeof first === "object" && first && typeof first.associateName != "undefined") {
      _request = associateName;
      _options = webapi_options;
    } else {
      _request = {
        associateName
      };
      _options = webapi_options;
    }
    return this._generateNewPasswordForExternalUserAsync(_request, _options);
  }
  async _canChangePasswordAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CanChangePassword", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async canChangePasswordAsync(associateId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = associateId;
    if (typeof first === "object" && first && typeof first.associateId != "undefined") {
      _request = associateId;
      _options = webapi_options;
    } else {
      _request = {
        associateId
      };
      _options = webapi_options;
    }
    return this._canChangePasswordAsync(_request, _options);
  }
  async _getSupportedChangePasswordTypesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetSupportedChangePasswordTypes", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getSupportedChangePasswordTypesAsync(associateId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = associateId;
    if (typeof first === "object" && first && typeof first.associateId != "undefined") {
      _request = associateId;
      _options = webapi_options;
    } else {
      _request = {
        associateId
      };
      _options = webapi_options;
    }
    return this._getSupportedChangePasswordTypesAsync(_request, _options);
  }
  async _changePasswordAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ChangePassword", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async changePasswordAsync(associateId, oldPassword, newPassword, webapi_options) {
    let _request = null;
    let _options = null;
    const first = associateId;
    if (typeof first === "object" && first && (typeof first.associateId != "undefined" || typeof first.oldPassword != "undefined" || typeof first.newPassword != "undefined")) {
      _request = associateId;
      _options = oldPassword;
    } else {
      _request = {
        associateId,
        oldPassword,
        newPassword
      };
      _options = webapi_options;
    }
    return this._changePasswordAsync(_request, _options);
  }
  async _sendChangePasswordEMailAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SendChangePasswordEMail", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_OperationResult_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async sendChangePasswordEMailAsync(associateId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = associateId;
    if (typeof first === "object" && first && typeof first.associateId != "undefined") {
      _request = associateId;
      _options = webapi_options;
    } else {
      _request = {
        associateId
      };
      _options = webapi_options;
    }
    return this._sendChangePasswordEMailAsync(_request, _options);
  }
  async _getUserFromPersonIdAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetUserFromPersonId", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_UserArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getUserFromPersonIdAsync(personId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = personId;
    if (typeof first === "object" && first && typeof first.personId != "undefined") {
      _request = personId;
      _options = webapi_options;
    } else {
      _request = {
        personId
      };
      _options = webapi_options;
    }
    return this._getUserFromPersonIdAsync(_request, _options);
  }
  async _createDefaultUserFromUserTypeAndPersonIdAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateDefaultUserFromUserTypeAndPersonId", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_User_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createDefaultUserFromUserTypeAndPersonIdAsync(userType, personId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = userType;
    if (typeof first === "object" && first && (typeof first.userType != "undefined" || typeof first.personId != "undefined")) {
      _request = userType;
      _options = personId;
    } else {
      _request = {
        userType,
        personId
      };
      _options = webapi_options;
    }
    return this._createDefaultUserFromUserTypeAndPersonIdAsync(_request, _options);
  }
  async _createDefaultUserFromUserTypeAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateDefaultUserFromUserType", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_User_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createDefaultUserFromUserTypeAsync(userType, webapi_options) {
    let _request = null;
    let _options = null;
    const first = userType;
    if (typeof first === "object" && first && typeof first.userType != "undefined") {
      _request = userType;
      _options = webapi_options;
    } else {
      _request = {
        userType
      };
      _options = webapi_options;
    }
    return this._createDefaultUserFromUserTypeAsync(_request, _options);
  }
  async _getUserFromEjUserIdAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetUserFromEjUserId", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_UserArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getUserFromEjUserIdAsync(ejUserId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = ejUserId;
    if (typeof first === "object" && first && typeof first.ejUserId != "undefined") {
      _request = ejUserId;
      _options = webapi_options;
    } else {
      _request = {
        ejUserId
      };
      _options = webapi_options;
    }
    return this._getUserFromEjUserIdAsync(_request, _options);
  }
  async _setPasswordFromNameAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetPasswordFromName", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setPasswordFromNameAsync(associateName, password, webapi_options) {
    let _request = null;
    let _options = null;
    const first = associateName;
    if (typeof first === "object" && first && (typeof first.associateName != "undefined" || typeof first.password != "undefined")) {
      _request = associateName;
      _options = password;
    } else {
      _request = {
        associateName,
        password
      };
      _options = webapi_options;
    }
    return this._setPasswordFromNameAsync(_request, _options);
  }
  async _setPasswordAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetPassword", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setPasswordAsync(associateId, password, webapi_options) {
    let _request = null;
    let _options = null;
    const first = associateId;
    if (typeof first === "object" && first && (typeof first.associateId != "undefined" || typeof first.password != "undefined")) {
      _request = associateId;
      _options = password;
    } else {
      _request = {
        associateId,
        password
      };
      _options = webapi_options;
    }
    return this._setPasswordAsync(_request, _options);
  }
  async _changeOwnPasswordAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ChangeOwnPassword", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async changeOwnPasswordAsync(oldPassword, newPassword, webapi_options) {
    let _request = null;
    let _options = null;
    const first = oldPassword;
    if (typeof first === "object" && first && (typeof first.oldPassword != "undefined" || typeof first.newPassword != "undefined")) {
      _request = oldPassword;
      _options = newPassword;
    } else {
      _request = {
        oldPassword,
        newPassword
      };
      _options = webapi_options;
    }
    return this._changeOwnPasswordAsync(_request, _options);
  }
  async _changePasswordFromNameAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ChangePasswordFromName", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async changePasswordFromNameAsync(associateName, oldPassword, newPassword, webapi_options) {
    let _request = null;
    let _options = null;
    const first = associateName;
    if (typeof first === "object" && first && (typeof first.associateName != "undefined" || typeof first.oldPassword != "undefined" || typeof first.newPassword != "undefined")) {
      _request = associateName;
      _options = oldPassword;
    } else {
      _request = {
        associateName,
        oldPassword,
        newPassword
      };
      _options = webapi_options;
    }
    return this._changePasswordFromNameAsync(_request, _options);
  }
  async _isUserNameValidAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("IsUserNameValid", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async isUserNameValidAsync(associateId, type, personId, userName, webapi_options) {
    let _request = null;
    let _options = null;
    const first = associateId;
    if (typeof first === "object" && first && (typeof first.associateId != "undefined" || typeof first.type != "undefined" || typeof first.personId != "undefined" || typeof first.userName != "undefined")) {
      _request = associateId;
      _options = type;
    } else {
      _request = {
        associateId,
        type,
        personId,
        userName
      };
      _options = webapi_options;
    }
    return this._isUserNameValidAsync(_request, _options);
  }
  async _isPasswordValidAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("IsPasswordValid", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async isPasswordValidAsync(associateId, type, personId, password, webapi_options) {
    let _request = null;
    let _options = null;
    const first = associateId;
    if (typeof first === "object" && first && (typeof first.associateId != "undefined" || typeof first.type != "undefined" || typeof first.personId != "undefined" || typeof first.password != "undefined")) {
      _request = associateId;
      _options = type;
    } else {
      _request = {
        associateId,
        type,
        personId,
        password
      };
      _options = webapi_options;
    }
    return this._isPasswordValidAsync(_request, _options);
  }
  async _setGeneratedPasswordAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetGeneratedPassword", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setGeneratedPasswordAsync(associateId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = associateId;
    if (typeof first === "object" && first && typeof first.associateId != "undefined") {
      _request = associateId;
      _options = webapi_options;
    } else {
      _request = {
        associateId
      };
      _options = webapi_options;
    }
    return this._setGeneratedPasswordAsync(_request, _options);
  }
  async _setGeneratedPasswordFromNameAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetGeneratedPasswordFromName", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setGeneratedPasswordFromNameAsync(associateName, webapi_options) {
    let _request = null;
    let _options = null;
    const first = associateName;
    if (typeof first === "object" && first && typeof first.associateName != "undefined") {
      _request = associateName;
      _options = webapi_options;
    } else {
      _request = {
        associateName
      };
      _options = webapi_options;
    }
    return this._setGeneratedPasswordFromNameAsync(_request, _options);
  }
  async _isPasswordValidWithReasonAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("IsPasswordValidWithReason", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_UserValidationResult_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async isPasswordValidWithReasonAsync(associateId, type, personId, password, webapi_options) {
    let _request = null;
    let _options = null;
    const first = associateId;
    if (typeof first === "object" && first && (typeof first.associateId != "undefined" || typeof first.type != "undefined" || typeof first.personId != "undefined" || typeof first.password != "undefined")) {
      _request = associateId;
      _options = type;
    } else {
      _request = {
        associateId,
        type,
        personId,
        password
      };
      _options = webapi_options;
    }
    return this._isPasswordValidWithReasonAsync(_request, _options);
  }
  async _isUserNameValidWithReasonAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("IsUserNameValidWithReason", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_UserValidationResult_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async isUserNameValidWithReasonAsync(associateId, type, personId, userName, webapi_options) {
    let _request = null;
    let _options = null;
    const first = associateId;
    if (typeof first === "object" && first && (typeof first.associateId != "undefined" || typeof first.type != "undefined" || typeof first.personId != "undefined" || typeof first.userName != "undefined")) {
      _request = associateId;
      _options = type;
    } else {
      _request = {
        associateId,
        type,
        personId,
        userName
      };
      _options = webapi_options;
    }
    return this._isUserNameValidWithReasonAsync(_request, _options);
  }
  async _changeUserTypeAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ChangeUserType", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_User_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async changeUserTypeAsync(user, userType, webapi_options) {
    let _request = null;
    let _options = null;
    const first = user;
    if (typeof first === "object" && first && (typeof first.user != "undefined" || typeof first.userType != "undefined")) {
      _request = user;
      _options = userType;
    } else {
      _request = {
        user,
        userType
      };
      _options = webapi_options;
    }
    return this._changeUserTypeAsync(_request, _options);
  }
  async _createDefaultUserFromUserTypeAndCredentialAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateDefaultUserFromUserTypeAndCredential", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_User_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createDefaultUserFromUserTypeAndCredentialAsync(userType, contactId, credentialType, credentialValue, credentialDisplayValue, webapi_options) {
    let _request = null;
    let _options = null;
    const first = userType;
    if (typeof first === "object" && first && (typeof first.userType != "undefined" || typeof first.contactId != "undefined" || typeof first.credentialType != "undefined" || typeof first.credentialValue != "undefined" || typeof first.credentialDisplayValue != "undefined")) {
      _request = userType;
      _options = contactId;
    } else {
      _request = {
        userType,
        contactId,
        credentialType,
        credentialValue,
        credentialDisplayValue
      };
      _options = webapi_options;
    }
    return this._createDefaultUserFromUserTypeAndCredentialAsync(_request, _options);
  }
  async _getValidUserNameAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetValidUserName", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getValidUserNameAsync(associateId, type, personId, userName, webapi_options) {
    let _request = null;
    let _options = null;
    const first = associateId;
    if (typeof first === "object" && first && (typeof first.associateId != "undefined" || typeof first.type != "undefined" || typeof first.personId != "undefined" || typeof first.userName != "undefined")) {
      _request = associateId;
      _options = type;
    } else {
      _request = {
        associateId,
        type,
        personId,
        userName
      };
      _options = webapi_options;
    }
    return this._getValidUserNameAsync(_request, _options);
  }
  async _removeLicensesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("RemoveLicenses", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async removeLicensesAsync(associateId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = associateId;
    if (typeof first === "object" && first && typeof first.associateId != "undefined") {
      _request = associateId;
      _options = webapi_options;
    } else {
      _request = {
        associateId
      };
      _options = webapi_options;
    }
    return this._removeLicensesAsync(_request, _options);
  }
  async _makeRetiredAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("MakeRetired", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async makeRetiredAsync(associateId, retired, webapi_options) {
    let _request = null;
    let _options = null;
    const first = associateId;
    if (typeof first === "object" && first && (typeof first.associateId != "undefined" || typeof first.retired != "undefined")) {
      _request = associateId;
      _options = retired;
    } else {
      _request = {
        associateId,
        retired
      };
      _options = webapi_options;
    }
    return this._makeRetiredAsync(_request, _options);
  }
  async _addOwnerContactAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("AddOwnerContact", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async addOwnerContactAsync(contactId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = contactId;
    if (typeof first === "object" && first && typeof first.contactId != "undefined") {
      _request = contactId;
      _options = webapi_options;
    } else {
      _request = {
        contactId
      };
      _options = webapi_options;
    }
    return this._addOwnerContactAsync(_request, _options);
  }
  async _removeOwnerContactAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("RemoveOwnerContact", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async removeOwnerContactAsync(contactId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = contactId;
    if (typeof first === "object" && first && typeof first.contactId != "undefined") {
      _request = contactId;
      _options = webapi_options;
    } else {
      _request = {
        contactId
      };
      _options = webapi_options;
    }
    return this._removeOwnerContactAsync(_request, _options);
  }
  async _resolveUserFromInfoAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ResolveUserFromInfo", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ResolvedUser_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async resolveUserFromInfoAsync(contactId, personName, phoneNumbers, emails, userType, credential, webapi_options) {
    let _request = null;
    let _options = null;
    const first = contactId;
    if (typeof first === "object" && first && (typeof first.contactId != "undefined" || typeof first.personName != "undefined" || typeof first.phoneNumbers != "undefined" || typeof first.emails != "undefined" || typeof first.userType != "undefined" || typeof first.credential != "undefined")) {
      _request = contactId;
      _options = personName;
    } else {
      _request = {
        contactId,
        personName,
        phoneNumbers,
        emails,
        userType,
        credential
      };
      _options = webapi_options;
    }
    return this._resolveUserFromInfoAsync(_request, _options);
  }
  async _getAccessTokenAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetAccessToken", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getAccessTokenAsync(appToken, includeCsSession, webapi_options) {
    let _request = null;
    let _options = null;
    const first = appToken;
    if (typeof first === "object" && first && (typeof first.appToken != "undefined" || typeof first.includeCsSession != "undefined")) {
      _request = appToken;
      _options = includeCsSession;
    } else {
      _request = {
        appToken,
        includeCsSession
      };
      _options = webapi_options;
    }
    return this._getAccessTokenAsync(_request, _options);
  }
  async _getValidUserNameForNewUserAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetValidUserNameForNewUser", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getValidUserNameForNewUserAsync(user, webapi_options) {
    let _request = null;
    let _options = null;
    const first = user;
    if (typeof first === "object" && first && typeof first.user != "undefined") {
      _request = user;
      _options = webapi_options;
    } else {
      _request = {
        user
      };
      _options = webapi_options;
    }
    return this._getValidUserNameForNewUserAsync(_request, _options);
  }
  async _getDefaultAssociateUserNameAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetDefaultAssociateUserName", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getDefaultAssociateUserNameAsync(user, webapi_options) {
    let _request = null;
    let _options = null;
    const first = user;
    if (typeof first === "object" && first && typeof first.user != "undefined") {
      _request = user;
      _options = webapi_options;
    } else {
      _request = {
        user
      };
      _options = webapi_options;
    }
    return this._getDefaultAssociateUserNameAsync(_request, _options);
  }
  async _isNickNameUniqueAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("IsNickNameUnique", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async isNickNameUniqueAsync(associateId, nickName, webapi_options) {
    let _request = null;
    let _options = null;
    const first = associateId;
    if (typeof first === "object" && first && (typeof first.associateId != "undefined" || typeof first.nickName != "undefined")) {
      _request = associateId;
      _options = nickName;
    } else {
      _request = {
        associateId,
        nickName
      };
      _options = webapi_options;
    }
    return this._isNickNameUniqueAsync(_request, _options);
  }
  async _validateUserAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ValidateUser", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_StringDictionary_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async validateUserAsync(user, webapi_options) {
    let _request = null;
    let _options = null;
    const first = user;
    if (typeof first === "object" && first && typeof first.user != "undefined") {
      _request = user;
      _options = webapi_options;
    } else {
      _request = {
        user
      };
      _options = webapi_options;
    }
    return this._validateUserAsync(_request, _options);
  }
  async _getUserPresenceStatusAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetUserPresenceStatus", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_UserPresenceStatus_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getUserPresenceStatusAsync(associateId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = associateId;
    if (typeof first === "object" && first && typeof first.associateId != "undefined") {
      _request = associateId;
      _options = webapi_options;
    } else {
      _request = {
        associateId
      };
      _options = webapi_options;
    }
    return this._getUserPresenceStatusAsync(_request, _options);
  }
  async _setUserPresenceStatusAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetUserPresenceStatus", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_UserPresenceStatus_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setUserPresenceStatusAsync(associateId, userPresenceStatus, webapi_options) {
    let _request = null;
    let _options = null;
    const first = associateId;
    if (typeof first === "object" && first && (typeof first.associateId != "undefined" || typeof first.userPresenceStatus != "undefined")) {
      _request = associateId;
      _options = userPresenceStatus;
    } else {
      _request = {
        associateId,
        userPresenceStatus
      };
      _options = webapi_options;
    }
    return this._setUserPresenceStatusAsync(_request, _options);
  }
  /*
   * Gets a UserGroup object.
   * @param userGroupId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single UserGroup
   */
  async getUserGroupAsync(userGroupId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetUserGroup?userGroupId=" + userGroupId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_UserGroup_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _saveUserGroupAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveUserGroup", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_UserGroup_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveUserGroupAsync(userGroup, webapi_options) {
    let _request = null;
    let _options = null;
    const first = userGroup;
    if (typeof first === "object" && first && typeof first.userGroup != "undefined") {
      _request = userGroup;
      _options = webapi_options;
    } else {
      _request = {
        userGroup
      };
      _options = webapi_options;
    }
    return this._saveUserGroupAsync(_request, _options);
  }
  async _getAllUserGroupsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetAllUserGroups", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_UserGroupArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getAllUserGroupsAsync(includeDeleted, webapi_options) {
    let _request = null;
    let _options = null;
    const first = includeDeleted;
    if (typeof first === "object" && first && typeof first.includeDeleted != "undefined") {
      _request = includeDeleted;
      _options = webapi_options;
    } else {
      _request = {
        includeDeleted
      };
      _options = webapi_options;
    }
    return this._getAllUserGroupsAsync(_request, _options);
  }
  async _createUserGroupAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateUserGroup", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_UserGroup_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Create UserGroup (Rank is assigned to the highest rank)
   * @returns
   */
  async createUserGroupAsync(webapi_options) {
    return this._createUserGroupAsync(webapi_options);
  }
  async _deleteUserGroupAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeleteUserGroup", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async deleteUserGroupAsync(userGroupToDelete, userGroupToMoveTo, webapi_options) {
    let _request = null;
    let _options = null;
    const first = userGroupToDelete;
    if (typeof first === "object" && first && (typeof first.userGroupToDelete != "undefined" || typeof first.userGroupToMoveTo != "undefined")) {
      _request = userGroupToDelete;
      _options = userGroupToMoveTo;
    } else {
      _request = {
        userGroupToDelete,
        userGroupToMoveTo
      };
      _options = webapi_options;
    }
    return this._deleteUserGroupAsync(_request, _options);
  }
  /*
   * Gets an array of UserGroup objects.
   * @param userGroupIds - The primary keys.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns An array of UserGroup
   */
  async getUserGroupListAsync(userGroupIds, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetUserGroupList", userGroupIds, config);
        WebApiBase.SetCompleted(options);
        const res = Create_UserGroupArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets a UserInfo object.
   * @param userInfoId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single UserInfo
   */
  async getUserInfoAsync(userInfoId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetUserInfo?userInfoId=" + userInfoId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_UserInfo_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets an array of UserInfo objects.
   * @param userInfoIds - The primary keys.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns An array of UserInfo
   */
  async getUserInfoListAsync(userInfoIds, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetUserInfoList", userInfoIds, config);
        WebApiBase.SetCompleted(options);
        const res = Create_UserInfoArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
};

// server/node_modules/@superoffice/webapi/dist/esm/ReplicationAgent.js
var ReplicationAgent = class extends WebApiBase {
  constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
    const options = WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
    options.basePath = "v1/Agents/Replication/";
    super(options);
  }
  /**
   * Set default values into a new Satellite.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultSatelliteAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultSatellite", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Satellite_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing Satellite or creates a new Satellite if the id parameter is empty
   * @param entity - The Satellite to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated Satellite
   */
  async saveSatelliteAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveSatellite", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Satellite_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets a Area object.
   * @param areaId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single Area
   */
  async getAreaAsync(areaId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetArea?areaId=" + areaId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Area_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _setFreetextSearchEnabledOnAreaAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetFreetextSearchEnabledOnArea", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setFreetextSearchEnabledOnAreaAsync(areaId, freetextEnabled, webapi_options) {
    let _request = null;
    let _options = null;
    const first = areaId;
    if (typeof first === "object" && first && (typeof first.areaId != "undefined" || typeof first.freetextEnabled != "undefined")) {
      _request = areaId;
      _options = freetextEnabled;
    } else {
      _request = {
        areaId,
        freetextEnabled
      };
      _options = webapi_options;
    }
    return this._setFreetextSearchEnabledOnAreaAsync(_request, _options);
  }
  /*
   * Gets an array of Area objects.
   * @param areaIds - The primary keys.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns An array of Area
   */
  async getAreaListAsync(areaIds, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetAreaList", areaIds, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AreaArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets a Satellite object.
   * @param satelliteId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single Satellite
   */
  async getSatelliteAsync(satelliteId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetSatellite?satelliteId=" + satelliteId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Satellite_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getCentralLicenseAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetCentralLicense", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_LicenseOwnerArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   *
   * @returns
   */
  async getCentralLicenseAsync(webapi_options) {
    return this._getCentralLicenseAsync(webapi_options);
  }
  async _saveCentralLicenseAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveCentralLicense", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_LicenseOwnerArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveCentralLicenseAsync(license, webapi_options) {
    let _request = null;
    let _options = null;
    const first = license;
    if (typeof first === "object" && first && typeof first.license != "undefined") {
      _request = license;
      _options = webapi_options;
    } else {
      _request = {
        license
      };
      _options = webapi_options;
    }
    return this._saveCentralLicenseAsync(_request, _options);
  }
};

// server/node_modules/@superoffice/webapi/dist/esm/TimeZoneAgent.js
var TimeZoneAgent = class extends WebApiBase {
  constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
    const options = WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
    options.basePath = "v1/Agents/TimeZone/";
    super(options);
  }
  async _getDefaultTimeZoneInformationAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetDefaultTimeZoneInformation", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PreferredTimeZone_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Get information about the current, preferred timezone for the current user. If no such preference has been set, returns the correct fallback (and UserPreferenceId is 0)
   * @returns Get information about the current, preferred timezone for the current user.
   */
  async getDefaultTimeZoneInformationAsync(webapi_options) {
    return this._getDefaultTimeZoneInformationAsync(webapi_options);
  }
  async _initializeTimeZoneDataAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("InitializeTimeZoneData", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TimeZoneDataArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Initalizes the TimeZoneData
   * @returns
   */
  async initializeTimeZoneDataAsync(webapi_options) {
    return this._initializeTimeZoneDataAsync(webapi_options);
  }
  async _getBaseTimeZoneIdAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetBaseTimeZoneId", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Get the base timezone id.
   * @returns Returns the base timezone id. Returns 0 if not set.
   */
  async getBaseTimeZoneIdAsync(webapi_options) {
    return this._getBaseTimeZoneIdAsync(webapi_options);
  }
  async _updateTimeZoneDataAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("UpdateTimeZoneData", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Retrieve time zone data from the SuperOffice server and update TimeZone data in the database
   * @returns Returns true if the operation succeeded
   */
  async updateTimeZoneDataAsync(webapi_options) {
    return this._updateTimeZoneDataAsync(webapi_options);
  }
  async _checkNewTimeZoneDataAvailableAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CheckNewTimeZoneDataAvailable", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Check to see if new timezone data is available
   * @returns Returns true if new timezone info is found available, false otherwise
   */
  async checkNewTimeZoneDataAvailableAsync(webapi_options) {
    return this._checkNewTimeZoneDataAvailableAsync(webapi_options);
  }
  async _toggleActiveTimeZoneRowAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ToggleActiveTimeZoneRow", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async toggleActiveTimeZoneRowAsync(id, webapi_options) {
    let _request = null;
    let _options = null;
    const first = id;
    if (typeof first === "object" && first && typeof first.id != "undefined") {
      _request = id;
      _options = webapi_options;
    } else {
      _request = {
        id
      };
      _options = webapi_options;
    }
    return this._toggleActiveTimeZoneRowAsync(_request, _options);
  }
  async _setActiveTimeZonesByFilterAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetActiveTimeZonesByFilter", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setActiveTimeZonesByFilterAsync(filter2, active, webapi_options) {
    let _request = null;
    let _options = null;
    const first = filter2;
    if (typeof first === "object" && first && (typeof first.filter != "undefined" || typeof first.active != "undefined")) {
      _request = filter2;
      _options = active;
    } else {
      _request = {
        filter: filter2,
        active
      };
      _options = webapi_options;
    }
    return this._setActiveTimeZonesByFilterAsync(_request, _options);
  }
  async _timeOfLastTimeZoneUpdateAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("TimeOfLastTimeZoneUpdate", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Get the time time zone data was last updated
   * @returns Time of last update
   */
  async timeOfLastTimeZoneUpdateAsync(webapi_options) {
    return this._timeOfLastTimeZoneUpdateAsync(webapi_options);
  }
  async _setBaseTimeZoneIdAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetBaseTimeZoneId", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setBaseTimeZoneIdAsync(timezoneId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = timezoneId;
    if (typeof first === "object" && first && typeof first.timezoneId != "undefined") {
      _request = timezoneId;
      _options = webapi_options;
    } else {
      _request = {
        timezoneId
      };
      _options = webapi_options;
    }
    return this._setBaseTimeZoneIdAsync(_request, _options);
  }
  async _getDefaultTimeZonePreferenceAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetDefaultTimeZonePreference", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Returns the id of the default timezone preference with deflevel system wide
   * @returns The id of the system wide default timezone preference
   */
  async getDefaultTimeZonePreferenceAsync(webapi_options) {
    return this._getDefaultTimeZonePreferenceAsync(webapi_options);
  }
  async _deleteTimeZonesAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeleteTimeZones", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Deletes all time zone data (locations and rules) from the database
   * @returns
   */
  async deleteTimeZonesAsync(webapi_options) {
    return this._deleteTimeZonesAsync(webapi_options);
  }
  async _setActiveTimeZoneRowAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetActiveTimeZoneRow", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setActiveTimeZoneRowAsync(id, active, webapi_options) {
    let _request = null;
    let _options = null;
    const first = id;
    if (typeof first === "object" && first && (typeof first.id != "undefined" || typeof first.active != "undefined")) {
      _request = id;
      _options = active;
    } else {
      _request = {
        id,
        active
      };
      _options = webapi_options;
    }
    return this._setActiveTimeZoneRowAsync(_request, _options);
  }
};

// server/node_modules/@superoffice/webapi/dist/esm/MessagingAgent.js
var MessagingAgent = class extends WebApiBase {
  constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
    const options = WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
    options.basePath = "v1/Agents/Messaging/";
    super(options);
  }
  async _createMessageAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateMessage", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createMessageAsync(incomingMessage, webapi_options) {
    let _request = null;
    let _options = null;
    const first = incomingMessage;
    if (typeof first === "object" && first && typeof first.incomingMessage != "undefined") {
      _request = incomingMessage;
      _options = webapi_options;
    } else {
      _request = {
        incomingMessage
      };
      _options = webapi_options;
    }
    return this._createMessageAsync(_request, _options);
  }
  async _getDeliveryStatusAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetDeliveryStatus", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_MessageDeliveryStatusArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getDeliveryStatusAsync(messagingIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = messagingIds;
    if (typeof first === "object" && first && typeof first.messagingIds != "undefined") {
      _request = messagingIds;
      _options = webapi_options;
    } else {
      _request = {
        messagingIds
      };
      _options = webapi_options;
    }
    return this._getDeliveryStatusAsync(_request, _options);
  }
  async _setDeliveryStatusAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetDeliveryStatus", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setDeliveryStatusAsync(plugin, externalMessageId, status, statusDescription, webapi_options) {
    let _request = null;
    let _options = null;
    const first = plugin;
    if (typeof first === "object" && first && (typeof first.plugin != "undefined" || typeof first.externalMessageId != "undefined" || typeof first.status != "undefined" || typeof first.statusDescription != "undefined")) {
      _request = plugin;
      _options = externalMessageId;
    } else {
      _request = {
        plugin,
        externalMessageId,
        status,
        statusDescription
      };
      _options = webapi_options;
    }
    return this._setDeliveryStatusAsync(_request, _options);
  }
  async _sendMessagesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SendMessages", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_MessageDeliveryStatusArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async sendMessagesAsync(plugin, outgoingMessages, webapi_options) {
    let _request = null;
    let _options = null;
    const first = plugin;
    if (typeof first === "object" && first && (typeof first.plugin != "undefined" || typeof first.outgoingMessages != "undefined")) {
      _request = plugin;
      _options = outgoingMessages;
    } else {
      _request = {
        plugin,
        outgoingMessages
      };
      _options = webapi_options;
    }
    return this._sendMessagesAsync(_request, _options);
  }
  async _sendMessagesWithConfigAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SendMessagesWithConfig", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_MessageDeliveryStatusArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async sendMessagesWithConfigAsync(plugin, outgoingMessages, config, webapi_options) {
    let _request = null;
    let _options = null;
    const first = plugin;
    if (typeof first === "object" && first && (typeof first.plugin != "undefined" || typeof first.outgoingMessages != "undefined" || typeof first.config != "undefined")) {
      _request = plugin;
      _options = outgoingMessages;
    } else {
      _request = {
        plugin,
        outgoingMessages,
        config
      };
      _options = webapi_options;
    }
    return this._sendMessagesWithConfigAsync(_request, _options);
  }
  async _getPluginsAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPlugins", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ProviderInfoArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   *
   * @returns
   */
  async getPluginsAsync(webapi_options) {
    return this._getPluginsAsync(webapi_options);
  }
};

// server/node_modules/@superoffice/webapi/dist/esm/ImportAgent.js
var ImportAgent = class extends WebApiBase {
  constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
    const options = WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
    options.basePath = "v1/Agents/Import/";
    super(options);
  }
  async _previewImportAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("PreviewImport", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ImportLineArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async previewImportAsync(importLines, columnDefinition, culture, context, webapi_options) {
    let _request = null;
    let _options = null;
    const first = importLines;
    if (typeof first === "object" && first && (typeof first.importLines != "undefined" || typeof first.columnDefinition != "undefined" || typeof first.culture != "undefined" || typeof first.context != "undefined")) {
      _request = importLines;
      _options = columnDefinition;
    } else {
      _request = {
        importLines,
        columnDefinition,
        culture,
        context
      };
      _options = webapi_options;
    }
    return this._previewImportAsync(_request, _options);
  }
  async _saveImportAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveImport", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveImportAsync(importLines, columnDefinition, createSelection, culture, context, webapi_options) {
    let _request = null;
    let _options = null;
    const first = importLines;
    if (typeof first === "object" && first && (typeof first.importLines != "undefined" || typeof first.columnDefinition != "undefined" || typeof first.createSelection != "undefined" || typeof first.culture != "undefined" || typeof first.context != "undefined")) {
      _request = importLines;
      _options = columnDefinition;
    } else {
      _request = {
        importLines,
        columnDefinition,
        createSelection,
        culture,
        context
      };
      _options = webapi_options;
    }
    return this._saveImportAsync(_request, _options);
  }
  async _createDefaultImportLineAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateDefaultImportLine", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ImportLine_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createDefaultImportLineAsync(countColumns, webapi_options) {
    let _request = null;
    let _options = null;
    const first = countColumns;
    if (typeof first === "object" && first && typeof first.countColumns != "undefined") {
      _request = countColumns;
      _options = webapi_options;
    } else {
      _request = {
        countColumns
      };
      _options = webapi_options;
    }
    return this._createDefaultImportLineAsync(_request, _options);
  }
  async _createErpImportDataAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateErpImportData", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ImportErpData_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createErpImportDataAsync(restriction, columns, connectionId, erpActorType, webapi_options) {
    let _request = null;
    let _options = null;
    const first = restriction;
    if (typeof first === "object" && first && (typeof first.restriction != "undefined" || typeof first.columns != "undefined" || typeof first.connectionId != "undefined" || typeof first.erpActorType != "undefined")) {
      _request = restriction;
      _options = columns;
    } else {
      _request = {
        restriction,
        columns,
        connectionId,
        erpActorType
      };
      _options = webapi_options;
    }
    return this._createErpImportDataAsync(_request, _options);
  }
};

// server/node_modules/@superoffice/webapi/dist/esm/FreeTextAgent.js
var FreeTextAgent = class extends WebApiBase {
  constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
    const options = WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
    options.basePath = "v1/Agents/FreeText/";
    super(options);
  }
  async _getStatusAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetStatus", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_FreeText_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Returns status for the freetext search words
   * @returns The freetext status
   */
  async getStatusAsync(webapi_options) {
    return this._getStatusAsync(webapi_options);
  }
  async _setEnabledAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetEnabled", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setEnabledAsync(enabled, webapi_options) {
    let _request = null;
    let _options = null;
    const first = enabled;
    if (typeof first === "object" && first && typeof first.enabled != "undefined") {
      _request = enabled;
      _options = webapi_options;
    } else {
      _request = {
        enabled
      };
      _options = webapi_options;
    }
    return this._setEnabledAsync(_request, _options);
  }
  async _setAutoEnableTravelAreasAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetAutoEnableTravelAreas", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setAutoEnableTravelAreasAsync(autoEnable, webapi_options) {
    let _request = null;
    let _options = null;
    const first = autoEnable;
    if (typeof first === "object" && first && typeof first.autoEnable != "undefined") {
      _request = autoEnable;
      _options = webapi_options;
    } else {
      _request = {
        autoEnable
      };
      _options = webapi_options;
    }
    return this._setAutoEnableTravelAreasAsync(_request, _options);
  }
  async _setSingleWordOperatorAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetSingleWordOperator", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setSingleWordOperatorAsync(freeTextOperator, webapi_options) {
    let _request = null;
    let _options = null;
    const first = freeTextOperator;
    if (typeof first === "object" && first && typeof first.freeTextOperator != "undefined") {
      _request = freeTextOperator;
      _options = webapi_options;
    } else {
      _request = {
        freeTextOperator
      };
      _options = webapi_options;
    }
    return this._setSingleWordOperatorAsync(_request, _options);
  }
  async _setMultiWordOperatorAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetMultiWordOperator", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setMultiWordOperatorAsync(freeTextOperator, webapi_options) {
    let _request = null;
    let _options = null;
    const first = freeTextOperator;
    if (typeof first === "object" && first && typeof first.freeTextOperator != "undefined") {
      _request = freeTextOperator;
      _options = webapi_options;
    } else {
      _request = {
        freeTextOperator
      };
      _options = webapi_options;
    }
    return this._setMultiWordOperatorAsync(_request, _options);
  }
  async _getStopWordListAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetStopWordList", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Returns the list of stop words
   * @returns The list of stop words
   */
  async getStopWordListAsync(webapi_options) {
    return this._getStopWordListAsync(webapi_options);
  }
  async _addWordsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("AddWords", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async addWordsAsync(stopWords, webapi_options) {
    let _request = null;
    let _options = null;
    const first = stopWords;
    if (typeof first === "object" && first && typeof first.stopWords != "undefined") {
      _request = stopWords;
      _options = webapi_options;
    } else {
      _request = {
        stopWords
      };
      _options = webapi_options;
    }
    return this._addWordsAsync(_request, _options);
  }
  async _deleteStopWordsByIdAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeleteStopWordsById", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async deleteStopWordsByIdAsync(stopWordIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = stopWordIds;
    if (typeof first === "object" && first && typeof first.stopWordIds != "undefined") {
      _request = stopWordIds;
      _options = webapi_options;
    } else {
      _request = {
        stopWordIds
      };
      _options = webapi_options;
    }
    return this._deleteStopWordsByIdAsync(_request, _options);
  }
  async _getSuggestedStopWordsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetSuggestedStopWords", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_MDOListItemArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getSuggestedStopWordsAsync(countWords, webapi_options) {
    let _request = null;
    let _options = null;
    const first = countWords;
    if (typeof first === "object" && first && typeof first.countWords != "undefined") {
      _request = countWords;
      _options = webapi_options;
    } else {
      _request = {
        countWords
      };
      _options = webapi_options;
    }
    return this._getSuggestedStopWordsAsync(_request, _options);
  }
  async _regenerateIndexAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("RegenerateIndex", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_BatchTaskInfo_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async regenerateIndexAsync(runAsBatch, webapi_options) {
    let _request = null;
    let _options = null;
    const first = runAsBatch;
    if (typeof first === "object" && first && typeof first.runAsBatch != "undefined") {
      _request = runAsBatch;
      _options = webapi_options;
    } else {
      _request = {
        runAsBatch
      };
      _options = webapi_options;
    }
    return this._regenerateIndexAsync(_request, _options);
  }
  async _freetextIndexRowsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("FreetextIndexRows", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async freetextIndexRowsAsync(tableName, ids, webapi_options) {
    let _request = null;
    let _options = null;
    const first = tableName;
    if (typeof first === "object" && first && (typeof first.tableName != "undefined" || typeof first.ids != "undefined")) {
      _request = tableName;
      _options = ids;
    } else {
      _request = {
        tableName,
        ids
      };
      _options = webapi_options;
    }
    return this._freetextIndexRowsAsync(_request, _options);
  }
};

// server/node_modules/@superoffice/webapi/dist/esm/NumberAllocationAgent.js
var NumberAllocationAgent = class extends WebApiBase {
  constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
    const options = WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
    options.basePath = "v1/Agents/NumberAllocation/";
    super(options);
  }
  /**
   * Set default values into a new RefCountEntity.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultRefCountEntityAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultRefCountEntity", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_RefCountEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing RefCountEntity or creates a new RefCountEntity if the id parameter is empty
   * @param entity - The RefCountEntity to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated RefCountEntity
   */
  async saveRefCountEntityAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveRefCountEntity", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_RefCountEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Deletes the RefCountEntity
   * @param RefCountEntityId - The id of the RefCountEntity to be deleted.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   */
  async deleteRefCountEntityAsync(RefCountEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("DeleteRefCountEntity?RefCountEntityId=" + RefCountEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets a RefCountEntity object.
   * @param refCountEntityId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single RefCountEntity
   */
  async getRefCountEntityAsync(refCountEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetRefCountEntity?refCountEntityId=" + refCountEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_RefCountEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _saveDefaultNumberingAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveDefaultNumbering", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveDefaultNumberingAsync(refCountEntity, webapi_options) {
    let _request = null;
    let _options = null;
    const first = refCountEntity;
    if (typeof first === "object" && first && typeof first.refCountEntity != "undefined") {
      _request = refCountEntity;
      _options = webapi_options;
    } else {
      _request = {
        refCountEntity
      };
      _options = webapi_options;
    }
    return this._saveDefaultNumberingAsync(_request, _options);
  }
  async _getNumberEachTemplateAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetNumberEachTemplate", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Returns true or false if Automatically create new counters for new document templates
   * @returns Is NumberEachTemplate?
   */
  async getNumberEachTemplateAsync(webapi_options) {
    return this._getNumberEachTemplateAsync(webapi_options);
  }
  async _setNumberEachTemplateAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetNumberEachTemplate", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setNumberEachTemplateAsync(setValue, webapi_options) {
    let _request = null;
    let _options = null;
    const first = setValue;
    if (typeof first === "object" && first && typeof first.setValue != "undefined") {
      _request = setValue;
      _options = webapi_options;
    } else {
      _request = {
        setValue
      };
      _options = webapi_options;
    }
    return this._setNumberEachTemplateAsync(_request, _options);
  }
};

// server/node_modules/@superoffice/webapi/dist/esm/CustomerServiceAgent.js
var CustomerServiceAgent = class extends WebApiBase {
  constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
    const options = WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
    options.basePath = "v1/Agents/CustomerService/";
    super(options);
  }
  /**
   * Set default values into a new CustomerCenterConfig.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultCustomerCenterConfigAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultCustomerCenterConfig", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_CustomerCenterConfig_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing CustomerCenterConfig or creates a new CustomerCenterConfig if the id parameter is empty
   * @param entity - The CustomerCenterConfig to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated CustomerCenterConfig
   */
  async saveCustomerCenterConfigAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveCustomerCenterConfig", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_CustomerCenterConfig_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Deletes the CustomerCenterConfig
   * @param CustomerCenterConfigId - The id of the CustomerCenterConfig to be deleted.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   */
  async deleteCustomerCenterConfigAsync(CustomerCenterConfigId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("DeleteCustomerCenterConfig?CustomerCenterConfigId=" + CustomerCenterConfigId, null, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new MailboxEntity.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultMailboxEntityAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultMailboxEntity", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_MailboxEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing MailboxEntity or creates a new MailboxEntity if the id parameter is empty
   * @param entity - The MailboxEntity to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated MailboxEntity
   */
  async saveMailboxEntityAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveMailboxEntity", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_MailboxEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new SmsConfig.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultSmsConfigAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultSmsConfig", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SmsConfig_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing SmsConfig or creates a new SmsConfig if the id parameter is empty
   * @param entity - The SmsConfig to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated SmsConfig
   */
  async saveSmsConfigAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveSmsConfig", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SmsConfig_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _updateFeatureTogglesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("UpdateFeatureToggles", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async updateFeatureTogglesAsync(featureToggles, webapi_options) {
    let _request = null;
    let _options = null;
    const first = featureToggles;
    if (typeof first === "object" && first && typeof first.featureToggles != "undefined") {
      _request = featureToggles;
      _options = webapi_options;
    } else {
      _request = {
        featureToggles
      };
      _options = webapi_options;
    }
    return this._updateFeatureTogglesAsync(_request, _options);
  }
  async _eventHandlerExistsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("EventHandlerExists", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async eventHandlerExistsAsync(eventHandlerType, webapi_options) {
    let _request = null;
    let _options = null;
    const first = eventHandlerType;
    if (typeof first === "object" && first && typeof first.eventHandlerType != "undefined") {
      _request = eventHandlerType;
      _options = webapi_options;
    } else {
      _request = {
        eventHandlerType
      };
      _options = webapi_options;
    }
    return this._eventHandlerExistsAsync(_request, _options);
  }
  async _createSessionAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateSession", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_CsSessionKey_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createSessionAsync(remoteIp, webapi_options) {
    let _request = null;
    let _options = null;
    const first = remoteIp;
    if (typeof first === "object" && first && typeof first.remoteIp != "undefined") {
      _request = remoteIp;
      _options = webapi_options;
    } else {
      _request = {
        remoteIp
      };
      _options = webapi_options;
    }
    return this._createSessionAsync(_request, _options);
  }
  async _removeSessionAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("RemoveSession", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async removeSessionAsync(loginId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = loginId;
    if (typeof first === "object" && first && typeof first.loginId != "undefined") {
      _request = loginId;
      _options = webapi_options;
    } else {
      _request = {
        loginId
      };
      _options = webapi_options;
    }
    return this._removeSessionAsync(_request, _options);
  }
  async _sessionIsValidAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SessionIsValid", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async sessionIsValidAsync(csSessionKey, webapi_options) {
    let _request = null;
    let _options = null;
    const first = csSessionKey;
    if (typeof first === "object" && first && typeof first.csSessionKey != "undefined") {
      _request = csSessionKey;
      _options = webapi_options;
    } else {
      _request = {
        csSessionKey
      };
      _options = webapi_options;
    }
    return this._sessionIsValidAsync(_request, _options);
  }
  async _hasChatNotifyAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("HasChatNotify", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Check if user has any chat notification
   * @returns True if the user has at least one notification setting on
   */
  async hasChatNotifyAsync(webapi_options) {
    return this._hasChatNotifyAsync(webapi_options);
  }
  async _checkSymmetricEncryptionAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CheckSymmetricEncryption", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async checkSymmetricEncryptionAsync(encryptedString, webapi_options) {
    let _request = null;
    let _options = null;
    const first = encryptedString;
    if (typeof first === "object" && first && typeof first.encryptedString != "undefined") {
      _request = encryptedString;
      _options = webapi_options;
    } else {
      _request = {
        encryptedString
      };
      _options = webapi_options;
    }
    return this._checkSymmetricEncryptionAsync(_request, _options);
  }
  async _reportSessionActiveAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ReportSessionActive", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async reportSessionActiveAsync(sessionKey, webapi_options) {
    let _request = null;
    let _options = null;
    const first = sessionKey;
    if (typeof first === "object" && first && typeof first.sessionKey != "undefined") {
      _request = sessionKey;
      _options = webapi_options;
    } else {
      _request = {
        sessionKey
      };
      _options = webapi_options;
    }
    return this._reportSessionActiveAsync(_request, _options);
  }
  /*
   * Gets a CustomerCenterConfig object.
   * @param customerCenterConfigId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single CustomerCenterConfig
   */
  async getCustomerCenterConfigAsync(customerCenterConfigId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetCustomerCenterConfig?customerCenterConfigId=" + customerCenterConfigId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_CustomerCenterConfig_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getAllCustomerCenterConfigsAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetAllCustomerCenterConfigs", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_CustomerCenterConfigArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Get all rows from cust_config as an array of CustomerCenterConfig entities
   * @returns An array of CustomerCenterConfig entities
   */
  async getAllCustomerCenterConfigsAsync(webapi_options) {
    return this._getAllCustomerCenterConfigsAsync(webapi_options);
  }
  async _saveAllCustomerCenterConfigsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveAllCustomerCenterConfigs", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveAllCustomerCenterConfigsAsync(custConfigs, webapi_options) {
    let _request = null;
    let _options = null;
    const first = custConfigs;
    if (typeof first === "object" && first && typeof first.custConfigs != "undefined") {
      _request = custConfigs;
      _options = webapi_options;
    } else {
      _request = {
        custConfigs
      };
      _options = webapi_options;
    }
    return this._saveAllCustomerCenterConfigsAsync(_request, _options);
  }
  async _checkIfCustomizedTemplatesAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CheckIfCustomizedTemplates", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Checks whether the core html templates are customized
   * @returns True if the templates are customized
   */
  async checkIfCustomizedTemplatesAsync(webapi_options) {
    return this._checkIfCustomizedTemplatesAsync(webapi_options);
  }
  async _getProgramUrlAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetProgramUrl", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getProgramUrlAsync(programName, external, webapi_options) {
    let _request = null;
    let _options = null;
    const first = programName;
    if (typeof first === "object" && first && (typeof first.programName != "undefined" || typeof first.external != "undefined")) {
      _request = programName;
      _options = external;
    } else {
      _request = {
        programName,
        external
      };
      _options = webapi_options;
    }
    return this._getProgramUrlAsync(_request, _options);
  }
  async _getFaqForCustomerAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetFaqForCustomer", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getFaqForCustomerAsync(faqEntryId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = faqEntryId;
    if (typeof first === "object" && first && typeof first.faqEntryId != "undefined") {
      _request = faqEntryId;
      _options = webapi_options;
    } else {
      _request = {
        faqEntryId
      };
      _options = webapi_options;
    }
    return this._getFaqForCustomerAsync(_request, _options);
  }
  async _getCustomerServiceStartupAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetCustomerServiceStartup", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_CustomerServiceStartup_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Get the carrier with data that Service needs when starting up
   * @returns The carrier containing the startup data
   */
  async getCustomerServiceStartupAsync(webapi_options) {
    return this._getCustomerServiceStartupAsync(webapi_options);
  }
  async _executeEventHandlersAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ExecuteEventHandlers", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_EventData_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async executeEventHandlersAsync(eventData, webapi_options) {
    let _request = null;
    let _options = null;
    const first = eventData;
    if (typeof first === "object" && first && typeof first.eventData != "undefined") {
      _request = eventData;
      _options = webapi_options;
    } else {
      _request = {
        eventData
      };
      _options = webapi_options;
    }
    return this._executeEventHandlersAsync(_request, _options);
  }
  async _getMailboxesAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetMailboxes", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_MailboxArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * This method will get all registered mailboxes in Service
   * @returns An array of Mailbox objects
   */
  async getMailboxesAsync(webapi_options) {
    return this._getMailboxesAsync(webapi_options);
  }
  /*
   * Gets a MailboxEntity object.
   * @param mailboxEntityId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single MailboxEntity
   */
  async getMailboxEntityAsync(mailboxEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetMailboxEntity?mailboxEntityId=" + mailboxEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_MailboxEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getPreviewFaqEntryAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPreviewFaqEntry", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PreviewFaqEntry_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getPreviewFaqEntryAsync(kbEntryId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = kbEntryId;
    if (typeof first === "object" && first && typeof first.kbEntryId != "undefined") {
      _request = kbEntryId;
      _options = webapi_options;
    } else {
      _request = {
        kbEntryId
      };
      _options = webapi_options;
    }
    return this._getPreviewFaqEntryAsync(_request, _options);
  }
  async _getPreviewQuickReplyAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPreviewQuickReply", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PreviewQuickReply_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getPreviewQuickReplyAsync(quickReplyId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = quickReplyId;
    if (typeof first === "object" && first && typeof first.quickReplyId != "undefined") {
      _request = quickReplyId;
      _options = webapi_options;
    } else {
      _request = {
        quickReplyId
      };
      _options = webapi_options;
    }
    return this._getPreviewQuickReplyAsync(_request, _options);
  }
  async _getPreviewReplyTemplateAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPreviewReplyTemplate", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PreviewReplyTemplate_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getPreviewReplyTemplateAsync(replyTemplateId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = replyTemplateId;
    if (typeof first === "object" && first && typeof first.replyTemplateId != "undefined") {
      _request = replyTemplateId;
      _options = webapi_options;
    } else {
      _request = {
        replyTemplateId
      };
      _options = webapi_options;
    }
    return this._getPreviewReplyTemplateAsync(_request, _options);
  }
  async _getParsedTemplateAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetParsedTemplate", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ReplyTemplateParsed_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getParsedTemplateAsync(replyTemplateId, languageId, personId, ticketId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = replyTemplateId;
    if (typeof first === "object" && first && (typeof first.replyTemplateId != "undefined" || typeof first.languageId != "undefined" || typeof first.personId != "undefined" || typeof first.ticketId != "undefined")) {
      _request = replyTemplateId;
      _options = languageId;
    } else {
      _request = {
        replyTemplateId,
        languageId,
        personId,
        ticketId
      };
      _options = webapi_options;
    }
    return this._getParsedTemplateAsync(_request, _options);
  }
  async _getUnparsedTemplateAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetUnparsedTemplate", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ReplyTemplateParsed_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getUnparsedTemplateAsync(replyTemplateId, languageId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = replyTemplateId;
    if (typeof first === "object" && first && (typeof first.replyTemplateId != "undefined" || typeof first.languageId != "undefined")) {
      _request = replyTemplateId;
      _options = languageId;
    } else {
      _request = {
        replyTemplateId,
        languageId
      };
      _options = webapi_options;
    }
    return this._getUnparsedTemplateAsync(_request, _options);
  }
  async _getSmsConfigAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetSmsConfig", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SmsConfig_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Get the SmsConfig settings for Customer Service sms providers.
   * @returns Current SMS configuration.
   */
  async getSmsConfigAsync(webapi_options) {
    return this._getSmsConfigAsync(webapi_options);
  }
  async _testSmtpServerAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("TestSmtpServer", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SmtpTestResult_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async testSmtpServerAsync(smtpUri, from, useStoredPassword, webapi_options) {
    let _request = null;
    let _options = null;
    const first = smtpUri;
    if (typeof first === "object" && first && (typeof first.smtpUri != "undefined" || typeof first.from != "undefined" || typeof first.useStoredPassword != "undefined")) {
      _request = smtpUri;
      _options = from;
    } else {
      _request = {
        smtpUri,
        from,
        useStoredPassword
      };
      _options = webapi_options;
    }
    return this._testSmtpServerAsync(_request, _options);
  }
  async _getStatisticsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetStatistics", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_StatisticsDataSetArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getStatisticsAsync(functions, webapi_options) {
    let _request = null;
    let _options = null;
    const first = functions;
    if (typeof first === "object" && first && typeof first.functions != "undefined") {
      _request = functions;
      _options = webapi_options;
    } else {
      _request = {
        functions
      };
      _options = webapi_options;
    }
    return this._getStatisticsAsync(_request, _options);
  }
  async _getSystemTemplateSettingsAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetSystemTemplateSettings", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SystemTemplateSettings_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Returns system template settings
   * @returns System template settings item
   */
  async getSystemTemplateSettingsAsync(webapi_options) {
    return this._getSystemTemplateSettingsAsync(webapi_options);
  }
  async _saveSystemTemplateSettingsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveSystemTemplateSettings", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SystemTemplateSettings_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveSystemTemplateSettingsAsync(systemTemplateSettings, webapi_options) {
    let _request = null;
    let _options = null;
    const first = systemTemplateSettings;
    if (typeof first === "object" && first && typeof first.systemTemplateSettings != "undefined") {
      _request = systemTemplateSettings;
      _options = webapi_options;
    } else {
      _request = {
        systemTemplateSettings
      };
      _options = webapi_options;
    }
    return this._saveSystemTemplateSettingsAsync(_request, _options);
  }
  async _createTicketFromMailDataAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateTicketFromMailData", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TicketInfo_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createTicketFromMailDataAsync(mailboxId, data, webapi_options) {
    let _request = null;
    let _options = null;
    const first = mailboxId;
    if (typeof first === "object" && first && (typeof first.mailboxId != "undefined" || typeof first.data != "undefined")) {
      _request = mailboxId;
      _options = data;
    } else {
      _request = {
        mailboxId,
        data
      };
      _options = webapi_options;
    }
    return this._createTicketFromMailDataAsync(_request, _options);
  }
  async _addMessageFromMailDataAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("AddMessageFromMailData", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TicketInfo_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async addMessageFromMailDataAsync(ticketId, data, webapi_options) {
    let _request = null;
    let _options = null;
    const first = ticketId;
    if (typeof first === "object" && first && (typeof first.ticketId != "undefined" || typeof first.data != "undefined")) {
      _request = ticketId;
      _options = data;
    } else {
      _request = {
        ticketId,
        data
      };
      _options = webapi_options;
    }
    return this._addMessageFromMailDataAsync(_request, _options);
  }
  async _findTicketsByTitleOrIdAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("FindTicketsByTitleOrId", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TicketInfoArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async findTicketsByTitleOrIdAsync(titleOrId, maxRows, webapi_options) {
    let _request = null;
    let _options = null;
    const first = titleOrId;
    if (typeof first === "object" && first && (typeof first.titleOrId != "undefined" || typeof first.maxRows != "undefined")) {
      _request = titleOrId;
      _options = maxRows;
    } else {
      _request = {
        titleOrId,
        maxRows
      };
      _options = webapi_options;
    }
    return this._findTicketsByTitleOrIdAsync(_request, _options);
  }
};

// server/node_modules/@superoffice/webapi/dist/esm/PocketAgent.js
var PocketAgent = class extends WebApiBase {
  constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
    const options = WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
    options.basePath = "v1/Agents/Pocket/";
    super(options);
  }
  async _getMyCallerIDsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetMyCallerIDs", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_CallerIDCollection_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getMyCallerIDsAsync(lastHash, minDate, maxDate, webapi_options) {
    let _request = null;
    let _options = null;
    const first = lastHash;
    if (typeof first === "object" && first && (typeof first.lastHash != "undefined" || typeof first.minDate != "undefined" || typeof first.maxDate != "undefined")) {
      _request = lastHash;
      _options = minDate;
    } else {
      _request = {
        lastHash,
        minDate,
        maxDate
      };
      _options = webapi_options;
    }
    return this._getMyCallerIDsAsync(_request, _options);
  }
  async _getCallerIDsFromSelectionAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetCallerIDsFromSelection", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_CallerIDCollection_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getCallerIDsFromSelectionAsync(selectionId, lastHash, webapi_options) {
    let _request = null;
    let _options = null;
    const first = selectionId;
    if (typeof first === "object" && first && (typeof first.selectionId != "undefined" || typeof first.lastHash != "undefined")) {
      _request = selectionId;
      _options = lastHash;
    } else {
      _request = {
        selectionId,
        lastHash
      };
      _options = webapi_options;
    }
    return this._getCallerIDsFromSelectionAsync(_request, _options);
  }
  async _getPocketStartupDataAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPocketStartupData", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PocketStartupData_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getPocketStartupDataAsync(tables, currentClientTime, webapi_options) {
    let _request = null;
    let _options = null;
    const first = tables;
    if (typeof first === "object" && first && (typeof first.tables != "undefined" || typeof first.currentClientTime != "undefined")) {
      _request = tables;
      _options = currentClientTime;
    } else {
      _request = {
        tables,
        currentClientTime
      };
      _options = webapi_options;
    }
    return this._getPocketStartupDataAsync(_request, _options);
  }
  async _registerDeviceForPushNotificationAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("RegisterDeviceForPushNotification", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async registerDeviceForPushNotificationAsync(deviceInfo, webapi_options) {
    let _request = null;
    let _options = null;
    const first = deviceInfo;
    if (typeof first === "object" && first && typeof first.deviceInfo != "undefined") {
      _request = deviceInfo;
      _options = webapi_options;
    } else {
      _request = {
        deviceInfo
      };
      _options = webapi_options;
    }
    return this._registerDeviceForPushNotificationAsync(_request, _options);
  }
  async _getRegisteredDevicesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetRegisteredDevices", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PocketDeviceInfoArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getRegisteredDevicesAsync(associateId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = associateId;
    if (typeof first === "object" && first && typeof first.associateId != "undefined") {
      _request = associateId;
      _options = webapi_options;
    } else {
      _request = {
        associateId
      };
      _options = webapi_options;
    }
    return this._getRegisteredDevicesAsync(_request, _options);
  }
  async _setPushNotificationTagsForDeviceAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetPushNotificationTagsForDevice", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setPushNotificationTagsForDeviceAsync(deviceIdentifier, tags, webapi_options) {
    let _request = null;
    let _options = null;
    const first = deviceIdentifier;
    if (typeof first === "object" && first && (typeof first.deviceIdentifier != "undefined" || typeof first.tags != "undefined")) {
      _request = deviceIdentifier;
      _options = tags;
    } else {
      _request = {
        deviceIdentifier,
        tags
      };
      _options = webapi_options;
    }
    return this._setPushNotificationTagsForDeviceAsync(_request, _options);
  }
  async _setPushNotificationTagsForUserAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetPushNotificationTagsForUser", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setPushNotificationTagsForUserAsync(associateId, tags, webapi_options) {
    let _request = null;
    let _options = null;
    const first = associateId;
    if (typeof first === "object" && first && (typeof first.associateId != "undefined" || typeof first.tags != "undefined")) {
      _request = associateId;
      _options = tags;
    } else {
      _request = {
        associateId,
        tags
      };
      _options = webapi_options;
    }
    return this._setPushNotificationTagsForUserAsync(_request, _options);
  }
  async _getPushNotificationTagsForDeviceAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPushNotificationTagsForDevice", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getPushNotificationTagsForDeviceAsync(deviceIdentifier, webapi_options) {
    let _request = null;
    let _options = null;
    const first = deviceIdentifier;
    if (typeof first === "object" && first && typeof first.deviceIdentifier != "undefined") {
      _request = deviceIdentifier;
      _options = webapi_options;
    } else {
      _request = {
        deviceIdentifier
      };
      _options = webapi_options;
    }
    return this._getPushNotificationTagsForDeviceAsync(_request, _options);
  }
  async _sendPushNotificationAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SendPushNotification", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async sendPushNotificationAsync(associateIds, message, webapi_options) {
    let _request = null;
    let _options = null;
    const first = associateIds;
    if (typeof first === "object" && first && (typeof first.associateIds != "undefined" || typeof first.message != "undefined")) {
      _request = associateIds;
      _options = message;
    } else {
      _request = {
        associateIds,
        message
      };
      _options = webapi_options;
    }
    return this._sendPushNotificationAsync(_request, _options);
  }
  async _runAppointmentAlarmBrokerAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("RunAppointmentAlarmBroker", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Execute the AppointmentAlarmBroker once
   * @returns This method has no return value
   */
  async runAppointmentAlarmBrokerAsync(webapi_options) {
    return this._runAppointmentAlarmBrokerAsync(webapi_options);
  }
  async _notifyUsersAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("NotifyUsers", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async notifyUsersAsync(notificationEventType, id, webapi_options) {
    let _request = null;
    let _options = null;
    const first = notificationEventType;
    if (typeof first === "object" && first && (typeof first.notificationEventType != "undefined" || typeof first.id != "undefined")) {
      _request = notificationEventType;
      _options = id;
    } else {
      _request = {
        notificationEventType,
        id
      };
      _options = webapi_options;
    }
    return this._notifyUsersAsync(_request, _options);
  }
  async _notificationHandledAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("NotificationHandled", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async notificationHandledAsync(notificationEventType, id, webapi_options) {
    let _request = null;
    let _options = null;
    const first = notificationEventType;
    if (typeof first === "object" && first && (typeof first.notificationEventType != "undefined" || typeof first.id != "undefined")) {
      _request = notificationEventType;
      _options = id;
    } else {
      _request = {
        notificationEventType,
        id
      };
      _options = webapi_options;
    }
    return this._notificationHandledAsync(_request, _options);
  }
  async _notificationsHandledAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("NotificationsHandled", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async notificationsHandledAsync(notificationEvents, webapi_options) {
    let _request = null;
    let _options = null;
    const first = notificationEvents;
    if (typeof first === "object" && first && typeof first.notificationEvents != "undefined") {
      _request = notificationEvents;
      _options = webapi_options;
    } else {
      _request = {
        notificationEvents
      };
      _options = webapi_options;
    }
    return this._notificationsHandledAsync(_request, _options);
  }
};

// server/node_modules/@superoffice/webapi/dist/esm/DashboardAgent.js
var DashboardAgent = class extends WebApiBase {
  constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
    const options = WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
    options.basePath = "v1/Agents/Dashboard/";
    super(options);
  }
  /**
   * Set default values into a new Dashboard.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultDashboardAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultDashboard", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Dashboard_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing Dashboard or creates a new Dashboard if the id parameter is empty
   * @param entity - The Dashboard to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated Dashboard
   */
  async saveDashboardAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveDashboard", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Dashboard_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Deletes the Dashboard
   * @param DashboardId - The id of the Dashboard to be deleted.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   */
  async deleteDashboardAsync(DashboardId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("DeleteDashboard?DashboardId=" + DashboardId, null, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new DashboardTile.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultDashboardTileAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultDashboardTile", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DashboardTile_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing DashboardTile or creates a new DashboardTile if the id parameter is empty
   * @param entity - The DashboardTile to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated DashboardTile
   */
  async saveDashboardTileAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveDashboardTile", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DashboardTile_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Deletes the DashboardTile
   * @param DashboardTileId - The id of the DashboardTile to be deleted.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   */
  async deleteDashboardTileAsync(DashboardTileId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("DeleteDashboardTile?DashboardTileId=" + DashboardTileId, null, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets a Dashboard object.
   * @param dashboardId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single Dashboard
   */
  async getDashboardAsync(dashboardId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetDashboard?dashboardId=" + dashboardId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Dashboard_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getDashboardsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetDashboards", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DashboardArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getDashboardsAsync(associateId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = associateId;
    if (typeof first === "object" && first && typeof first.associateId != "undefined") {
      _request = associateId;
      _options = webapi_options;
    } else {
      _request = {
        associateId
      };
      _options = webapi_options;
    }
    return this._getDashboardsAsync(_request, _options);
  }
  async _setTileAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetTile", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Dashboard_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setTileAsync(dashboardId, tileId, position, webapi_options) {
    let _request = null;
    let _options = null;
    const first = dashboardId;
    if (typeof first === "object" && first && (typeof first.dashboardId != "undefined" || typeof first.tileId != "undefined" || typeof first.position != "undefined")) {
      _request = dashboardId;
      _options = tileId;
    } else {
      _request = {
        dashboardId,
        tileId,
        position
      };
      _options = webapi_options;
    }
    return this._setTileAsync(_request, _options);
  }
  /*
   * Gets a DashboardTile object.
   * @param dashboardTileId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single DashboardTile
   */
  async getDashboardTileAsync(dashboardTileId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetDashboardTile?dashboardTileId=" + dashboardTileId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DashboardTile_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getDashboardTilesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetDashboardTiles", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DashboardTileArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getDashboardTilesAsync(dashboardTileIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = dashboardTileIds;
    if (typeof first === "object" && first && typeof first.dashboardTileIds != "undefined") {
      _request = dashboardTileIds;
      _options = webapi_options;
    } else {
      _request = {
        dashboardTileIds
      };
      _options = webapi_options;
    }
    return this._getDashboardTilesAsync(_request, _options);
  }
  async _getStandardDashboardTileFromChartIdAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetStandardDashboardTileFromChartId", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DashboardTile_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getStandardDashboardTileFromChartIdAsync(chartId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = chartId;
    if (typeof first === "object" && first && typeof first.chartId != "undefined") {
      _request = chartId;
      _options = webapi_options;
    } else {
      _request = {
        chartId
      };
      _options = webapi_options;
    }
    return this._getStandardDashboardTileFromChartIdAsync(_request, _options);
  }
  async _getDataAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetData", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TileDataArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getDataAsync(dashboardTileId, restrictions, webapi_options) {
    let _request = null;
    let _options = null;
    const first = dashboardTileId;
    if (typeof first === "object" && first && (typeof first.dashboardTileId != "undefined" || typeof first.restrictions != "undefined")) {
      _request = dashboardTileId;
      _options = restrictions;
    } else {
      _request = {
        dashboardTileId,
        restrictions
      };
      _options = webapi_options;
    }
    return this._getDataAsync(_request, _options);
  }
  async _createNewFromTemplateAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateNewFromTemplate", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DashboardTile_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createNewFromTemplateAsync(dashboardTileId, caption, description, selectionId, visibleFor, webapi_options) {
    let _request = null;
    let _options = null;
    const first = dashboardTileId;
    if (typeof first === "object" && first && (typeof first.dashboardTileId != "undefined" || typeof first.caption != "undefined" || typeof first.description != "undefined" || typeof first.selectionId != "undefined" || typeof first.visibleFor != "undefined")) {
      _request = dashboardTileId;
      _options = caption;
    } else {
      _request = {
        dashboardTileId,
        caption,
        description,
        selectionId,
        visibleFor
      };
      _options = webapi_options;
    }
    return this._createNewFromTemplateAsync(_request, _options);
  }
  async _getDataWithSelectionAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetDataWithSelection", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TileDataArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getDataWithSelectionAsync(dashboardTileId, selectionId, restrictions, webapi_options) {
    let _request = null;
    let _options = null;
    const first = dashboardTileId;
    if (typeof first === "object" && first && (typeof first.dashboardTileId != "undefined" || typeof first.selectionId != "undefined" || typeof first.restrictions != "undefined")) {
      _request = dashboardTileId;
      _options = selectionId;
    } else {
      _request = {
        dashboardTileId,
        selectionId,
        restrictions
      };
      _options = webapi_options;
    }
    return this._getDataWithSelectionAsync(_request, _options);
  }
};

// server/node_modules/@superoffice/webapi/dist/esm/DashAgent.js
var DashAgent = class extends WebApiBase {
  constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
    const options = WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
    options.basePath = "v1/Agents/Dash/";
    super(options);
  }
  /**
   * Set default values into a new Dash.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultDashAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultDash", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Dash_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing Dash or creates a new Dash if the id parameter is empty
   * @param entity - The Dash to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated Dash
   */
  async saveDashAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveDash", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Dash_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Deletes the Dash
   * @param DashId - The id of the Dash to be deleted.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   */
  async deleteDashAsync(DashId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("DeleteDash?DashId=" + DashId, null, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new DashCollection.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultDashCollectionAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultDashCollection", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DashCollection_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new DashTheme.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultDashThemeAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultDashTheme", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DashTheme_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing DashTheme or creates a new DashTheme if the id parameter is empty
   * @param entity - The DashTheme to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated DashTheme
   */
  async saveDashThemeAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveDashTheme", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DashTheme_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Deletes the DashTheme
   * @param DashThemeId - The id of the DashTheme to be deleted.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   */
  async deleteDashThemeAsync(DashThemeId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("DeleteDashTheme?DashThemeId=" + DashThemeId, null, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new DashTile.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultDashTileAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultDashTile", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DashTile_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing DashTile or creates a new DashTile if the id parameter is empty
   * @param entity - The DashTile to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated DashTile
   */
  async saveDashTileAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveDashTile", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DashTile_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Deletes the DashTile
   * @param DashTileId - The id of the DashTile to be deleted.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   */
  async deleteDashTileAsync(DashTileId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("DeleteDashTile?DashTileId=" + DashTileId, null, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new DashTileDefinition.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultDashTileDefinitionAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultDashTileDefinition", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DashTileDefinition_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing DashTileDefinition or creates a new DashTileDefinition if the id parameter is empty
   * @param entity - The DashTileDefinition to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated DashTileDefinition
   */
  async saveDashTileDefinitionAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveDashTileDefinition", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DashTileDefinition_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Deletes the DashTileDefinition
   * @param DashTileDefinitionId - The id of the DashTileDefinition to be deleted.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   */
  async deleteDashTileDefinitionAsync(DashTileDefinitionId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("DeleteDashTileDefinition?DashTileDefinitionId=" + DashTileDefinitionId, null, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new PreviewDash.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultPreviewDashAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultPreviewDash", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PreviewDash_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new PreviewDashTile.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultPreviewDashTileAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultPreviewDashTile", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PreviewDashTile_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets a Dash object.
   * @param dashId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single Dash
   */
  async getDashAsync(dashId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetDash?dashId=" + dashId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Dash_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _addTileToDashboardAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("AddTileToDashboard", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DashTile_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async addTileToDashboardAsync(dashboardId, dashTileDefinitionId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = dashboardId;
    if (typeof first === "object" && first && (typeof first.dashboardId != "undefined" || typeof first.dashTileDefinitionId != "undefined")) {
      _request = dashboardId;
      _options = dashTileDefinitionId;
    } else {
      _request = {
        dashboardId,
        dashTileDefinitionId
      };
      _options = webapi_options;
    }
    return this._addTileToDashboardAsync(_request, _options);
  }
  async _addNewTileToDashboardAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("AddNewTileToDashboard", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DashTile_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async addNewTileToDashboardAsync(dashboardId, dashTileDefinition, webapi_options) {
    let _request = null;
    let _options = null;
    const first = dashboardId;
    if (typeof first === "object" && first && (typeof first.dashboardId != "undefined" || typeof first.dashTileDefinition != "undefined")) {
      _request = dashboardId;
      _options = dashTileDefinition;
    } else {
      _request = {
        dashboardId,
        dashTileDefinition
      };
      _options = webapi_options;
    }
    return this._addNewTileToDashboardAsync(_request, _options);
  }
  async _duplicateDashboardAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DuplicateDashboard", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Dash_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async duplicateDashboardAsync(dashboardId, name, webapi_options) {
    let _request = null;
    let _options = null;
    const first = dashboardId;
    if (typeof first === "object" && first && (typeof first.dashboardId != "undefined" || typeof first.name != "undefined")) {
      _request = dashboardId;
      _options = name;
    } else {
      _request = {
        dashboardId,
        name
      };
      _options = webapi_options;
    }
    return this._duplicateDashboardAsync(_request, _options);
  }
  async _getDashListAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetDashList", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DashArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getDashListAsync(dashboards, webapi_options) {
    let _request = null;
    let _options = null;
    const first = dashboards;
    if (typeof first === "object" && first && typeof first.dashboards != "undefined") {
      _request = dashboards;
      _options = webapi_options;
    } else {
      _request = {
        dashboards
      };
      _options = webapi_options;
    }
    return this._getDashListAsync(_request, _options);
  }
  async _getDashCollectionAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetDashCollection", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DashCollection_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Gets a collection of dashboards for the current associate
   * @returns Dashboard collection
   */
  async getDashCollectionAsync(webapi_options) {
    return this._getDashCollectionAsync(webapi_options);
  }
  /*
   * Gets a DashTheme object.
   * @param dashThemeId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single DashTheme
   */
  async getDashThemeAsync(dashThemeId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetDashTheme?dashThemeId=" + dashThemeId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DashTheme_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets a DashTile object.
   * @param dashTileId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single DashTile
   */
  async getDashTileAsync(dashTileId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetDashTile?dashTileId=" + dashTileId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DashTile_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getDashTilesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetDashTiles", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DashTileArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getDashTilesAsync(dashboardId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = dashboardId;
    if (typeof first === "object" && first && typeof first.dashboardId != "undefined") {
      _request = dashboardId;
      _options = webapi_options;
    } else {
      _request = {
        dashboardId
      };
      _options = webapi_options;
    }
    return this._getDashTilesAsync(_request, _options);
  }
  async _saveDashTilesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveDashTiles", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveDashTilesAsync(dashboardId, dashTiles, webapi_options) {
    let _request = null;
    let _options = null;
    const first = dashboardId;
    if (typeof first === "object" && first && (typeof first.dashboardId != "undefined" || typeof first.dashTiles != "undefined")) {
      _request = dashboardId;
      _options = dashTiles;
    } else {
      _request = {
        dashboardId,
        dashTiles
      };
      _options = webapi_options;
    }
    return this._saveDashTilesAsync(_request, _options);
  }
  async _createDashTileSelectionFromEntityAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateDashTileSelectionFromEntity", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createDashTileSelectionFromEntityAsync(entityName, webapi_options) {
    let _request = null;
    let _options = null;
    const first = entityName;
    if (typeof first === "object" && first && typeof first.entityName != "undefined") {
      _request = entityName;
      _options = webapi_options;
    } else {
      _request = {
        entityName
      };
      _options = webapi_options;
    }
    return this._createDashTileSelectionFromEntityAsync(_request, _options);
  }
  async _copyTileSelectionAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CopyTileSelection", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async copyTileSelectionAsync(selectionId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = selectionId;
    if (typeof first === "object" && first && typeof first.selectionId != "undefined") {
      _request = selectionId;
      _options = webapi_options;
    } else {
      _request = {
        selectionId
      };
      _options = webapi_options;
    }
    return this._copyTileSelectionAsync(_request, _options);
  }
  async _getTempTileSelectionAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetTempTileSelection", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getTempTileSelectionAsync(selectionId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = selectionId;
    if (typeof first === "object" && first && typeof first.selectionId != "undefined") {
      _request = selectionId;
      _options = webapi_options;
    } else {
      _request = {
        selectionId
      };
      _options = webapi_options;
    }
    return this._getTempTileSelectionAsync(_request, _options);
  }
  async _getSecondaryTempTileSelectionAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetSecondaryTempTileSelection", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getSecondaryTempTileSelectionAsync(selectionId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = selectionId;
    if (typeof first === "object" && first && typeof first.selectionId != "undefined") {
      _request = selectionId;
      _options = webapi_options;
    } else {
      _request = {
        selectionId
      };
      _options = webapi_options;
    }
    return this._getSecondaryTempTileSelectionAsync(_request, _options);
  }
  async _createDefaultTileForEntityAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateDefaultTileForEntity", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DashTile_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createDefaultTileForEntityAsync(entityName, webapi_options) {
    let _request = null;
    let _options = null;
    const first = entityName;
    if (typeof first === "object" && first && typeof first.entityName != "undefined") {
      _request = entityName;
      _options = webapi_options;
    } else {
      _request = {
        entityName
      };
      _options = webapi_options;
    }
    return this._createDefaultTileForEntityAsync(_request, _options);
  }
  async _duplicateTileAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DuplicateTile", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DashTile_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async duplicateTileAsync(dashTileId, name, webapi_options) {
    let _request = null;
    let _options = null;
    const first = dashTileId;
    if (typeof first === "object" && first && (typeof first.dashTileId != "undefined" || typeof first.name != "undefined")) {
      _request = dashTileId;
      _options = name;
    } else {
      _request = {
        dashTileId,
        name
      };
      _options = webapi_options;
    }
    return this._duplicateTileAsync(_request, _options);
  }
  /*
   * Gets a DashTileDefinition object.
   * @param dashTileDefinitionId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single DashTileDefinition
   */
  async getDashTileDefinitionAsync(dashTileDefinitionId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetDashTileDefinition?dashTileDefinitionId=" + dashTileDefinitionId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DashTileDefinition_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _createDefaultTileDefinitionForEntityAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateDefaultTileDefinitionForEntity", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DashTileDefinition_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createDefaultTileDefinitionForEntityAsync(entityName, webapi_options) {
    let _request = null;
    let _options = null;
    const first = entityName;
    if (typeof first === "object" && first && typeof first.entityName != "undefined") {
      _request = entityName;
      _options = webapi_options;
    } else {
      _request = {
        entityName
      };
      _options = webapi_options;
    }
    return this._createDefaultTileDefinitionForEntityAsync(_request, _options);
  }
  async _getDashTileHtmlAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetDashTileHtml", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DashTileHtml_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getDashTileHtmlAsync(dashboardTileDefinitionId, languageCode, webapi_options) {
    let _request = null;
    let _options = null;
    const first = dashboardTileDefinitionId;
    if (typeof first === "object" && first && (typeof first.dashboardTileDefinitionId != "undefined" || typeof first.languageCode != "undefined")) {
      _request = dashboardTileDefinitionId;
      _options = languageCode;
    } else {
      _request = {
        dashboardTileDefinitionId,
        languageCode
      };
      _options = webapi_options;
    }
    return this._getDashTileHtmlAsync(_request, _options);
  }
  async _getDashTileHtmlListAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetDashTileHtmlList", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DashTileHtmlArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getDashTileHtmlListAsync(dashboardTileDefinitionId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = dashboardTileDefinitionId;
    if (typeof first === "object" && first && typeof first.dashboardTileDefinitionId != "undefined") {
      _request = dashboardTileDefinitionId;
      _options = webapi_options;
    } else {
      _request = {
        dashboardTileDefinitionId
      };
      _options = webapi_options;
    }
    return this._getDashTileHtmlListAsync(_request, _options);
  }
  async _saveDashTileHtmlListAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveDashTileHtmlList", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DashTileHtmlArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveDashTileHtmlListAsync(dashboardTileDefinitionId, languages, webapi_options) {
    let _request = null;
    let _options = null;
    const first = dashboardTileDefinitionId;
    if (typeof first === "object" && first && (typeof first.dashboardTileDefinitionId != "undefined" || typeof first.languages != "undefined")) {
      _request = dashboardTileDefinitionId;
      _options = languages;
    } else {
      _request = {
        dashboardTileDefinitionId,
        languages
      };
      _options = webapi_options;
    }
    return this._saveDashTileHtmlListAsync(_request, _options);
  }
  async _getPreviewDashAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPreviewDash", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PreviewDash_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getPreviewDashAsync(dashboardId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = dashboardId;
    if (typeof first === "object" && first && typeof first.dashboardId != "undefined") {
      _request = dashboardId;
      _options = webapi_options;
    } else {
      _request = {
        dashboardId
      };
      _options = webapi_options;
    }
    return this._getPreviewDashAsync(_request, _options);
  }
};

// server/node_modules/@superoffice/webapi/dist/esm/TargetsAgent.js
var TargetsAgent = class extends WebApiBase {
  constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
    const options = WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
    options.basePath = "v1/Agents/Targets/";
    super(options);
  }
  /**
   * Set default values into a new TargetAssignment.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultTargetAssignmentAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultTargetAssignment", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TargetAssignment_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new TargetDimension.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultTargetDimensionAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultTargetDimension", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TargetDimension_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing TargetDimension or creates a new TargetDimension if the id parameter is empty
   * @param entity - The TargetDimension to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated TargetDimension
   */
  async saveTargetDimensionAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveTargetDimension", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TargetDimension_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Deletes the TargetDimension
   * @param TargetDimensionId - The id of the TargetDimension to be deleted.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   */
  async deleteTargetDimensionAsync(TargetDimensionId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("DeleteTargetDimension?TargetDimensionId=" + TargetDimensionId, null, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new TargetGroup.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultTargetGroupAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultTargetGroup", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TargetGroup_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing TargetGroup or creates a new TargetGroup if the id parameter is empty
   * @param entity - The TargetGroup to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated TargetGroup
   */
  async saveTargetGroupAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveTargetGroup", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TargetGroup_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Deletes the TargetGroup
   * @param TargetGroupId - The id of the TargetGroup to be deleted.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   */
  async deleteTargetGroupAsync(TargetGroupId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("DeleteTargetGroup?TargetGroupId=" + TargetGroupId, null, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new TargetRevision.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultTargetRevisionAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultTargetRevision", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TargetRevision_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new TargetRevisionHistory.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultTargetRevisionHistoryAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultTargetRevisionHistory", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TargetRevisionHistory_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _createDefaultTargetAssignmentForCompanyAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateDefaultTargetAssignmentForCompany", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TargetAssignment_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Returns a default target assignment for the owner company.
   * @returns Default target assignment for the owner company.
   */
  async createDefaultTargetAssignmentForCompanyAsync(webapi_options) {
    return this._createDefaultTargetAssignmentForCompanyAsync(webapi_options);
  }
  async _createDefaultTargetAssignmentForUserGroupAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateDefaultTargetAssignmentForUserGroup", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TargetAssignmentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createDefaultTargetAssignmentForUserGroupAsync(userGroupId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = userGroupId;
    if (typeof first === "object" && first && typeof first.userGroupId != "undefined") {
      _request = userGroupId;
      _options = webapi_options;
    } else {
      _request = {
        userGroupId
      };
      _options = webapi_options;
    }
    return this._createDefaultTargetAssignmentForUserGroupAsync(_request, _options);
  }
  async _getTargetAssignmentForYearAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetTargetAssignmentForYear", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TargetAssignment_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getTargetAssignmentForYearAsync(targetYear, entityType, targetLevel, id, webapi_options) {
    let _request = null;
    let _options = null;
    const first = targetYear;
    if (typeof first === "object" && first && (typeof first.targetYear != "undefined" || typeof first.entityType != "undefined" || typeof first.targetLevel != "undefined" || typeof first.id != "undefined")) {
      _request = targetYear;
      _options = entityType;
    } else {
      _request = {
        targetYear,
        entityType,
        targetLevel,
        id
      };
      _options = webapi_options;
    }
    return this._getTargetAssignmentForYearAsync(_request, _options);
  }
  async _createDefaultTargetAssignmentForCompanyWithDimensionAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateDefaultTargetAssignmentForCompanyWithDimension", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TargetAssignmentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createDefaultTargetAssignmentForCompanyWithDimensionAsync(targetDimensionId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = targetDimensionId;
    if (typeof first === "object" && first && typeof first.targetDimensionId != "undefined") {
      _request = targetDimensionId;
      _options = webapi_options;
    } else {
      _request = {
        targetDimensionId
      };
      _options = webapi_options;
    }
    return this._createDefaultTargetAssignmentForCompanyWithDimensionAsync(_request, _options);
  }
  async _createDefaultTargetAssignmentForUserGroupWithDimensionAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateDefaultTargetAssignmentForUserGroupWithDimension", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TargetAssignmentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createDefaultTargetAssignmentForUserGroupWithDimensionAsync(userGroupId, targetDimensionId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = userGroupId;
    if (typeof first === "object" && first && (typeof first.userGroupId != "undefined" || typeof first.targetDimensionId != "undefined")) {
      _request = userGroupId;
      _options = targetDimensionId;
    } else {
      _request = {
        userGroupId,
        targetDimensionId
      };
      _options = webapi_options;
    }
    return this._createDefaultTargetAssignmentForUserGroupWithDimensionAsync(_request, _options);
  }
  async _getTargetAssignmentForYearAndDimensionAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetTargetAssignmentForYearAndDimension", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TargetAssignment_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getTargetAssignmentForYearAndDimensionAsync(targetYear, entityType, targetLevel, id, dimensionId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = targetYear;
    if (typeof first === "object" && first && (typeof first.targetYear != "undefined" || typeof first.entityType != "undefined" || typeof first.targetLevel != "undefined" || typeof first.id != "undefined" || typeof first.dimensionId != "undefined")) {
      _request = targetYear;
      _options = entityType;
    } else {
      _request = {
        targetYear,
        entityType,
        targetLevel,
        id,
        dimensionId
      };
      _options = webapi_options;
    }
    return this._getTargetAssignmentForYearAndDimensionAsync(_request, _options);
  }
  async _createDefaultTargetAssignmentForCompanyWithYearAndDimensionAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateDefaultTargetAssignmentForCompanyWithYearAndDimension", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TargetAssignmentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createDefaultTargetAssignmentForCompanyWithYearAndDimensionAsync(year, targetDimensionId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = year;
    if (typeof first === "object" && first && (typeof first.year != "undefined" || typeof first.targetDimensionId != "undefined")) {
      _request = year;
      _options = targetDimensionId;
    } else {
      _request = {
        year,
        targetDimensionId
      };
      _options = webapi_options;
    }
    return this._createDefaultTargetAssignmentForCompanyWithYearAndDimensionAsync(_request, _options);
  }
  async _createDefaultTargetAssignmentForUserGroupWithYearAndDimensionAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateDefaultTargetAssignmentForUserGroupWithYearAndDimension", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TargetAssignmentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createDefaultTargetAssignmentForUserGroupWithYearAndDimensionAsync(userGroupId, year, targetDimensionId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = userGroupId;
    if (typeof first === "object" && first && (typeof first.userGroupId != "undefined" || typeof first.year != "undefined" || typeof first.targetDimensionId != "undefined")) {
      _request = userGroupId;
      _options = year;
    } else {
      _request = {
        userGroupId,
        year,
        targetDimensionId
      };
      _options = webapi_options;
    }
    return this._createDefaultTargetAssignmentForUserGroupWithYearAndDimensionAsync(_request, _options);
  }
  /*
   * Gets a TargetDimension object.
   * @param targetDimensionId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single TargetDimension
   */
  async getTargetDimensionAsync(targetDimensionId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetTargetDimension?targetDimensionId=" + targetDimensionId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TargetDimension_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getTargetDimensionsForEntityTypeAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetTargetDimensionsForEntityType", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TargetDimensionArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getTargetDimensionsForEntityTypeAsync(entityType, webapi_options) {
    let _request = null;
    let _options = null;
    const first = entityType;
    if (typeof first === "object" && first && typeof first.entityType != "undefined") {
      _request = entityType;
      _options = webapi_options;
    } else {
      _request = {
        entityType
      };
      _options = webapi_options;
    }
    return this._getTargetDimensionsForEntityTypeAsync(_request, _options);
  }
  async _getTargetGroupIdsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetTargetGroupIds", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getTargetGroupIdsAsync(targetDimensionId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = targetDimensionId;
    if (typeof first === "object" && first && typeof first.targetDimensionId != "undefined") {
      _request = targetDimensionId;
      _options = webapi_options;
    } else {
      _request = {
        targetDimensionId
      };
      _options = webapi_options;
    }
    return this._getTargetGroupIdsAsync(_request, _options);
  }
  /*
   * Gets a TargetGroup object.
   * @param targetGroupId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single TargetGroup
   */
  async getTargetGroupAsync(targetGroupId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetTargetGroup?targetGroupId=" + targetGroupId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TargetGroup_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getTargetGroupForYearAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetTargetGroupForYear", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TargetGroup_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getTargetGroupForYearAsync(targetYear, entityType, webapi_options) {
    let _request = null;
    let _options = null;
    const first = targetYear;
    if (typeof first === "object" && first && (typeof first.targetYear != "undefined" || typeof first.entityType != "undefined")) {
      _request = targetYear;
      _options = entityType;
    } else {
      _request = {
        targetYear,
        entityType
      };
      _options = webapi_options;
    }
    return this._getTargetGroupForYearAsync(_request, _options);
  }
  async _exportTargetGroupToExcelAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ExportTargetGroupToExcel", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ExportArchiveResult_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async exportTargetGroupToExcelAsync(targetGroupId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = targetGroupId;
    if (typeof first === "object" && first && typeof first.targetGroupId != "undefined") {
      _request = targetGroupId;
      _options = webapi_options;
    } else {
      _request = {
        targetGroupId
      };
      _options = webapi_options;
    }
    return this._exportTargetGroupToExcelAsync(_request, _options);
  }
  async _getTargetGroupForYearAndDimensionAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetTargetGroupForYearAndDimension", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TargetGroup_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getTargetGroupForYearAndDimensionAsync(targetYear, dimensionId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = targetYear;
    if (typeof first === "object" && first && (typeof first.targetYear != "undefined" || typeof first.dimensionId != "undefined")) {
      _request = targetYear;
      _options = dimensionId;
    } else {
      _request = {
        targetYear,
        dimensionId
      };
      _options = webapi_options;
    }
    return this._getTargetGroupForYearAndDimensionAsync(_request, _options);
  }
  async _getTargetRevisionHistoryAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetTargetRevisionHistory", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TargetRevisionHistory_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getTargetRevisionHistoryAsync(targetAssignmentInfoId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = targetAssignmentInfoId;
    if (typeof first === "object" && first && typeof first.targetAssignmentInfoId != "undefined") {
      _request = targetAssignmentInfoId;
      _options = webapi_options;
    } else {
      _request = {
        targetAssignmentInfoId
      };
      _options = webapi_options;
    }
    return this._getTargetRevisionHistoryAsync(_request, _options);
  }
};

// server/node_modules/@superoffice/webapi/dist/esm/FavouriteAgent.js
var FavouriteAgent = class extends WebApiBase {
  constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
    const options = WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
    options.basePath = "v1/Agents/Favourite/";
    super(options);
  }
  async _isFavouriteAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("IsFavourite", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async isFavouriteAsync(tableName, recordId, associateId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = tableName;
    if (typeof first === "object" && first && (typeof first.tableName != "undefined" || typeof first.recordId != "undefined" || typeof first.associateId != "undefined")) {
      _request = tableName;
      _options = recordId;
    } else {
      _request = {
        tableName,
        recordId,
        associateId
      };
      _options = webapi_options;
    }
    return this._isFavouriteAsync(_request, _options);
  }
  async _addFavouriteAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("AddFavourite", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async addFavouriteAsync(tableName, recordId, associateId, extraInfo, webapi_options) {
    let _request = null;
    let _options = null;
    const first = tableName;
    if (typeof first === "object" && first && (typeof first.tableName != "undefined" || typeof first.recordId != "undefined" || typeof first.associateId != "undefined" || typeof first.extraInfo != "undefined")) {
      _request = tableName;
      _options = recordId;
    } else {
      _request = {
        tableName,
        recordId,
        associateId,
        extraInfo
      };
      _options = webapi_options;
    }
    return this._addFavouriteAsync(_request, _options);
  }
  async _addFavouritesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("AddFavourites", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async addFavouritesAsync(tableName, recordIds, associateId, extraInfo, webapi_options) {
    let _request = null;
    let _options = null;
    const first = tableName;
    if (typeof first === "object" && first && (typeof first.tableName != "undefined" || typeof first.recordIds != "undefined" || typeof first.associateId != "undefined" || typeof first.extraInfo != "undefined")) {
      _request = tableName;
      _options = recordIds;
    } else {
      _request = {
        tableName,
        recordIds,
        associateId,
        extraInfo
      };
      _options = webapi_options;
    }
    return this._addFavouritesAsync(_request, _options);
  }
  async _addTicketsToFavouritesByProviderAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("AddTicketsToFavouritesByProvider", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async addTicketsToFavouritesByProviderAsync(providerName, restrictions, associateId, extraInfo, webapi_options) {
    let _request = null;
    let _options = null;
    const first = providerName;
    if (typeof first === "object" && first && (typeof first.providerName != "undefined" || typeof first.restrictions != "undefined" || typeof first.associateId != "undefined" || typeof first.extraInfo != "undefined")) {
      _request = providerName;
      _options = restrictions;
    } else {
      _request = {
        providerName,
        restrictions,
        associateId,
        extraInfo
      };
      _options = webapi_options;
    }
    return this._addTicketsToFavouritesByProviderAsync(_request, _options);
  }
  async _removeFavouritesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("RemoveFavourites", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async removeFavouritesAsync(tableName, recordIds, associateId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = tableName;
    if (typeof first === "object" && first && (typeof first.tableName != "undefined" || typeof first.recordIds != "undefined" || typeof first.associateId != "undefined")) {
      _request = tableName;
      _options = recordIds;
    } else {
      _request = {
        tableName,
        recordIds,
        associateId
      };
      _options = webapi_options;
    }
    return this._removeFavouritesAsync(_request, _options);
  }
  async _removeTicketsFromFavouritesByProviderAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("RemoveTicketsFromFavouritesByProvider", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async removeTicketsFromFavouritesByProviderAsync(providerName, restrictions, associateId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = providerName;
    if (typeof first === "object" && first && (typeof first.providerName != "undefined" || typeof first.restrictions != "undefined" || typeof first.associateId != "undefined")) {
      _request = providerName;
      _options = restrictions;
    } else {
      _request = {
        providerName,
        restrictions,
        associateId
      };
      _options = webapi_options;
    }
    return this._removeTicketsFromFavouritesByProviderAsync(_request, _options);
  }
  async _getFavouritesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetFavourites", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_FavouriteArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getFavouritesAsync(tableName, associateId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = tableName;
    if (typeof first === "object" && first && (typeof first.tableName != "undefined" || typeof first.associateId != "undefined")) {
      _request = tableName;
      _options = associateId;
    } else {
      _request = {
        tableName,
        associateId
      };
      _options = webapi_options;
    }
    return this._getFavouritesAsync(_request, _options);
  }
  async _removeFavouriteAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("RemoveFavourite", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async removeFavouriteAsync(tableName, recordId, associateId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = tableName;
    if (typeof first === "object" && first && (typeof first.tableName != "undefined" || typeof first.recordId != "undefined" || typeof first.associateId != "undefined")) {
      _request = tableName;
      _options = recordId;
    } else {
      _request = {
        tableName,
        recordId,
        associateId
      };
      _options = webapi_options;
    }
    return this._removeFavouriteAsync(_request, _options);
  }
  async _removeAllFavouritesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("RemoveAllFavourites", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async removeAllFavouritesAsync(tableName, associateId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = tableName;
    if (typeof first === "object" && first && (typeof first.tableName != "undefined" || typeof first.associateId != "undefined")) {
      _request = tableName;
      _options = associateId;
    } else {
      _request = {
        tableName,
        associateId
      };
      _options = webapi_options;
    }
    return this._removeAllFavouritesAsync(_request, _options);
  }
  async _toggleFavouriteAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ToggleFavourite", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async toggleFavouriteAsync(tableName, recordId, associateId, extraInfo, webapi_options) {
    let _request = null;
    let _options = null;
    const first = tableName;
    if (typeof first === "object" && first && (typeof first.tableName != "undefined" || typeof first.recordId != "undefined" || typeof first.associateId != "undefined" || typeof first.extraInfo != "undefined")) {
      _request = tableName;
      _options = recordId;
    } else {
      _request = {
        tableName,
        recordId,
        associateId,
        extraInfo
      };
      _options = webapi_options;
    }
    return this._toggleFavouriteAsync(_request, _options);
  }
  async _removeFavouritesByIdAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("RemoveFavouritesById", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async removeFavouritesByIdAsync(favouriteIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = favouriteIds;
    if (typeof first === "object" && first && typeof first.favouriteIds != "undefined") {
      _request = favouriteIds;
      _options = webapi_options;
    } else {
      _request = {
        favouriteIds
      };
      _options = webapi_options;
    }
    return this._removeFavouritesByIdAsync(_request, _options);
  }
};

// server/node_modules/@superoffice/webapi/dist/esm/DatabaseAgent.js
var DatabaseAgent = class extends WebApiBase {
  constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
    const options = WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
    options.basePath = "v1/Agents/Database/";
    super(options);
  }
  async _getStepsInDatabaseAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetStepsInDatabase", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DictionaryStepInformationArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Get information about the dictionary steps that are in the currently-loggedon database
   * @returns Array of dictionary steps in the database, listing only the highest number for each step
   */
  async getStepsInDatabaseAsync(webapi_options) {
    return this._getStepsInDatabaseAsync(webapi_options);
  }
  async _getStepsFromNetServerCodeAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetStepsFromNetServerCode", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DictionaryStepInformationArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Get information about the dictionary steps that NetServer was generated for
   * @returns Array of dictionary steps used when NetServer was generated, listing only the highest number for each step
   */
  async getStepsFromNetServerCodeAsync(webapi_options) {
    return this._getStepsFromNetServerCodeAsync(webapi_options);
  }
};

// server/node_modules/@superoffice/webapi/dist/esm/BulkUpdateAgent.js
var BulkUpdateAgent = class extends WebApiBase {
  constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
    const options = WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
    options.basePath = "v1/Agents/BulkUpdate/";
    super(options);
  }
  async _getAvailableFieldsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetAvailableFields", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_FieldValueInfoArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getAvailableFieldsAsync(tablename, webapi_options) {
    let _request = null;
    let _options = null;
    const first = tablename;
    if (typeof first === "object" && first && typeof first.tablename != "undefined") {
      _request = tablename;
      _options = webapi_options;
    } else {
      _request = {
        tablename
      };
      _options = webapi_options;
    }
    return this._getAvailableFieldsAsync(_request, _options);
  }
  async _getStoredFieldsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetStoredFields", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_FieldValueInfoArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getStoredFieldsAsync(tablename, context, webapi_options) {
    let _request = null;
    let _options = null;
    const first = tablename;
    if (typeof first === "object" && first && (typeof first.tablename != "undefined" || typeof first.context != "undefined")) {
      _request = tablename;
      _options = context;
    } else {
      _request = {
        tablename,
        context
      };
      _options = webapi_options;
    }
    return this._getStoredFieldsAsync(_request, _options);
  }
  async _executeBySelectionIdAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ExecuteBySelectionId", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async executeBySelectionIdAsync(fieldValueInfos, tableName, context, selectionId, isShadow, webapi_options) {
    let _request = null;
    let _options = null;
    const first = fieldValueInfos;
    if (typeof first === "object" && first && (typeof first.fieldValueInfos != "undefined" || typeof first.tableName != "undefined" || typeof first.context != "undefined" || typeof first.selectionId != "undefined" || typeof first.isShadow != "undefined")) {
      _request = fieldValueInfos;
      _options = tableName;
    } else {
      _request = {
        fieldValueInfos,
        tableName,
        context,
        selectionId,
        isShadow
      };
      _options = webapi_options;
    }
    return this._executeBySelectionIdAsync(_request, _options);
  }
  async _executeByEntityIdsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ExecuteByEntityIds", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async executeByEntityIdsAsync(fieldValueInfos, tableName, context, ids, webapi_options) {
    let _request = null;
    let _options = null;
    const first = fieldValueInfos;
    if (typeof first === "object" && first && (typeof first.fieldValueInfos != "undefined" || typeof first.tableName != "undefined" || typeof first.context != "undefined" || typeof first.ids != "undefined")) {
      _request = fieldValueInfos;
      _options = tableName;
    } else {
      _request = {
        fieldValueInfos,
        tableName,
        context,
        ids
      };
      _options = webapi_options;
    }
    return this._executeByEntityIdsAsync(_request, _options);
  }
  async _getJobResultsFromStorageAsJsonAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetJobResultsFromStorageAsJson", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Get result of the batchupdate job
   * @returns Result of job as json
   */
  async getJobResultsFromStorageAsJsonAsync(webapi_options) {
    return this._getJobResultsFromStorageAsJsonAsync(webapi_options);
  }
  async _removeStoredFieldsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("RemoveStoredFields", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async removeStoredFieldsAsync(tableName, context, webapi_options) {
    let _request = null;
    let _options = null;
    const first = tableName;
    if (typeof first === "object" && first && (typeof first.tableName != "undefined" || typeof first.context != "undefined")) {
      _request = tableName;
      _options = context;
    } else {
      _request = {
        tableName,
        context
      };
      _options = webapi_options;
    }
    return this._removeStoredFieldsAsync(_request, _options);
  }
  async _removeStoredFieldsAndGetDefaultFieldsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("RemoveStoredFieldsAndGetDefaultFields", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_FieldValueInfoArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async removeStoredFieldsAndGetDefaultFieldsAsync(tableName, context, webapi_options) {
    let _request = null;
    let _options = null;
    const first = tableName;
    if (typeof first === "object" && first && (typeof first.tableName != "undefined" || typeof first.context != "undefined")) {
      _request = tableName;
      _options = context;
    } else {
      _request = {
        tableName,
        context
      };
      _options = webapi_options;
    }
    return this._removeStoredFieldsAndGetDefaultFieldsAsync(_request, _options);
  }
  async _getJobResultAsJsonFromBinaryObjectIdAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetJobResultAsJsonFromBinaryObjectId", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getJobResultAsJsonFromBinaryObjectIdAsync(tableName, binaryObjectId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = tableName;
    if (typeof first === "object" && first && (typeof first.tableName != "undefined" || typeof first.binaryObjectId != "undefined")) {
      _request = tableName;
      _options = binaryObjectId;
    } else {
      _request = {
        tableName,
        binaryObjectId
      };
      _options = webapi_options;
    }
    return this._getJobResultAsJsonFromBinaryObjectIdAsync(_request, _options);
  }
};

// server/node_modules/@superoffice/webapi/dist/esm/MarketingAgent.js
var MarketingAgent = class extends WebApiBase {
  constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
    const options = WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
    options.basePath = "v1/Agents/Marketing/";
    super(options);
  }
  /**
   * Set default values into a new FormEntity.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultFormEntityAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultFormEntity", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_FormEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing FormEntity or creates a new FormEntity if the id parameter is empty
   * @param entity - The FormEntity to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated FormEntity
   */
  async saveFormEntityAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveFormEntity", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_FormEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Deletes the FormEntity
   * @param FormEntityId - The id of the FormEntity to be deleted.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   */
  async deleteFormEntityAsync(FormEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("DeleteFormEntity?FormEntityId=" + FormEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new FormSubmissionEntity.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultFormSubmissionEntityAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultFormSubmissionEntity", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_FormSubmissionEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing FormSubmissionEntity or creates a new FormSubmissionEntity if the id parameter is empty
   * @param entity - The FormSubmissionEntity to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated FormSubmissionEntity
   */
  async saveFormSubmissionEntityAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveFormSubmissionEntity", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_FormSubmissionEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Deletes the FormSubmissionEntity
   * @param FormSubmissionEntityId - The id of the FormSubmissionEntity to be deleted.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   */
  async deleteFormSubmissionEntityAsync(FormSubmissionEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("DeleteFormSubmissionEntity?FormSubmissionEntityId=" + FormSubmissionEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new ShipmentMessageBlockEntity.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultShipmentMessageBlockEntityAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultShipmentMessageBlockEntity", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ShipmentMessageBlockEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing ShipmentMessageBlockEntity or creates a new ShipmentMessageBlockEntity if the id parameter is empty
   * @param entity - The ShipmentMessageBlockEntity to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated ShipmentMessageBlockEntity
   */
  async saveShipmentMessageBlockEntityAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveShipmentMessageBlockEntity", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ShipmentMessageBlockEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Deletes the ShipmentMessageBlockEntity
   * @param ShipmentMessageBlockEntityId - The id of the ShipmentMessageBlockEntity to be deleted.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   */
  async deleteShipmentMessageBlockEntityAsync(ShipmentMessageBlockEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("DeleteShipmentMessageBlockEntity?ShipmentMessageBlockEntityId=" + ShipmentMessageBlockEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new ShipmentMessageEntity.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultShipmentMessageEntityAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultShipmentMessageEntity", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ShipmentMessageEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing ShipmentMessageEntity or creates a new ShipmentMessageEntity if the id parameter is empty
   * @param entity - The ShipmentMessageEntity to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated ShipmentMessageEntity
   */
  async saveShipmentMessageEntityAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveShipmentMessageEntity", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ShipmentMessageEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Deletes the ShipmentMessageEntity
   * @param ShipmentMessageEntityId - The id of the ShipmentMessageEntity to be deleted.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   */
  async deleteShipmentMessageEntityAsync(ShipmentMessageEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("DeleteShipmentMessageEntity?ShipmentMessageEntityId=" + ShipmentMessageEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets a FormEntity object.
   * @param formEntityId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single FormEntity
   */
  async getFormEntityAsync(formEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetFormEntity?formEntityId=" + formEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_FormEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _verifyGoogleRecaptchaAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("VerifyGoogleRecaptcha", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async verifyGoogleRecaptchaAsync(token, optionalSecretKey, webapi_options) {
    let _request = null;
    let _options = null;
    const first = token;
    if (typeof first === "object" && first && (typeof first.token != "undefined" || typeof first.optionalSecretKey != "undefined")) {
      _request = token;
      _options = optionalSecretKey;
    } else {
      _request = {
        token,
        optionalSecretKey
      };
      _options = webapi_options;
    }
    return this._verifyGoogleRecaptchaAsync(_request, _options);
  }
  /*
   * Gets a FormSubmissionEntity object.
   * @param formSubmissionEntityId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single FormSubmissionEntity
   */
  async getFormSubmissionEntityAsync(formSubmissionEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetFormSubmissionEntity?formSubmissionEntityId=" + formSubmissionEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_FormSubmissionEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _calculateMailingStatisticsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CalculateMailingStatistics", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async calculateMailingStatisticsAsync(shipmentId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = shipmentId;
    if (typeof first === "object" && first && typeof first.shipmentId != "undefined") {
      _request = shipmentId;
      _options = webapi_options;
    } else {
      _request = {
        shipmentId
      };
      _options = webapi_options;
    }
    return this._calculateMailingStatisticsAsync(_request, _options);
  }
  async _getFormSubmissionsCountAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetFormSubmissionsCount", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getFormSubmissionsCountAsync(formId, status, webapi_options) {
    let _request = null;
    let _options = null;
    const first = formId;
    if (typeof first === "object" && first && (typeof first.formId != "undefined" || typeof first.status != "undefined")) {
      _request = formId;
      _options = status;
    } else {
      _request = {
        formId,
        status
      };
      _options = webapi_options;
    }
    return this._getFormSubmissionsCountAsync(_request, _options);
  }
  async _getPreviewMailingAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPreviewMailing", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PreviewMailing_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getPreviewMailingAsync(shipmentAddrId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = shipmentAddrId;
    if (typeof first === "object" && first && typeof first.shipmentAddrId != "undefined") {
      _request = shipmentAddrId;
      _options = webapi_options;
    } else {
      _request = {
        shipmentAddrId
      };
      _options = webapi_options;
    }
    return this._getPreviewMailingAsync(_request, _options);
  }
  async _getPreviewMailingHeaderAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPreviewMailingHeader", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PreviewMailingHeader_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getPreviewMailingHeaderAsync(shipmentId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = shipmentId;
    if (typeof first === "object" && first && typeof first.shipmentId != "undefined") {
      _request = shipmentId;
      _options = webapi_options;
    } else {
      _request = {
        shipmentId
      };
      _options = webapi_options;
    }
    return this._getPreviewMailingHeaderAsync(_request, _options);
  }
  /*
   * Gets a ShipmentMessageBlockEntity object.
   * @param shipmentMessageBlockEntityId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single ShipmentMessageBlockEntity
   */
  async getShipmentMessageBlockEntityAsync(shipmentMessageBlockEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetShipmentMessageBlockEntity?shipmentMessageBlockEntityId=" + shipmentMessageBlockEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ShipmentMessageBlockEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getUserBlocksAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetUserBlocks", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ShipmentMessageBlockEntityArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getUserBlocksAsync(associateId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = associateId;
    if (typeof first === "object" && first && typeof first.associateId != "undefined") {
      _request = associateId;
      _options = webapi_options;
    } else {
      _request = {
        associateId
      };
      _options = webapi_options;
    }
    return this._getUserBlocksAsync(_request, _options);
  }
  /*
   * Gets a ShipmentMessageEntity object.
   * @param shipmentMessageEntityId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single ShipmentMessageEntity
   */
  async getShipmentMessageEntityAsync(shipmentMessageEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetShipmentMessageEntity?shipmentMessageEntityId=" + shipmentMessageEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ShipmentMessageEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
};

// server/node_modules/@superoffice/webapi/dist/esm/CRMScriptAgent.js
var CRMScriptAgent = class extends WebApiBase {
  constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
    const options = WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
    options.basePath = "v1/Agents/CRMScript/";
    super(options);
  }
  /**
   * Set default values into a new CRMScriptEntity.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultCRMScriptEntityAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultCRMScriptEntity", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_CRMScriptEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing CRMScriptEntity or creates a new CRMScriptEntity if the id parameter is empty
   * @param entity - The CRMScriptEntity to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated CRMScriptEntity
   */
  async saveCRMScriptEntityAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveCRMScriptEntity", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_CRMScriptEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Deletes the CRMScriptEntity
   * @param CRMScriptEntityId - The id of the CRMScriptEntity to be deleted.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   */
  async deleteCRMScriptEntityAsync(CRMScriptEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("DeleteCRMScriptEntity?CRMScriptEntityId=" + CRMScriptEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new TriggerScriptEntity.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultTriggerScriptEntityAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultTriggerScriptEntity", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TriggerScriptEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing TriggerScriptEntity or creates a new TriggerScriptEntity if the id parameter is empty
   * @param entity - The TriggerScriptEntity to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated TriggerScriptEntity
   */
  async saveTriggerScriptEntityAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveTriggerScriptEntity", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TriggerScriptEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Deletes the TriggerScriptEntity
   * @param TriggerScriptEntityId - The id of the TriggerScriptEntity to be deleted.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   */
  async deleteTriggerScriptEntityAsync(TriggerScriptEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("DeleteTriggerScriptEntity?TriggerScriptEntityId=" + TriggerScriptEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getCRMScriptByUniqueIdentifierAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetCRMScriptByUniqueIdentifier", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Script_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getCRMScriptByUniqueIdentifierAsync(uniqueIdentifier, webapi_options) {
    let _request = null;
    let _options = null;
    const first = uniqueIdentifier;
    if (typeof first === "object" && first && typeof first.uniqueIdentifier != "undefined") {
      _request = uniqueIdentifier;
      _options = webapi_options;
    } else {
      _request = {
        uniqueIdentifier
      };
      _options = webapi_options;
    }
    return this._getCRMScriptByUniqueIdentifierAsync(_request, _options);
  }
  async _saveCRMScriptByUniqueIdentifierAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveCRMScriptByUniqueIdentifier", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Script_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveCRMScriptByUniqueIdentifierAsync(uniqueIdentifier, crmscript, webapi_options) {
    let _request = null;
    let _options = null;
    const first = uniqueIdentifier;
    if (typeof first === "object" && first && (typeof first.uniqueIdentifier != "undefined" || typeof first.crmscript != "undefined")) {
      _request = uniqueIdentifier;
      _options = crmscript;
    } else {
      _request = {
        uniqueIdentifier,
        crmscript
      };
      _options = webapi_options;
    }
    return this._saveCRMScriptByUniqueIdentifierAsync(_request, _options);
  }
  async _deleteCRMScriptByUniqueIdentifierAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeleteCRMScriptByUniqueIdentifier", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async deleteCRMScriptByUniqueIdentifierAsync(uniqueIdentifier, webapi_options) {
    let _request = null;
    let _options = null;
    const first = uniqueIdentifier;
    if (typeof first === "object" && first && typeof first.uniqueIdentifier != "undefined") {
      _request = uniqueIdentifier;
      _options = webapi_options;
    } else {
      _request = {
        uniqueIdentifier
      };
      _options = webapi_options;
    }
    return this._deleteCRMScriptByUniqueIdentifierAsync(_request, _options);
  }
  /*
   * Gets a CRMScriptEntity object.
   * @param cRMScriptEntityId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single CRMScriptEntity
   */
  async getCRMScriptEntityAsync(cRMScriptEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetCRMScriptEntity?cRMScriptEntityId=" + cRMScriptEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_CRMScriptEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _executeScriptAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ExecuteScript", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async executeScriptAsync(crmScriptId, parameters, webapi_options) {
    let _request = null;
    let _options = null;
    const first = crmScriptId;
    if (typeof first === "object" && first && (typeof first.crmScriptId != "undefined" || typeof first.parameters != "undefined")) {
      _request = crmScriptId;
      _options = parameters;
    } else {
      _request = {
        crmScriptId,
        parameters
      };
      _options = webapi_options;
    }
    return this._executeScriptAsync(_request, _options);
  }
  async _executeScriptByIncludeIdAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ExecuteScriptByIncludeId", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async executeScriptByIncludeIdAsync(crmScriptIncludeId, parameters, webapi_options) {
    let _request = null;
    let _options = null;
    const first = crmScriptIncludeId;
    if (typeof first === "object" && first && (typeof first.crmScriptIncludeId != "undefined" || typeof first.parameters != "undefined")) {
      _request = crmScriptIncludeId;
      _options = parameters;
    } else {
      _request = {
        crmScriptIncludeId,
        parameters
      };
      _options = webapi_options;
    }
    return this._executeScriptByIncludeIdAsync(_request, _options);
  }
  async _executeScriptByUniqueIdAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ExecuteScriptByUniqueId", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async executeScriptByUniqueIdAsync(crmScriptUniqueId, parameters, webapi_options) {
    let _request = null;
    let _options = null;
    const first = crmScriptUniqueId;
    if (typeof first === "object" && first && (typeof first.crmScriptUniqueId != "undefined" || typeof first.parameters != "undefined")) {
      _request = crmScriptUniqueId;
      _options = parameters;
    } else {
      _request = {
        crmScriptUniqueId,
        parameters
      };
      _options = webapi_options;
    }
    return this._executeScriptByUniqueIdAsync(_request, _options);
  }
  async _executeScriptAsEventAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ExecuteScriptAsEvent", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_EventData_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async executeScriptAsEventAsync(crmScriptId, eventData, webapi_options) {
    let _request = null;
    let _options = null;
    const first = crmScriptId;
    if (typeof first === "object" && first && (typeof first.crmScriptId != "undefined" || typeof first.eventData != "undefined")) {
      _request = crmScriptId;
      _options = eventData;
    } else {
      _request = {
        crmScriptId,
        eventData
      };
      _options = webapi_options;
    }
    return this._executeScriptAsEventAsync(_request, _options);
  }
  async _executeScriptAsEventByUniqueIdAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ExecuteScriptAsEventByUniqueId", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_EventData_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async executeScriptAsEventByUniqueIdAsync(crmScriptUniqueId, eventData, webapi_options) {
    let _request = null;
    let _options = null;
    const first = crmScriptUniqueId;
    if (typeof first === "object" && first && (typeof first.crmScriptUniqueId != "undefined" || typeof first.eventData != "undefined")) {
      _request = crmScriptUniqueId;
      _options = eventData;
    } else {
      _request = {
        crmScriptUniqueId,
        eventData
      };
      _options = webapi_options;
    }
    return this._executeScriptAsEventByUniqueIdAsync(_request, _options);
  }
  async _validateScriptAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ValidateScript", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_CRMScriptResult_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async validateScriptAsync(crmScriptId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = crmScriptId;
    if (typeof first === "object" && first && typeof first.crmScriptId != "undefined") {
      _request = crmScriptId;
      _options = webapi_options;
    } else {
      _request = {
        crmScriptId
      };
      _options = webapi_options;
    }
    return this._validateScriptAsync(_request, _options);
  }
  async _validateScriptByIncludeIdAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ValidateScriptByIncludeId", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_CRMScriptResult_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async validateScriptByIncludeIdAsync(crmScriptIncludeId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = crmScriptIncludeId;
    if (typeof first === "object" && first && typeof first.crmScriptIncludeId != "undefined") {
      _request = crmScriptIncludeId;
      _options = webapi_options;
    } else {
      _request = {
        crmScriptIncludeId
      };
      _options = webapi_options;
    }
    return this._validateScriptByIncludeIdAsync(_request, _options);
  }
  async _validateScriptByUniqueIdAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ValidateScriptByUniqueId", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_CRMScriptResult_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async validateScriptByUniqueIdAsync(crmScriptUniqueId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = crmScriptUniqueId;
    if (typeof first === "object" && first && typeof first.crmScriptUniqueId != "undefined") {
      _request = crmScriptUniqueId;
      _options = webapi_options;
    } else {
      _request = {
        crmScriptUniqueId
      };
      _options = webapi_options;
    }
    return this._validateScriptByUniqueIdAsync(_request, _options);
  }
  async _executeScriptByStringAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ExecuteScriptByString", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_CRMScriptRunResult_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async executeScriptByStringAsync(script, parameters, eventData, webapi_options) {
    let _request = null;
    let _options = null;
    const first = script;
    if (typeof first === "object" && first && (typeof first.script != "undefined" || typeof first.parameters != "undefined" || typeof first.eventData != "undefined")) {
      _request = script;
      _options = parameters;
    } else {
      _request = {
        script,
        parameters,
        eventData
      };
      _options = webapi_options;
    }
    return this._executeScriptByStringAsync(_request, _options);
  }
  async _validateScriptByStringAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ValidateScriptByString", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_CRMScriptResult_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async validateScriptByStringAsync(script, webapi_options) {
    let _request = null;
    let _options = null;
    const first = script;
    if (typeof first === "object" && first && typeof first.script != "undefined") {
      _request = script;
      _options = webapi_options;
    } else {
      _request = {
        script
      };
      _options = webapi_options;
    }
    return this._validateScriptByStringAsync(_request, _options);
  }
  /*
   * Gets a TriggerScriptEntity object.
   * @param triggerScriptEntityId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single TriggerScriptEntity
   */
  async getTriggerScriptEntityAsync(triggerScriptEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetTriggerScriptEntity?triggerScriptEntityId=" + triggerScriptEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TriggerScriptEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getTriggerScriptByUniqueIdAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetTriggerScriptByUniqueId", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TriggerScriptEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getTriggerScriptByUniqueIdAsync(triggerScriptUniqueId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = triggerScriptUniqueId;
    if (typeof first === "object" && first && typeof first.triggerScriptUniqueId != "undefined") {
      _request = triggerScriptUniqueId;
      _options = webapi_options;
    } else {
      _request = {
        triggerScriptUniqueId
      };
      _options = webapi_options;
    }
    return this._getTriggerScriptByUniqueIdAsync(_request, _options);
  }
  async _saveTriggerScriptByUniqueIdAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveTriggerScriptByUniqueId", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TriggerScriptEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveTriggerScriptByUniqueIdAsync(triggerScriptUniqueId, entity, webapi_options) {
    let _request = null;
    let _options = null;
    const first = triggerScriptUniqueId;
    if (typeof first === "object" && first && (typeof first.triggerScriptUniqueId != "undefined" || typeof first.entity != "undefined")) {
      _request = triggerScriptUniqueId;
      _options = entity;
    } else {
      _request = {
        triggerScriptUniqueId,
        entity
      };
      _options = webapi_options;
    }
    return this._saveTriggerScriptByUniqueIdAsync(_request, _options);
  }
  async _deleteTriggerScriptByUniqueIdAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeleteTriggerScriptByUniqueId", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async deleteTriggerScriptByUniqueIdAsync(triggerScriptUniqueId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = triggerScriptUniqueId;
    if (typeof first === "object" && first && typeof first.triggerScriptUniqueId != "undefined") {
      _request = triggerScriptUniqueId;
      _options = webapi_options;
    } else {
      _request = {
        triggerScriptUniqueId
      };
      _options = webapi_options;
    }
    return this._deleteTriggerScriptByUniqueIdAsync(_request, _options);
  }
  async _validateTriggerScriptAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ValidateTriggerScript", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_CRMScriptResult_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async validateTriggerScriptAsync(triggerScriptId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = triggerScriptId;
    if (typeof first === "object" && first && typeof first.triggerScriptId != "undefined") {
      _request = triggerScriptId;
      _options = webapi_options;
    } else {
      _request = {
        triggerScriptId
      };
      _options = webapi_options;
    }
    return this._validateTriggerScriptAsync(_request, _options);
  }
  async _validateTriggerScriptByUniqueIdAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ValidateTriggerScriptByUniqueId", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_CRMScriptResult_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async validateTriggerScriptByUniqueIdAsync(triggerScriptUniqueId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = triggerScriptUniqueId;
    if (typeof first === "object" && first && typeof first.triggerScriptUniqueId != "undefined") {
      _request = triggerScriptUniqueId;
      _options = webapi_options;
    } else {
      _request = {
        triggerScriptUniqueId
      };
      _options = webapi_options;
    }
    return this._validateTriggerScriptByUniqueIdAsync(_request, _options);
  }
};

// server/node_modules/@superoffice/webapi/dist/esm/TicketAgent.js
var TicketAgent = class extends WebApiBase {
  constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
    const options = WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
    options.basePath = "v1/Agents/Ticket/";
    super(options);
  }
  /**
   * Set default values into a new AttachmentEntity.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultAttachmentEntityAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultAttachmentEntity", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AttachmentEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing AttachmentEntity or creates a new AttachmentEntity if the id parameter is empty
   * @param entity - The AttachmentEntity to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated AttachmentEntity
   */
  async saveAttachmentEntityAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveAttachmentEntity", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AttachmentEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new TicketEntity.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultTicketEntityAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultTicketEntity", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TicketEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing TicketEntity or creates a new TicketEntity if the id parameter is empty
   * @param entity - The TicketEntity to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated TicketEntity
   */
  async saveTicketEntityAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveTicketEntity", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TicketEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new TicketMessageEntity.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultTicketMessageEntityAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultTicketMessageEntity", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TicketMessageEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing TicketMessageEntity or creates a new TicketMessageEntity if the id parameter is empty
   * @param entity - The TicketMessageEntity to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated TicketMessageEntity
   */
  async saveTicketMessageEntityAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveTicketMessageEntity", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TicketMessageEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets a AttachmentEntity object.
   * @param attachmentEntityId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single AttachmentEntity
   */
  async getAttachmentEntityAsync(attachmentEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetAttachmentEntity?attachmentEntityId=" + attachmentEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AttachmentEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _copyFromCRMDocumentAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CopyFromCRMDocument", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AttachmentEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async copyFromCRMDocumentAsync(documentId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = documentId;
    if (typeof first === "object" && first && typeof first.documentId != "undefined") {
      _request = documentId;
      _options = webapi_options;
    } else {
      _request = {
        documentId
      };
      _options = webapi_options;
    }
    return this._copyFromCRMDocumentAsync(_request, _options);
  }
  async _copyToTempFileAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CopyToTempFile", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async copyToTempFileAsync(filename, attachmentId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = filename;
    if (typeof first === "object" && first && (typeof first.filename != "undefined" || typeof first.attachmentId != "undefined")) {
      _request = filename;
      _options = attachmentId;
    } else {
      _request = {
        filename,
        attachmentId
      };
      _options = webapi_options;
    }
    return this._copyToTempFileAsync(_request, _options);
  }
  async _uploadAttachmentAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("UploadAttachment", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async uploadAttachmentAsync(attachmentId, content, webapi_options) {
    let _request = null;
    let _options = null;
    const first = attachmentId;
    if (typeof first === "object" && first && (typeof first.attachmentId != "undefined" || typeof first.content != "undefined")) {
      _request = attachmentId;
      _options = content;
    } else {
      _request = {
        attachmentId,
        content
      };
      _options = webapi_options;
    }
    _request.content = ToBase64(_request.content);
    return this._uploadAttachmentAsync(_request, _options);
  }
  async _getAttachmentStreamAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        if (!options || options.returnBlobAs == ReturnBlobType.AsArrayBuffer) {
          config.responseType = "arraybuffer";
          config.headers = config.headers || {};
          config.headers["Accept"] = "application/octet-stream";
        }
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetAttachmentStream", request, config);
        WebApiBase.SetCompleted(options);
        let res = null;
        if (options && options.returnBlobAs != ReturnBlobType.AsArrayBuffer) {
          res = response.data;
          if (options.returnBlobAs == ReturnBlobType.AsString) {
            res = FromBase64ToString(res);
          }
        } else {
          res = response.data;
        }
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getAttachmentStreamAsync(attachmentId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = attachmentId;
    if (typeof first === "object" && first && typeof first.attachmentId != "undefined") {
      _request = attachmentId;
      _options = webapi_options;
    } else {
      _request = {
        attachmentId
      };
      _options = webapi_options;
    }
    return this._getAttachmentStreamAsync(_request, _options);
  }
  /*
   * Gets a Ticket object.
   * @param ticketId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single Ticket
   */
  async getTicketAsync(ticketId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetTicket?ticketId=" + ticketId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Ticket_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getTicketsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetTickets", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TicketArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getTicketsAsync(ticketIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = ticketIds;
    if (typeof first === "object" && first && typeof first.ticketIds != "undefined") {
      _request = ticketIds;
      _options = webapi_options;
    } else {
      _request = {
        ticketIds
      };
      _options = webapi_options;
    }
    return this._getTicketsAsync(_request, _options);
  }
  /*
   * Gets a TicketEntity object.
   * @param ticketEntityId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single TicketEntity
   */
  async getTicketEntityAsync(ticketEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetTicketEntity?ticketEntityId=" + ticketEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TicketEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getForRmUiAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetForRmUi", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TicketEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getForRmUiAsync(ticketId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = ticketId;
    if (typeof first === "object" && first && typeof first.ticketId != "undefined") {
      _request = ticketId;
      _options = webapi_options;
    } else {
      _request = {
        ticketId
      };
      _options = webapi_options;
    }
    return this._getForRmUiAsync(_request, _options);
  }
  async _deleteTicketEntityAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeleteTicketEntity", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async deleteTicketEntityAsync(ticketEntityId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = ticketEntityId;
    if (typeof first === "object" && first && typeof first.ticketEntityId != "undefined") {
      _request = ticketEntityId;
      _options = webapi_options;
    } else {
      _request = {
        ticketEntityId
      };
      _options = webapi_options;
    }
    return this._deleteTicketEntityAsync(_request, _options);
  }
  async _notifyNewTicketAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("NotifyNewTicket", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async notifyNewTicketAsync(ticketEntityId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = ticketEntityId;
    if (typeof first === "object" && first && typeof first.ticketEntityId != "undefined") {
      _request = ticketEntityId;
      _options = webapi_options;
    } else {
      _request = {
        ticketEntityId
      };
      _options = webapi_options;
    }
    return this._notifyNewTicketAsync(_request, _options);
  }
  async _notifyNewTicketMessageAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("NotifyNewTicketMessage", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async notifyNewTicketMessageAsync(ticketEntityId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = ticketEntityId;
    if (typeof first === "object" && first && typeof first.ticketEntityId != "undefined") {
      _request = ticketEntityId;
      _options = webapi_options;
    } else {
      _request = {
        ticketEntityId
      };
      _options = webapi_options;
    }
    return this._notifyNewTicketMessageAsync(_request, _options);
  }
  async _getTicketAttachmentsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetTicketAttachments", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AttachmentEntityArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getTicketAttachmentsAsync(ticketEntityId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = ticketEntityId;
    if (typeof first === "object" && first && typeof first.ticketEntityId != "undefined") {
      _request = ticketEntityId;
      _options = webapi_options;
    } else {
      _request = {
        ticketEntityId
      };
      _options = webapi_options;
    }
    return this._getTicketAttachmentsAsync(_request, _options);
  }
  async _validateAttachmentsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ValidateAttachments", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AttachmentValidationResultArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async validateAttachmentsAsync(attachmentIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = attachmentIds;
    if (typeof first === "object" && first && typeof first.attachmentIds != "undefined") {
      _request = attachmentIds;
      _options = webapi_options;
    } else {
      _request = {
        attachmentIds
      };
      _options = webapi_options;
    }
    return this._validateAttachmentsAsync(_request, _options);
  }
  async _setTicketReadByOwnerAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetTicketReadByOwner", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TicketEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setTicketReadByOwnerAsync(ticketEntityId, readStatus, checkEscalating, webapi_options) {
    let _request = null;
    let _options = null;
    const first = ticketEntityId;
    if (typeof first === "object" && first && (typeof first.ticketEntityId != "undefined" || typeof first.readStatus != "undefined" || typeof first.checkEscalating != "undefined")) {
      _request = ticketEntityId;
      _options = readStatus;
    } else {
      _request = {
        ticketEntityId,
        readStatus,
        checkEscalating
      };
      _options = webapi_options;
    }
    return this._setTicketReadByOwnerAsync(_request, _options);
  }
  async _saveTicketEntityWithNotifyAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveTicketEntityWithNotify", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TicketEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveTicketEntityWithNotifyAsync(newEntity, notify, webapi_options) {
    let _request = null;
    let _options = null;
    const first = newEntity;
    if (typeof first === "object" && first && (typeof first.newEntity != "undefined" || typeof first.notify != "undefined")) {
      _request = newEntity;
      _options = notify;
    } else {
      _request = {
        newEntity,
        notify
      };
      _options = webapi_options;
    }
    return this._saveTicketEntityWithNotifyAsync(_request, _options);
  }
  async _getNextInQueueAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetNextInQueue", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TicketEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Assign a ticket to the caller based on intelligent queue system
   * @returns The ticket entity after assigning it to the caller
   */
  async getNextInQueueAsync(webapi_options) {
    return this._getNextInQueueAsync(webapi_options);
  }
  async _processTicketWhenReadAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ProcessTicketWhenRead", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TicketEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async processTicketWhenReadAsync(ticketEntityId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = ticketEntityId;
    if (typeof first === "object" && first && typeof first.ticketEntityId != "undefined") {
      _request = ticketEntityId;
      _options = webapi_options;
    } else {
      _request = {
        ticketEntityId
      };
      _options = webapi_options;
    }
    return this._processTicketWhenReadAsync(_request, _options);
  }
  async _splitTicketAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SplitTicket", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TicketEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async splitTicketAsync(sourceTicketEntityId, sourceTicketEntityStatusId, sourceTicketEntityActivate, transferMessageIds, newTicketEntity, webapi_options) {
    let _request = null;
    let _options = null;
    const first = sourceTicketEntityId;
    if (typeof first === "object" && first && (typeof first.sourceTicketEntityId != "undefined" || typeof first.sourceTicketEntityStatusId != "undefined" || typeof first.sourceTicketEntityActivate != "undefined" || typeof first.transferMessageIds != "undefined" || typeof first.newTicketEntity != "undefined")) {
      _request = sourceTicketEntityId;
      _options = sourceTicketEntityStatusId;
    } else {
      _request = {
        sourceTicketEntityId,
        sourceTicketEntityStatusId,
        sourceTicketEntityActivate,
        transferMessageIds,
        newTicketEntity
      };
      _options = webapi_options;
    }
    return this._splitTicketAsync(_request, _options);
  }
  async _splitTicketMessageAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SplitTicketMessage", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TicketEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async splitTicketMessageAsync(sourceTicketMessage, newTicketEntity, newTicketMessage, transferAttachmentsIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = sourceTicketMessage;
    if (typeof first === "object" && first && (typeof first.sourceTicketMessage != "undefined" || typeof first.newTicketEntity != "undefined" || typeof first.newTicketMessage != "undefined" || typeof first.transferAttachmentsIds != "undefined")) {
      _request = sourceTicketMessage;
      _options = newTicketEntity;
    } else {
      _request = {
        sourceTicketMessage,
        newTicketEntity,
        newTicketMessage,
        transferAttachmentsIds
      };
      _options = webapi_options;
    }
    return this._splitTicketMessageAsync(_request, _options);
  }
  async _updateTicketsReadStatusAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("UpdateTicketsReadStatus", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async updateTicketsReadStatusAsync(ticketIds, newStatus, webapi_options) {
    let _request = null;
    let _options = null;
    const first = ticketIds;
    if (typeof first === "object" && first && (typeof first.ticketIds != "undefined" || typeof first.newStatus != "undefined")) {
      _request = ticketIds;
      _options = newStatus;
    } else {
      _request = {
        ticketIds,
        newStatus
      };
      _options = webapi_options;
    }
    return this._updateTicketsReadStatusAsync(_request, _options);
  }
  async _updateTicketsReadStatusByProviderAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("UpdateTicketsReadStatusByProvider", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async updateTicketsReadStatusByProviderAsync(provider, restrictions, newStatus, webapi_options) {
    let _request = null;
    let _options = null;
    const first = provider;
    if (typeof first === "object" && first && (typeof first.provider != "undefined" || typeof first.restrictions != "undefined" || typeof first.newStatus != "undefined")) {
      _request = provider;
      _options = restrictions;
    } else {
      _request = {
        provider,
        restrictions,
        newStatus
      };
      _options = webapi_options;
    }
    return this._updateTicketsReadStatusByProviderAsync(_request, _options);
  }
  async _mergeTicketsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("MergeTickets", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TicketEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async mergeTicketsAsync(mergedTicketEntity, secondaryTicketIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = mergedTicketEntity;
    if (typeof first === "object" && first && (typeof first.mergedTicketEntity != "undefined" || typeof first.secondaryTicketIds != "undefined")) {
      _request = mergedTicketEntity;
      _options = secondaryTicketIds;
    } else {
      _request = {
        mergedTicketEntity,
        secondaryTicketIds
      };
      _options = webapi_options;
    }
    return this._mergeTicketsAsync(_request, _options);
  }
  async _setDeletedStatusByIdsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetDeletedStatusByIds", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setDeletedStatusByIdsAsync(ticketIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = ticketIds;
    if (typeof first === "object" && first && typeof first.ticketIds != "undefined") {
      _request = ticketIds;
      _options = webapi_options;
    } else {
      _request = {
        ticketIds
      };
      _options = webapi_options;
    }
    return this._setDeletedStatusByIdsAsync(_request, _options);
  }
  async _setDeletedStatusByProviderAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetDeletedStatusByProvider", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setDeletedStatusByProviderAsync(providerName, restrictions, webapi_options) {
    let _request = null;
    let _options = null;
    const first = providerName;
    if (typeof first === "object" && first && (typeof first.providerName != "undefined" || typeof first.restrictions != "undefined")) {
      _request = providerName;
      _options = restrictions;
    } else {
      _request = {
        providerName,
        restrictions
      };
      _options = webapi_options;
    }
    return this._setDeletedStatusByProviderAsync(_request, _options);
  }
  async _undeleteByIdsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("UndeleteByIds", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async undeleteByIdsAsync(ticketIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = ticketIds;
    if (typeof first === "object" && first && typeof first.ticketIds != "undefined") {
      _request = ticketIds;
      _options = webapi_options;
    } else {
      _request = {
        ticketIds
      };
      _options = webapi_options;
    }
    return this._undeleteByIdsAsync(_request, _options);
  }
  async _resolveTicketIdAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ResolveTicketId", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async resolveTicketIdAsync(ticketId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = ticketId;
    if (typeof first === "object" && first && typeof first.ticketId != "undefined") {
      _request = ticketId;
      _options = webapi_options;
    } else {
      _request = {
        ticketId
      };
      _options = webapi_options;
    }
    return this._resolveTicketIdAsync(_request, _options);
  }
  async _batchForwardAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("BatchForward", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async batchForwardAsync(ticketIds, to, cc, bcc, comment, closeTicket, webapi_options) {
    let _request = null;
    let _options = null;
    const first = ticketIds;
    if (typeof first === "object" && first && (typeof first.ticketIds != "undefined" || typeof first.to != "undefined" || typeof first.cc != "undefined" || typeof first.bcc != "undefined" || typeof first.comment != "undefined" || typeof first.closeTicket != "undefined")) {
      _request = ticketIds;
      _options = to;
    } else {
      _request = {
        ticketIds,
        to,
        cc,
        bcc,
        comment,
        closeTicket
      };
      _options = webapi_options;
    }
    return this._batchForwardAsync(_request, _options);
  }
  async _batchReplyAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("BatchReply", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async batchReplyAsync(batchReplyData, webapi_options) {
    let _request = null;
    let _options = null;
    const first = batchReplyData;
    if (typeof first === "object" && first && typeof first.batchReplyData != "undefined") {
      _request = batchReplyData;
      _options = webapi_options;
    } else {
      _request = {
        batchReplyData
      };
      _options = webapi_options;
    }
    return this._batchReplyAsync(_request, _options);
  }
  async _clearNotifyAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ClearNotify", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async clearNotifyAsync(ids, webapi_options) {
    let _request = null;
    let _options = null;
    const first = ids;
    if (typeof first === "object" && first && typeof first.ids != "undefined") {
      _request = ids;
      _options = webapi_options;
    } else {
      _request = {
        ids
      };
      _options = webapi_options;
    }
    return this._clearNotifyAsync(_request, _options);
  }
  /*
   * Gets a TicketMessage object.
   * @param ticketMessageId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single TicketMessage
   */
  async getTicketMessageAsync(ticketMessageId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetTicketMessage?ticketMessageId=" + ticketMessageId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TicketMessage_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets a TicketMessageEntity object.
   * @param ticketMessageEntityId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single TicketMessageEntity
   */
  async getTicketMessageEntityAsync(ticketMessageEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetTicketMessageEntity?ticketMessageEntityId=" + ticketMessageEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TicketMessageEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _deleteTicketMessageEntityAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeleteTicketMessageEntity", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async deleteTicketMessageEntityAsync(ticketMessageEntityId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = ticketMessageEntityId;
    if (typeof first === "object" && first && typeof first.ticketMessageEntityId != "undefined") {
      _request = ticketMessageEntityId;
      _options = webapi_options;
    } else {
      _request = {
        ticketMessageEntityId
      };
      _options = webapi_options;
    }
    return this._deleteTicketMessageEntityAsync(_request, _options);
  }
  async _sanitizeMailContentAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SanitizeMailContent", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async sanitizeMailContentAsync(content, webapi_options) {
    let _request = null;
    let _options = null;
    const first = content;
    if (typeof first === "object" && first && typeof first.content != "undefined") {
      _request = content;
      _options = webapi_options;
    } else {
      _request = {
        content
      };
      _options = webapi_options;
    }
    return this._sanitizeMailContentAsync(_request, _options);
  }
  async _sanitizeMailContentsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SanitizeMailContents", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async sanitizeMailContentsAsync(contents, webapi_options) {
    let _request = null;
    let _options = null;
    const first = contents;
    if (typeof first === "object" && first && typeof first.contents != "undefined") {
      _request = contents;
      _options = webapi_options;
    } else {
      _request = {
        contents
      };
      _options = webapi_options;
    }
    return this._sanitizeMailContentsAsync(_request, _options);
  }
  async _html2TextAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("Html2Text", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async html2TextAsync(content, webapi_options) {
    let _request = null;
    let _options = null;
    const first = content;
    if (typeof first === "object" && first && typeof first.content != "undefined") {
      _request = content;
      _options = webapi_options;
    } else {
      _request = {
        content
      };
      _options = webapi_options;
    }
    return this._html2TextAsync(_request, _options);
  }
  async _getAttachmentInfoAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetAttachmentInfo", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AttachmentEntityArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getAttachmentInfoAsync(ticketMessageEntityId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = ticketMessageEntityId;
    if (typeof first === "object" && first && typeof first.ticketMessageEntityId != "undefined") {
      _request = ticketMessageEntityId;
      _options = webapi_options;
    } else {
      _request = {
        ticketMessageEntityId
      };
      _options = webapi_options;
    }
    return this._getAttachmentInfoAsync(_request, _options);
  }
  async _getAttachmentInfoNonInlineAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetAttachmentInfoNonInline", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AttachmentEntityArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getAttachmentInfoNonInlineAsync(ticketMessageEntityId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = ticketMessageEntityId;
    if (typeof first === "object" && first && typeof first.ticketMessageEntityId != "undefined") {
      _request = ticketMessageEntityId;
      _options = webapi_options;
    } else {
      _request = {
        ticketMessageEntityId
      };
      _options = webapi_options;
    }
    return this._getAttachmentInfoNonInlineAsync(_request, _options);
  }
  async _addAttachmentsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("AddAttachments", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async addAttachmentsAsync(ticketMessageEntityId, attachmentIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = ticketMessageEntityId;
    if (typeof first === "object" && first && (typeof first.ticketMessageEntityId != "undefined" || typeof first.attachmentIds != "undefined")) {
      _request = ticketMessageEntityId;
      _options = attachmentIds;
    } else {
      _request = {
        ticketMessageEntityId,
        attachmentIds
      };
      _options = webapi_options;
    }
    return this._addAttachmentsAsync(_request, _options);
  }
  async _removeMessageAttachmentsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("RemoveMessageAttachments", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async removeMessageAttachmentsAsync(ticketMessageEntityId, attachmentIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = ticketMessageEntityId;
    if (typeof first === "object" && first && (typeof first.ticketMessageEntityId != "undefined" || typeof first.attachmentIds != "undefined")) {
      _request = ticketMessageEntityId;
      _options = attachmentIds;
    } else {
      _request = {
        ticketMessageEntityId,
        attachmentIds
      };
      _options = webapi_options;
    }
    return this._removeMessageAttachmentsAsync(_request, _options);
  }
  async _getPreviewAttachmentStreamAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetPreviewAttachmentStream", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DocumentPreview_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getPreviewAttachmentStreamAsync(attachmentId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = attachmentId;
    if (typeof first === "object" && first && typeof first.attachmentId != "undefined") {
      _request = attachmentId;
      _options = webapi_options;
    } else {
      _request = {
        attachmentId
      };
      _options = webapi_options;
    }
    return this._getPreviewAttachmentStreamAsync(_request, _options);
  }
  async _sendTicketMessageAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SendTicketMessage", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async sendTicketMessageAsync(ticketMessageEntityId, to, cc, bcc, subject, replyTemplateId, gdprSource, webapi_options) {
    let _request = null;
    let _options = null;
    const first = ticketMessageEntityId;
    if (typeof first === "object" && first && (typeof first.ticketMessageEntityId != "undefined" || typeof first.to != "undefined" || typeof first.cc != "undefined" || typeof first.bcc != "undefined" || typeof first.subject != "undefined" || typeof first.replyTemplateId != "undefined" || typeof first.gdprSource != "undefined")) {
      _request = ticketMessageEntityId;
      _options = to;
    } else {
      _request = {
        ticketMessageEntityId,
        to,
        cc,
        bcc,
        subject,
        replyTemplateId,
        gdprSource
      };
      _options = webapi_options;
    }
    return this._sendTicketMessageAsync(_request, _options);
  }
  async _sendTicketMessageSmsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SendTicketMessageSms", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async sendTicketMessageSmsAsync(ticketMessageEntityId, replyTemplateId, sms, webapi_options) {
    let _request = null;
    let _options = null;
    const first = ticketMessageEntityId;
    if (typeof first === "object" && first && (typeof first.ticketMessageEntityId != "undefined" || typeof first.replyTemplateId != "undefined" || typeof first.sms != "undefined")) {
      _request = ticketMessageEntityId;
      _options = replyTemplateId;
    } else {
      _request = {
        ticketMessageEntityId,
        replyTemplateId,
        sms
      };
      _options = webapi_options;
    }
    return this._sendTicketMessageSmsAsync(_request, _options);
  }
  async _setTicketMessageImportantAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SetTicketMessageImportant", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async setTicketMessageImportantAsync(ticketMessageId, important, webapi_options) {
    let _request = null;
    let _options = null;
    const first = ticketMessageId;
    if (typeof first === "object" && first && (typeof first.ticketMessageId != "undefined" || typeof first.important != "undefined")) {
      _request = ticketMessageId;
      _options = important;
    } else {
      _request = {
        ticketMessageId,
        important
      };
      _options = webapi_options;
    }
    return this._setTicketMessageImportantAsync(_request, _options);
  }
  async _calculateMessageRecipientsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CalculateMessageRecipients", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_RecipientArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async calculateMessageRecipientsAsync(ticketId, actionType, messageId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = ticketId;
    if (typeof first === "object" && first && (typeof first.ticketId != "undefined" || typeof first.actionType != "undefined" || typeof first.messageId != "undefined")) {
      _request = ticketId;
      _options = actionType;
    } else {
      _request = {
        ticketId,
        actionType,
        messageId
      };
      _options = webapi_options;
    }
    return this._calculateMessageRecipientsAsync(_request, _options);
  }
  async _saveTicketMessageEntityWithNotifyAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveTicketMessageEntityWithNotify", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TicketMessageEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveTicketMessageEntityWithNotifyAsync(newEntity, notify, webapi_options) {
    let _request = null;
    let _options = null;
    const first = newEntity;
    if (typeof first === "object" && first && (typeof first.newEntity != "undefined" || typeof first.notify != "undefined")) {
      _request = newEntity;
      _options = notify;
    } else {
      _request = {
        newEntity,
        notify
      };
      _options = webapi_options;
    }
    return this._saveTicketMessageEntityWithNotifyAsync(_request, _options);
  }
  async _saveTicketMessageEntityWithOptionsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveTicketMessageEntityWithOptions", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TicketMessageEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveTicketMessageEntityWithOptionsAsync(entity, notify, attachmentIds, updateRepliedAt, webapi_options) {
    let _request = null;
    let _options = null;
    const first = entity;
    if (typeof first === "object" && first && (typeof first.entity != "undefined" || typeof first.notify != "undefined" || typeof first.attachmentIds != "undefined" || typeof first.updateRepliedAt != "undefined")) {
      _request = entity;
      _options = notify;
    } else {
      _request = {
        entity,
        notify,
        attachmentIds,
        updateRepliedAt
      };
      _options = webapi_options;
    }
    return this._saveTicketMessageEntityWithOptionsAsync(_request, _options);
  }
  async _getDefaultMessageContentAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetDefaultMessageContent", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getDefaultMessageContentAsync(ticketId, messageActionType, ticketMessageId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = ticketId;
    if (typeof first === "object" && first && (typeof first.ticketId != "undefined" || typeof first.messageActionType != "undefined" || typeof first.ticketMessageId != "undefined")) {
      _request = ticketId;
      _options = messageActionType;
    } else {
      _request = {
        ticketId,
        messageActionType,
        ticketMessageId
      };
      _options = webapi_options;
    }
    return this._getDefaultMessageContentAsync(_request, _options);
  }
  async _getTicketMessageWithEmbeddedDataAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetTicketMessageWithEmbeddedData", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TicketMessageEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getTicketMessageWithEmbeddedDataAsync(id, embedImages, webapi_options) {
    let _request = null;
    let _options = null;
    const first = id;
    if (typeof first === "object" && first && (typeof first.id != "undefined" || typeof first.embedImages != "undefined")) {
      _request = id;
      _options = embedImages;
    } else {
      _request = {
        id,
        embedImages
      };
      _options = webapi_options;
    }
    return this._getTicketMessageWithEmbeddedDataAsync(_request, _options);
  }
  async _deleteMessageHeadersAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeleteMessageHeaders", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async deleteMessageHeadersAsync(headerIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = headerIds;
    if (typeof first === "object" && first && typeof first.headerIds != "undefined") {
      _request = headerIds;
      _options = webapi_options;
    } else {
      _request = {
        headerIds
      };
      _options = webapi_options;
    }
    return this._deleteMessageHeadersAsync(_request, _options);
  }
  async _getTicketMessageWithOptionsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetTicketMessageWithOptions", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TicketMessageEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getTicketMessageWithOptionsAsync(ticketMessageEntityId, includeNonInlineAttachmentsInfo, webapi_options) {
    let _request = null;
    let _options = null;
    const first = ticketMessageEntityId;
    if (typeof first === "object" && first && (typeof first.ticketMessageEntityId != "undefined" || typeof first.includeNonInlineAttachmentsInfo != "undefined")) {
      _request = ticketMessageEntityId;
      _options = includeNonInlineAttachmentsInfo;
    } else {
      _request = {
        ticketMessageEntityId,
        includeNonInlineAttachmentsInfo
      };
      _options = webapi_options;
    }
    return this._getTicketMessageWithOptionsAsync(_request, _options);
  }
  async _getTicketSummariesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetTicketSummaries", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TicketSummaryItemArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getTicketSummariesAsync(ticketIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = ticketIds;
    if (typeof first === "object" && first && typeof first.ticketIds != "undefined") {
      _request = ticketIds;
      _options = webapi_options;
    } else {
      _request = {
        ticketIds
      };
      _options = webapi_options;
    }
    return this._getTicketSummariesAsync(_request, _options);
  }
};

// server/node_modules/@superoffice/webapi/dist/esm/DatabaseTableAgent.js
var DatabaseTableAgent = class extends WebApiBase {
  constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
    const options = WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
    options.basePath = "v1/Agents/DatabaseTable/";
    super(options);
  }
  async _readRowAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ReadRow", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_TableRecord_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async readRowAsync(tableName, id, webapi_options) {
    let _request = null;
    let _options = null;
    const first = tableName;
    if (typeof first === "object" && first && (typeof first.tableName != "undefined" || typeof first.id != "undefined")) {
      _request = tableName;
      _options = id;
    } else {
      _request = {
        tableName,
        id
      };
      _options = webapi_options;
    }
    return this._readRowAsync(_request, _options);
  }
  async _insertRowAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("InsertRow", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async insertRowAsync(tableName, values, webapi_options) {
    let _request = null;
    let _options = null;
    const first = tableName;
    if (typeof first === "object" && first && (typeof first.tableName != "undefined" || typeof first.values != "undefined")) {
      _request = tableName;
      _options = values;
    } else {
      _request = {
        tableName,
        values
      };
      _options = webapi_options;
    }
    return this._insertRowAsync(_request, _options);
  }
  async _updateRowAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("UpdateRow", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async updateRowAsync(tableName, id, values, webapi_options) {
    let _request = null;
    let _options = null;
    const first = tableName;
    if (typeof first === "object" && first && (typeof first.tableName != "undefined" || typeof first.id != "undefined" || typeof first.values != "undefined")) {
      _request = tableName;
      _options = id;
    } else {
      _request = {
        tableName,
        id,
        values
      };
      _options = webapi_options;
    }
    return this._updateRowAsync(_request, _options);
  }
  async _deleteRowAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeleteRow", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async deleteRowAsync(tableName, id, webapi_options) {
    let _request = null;
    let _options = null;
    const first = tableName;
    if (typeof first === "object" && first && (typeof first.tableName != "undefined" || typeof first.id != "undefined")) {
      _request = tableName;
      _options = id;
    } else {
      _request = {
        tableName,
        id
      };
      _options = webapi_options;
    }
    return this._deleteRowAsync(_request, _options);
  }
  async _insertAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("Insert", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_MassOperationResult_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async insertAsync(tableName, columns, data, webapi_options) {
    let _request = null;
    let _options = null;
    const first = tableName;
    if (typeof first === "object" && first && (typeof first.tableName != "undefined" || typeof first.columns != "undefined" || typeof first.data != "undefined")) {
      _request = tableName;
      _options = columns;
    } else {
      _request = {
        tableName,
        columns,
        data
      };
      _options = webapi_options;
    }
    return this._insertAsync(_request, _options);
  }
  async _truncateAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("Truncate", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_MassOperationResult_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async truncateAsync(tableName, webapi_options) {
    let _request = null;
    let _options = null;
    const first = tableName;
    if (typeof first === "object" && first && typeof first.tableName != "undefined") {
      _request = tableName;
      _options = webapi_options;
    } else {
      _request = {
        tableName
      };
      _options = webapi_options;
    }
    return this._truncateAsync(_request, _options);
  }
  async _upsertAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("Upsert", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_MassOperationResult_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async upsertAsync(tableName, columns, keys, data, nomatchAction, returnRowStatus, webapi_options) {
    let _request = null;
    let _options = null;
    const first = tableName;
    if (typeof first === "object" && first && (typeof first.tableName != "undefined" || typeof first.columns != "undefined" || typeof first.keys != "undefined" || typeof first.data != "undefined" || typeof first.nomatchAction != "undefined" || typeof first.returnRowStatus != "undefined")) {
      _request = tableName;
      _options = columns;
    } else {
      _request = {
        tableName,
        columns,
        keys,
        data,
        nomatchAction,
        returnRowStatus
      };
      _options = webapi_options;
    }
    return this._upsertAsync(_request, _options);
  }
  async _deleteAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("Delete", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_MassOperationResult_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async deleteAsync(tableName, ids, webapi_options) {
    let _request = null;
    let _options = null;
    const first = tableName;
    if (typeof first === "object" && first && (typeof first.tableName != "undefined" || typeof first.ids != "undefined")) {
      _request = tableName;
      _options = ids;
    } else {
      _request = {
        tableName,
        ids
      };
      _options = webapi_options;
    }
    return this._deleteAsync(_request, _options);
  }
};

// server/node_modules/@superoffice/webapi/dist/esm/ChatAgent.js
var ChatAgent = class extends WebApiBase {
  constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
    const options = WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
    options.basePath = "v1/Agents/Chat/";
    super(options);
  }
  /**
   * Set default values into a new ChatSessionEntity.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultChatSessionEntityAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultChatSessionEntity", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ChatSessionEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing ChatSessionEntity or creates a new ChatSessionEntity if the id parameter is empty
   * @param entity - The ChatSessionEntity to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated ChatSessionEntity
   */
  async saveChatSessionEntityAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveChatSessionEntity", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ChatSessionEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Deletes the ChatSessionEntity
   * @param ChatSessionEntityId - The id of the ChatSessionEntity to be deleted.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   */
  async deleteChatSessionEntityAsync(ChatSessionEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("DeleteChatSessionEntity?ChatSessionEntityId=" + ChatSessionEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new ChatTopicAgent.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultChatTopicAgentAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultChatTopicAgent", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ChatTopicAgent_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new ChatTopicEntity.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultChatTopicEntityAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultChatTopicEntity", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ChatTopicEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing ChatTopicEntity or creates a new ChatTopicEntity if the id parameter is empty
   * @param entity - The ChatTopicEntity to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated ChatTopicEntity
   */
  async saveChatTopicEntityAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveChatTopicEntity", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ChatTopicEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Deletes the ChatTopicEntity
   * @param ChatTopicEntityId - The id of the ChatTopicEntity to be deleted.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   */
  async deleteChatTopicEntityAsync(ChatTopicEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("DeleteChatTopicEntity?ChatTopicEntityId=" + ChatTopicEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getChatPresenceAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetChatPresence", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ChatPresenceArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Get the chat presence status for all chat users
   * @returns An array with ChatPresence objects for each user
   */
  async getChatPresenceAsync(webapi_options) {
    return this._getChatPresenceAsync(webapi_options);
  }
  async _saveChatPresenceAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SaveChatPresence", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async saveChatPresenceAsync(chatPresence, webapi_options) {
    let _request = null;
    let _options = null;
    const first = chatPresence;
    if (typeof first === "object" && first && typeof first.chatPresence != "undefined") {
      _request = chatPresence;
      _options = webapi_options;
    } else {
      _request = {
        chatPresence
      };
      _options = webapi_options;
    }
    return this._saveChatPresenceAsync(_request, _options);
  }
  /*
   * Gets a ChatSessionEntity object.
   * @param chatSessionEntityId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single ChatSessionEntity
   */
  async getChatSessionEntityAsync(chatSessionEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetChatSessionEntity?chatSessionEntityId=" + chatSessionEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ChatSessionEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _chatSessionsForUserAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ChatSessionsForUser", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ChatSessionEntityArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Get all chat sessions which this user is a member of. Members means that you have at least one of: Can Respond, Notifications, Listen or Manager
   * @returns Array of chat sessions the current user can access
   */
  async chatSessionsForUserAsync(webapi_options) {
    return this._chatSessionsForUserAsync(webapi_options);
  }
  async _transferChatSessionAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("TransferChatSession", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ChatSessionEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async transferChatSessionAsync(chatSessionId, toAssociate, webapi_options) {
    let _request = null;
    let _options = null;
    const first = chatSessionId;
    if (typeof first === "object" && first && (typeof first.chatSessionId != "undefined" || typeof first.toAssociate != "undefined")) {
      _request = chatSessionId;
      _options = toAssociate;
    } else {
      _request = {
        chatSessionId,
        toAssociate
      };
      _options = webapi_options;
    }
    return this._transferChatSessionAsync(_request, _options);
  }
  async _acceptChatSessionTransferAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("AcceptChatSessionTransfer", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ChatSessionEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async acceptChatSessionTransferAsync(chatSessionId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = chatSessionId;
    if (typeof first === "object" && first && typeof first.chatSessionId != "undefined") {
      _request = chatSessionId;
      _options = webapi_options;
    } else {
      _request = {
        chatSessionId
      };
      _options = webapi_options;
    }
    return this._acceptChatSessionTransferAsync(_request, _options);
  }
  async _rejectChatSessionTransferAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("RejectChatSessionTransfer", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ChatSessionEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async rejectChatSessionTransferAsync(chatSessionId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = chatSessionId;
    if (typeof first === "object" && first && typeof first.chatSessionId != "undefined") {
      _request = chatSessionId;
      _options = webapi_options;
    } else {
      _request = {
        chatSessionId
      };
      _options = webapi_options;
    }
    return this._rejectChatSessionTransferAsync(_request, _options);
  }
  async _pickUpChatSessionAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("PickUpChatSession", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ChatSessionEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async pickUpChatSessionAsync(chatSessionId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = chatSessionId;
    if (typeof first === "object" && first && typeof first.chatSessionId != "undefined") {
      _request = chatSessionId;
      _options = webapi_options;
    } else {
      _request = {
        chatSessionId
      };
      _options = webapi_options;
    }
    return this._pickUpChatSessionAsync(_request, _options);
  }
  async _pickUpFirstChatSessionAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("PickUpFirstChatSession", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ChatSessionEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * &apos;answer&apos; the first available session from the queue: assign the session to the user. The welcome message is sent to the customer.
   * @returns The picked-up chat session
   */
  async pickUpFirstChatSessionAsync(webapi_options) {
    return this._pickUpFirstChatSessionAsync(webapi_options);
  }
  async _resetChatSessionAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ResetChatSession", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ChatSessionEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async resetChatSessionAsync(chatSessionId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = chatSessionId;
    if (typeof first === "object" && first && typeof first.chatSessionId != "undefined") {
      _request = chatSessionId;
      _options = webapi_options;
    } else {
      _request = {
        chatSessionId
      };
      _options = webapi_options;
    }
    return this._resetChatSessionAsync(_request, _options);
  }
  async _getChatTranscriptAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetChatTranscript", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getChatTranscriptAsync(chatSessionId, html, webapi_options) {
    let _request = null;
    let _options = null;
    const first = chatSessionId;
    if (typeof first === "object" && first && (typeof first.chatSessionId != "undefined" || typeof first.html != "undefined")) {
      _request = chatSessionId;
      _options = html;
    } else {
      _request = {
        chatSessionId,
        html
      };
      _options = webapi_options;
    }
    return this._getChatTranscriptAsync(_request, _options);
  }
  async _getChatMessagesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetChatMessages", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ChatMessageArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getChatMessagesAsync(chatSessionId, after, webapi_options) {
    let _request = null;
    let _options = null;
    const first = chatSessionId;
    if (typeof first === "object" && first && (typeof first.chatSessionId != "undefined" || typeof first.after != "undefined")) {
      _request = chatSessionId;
      _options = after;
    } else {
      _request = {
        chatSessionId,
        after
      };
      _options = webapi_options;
    }
    return this._getChatMessagesAsync(_request, _options);
  }
  async _addChatMessageAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("AddChatMessage", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ChatMessage_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async addChatMessageAsync(chatSessionId, message, webapi_options) {
    let _request = null;
    let _options = null;
    const first = chatSessionId;
    if (typeof first === "object" && first && (typeof first.chatSessionId != "undefined" || typeof first.message != "undefined")) {
      _request = chatSessionId;
      _options = message;
    } else {
      _request = {
        chatSessionId,
        message
      };
      _options = webapi_options;
    }
    return this._addChatMessageAsync(_request, _options);
  }
  /*
   * Gets a ChatTopicEntity object.
   * @param chatTopicEntityId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single ChatTopicEntity
   */
  async getChatTopicEntityAsync(chatTopicEntityId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetChatTopicEntity?chatTopicEntityId=" + chatTopicEntityId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ChatTopicEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _isWithinOpeningHoursAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("IsWithinOpeningHours", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async isWithinOpeningHoursAsync(chatTopicId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = chatTopicId;
    if (typeof first === "object" && first && typeof first.chatTopicId != "undefined") {
      _request = chatTopicId;
      _options = webapi_options;
    } else {
      _request = {
        chatTopicId
      };
      _options = webapi_options;
    }
    return this._isWithinOpeningHoursAsync(_request, _options);
  }
  async _chatTopicsForUserAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ChatTopicsForUser", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ChatTopicEntityArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Get all chat topics which this user is a member of. Members means that you have at least one of: Can Respond, Notifications, Listen or Manager
   * @returns Array of chat topics the current user can access
   */
  async chatTopicsForUserAsync(webapi_options) {
    return this._chatTopicsForUserAsync(webapi_options);
  }
  async _getUserAgentListAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetUserAgentList", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_MDOListItemArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getUserAgentListAsync(flat, onlyPresent, webapi_options) {
    let _request = null;
    let _options = null;
    const first = flat;
    if (typeof first === "object" && first && (typeof first.flat != "undefined" || typeof first.onlyPresent != "undefined")) {
      _request = flat;
      _options = onlyPresent;
    } else {
      _request = {
        flat,
        onlyPresent
      };
      _options = webapi_options;
    }
    return this._getUserAgentListAsync(_request, _options);
  }
  async _getChatTopicUserAgentListAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetChatTopicUserAgentList", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ChatTopicAgentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getChatTopicUserAgentListAsync(chatTopicId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = chatTopicId;
    if (typeof first === "object" && first && typeof first.chatTopicId != "undefined") {
      _request = chatTopicId;
      _options = webapi_options;
    } else {
      _request = {
        chatTopicId
      };
      _options = webapi_options;
    }
    return this._getChatTopicUserAgentListAsync(_request, _options);
  }
  async _getChatTopicUserAgentAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetChatTopicUserAgent", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ChatTopicAgent_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getChatTopicUserAgentAsync(chatTopicId, username, webapi_options) {
    let _request = null;
    let _options = null;
    const first = chatTopicId;
    if (typeof first === "object" && first && (typeof first.chatTopicId != "undefined" || typeof first.username != "undefined")) {
      _request = chatTopicId;
      _options = username;
    } else {
      _request = {
        chatTopicId,
        username
      };
      _options = webapi_options;
    }
    return this._getChatTopicUserAgentAsync(_request, _options);
  }
  async _addChatTopicUserAgentAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("AddChatTopicUserAgent", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ChatTopicAgent_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async addChatTopicUserAgentAsync(chatTopicId, useragent, webapi_options) {
    let _request = null;
    let _options = null;
    const first = chatTopicId;
    if (typeof first === "object" && first && (typeof first.chatTopicId != "undefined" || typeof first.useragent != "undefined")) {
      _request = chatTopicId;
      _options = useragent;
    } else {
      _request = {
        chatTopicId,
        useragent
      };
      _options = webapi_options;
    }
    return this._addChatTopicUserAgentAsync(_request, _options);
  }
  async _updateChatTopicUserAgentAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("UpdateChatTopicUserAgent", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ChatTopicAgent_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async updateChatTopicUserAgentAsync(chatTopicId, username, useragent, webapi_options) {
    let _request = null;
    let _options = null;
    const first = chatTopicId;
    if (typeof first === "object" && first && (typeof first.chatTopicId != "undefined" || typeof first.username != "undefined" || typeof first.useragent != "undefined")) {
      _request = chatTopicId;
      _options = username;
    } else {
      _request = {
        chatTopicId,
        username,
        useragent
      };
      _options = webapi_options;
    }
    return this._updateChatTopicUserAgentAsync(_request, _options);
  }
  async _updateChatTopicUserAgentsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("UpdateChatTopicUserAgents", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ChatTopicAgentArray_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async updateChatTopicUserAgentsAsync(chatTopicId, useragents, webapi_options) {
    let _request = null;
    let _options = null;
    const first = chatTopicId;
    if (typeof first === "object" && first && (typeof first.chatTopicId != "undefined" || typeof first.useragents != "undefined")) {
      _request = chatTopicId;
      _options = useragents;
    } else {
      _request = {
        chatTopicId,
        useragents
      };
      _options = webapi_options;
    }
    return this._updateChatTopicUserAgentsAsync(_request, _options);
  }
  async _deleteChatTopicUserAgentAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DeleteChatTopicUserAgent", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async deleteChatTopicUserAgentAsync(chatTopicId, username, webapi_options) {
    let _request = null;
    let _options = null;
    const first = chatTopicId;
    if (typeof first === "object" && first && (typeof first.chatTopicId != "undefined" || typeof first.username != "undefined")) {
      _request = chatTopicId;
      _options = username;
    } else {
      _request = {
        chatTopicId,
        username
      };
      _options = webapi_options;
    }
    return this._deleteChatTopicUserAgentAsync(_request, _options);
  }
  async _createChatSessionForTopicAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateChatSessionForTopic", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ChatSessionEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createChatSessionForTopicAsync(chatTopicId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = chatTopicId;
    if (typeof first === "object" && first && typeof first.chatTopicId != "undefined") {
      _request = chatTopicId;
      _options = webapi_options;
    } else {
      _request = {
        chatTopicId
      };
      _options = webapi_options;
    }
    return this._createChatSessionForTopicAsync(_request, _options);
  }
};

// server/node_modules/@superoffice/webapi/dist/esm/AIAgent.js
var AIAgent = class extends WebApiBase {
  constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
    const options = WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
    options.basePath = "v1/Agents/AI/";
    super(options);
  }
  async _getTrainingStatusAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetTrainingStatus", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = Create_CategorizationStatusResponse_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Calling the HugoAI endpoint to fetch the current training status.
   * @returns Carrier to describe the current status of HugoAI categorization
   */
  async getTrainingStatusAsync(webapi_options) {
    return this._getTrainingStatusAsync(webapi_options);
  }
  async _guessCategoryAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GuessCategory", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async guessCategoryAsync(ticketId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = ticketId;
    if (typeof first === "object" && first && typeof first.ticketId != "undefined") {
      _request = ticketId;
      _options = webapi_options;
    } else {
      _request = {
        ticketId
      };
      _options = webapi_options;
    }
    return this._guessCategoryAsync(_request, _options);
  }
  async _trainCategoryGuesserAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("TrainCategoryGuesser", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async trainCategoryGuesserAsync(selectionId, maxItems, maxTextLength, webapi_options) {
    let _request = null;
    let _options = null;
    const first = selectionId;
    if (typeof first === "object" && first && (typeof first.selectionId != "undefined" || typeof first.maxItems != "undefined" || typeof first.maxTextLength != "undefined")) {
      _request = selectionId;
      _options = maxItems;
    } else {
      _request = {
        selectionId,
        maxItems,
        maxTextLength
      };
      _options = webapi_options;
    }
    return this._trainCategoryGuesserAsync(_request, _options);
  }
  async _getChatbotResponseAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetChatbotResponse", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ChatbotTurn_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getChatbotResponseAsync(isoLangCode, userPrompt, displayValue, previousTurns, webapi_options) {
    let _request = null;
    let _options = null;
    const first = isoLangCode;
    if (typeof first === "object" && first && (typeof first.isoLangCode != "undefined" || typeof first.userPrompt != "undefined" || typeof first.displayValue != "undefined" || typeof first.previousTurns != "undefined")) {
      _request = isoLangCode;
      _options = userPrompt;
    } else {
      _request = {
        isoLangCode,
        userPrompt,
        displayValue,
        previousTurns
      };
      _options = webapi_options;
    }
    return this._getChatbotResponseAsync(_request, _options);
  }
  async _getChatbotPromptSuggestionsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetChatbotPromptSuggestions", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ChatbotTurn_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getChatbotPromptSuggestionsAsync(isoLangCode, soProtocol, currentContactId, currentPersonId, currentProjectId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = isoLangCode;
    if (typeof first === "object" && first && (typeof first.isoLangCode != "undefined" || typeof first.soProtocol != "undefined" || typeof first.currentContactId != "undefined" || typeof first.currentPersonId != "undefined" || typeof first.currentProjectId != "undefined")) {
      _request = isoLangCode;
      _options = soProtocol;
    } else {
      _request = {
        isoLangCode,
        soProtocol,
        currentContactId,
        currentPersonId,
        currentProjectId
      };
      _options = webapi_options;
    }
    return this._getChatbotPromptSuggestionsAsync(_request, _options);
  }
  async _detectLanguageAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DetectLanguage", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async detectLanguageAsync(text, webapi_options) {
    let _request = null;
    let _options = null;
    const first = text;
    if (typeof first === "object" && first && typeof first.text != "undefined") {
      _request = text;
      _options = webapi_options;
    } else {
      _request = {
        text
      };
      _options = webapi_options;
    }
    return this._detectLanguageAsync(_request, _options);
  }
  async _detectSentimentAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("DetectSentiment", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_Sentiment_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async detectSentimentAsync(text, webapi_options) {
    let _request = null;
    let _options = null;
    const first = text;
    if (typeof first === "object" && first && typeof first.text != "undefined") {
      _request = text;
      _options = webapi_options;
    } else {
      _request = {
        text
      };
      _options = webapi_options;
    }
    return this._detectSentimentAsync(_request, _options);
  }
  async _translateAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("Translate", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async translateAsync(text, targetLanguage, webapi_options) {
    let _request = null;
    let _options = null;
    const first = text;
    if (typeof first === "object" && first && (typeof first.text != "undefined" || typeof first.targetLanguage != "undefined")) {
      _request = text;
      _options = targetLanguage;
    } else {
      _request = {
        text,
        targetLanguage
      };
      _options = webapi_options;
    }
    return this._translateAsync(_request, _options);
  }
  async _translateEntityAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("TranslateEntity", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async translateEntityAsync(entityName, entityId, targetLanguage, webapi_options) {
    let _request = null;
    let _options = null;
    const first = entityName;
    if (typeof first === "object" && first && (typeof first.entityName != "undefined" || typeof first.entityId != "undefined" || typeof first.targetLanguage != "undefined")) {
      _request = entityName;
      _options = entityId;
    } else {
      _request = {
        entityName,
        entityId,
        targetLanguage
      };
      _options = webapi_options;
    }
    return this._translateEntityAsync(_request, _options);
  }
  async _summarizeTicketAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SummarizeTicket", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async summarizeTicketAsync(ticketId, numSentences, isoLangCode, webapi_options) {
    let _request = null;
    let _options = null;
    const first = ticketId;
    if (typeof first === "object" && first && (typeof first.ticketId != "undefined" || typeof first.numSentences != "undefined" || typeof first.isoLangCode != "undefined")) {
      _request = ticketId;
      _options = numSentences;
    } else {
      _request = {
        ticketId,
        numSentences,
        isoLangCode
      };
      _options = webapi_options;
    }
    return this._summarizeTicketAsync(_request, _options);
  }
  async _getSummarizeTicketPromptAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetSummarizeTicketPrompt", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ChatbotTurn_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getSummarizeTicketPromptAsync(ticketId, numSentences, summary, isoLangCode, webapi_options) {
    let _request = null;
    let _options = null;
    const first = ticketId;
    if (typeof first === "object" && first && (typeof first.ticketId != "undefined" || typeof first.numSentences != "undefined" || typeof first.summary != "undefined" || typeof first.isoLangCode != "undefined")) {
      _request = ticketId;
      _options = numSentences;
    } else {
      _request = {
        ticketId,
        numSentences,
        summary,
        isoLangCode
      };
      _options = webapi_options;
    }
    return this._getSummarizeTicketPromptAsync(_request, _options);
  }
  async _summarizeContactAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SummarizeContact", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async summarizeContactAsync(contactId, numSentences, isoLangCode, webapi_options) {
    let _request = null;
    let _options = null;
    const first = contactId;
    if (typeof first === "object" && first && (typeof first.contactId != "undefined" || typeof first.numSentences != "undefined" || typeof first.isoLangCode != "undefined")) {
      _request = contactId;
      _options = numSentences;
    } else {
      _request = {
        contactId,
        numSentences,
        isoLangCode
      };
      _options = webapi_options;
    }
    return this._summarizeContactAsync(_request, _options);
  }
  async _getSummarizeContactPromptAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetSummarizeContactPrompt", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ChatbotTurn_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getSummarizeContactPromptAsync(contactId, numSentences, summary, isoLangCode, webapi_options) {
    let _request = null;
    let _options = null;
    const first = contactId;
    if (typeof first === "object" && first && (typeof first.contactId != "undefined" || typeof first.numSentences != "undefined" || typeof first.summary != "undefined" || typeof first.isoLangCode != "undefined")) {
      _request = contactId;
      _options = numSentences;
    } else {
      _request = {
        contactId,
        numSentences,
        summary,
        isoLangCode
      };
      _options = webapi_options;
    }
    return this._getSummarizeContactPromptAsync(_request, _options);
  }
  async _summarizeSaleAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SummarizeSale", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async summarizeSaleAsync(saleId, numSentences, isoLangCode, webapi_options) {
    let _request = null;
    let _options = null;
    const first = saleId;
    if (typeof first === "object" && first && (typeof first.saleId != "undefined" || typeof first.numSentences != "undefined" || typeof first.isoLangCode != "undefined")) {
      _request = saleId;
      _options = numSentences;
    } else {
      _request = {
        saleId,
        numSentences,
        isoLangCode
      };
      _options = webapi_options;
    }
    return this._summarizeSaleAsync(_request, _options);
  }
  async _getSummarizeSalePromptAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetSummarizeSalePrompt", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ChatbotTurn_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getSummarizeSalePromptAsync(saleId, numSentences, summary, isoLangCode, webapi_options) {
    let _request = null;
    let _options = null;
    const first = saleId;
    if (typeof first === "object" && first && (typeof first.saleId != "undefined" || typeof first.numSentences != "undefined" || typeof first.summary != "undefined" || typeof first.isoLangCode != "undefined")) {
      _request = saleId;
      _options = numSentences;
    } else {
      _request = {
        saleId,
        numSentences,
        summary,
        isoLangCode
      };
      _options = webapi_options;
    }
    return this._getSummarizeSalePromptAsync(_request, _options);
  }
};

// server/node_modules/@superoffice/webapi/dist/esm/DocumentMigrationAgent.js
var DocumentMigrationAgent = class extends WebApiBase {
  constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
    const options = WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
    options.basePath = "v1/Agents/DocumentMigration/";
    super(options);
  }
  /**
   * Set default values into a new DocumentMigrationItemList.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultDocumentMigrationItemListAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultDocumentMigrationItemList", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DocumentMigrationItemList_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new DocumentTemplateMigrationList.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultDocumentTemplateMigrationListAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultDocumentTemplateMigrationList", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DocumentTemplateMigrationList_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getForAllDocumentsAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetForAllDocuments", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DocumentMigrationItemList_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getForAllDocumentsAsync(documentPluginId, includeEmails, webapi_options) {
    let _request = null;
    let _options = null;
    const first = documentPluginId;
    if (typeof first === "object" && first && (typeof first.documentPluginId != "undefined" || typeof first.includeEmails != "undefined")) {
      _request = documentPluginId;
      _options = includeEmails;
    } else {
      _request = {
        documentPluginId,
        includeEmails
      };
      _options = webapi_options;
    }
    return this._getForAllDocumentsAsync(_request, _options);
  }
  async _getForDateRangeAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetForDateRange", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DocumentMigrationItemList_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getForDateRangeAsync(documentPluginId, minDate, maxDate, includeEmails, webapi_options) {
    let _request = null;
    let _options = null;
    const first = documentPluginId;
    if (typeof first === "object" && first && (typeof first.documentPluginId != "undefined" || typeof first.minDate != "undefined" || typeof first.maxDate != "undefined" || typeof first.includeEmails != "undefined")) {
      _request = documentPluginId;
      _options = minDate;
    } else {
      _request = {
        documentPluginId,
        minDate,
        maxDate,
        includeEmails
      };
      _options = webapi_options;
    }
    return this._getForDateRangeAsync(_request, _options);
  }
  async _getForSelectionAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetForSelection", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DocumentMigrationItemList_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getForSelectionAsync(documentPluginId, selectionId, includeEmails, webapi_options) {
    let _request = null;
    let _options = null;
    const first = documentPluginId;
    if (typeof first === "object" && first && (typeof first.documentPluginId != "undefined" || typeof first.selectionId != "undefined" || typeof first.includeEmails != "undefined")) {
      _request = documentPluginId;
      _options = selectionId;
    } else {
      _request = {
        documentPluginId,
        selectionId,
        includeEmails
      };
      _options = webapi_options;
    }
    return this._getForSelectionAsync(_request, _options);
  }
  async _migrateDocumentToNewDocPluginAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("MigrateDocumentToNewDocPlugin", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async migrateDocumentToNewDocPluginAsync(documentId, documentPluginId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = documentId;
    if (typeof first === "object" && first && (typeof first.documentId != "undefined" || typeof first.documentPluginId != "undefined")) {
      _request = documentId;
      _options = documentPluginId;
    } else {
      _request = {
        documentId,
        documentPluginId
      };
      _options = webapi_options;
    }
    return this._migrateDocumentToNewDocPluginAsync(_request, _options);
  }
  async _hasDocumentsToMigrateAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("HasDocumentsToMigrate", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Checks if there are any documents in the current database stored using a non-default document-plugin, and which can be migrated.
   * @returns True if there are documents available to migrate.
   */
  async hasDocumentsToMigrateAsync(webapi_options) {
    return this._hasDocumentsToMigrateAsync(webapi_options);
  }
  async _getForTemplatesAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetForTemplates", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DocumentTemplateMigrationList_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getForTemplatesAsync(targetDocumentPluginId, includeEmails, webapi_options) {
    let _request = null;
    let _options = null;
    const first = targetDocumentPluginId;
    if (typeof first === "object" && first && (typeof first.targetDocumentPluginId != "undefined" || typeof first.includeEmails != "undefined")) {
      _request = targetDocumentPluginId;
      _options = includeEmails;
    } else {
      _request = {
        targetDocumentPluginId,
        includeEmails
      };
      _options = webapi_options;
    }
    return this._getForTemplatesAsync(_request, _options);
  }
  async _migrateTemplateToNewDocPluginAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("MigrateTemplateToNewDocPlugin", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async migrateTemplateToNewDocPluginAsync(documentTemplateId, targetDocumentPluginId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = documentTemplateId;
    if (typeof first === "object" && first && (typeof first.documentTemplateId != "undefined" || typeof first.targetDocumentPluginId != "undefined")) {
      _request = documentTemplateId;
      _options = targetDocumentPluginId;
    } else {
      _request = {
        documentTemplateId,
        targetDocumentPluginId
      };
      _options = webapi_options;
    }
    return this._migrateTemplateToNewDocPluginAsync(_request, _options);
  }
};

// server/node_modules/@superoffice/webapi/dist/esm/WorkflowAgent.js
var WorkflowAgent = class extends WebApiBase {
  constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
    const options = WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
    options.basePath = "v1/Agents/Workflow/";
    super(options);
  }
  /**
   * Set default values into a new EmailFlow.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultEmailFlowAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultEmailFlow", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_EmailFlow_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing EmailFlow or creates a new EmailFlow if the id parameter is empty
   * @param entity - The EmailFlow to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated EmailFlow
   */
  async saveEmailFlowAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveEmailFlow", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_EmailFlow_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Deletes the EmailFlow
   * @param EmailFlowId - The id of the EmailFlow to be deleted.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   */
  async deleteEmailFlowAsync(EmailFlowId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("DeleteEmailFlow?EmailFlowId=" + EmailFlowId, null, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new WorkflowEvent.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultWorkflowEventAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultWorkflowEvent", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_WorkflowEvent_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new WorkflowEventResult.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultWorkflowEventResultAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultWorkflowEventResult", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_WorkflowEventResult_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new WorkflowFilter.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultWorkflowFilterAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultWorkflowFilter", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_WorkflowFilter_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new WorkflowGoal.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultWorkflowGoalAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultWorkflowGoal", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_WorkflowGoal_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing WorkflowGoal or creates a new WorkflowGoal if the id parameter is empty
   * @param entity - The WorkflowGoal to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated WorkflowGoal
   */
  async saveWorkflowGoalAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveWorkflowGoal", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_WorkflowGoal_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Deletes the WorkflowGoal
   * @param WorkflowGoalId - The id of the WorkflowGoal to be deleted.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   */
  async deleteWorkflowGoalAsync(WorkflowGoalId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("DeleteWorkflowGoal?WorkflowGoalId=" + WorkflowGoalId, null, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new WorkflowStepOption.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultWorkflowStepOptionAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultWorkflowStepOption", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_WorkflowStepOption_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing WorkflowStepOption or creates a new WorkflowStepOption if the id parameter is empty
   * @param entity - The WorkflowStepOption to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated WorkflowStepOption
   */
  async saveWorkflowStepOptionAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveWorkflowStepOption", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_WorkflowStepOption_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Deletes the WorkflowStepOption
   * @param WorkflowStepOptionId - The id of the WorkflowStepOption to be deleted.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   */
  async deleteWorkflowStepOptionAsync(WorkflowStepOptionId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("DeleteWorkflowStepOption?WorkflowStepOptionId=" + WorkflowStepOptionId, null, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Set default values into a new WorkflowTrigger.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async createDefaultWorkflowTriggerAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("CreateDefaultWorkflowTrigger", null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_WorkflowTrigger_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Replace the existing WorkflowTrigger or creates a new WorkflowTrigger if the id parameter is empty
   * @param entity - The WorkflowTrigger to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New or updated WorkflowTrigger
   */
  async saveWorkflowTriggerAsync(entity, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("SaveWorkflowTrigger", entity, config);
        WebApiBase.SetCompleted(options);
        const res = Create_WorkflowTrigger_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Deletes the WorkflowTrigger
   * @param WorkflowTriggerId - The id of the WorkflowTrigger to be deleted.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   */
  async deleteWorkflowTriggerAsync(WorkflowTriggerId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("DeleteWorkflowTrigger?WorkflowTriggerId=" + WorkflowTriggerId, null, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets a EmailFlow object.
   * @param emailFlowId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single EmailFlow
   */
  async getEmailFlowAsync(emailFlowId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetEmailFlow?emailFlowId=" + emailFlowId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_EmailFlow_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _tryAddPersonsToEmailFlowAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("TryAddPersonsToEmailFlow", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async tryAddPersonsToEmailFlowAsync(emailFlowId, personIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = emailFlowId;
    if (typeof first === "object" && first && (typeof first.emailFlowId != "undefined" || typeof first.personIds != "undefined")) {
      _request = emailFlowId;
      _options = personIds;
    } else {
      _request = {
        emailFlowId,
        personIds
      };
      _options = webapi_options;
    }
    return this._tryAddPersonsToEmailFlowAsync(_request, _options);
  }
  async _removeParticipantsFromEmailFlowAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("RemoveParticipantsFromEmailFlow", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async removeParticipantsFromEmailFlowAsync(emailFlowId, workflowInstanceIds, webapi_options) {
    let _request = null;
    let _options = null;
    const first = emailFlowId;
    if (typeof first === "object" && first && (typeof first.emailFlowId != "undefined" || typeof first.workflowInstanceIds != "undefined")) {
      _request = emailFlowId;
      _options = workflowInstanceIds;
    } else {
      _request = {
        emailFlowId,
        workflowInstanceIds
      };
      _options = webapi_options;
    }
    return this._removeParticipantsFromEmailFlowAsync(_request, _options);
  }
  async _createEmailFlowContentAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateEmailFlowContent", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createEmailFlowContentAsync(emailFlowId, contentName, webapi_options) {
    let _request = null;
    let _options = null;
    const first = emailFlowId;
    if (typeof first === "object" && first && (typeof first.emailFlowId != "undefined" || typeof first.contentName != "undefined")) {
      _request = emailFlowId;
      _options = contentName;
    } else {
      _request = {
        emailFlowId,
        contentName
      };
      _options = webapi_options;
    }
    return this._createEmailFlowContentAsync(_request, _options);
  }
  async _connectEmailFlowContentAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("ConnectEmailFlowContent", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async connectEmailFlowContentAsync(emailFlowId, messageId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = emailFlowId;
    if (typeof first === "object" && first && (typeof first.emailFlowId != "undefined" || typeof first.messageId != "undefined")) {
      _request = emailFlowId;
      _options = messageId;
    } else {
      _request = {
        emailFlowId,
        messageId
      };
      _options = webapi_options;
    }
    return this._connectEmailFlowContentAsync(_request, _options);
  }
  async _copyEmailFlowContentAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CopyEmailFlowContent", request, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async copyEmailFlowContentAsync(emailFlowId, shipmentId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = emailFlowId;
    if (typeof first === "object" && first && (typeof first.emailFlowId != "undefined" || typeof first.shipmentId != "undefined")) {
      _request = emailFlowId;
      _options = shipmentId;
    } else {
      _request = {
        emailFlowId,
        shipmentId
      };
      _options = webapi_options;
    }
    return this._copyEmailFlowContentAsync(_request, _options);
  }
  async _runAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("Run", void 0, config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /**
   * Run the workflow engine right now
   * @returns Suggested time for next run
   */
  async runAsync(webapi_options) {
    return this._runAsync(webapi_options);
  }
  async _sendEventAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("SendEvent", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_WorkflowEventResult_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async sendEventAsync(workflowEvent, webapi_options) {
    let _request = null;
    let _options = null;
    const first = workflowEvent;
    if (typeof first === "object" && first && typeof first.workflowEvent != "undefined") {
      _request = workflowEvent;
      _options = webapi_options;
    } else {
      _request = {
        workflowEvent
      };
      _options = webapi_options;
    }
    return this._sendEventAsync(_request, _options);
  }
  /*
   * Gets a WorkflowGoal object.
   * @param workflowGoalId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single WorkflowGoal
   */
  async getWorkflowGoalAsync(workflowGoalId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetWorkflowGoal?workflowGoalId=" + workflowGoalId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_WorkflowGoal_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async _getWorkflowStepAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("GetWorkflowStep", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_WorkflowStepBase_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async getWorkflowStepAsync(workflowStepId, webapi_options) {
    let _request = null;
    let _options = null;
    const first = workflowStepId;
    if (typeof first === "object" && first && typeof first.workflowStepId != "undefined") {
      _request = workflowStepId;
      _options = webapi_options;
    } else {
      _request = {
        workflowStepId
      };
      _options = webapi_options;
    }
    return this._getWorkflowStepAsync(_request, _options);
  }
  async _addAfterWorkflowStepAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("AddAfterWorkflowStep", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_WorkflowStepBase_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async addAfterWorkflowStepAsync(workflowStepId, subStep, webapi_options) {
    let _request = null;
    let _options = null;
    const first = workflowStepId;
    if (typeof first === "object" && first && (typeof first.workflowStepId != "undefined" || typeof first.subStep != "undefined")) {
      _request = workflowStepId;
      _options = subStep;
    } else {
      _request = {
        workflowStepId,
        subStep
      };
      _options = webapi_options;
    }
    return this._addAfterWorkflowStepAsync(_request, _options);
  }
  async _createDefaultWorkflowStepFromTypeAsync(request, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        config.baseURL = this._options.baseUrl;
        const response = await this._axios.post("CreateDefaultWorkflowStepFromType", request, config);
        WebApiBase.SetCompleted(options);
        const res = Create_WorkflowStepBase_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  async createDefaultWorkflowStepFromTypeAsync(stepType, webapi_options) {
    let _request = null;
    let _options = null;
    const first = stepType;
    if (typeof first === "object" && first && typeof first.stepType != "undefined") {
      _request = stepType;
      _options = webapi_options;
    } else {
      _request = {
        stepType
      };
      _options = webapi_options;
    }
    return this._createDefaultWorkflowStepFromTypeAsync(_request, _options);
  }
  /*
   * Gets a WorkflowStepOption object.
   * @param workflowStepOptionId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single WorkflowStepOption
   */
  async getWorkflowStepOptionAsync(workflowStepOptionId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetWorkflowStepOption?workflowStepOptionId=" + workflowStepOptionId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_WorkflowStepOption_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * Gets a WorkflowTrigger object.
   * @param workflowTriggerId - The primary key.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A single WorkflowTrigger
   */
  async getWorkflowTriggerAsync(workflowTriggerId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("GetWorkflowTrigger?workflowTriggerId=" + workflowTriggerId, null, config);
        WebApiBase.SetCompleted(options);
        const res = Create_WorkflowTrigger_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
};

// server/node_modules/@superoffice/webapi/dist/esm/ContactRestApi.js
var ContactRestApi = class extends WebApiBase {
  constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
    const options = WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
    options.basePath = "v1/Contact/";
    super(options);
  }
  /**
   * `GET /api/v1/Contact/default`
   * Set default values into a new ContactEntity.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async getDefaultAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.get("default", config);
        WebApiBase.SetCompleted(options);
        const res = Create_ContactEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * `POST /api/v1/Contact/`
   * Creates a new ContactEntity
   * @param newContact - The ContactEntity to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New ContactEntity
   */
  async postAsync(newContact, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("", newContact, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ContactEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * `PUT /api/v1/Contact/123`
   * Replace the existing ContactEntity
   * @param contact - The ContactEntity to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns The updated ContactEntity
   */
  async putByIdAsync(id, contact, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.put(id.toString(), contact, config);
        WebApiBase.SetCompleted(options);
        let res = null;
        if (response.status != 304)
          res = Create_ContactEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * `PATCH /api/v1/Contact/123`
   * Updates an existing ContactEntity
   * @param contact - The partial ContactEntity containing updated values, or an array of RFC6902 PATCH operations.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns The updated ContactEntity
   */
  async patchByIdAsync(id, contact, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.patch(id.toString(), contact, config);
        WebApiBase.SetCompleted(options);
        let res = null;
        if (response.status != 304)
          res = Create_ContactEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * `DELETE /api/v1/Contact/123`
   * Deletes the ContactEntity
   * @param contactId - The id of the ContactEntity to be deleted.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   */
  async deleteByIdAsync(contactId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.delete(contactId.toString(), config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * `GET /api/v1/Contact/123`
   * Get an existing ContactEntity
   * @param contactId - The ContactEntity to be get.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns The ContactEntity
   */
  async getByIdAsync(contactId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.get(contactId.toString(), config);
        WebApiBase.SetCompleted(options);
        let res = null;
        if (response.status != 304)
          res = Create_ContactEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
};

// server/node_modules/@superoffice/webapi/dist/esm/PersonRestApi.js
var PersonRestApi = class extends WebApiBase {
  constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
    const options = WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
    options.basePath = "v1/Person/";
    super(options);
  }
  /**
   * `GET /api/v1/Person/default`
   * Set default values into a new PersonEntity.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async getDefaultAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.get("default", config);
        WebApiBase.SetCompleted(options);
        const res = Create_PersonEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * `POST /api/v1/Person/`
   * Creates a new PersonEntity
   * @param newPerson - The PersonEntity to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New PersonEntity
   */
  async postAsync(newPerson, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("", newPerson, config);
        WebApiBase.SetCompleted(options);
        const res = Create_PersonEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * `PUT /api/v1/Person/123`
   * Replace the existing PersonEntity
   * @param person - The PersonEntity to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns The updated PersonEntity
   */
  async putByIdAsync(id, person, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.put(id.toString(), person, config);
        WebApiBase.SetCompleted(options);
        let res = null;
        if (response.status != 304)
          res = Create_PersonEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * `PATCH /api/v1/Person/123`
   * Updates an existing PersonEntity
   * @param person - The partial PersonEntity containing updated values, or an array of RFC6902 PATCH operations.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns The updated PersonEntity
   */
  async patchByIdAsync(id, person, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.patch(id.toString(), person, config);
        WebApiBase.SetCompleted(options);
        let res = null;
        if (response.status != 304)
          res = Create_PersonEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * `DELETE /api/v1/Person/123`
   * Deletes the PersonEntity
   * @param personId - The id of the PersonEntity to be deleted.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   */
  async deleteByIdAsync(personId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.delete(personId.toString(), config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * `GET /api/v1/Person/123`
   * Get an existing PersonEntity
   * @param personId - The PersonEntity to be get.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns The PersonEntity
   */
  async getByIdAsync(personId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.get(personId.toString(), config);
        WebApiBase.SetCompleted(options);
        let res = null;
        if (response.status != 304)
          res = Create_PersonEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
};

// server/node_modules/@superoffice/webapi/dist/esm/SaleRestApi.js
var SaleRestApi = class extends WebApiBase {
  constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
    const options = WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
    options.basePath = "v1/Sale/";
    super(options);
  }
  /**
   * `GET /api/v1/Sale/default`
   * Set default values into a new SaleEntity.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async getDefaultAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.get("default", config);
        WebApiBase.SetCompleted(options);
        const res = Create_SaleEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * `POST /api/v1/Sale/`
   * Creates a new SaleEntity
   * @param newSale - The SaleEntity to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New SaleEntity
   */
  async postAsync(newSale, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("", newSale, config);
        WebApiBase.SetCompleted(options);
        const res = Create_SaleEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * `PUT /api/v1/Sale/123`
   * Replace the existing SaleEntity
   * @param sale - The SaleEntity to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns The updated SaleEntity
   */
  async putByIdAsync(id, sale, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.put(id.toString(), sale, config);
        WebApiBase.SetCompleted(options);
        let res = null;
        if (response.status != 304)
          res = Create_SaleEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * `PATCH /api/v1/Sale/123`
   * Updates an existing SaleEntity
   * @param sale - The partial SaleEntity containing updated values, or an array of RFC6902 PATCH operations.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns The updated SaleEntity
   */
  async patchByIdAsync(id, sale, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.patch(id.toString(), sale, config);
        WebApiBase.SetCompleted(options);
        let res = null;
        if (response.status != 304)
          res = Create_SaleEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * `DELETE /api/v1/Sale/123`
   * Deletes the SaleEntity
   * @param saleId - The id of the SaleEntity to be deleted.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   */
  async deleteByIdAsync(saleId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.delete(saleId.toString(), config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * `GET /api/v1/Sale/123`
   * Get an existing SaleEntity
   * @param saleId - The SaleEntity to be get.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns The SaleEntity
   */
  async getByIdAsync(saleId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.get(saleId.toString(), config);
        WebApiBase.SetCompleted(options);
        let res = null;
        if (response.status != 304)
          res = Create_SaleEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
};

// server/node_modules/@superoffice/webapi/dist/esm/ProjectRestApi.js
var ProjectRestApi = class extends WebApiBase {
  constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
    const options = WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
    options.basePath = "v1/Project/";
    super(options);
  }
  /**
   * `GET /api/v1/Project/default`
   * Set default values into a new ProjectEntity.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async getDefaultAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.get("default", config);
        WebApiBase.SetCompleted(options);
        const res = Create_ProjectEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * `POST /api/v1/Project/`
   * Creates a new ProjectEntity
   * @param newProject - The ProjectEntity to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New ProjectEntity
   */
  async postAsync(newProject, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("", newProject, config);
        WebApiBase.SetCompleted(options);
        const res = Create_ProjectEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * `PUT /api/v1/Project/123`
   * Replace the existing ProjectEntity
   * @param project - The ProjectEntity to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns The updated ProjectEntity
   */
  async putByIdAsync(id, project, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.put(id.toString(), project, config);
        WebApiBase.SetCompleted(options);
        let res = null;
        if (response.status != 304)
          res = Create_ProjectEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * `PATCH /api/v1/Project/123`
   * Updates an existing ProjectEntity
   * @param project - The partial ProjectEntity containing updated values, or an array of RFC6902 PATCH operations.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns The updated ProjectEntity
   */
  async patchByIdAsync(id, project, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.patch(id.toString(), project, config);
        WebApiBase.SetCompleted(options);
        let res = null;
        if (response.status != 304)
          res = Create_ProjectEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * `DELETE /api/v1/Project/123`
   * Deletes the ProjectEntity
   * @param projectId - The id of the ProjectEntity to be deleted.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   */
  async deleteByIdAsync(projectId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.delete(projectId.toString(), config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * `GET /api/v1/Project/123`
   * Get an existing ProjectEntity
   * @param projectId - The ProjectEntity to be get.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns The ProjectEntity
   */
  async getByIdAsync(projectId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.get(projectId.toString(), config);
        WebApiBase.SetCompleted(options);
        let res = null;
        if (response.status != 304)
          res = Create_ProjectEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
};

// server/node_modules/@superoffice/webapi/dist/esm/AppointmentRestApi.js
var AppointmentRestApi = class extends WebApiBase {
  constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
    const options = WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
    options.basePath = "v1/Appointment/";
    super(options);
  }
  /**
   * `GET /api/v1/Appointment/default`
   * Set default values into a new AppointmentEntity.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async getDefaultAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.get("default", config);
        WebApiBase.SetCompleted(options);
        const res = Create_AppointmentEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * `POST /api/v1/Appointment/`
   * Creates a new AppointmentEntity
   * @param newAppointment - The AppointmentEntity to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New AppointmentEntity
   */
  async postAsync(newAppointment, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("", newAppointment, config);
        WebApiBase.SetCompleted(options);
        const res = Create_AppointmentEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * `PUT /api/v1/Appointment/123`
   * Replace the existing AppointmentEntity
   * @param appointment - The AppointmentEntity to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns The updated AppointmentEntity
   */
  async putByIdAsync(id, appointment, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.put(id.toString(), appointment, config);
        WebApiBase.SetCompleted(options);
        let res = null;
        if (response.status != 304)
          res = Create_AppointmentEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * `PATCH /api/v1/Appointment/123`
   * Updates an existing AppointmentEntity
   * @param appointment - The partial AppointmentEntity containing updated values, or an array of RFC6902 PATCH operations.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns The updated AppointmentEntity
   */
  async patchByIdAsync(id, appointment, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.patch(id.toString(), appointment, config);
        WebApiBase.SetCompleted(options);
        let res = null;
        if (response.status != 304)
          res = Create_AppointmentEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * `DELETE /api/v1/Appointment/123`
   * Deletes the AppointmentEntity
   * @param appointmentId - The id of the AppointmentEntity to be deleted.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   */
  async deleteByIdAsync(appointmentId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.delete(appointmentId.toString(), config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * `GET /api/v1/Appointment/123`
   * Get an existing AppointmentEntity
   * @param appointmentId - The AppointmentEntity to be get.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns The AppointmentEntity
   */
  async getByIdAsync(appointmentId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.get(appointmentId.toString(), config);
        WebApiBase.SetCompleted(options);
        let res = null;
        if (response.status != 304)
          res = Create_AppointmentEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
};

// server/node_modules/@superoffice/webapi/dist/esm/DocumentRestApi.js
var DocumentRestApi = class extends WebApiBase {
  constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
    const options = WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
    options.basePath = "v1/Document/";
    super(options);
  }
  /**
   * `GET /api/v1/Document/default`
   * Set default values into a new DocumentEntity.
   * NetServer calculates default values on the entity, which is required when creating/storing a new instance
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns A blank entity.
   */
  async getDefaultAsync(options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.get("default", config);
        WebApiBase.SetCompleted(options);
        const res = Create_DocumentEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * `POST /api/v1/Document/`
   * Creates a new DocumentEntity
   * @param newDocument - The DocumentEntity to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns New DocumentEntity
   */
  async postAsync(newDocument, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.post("", newDocument, config);
        WebApiBase.SetCompleted(options);
        const res = Create_DocumentEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * `PUT /api/v1/Document/123`
   * Replace the existing DocumentEntity
   * @param document - The DocumentEntity to be saved.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns The updated DocumentEntity
   */
  async putByIdAsync(id, document2, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.put(id.toString(), document2, config);
        WebApiBase.SetCompleted(options);
        let res = null;
        if (response.status != 304)
          res = Create_DocumentEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * `PATCH /api/v1/Document/123`
   * Updates an existing DocumentEntity
   * @param document - The partial DocumentEntity containing updated values, or an array of RFC6902 PATCH operations.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns The updated DocumentEntity
   */
  async patchByIdAsync(id, document2, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.patch(id.toString(), document2, config);
        WebApiBase.SetCompleted(options);
        let res = null;
        if (response.status != 304)
          res = Create_DocumentEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * `DELETE /api/v1/Document/123`
   * Deletes the DocumentEntity
   * @param documentId - The id of the DocumentEntity to be deleted.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   */
  async deleteByIdAsync(documentId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.delete(documentId.toString(), config);
        WebApiBase.SetCompleted(options);
        const res = response.data;
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
  /*
   * `GET /api/v1/Document/123`
   * Get an existing DocumentEntity
   * @param documentId - The DocumentEntity to be get.
   * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
   * @returns The DocumentEntity
   */
  async getByIdAsync(documentId, options) {
    const config = WebApiBase.GetAxiosRequestConfig(options, this._options);
    WebApiBase.SetPending(options);
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this._axios.get(documentId.toString(), config);
        WebApiBase.SetCompleted(options);
        let res = null;
        if (response.status != 304)
          res = Create_DocumentEntity_From(response.data);
        resolve(res);
      } catch (err) {
        WebApiBase.HandleError(options, config, err);
        reject(err);
      }
    });
  }
};

// server/node_modules/@superoffice/webapi/dist/esm/WebApi.js
var WebApi = class extends WebApiBase {
  constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
    WebApiBase._global_options = void 0;
    let options = WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
    super(options, false);
  }
  /** Define global options for webapi agents. Once called, you don't need to pass baseUrl to agents.
   *  This configuration also happens first time an agent is constructed.
   */
  static configure(baseUrlOrOptions, configOrOptions, resourceManagerOrOptions) {
    WebApiBase._global_options = void 0;
    const options = WebApiBase.FigureOutOptions(baseUrlOrOptions, configOrOptions, resourceManagerOrOptions);
    WebApiBase._global_options = options;
  }
  /** Authenticate with Basic username:password value. Will not work in CRM Online. */
  authenticateWithPassword(username, password) {
    let opts = WebApiBase._global_options;
    opts = opts || this._options || {};
    opts.axiosConfig = opts.axiosConfig || {};
    opts.axiosConfig.auth = { username, password };
  }
  /** Authenticate with SOTicket value. */
  authenticateWithTicket(ticket) {
    let opts = WebApiBase._global_options;
    opts = opts || this._options || {};
    opts.axiosConfig = opts.axiosConfig || {};
    opts.axiosConfig.headers = opts.axiosConfig.headers || {};
    opts.axiosConfig.headers["Authorization"] = "SOTicket " + ticket;
  }
  /** Authenticate with Bearer token */
  authenticateWithToken(token) {
    let opts = WebApiBase._global_options;
    opts = opts || this._options || {};
    opts.axiosConfig = opts.axiosConfig || {};
    opts.axiosConfig.headers = opts.axiosConfig.headers || {};
    opts.axiosConfig.headers["Authorization"] = "Bearer " + token;
  }
  /** Set SO-AppToken header when talking to CRM Online */
  applicationToken(token) {
    let opts = WebApiBase._global_options;
    opts = opts || this._options || {};
    opts.axiosConfig = opts.axiosConfig || {};
    opts.axiosConfig.headers = opts.axiosConfig.headers || {};
    opts.axiosConfig.headers["SO-AppToken"] = token;
  }
  // REST API -----------------
  /** The Contact Service. The service implements all services working with the Contact object */
  getContactRestApi(resourceParsing) {
    const options = WebApiBase.FigureOutOptions(this._options);
    if (typeof resourceParsing == "number")
      options.resourceParsing = resourceParsing;
    return new ContactRestApi(options);
  }
  /** The Person Service. The service implements all services working with the Person object. */
  getPersonRestApi(resourceParsing) {
    const options = WebApiBase.FigureOutOptions(this._options);
    if (typeof resourceParsing == "number")
      options.resourceParsing = resourceParsing;
    return new PersonRestApi(options);
  }
  /** The Sale Entity contains the sale amount, currency, and sale members. Sales are linked to contacts, persons, and/or projects. */
  getSaleRestApi(resourceParsing) {
    const options = WebApiBase.FigureOutOptions(this._options);
    if (typeof resourceParsing == "number")
      options.resourceParsing = resourceParsing;
    return new SaleRestApi(options);
  }
  /** The Project Service. The service implements all services working with the Project object */
  getProjectRestApi(resourceParsing) {
    const options = WebApiBase.FigureOutOptions(this._options);
    if (typeof resourceParsing == "number")
      options.resourceParsing = resourceParsing;
    return new ProjectRestApi(options);
  }
  /** Appointments appear in the diary, and have links to a Contact/Person and possibly a Project or Sale. They have start and end time+date. */
  getAppointmentRestApi(resourceParsing) {
    const options = WebApiBase.FigureOutOptions(this._options);
    if (typeof resourceParsing == "number")
      options.resourceParsing = resourceParsing;
    return new AppointmentRestApi(options);
  }
  /**  */
  getDocumentRestApi(resourceParsing) {
    const options = WebApiBase.FigureOutOptions(this._options);
    if (typeof resourceParsing == "number")
      options.resourceParsing = resourceParsing;
    return new DocumentRestApi(options);
  }
  // AGENTS API ------------
  /** Services for the Quote Management feature, part of the Sale module */
  getQuoteAgent(resourceParsing) {
    const options = WebApiBase.FigureOutOptions(this._options);
    if (typeof resourceParsing == "number")
      options.resourceParsing = resourceParsing;
    return new QuoteAgent(options);
  }
  /** Services for the ERP Integration Services feature */
  getErpSyncAgent(resourceParsing) {
    const options = WebApiBase.FigureOutOptions(this._options);
    if (typeof resourceParsing == "number")
      options.resourceParsing = resourceParsing;
    return new ErpSyncAgent(options);
  }
  /** String resource substitution management. */
  getResourceAgent(resourceParsing) {
    const options = WebApiBase.FigureOutOptions(this._options);
    if (typeof resourceParsing == "number")
      options.resourceParsing = resourceParsing;
    return new ResourceAgent(options);
  }
  /** Contact (company) data services. */
  getContactAgent(resourceParsing) {
    const options = WebApiBase.FigureOutOptions(this._options);
    if (typeof resourceParsing == "number")
      options.resourceParsing = resourceParsing;
    return new ContactAgent(options);
  }
  /** Person data services. */
  getPersonAgent(resourceParsing) {
    const options = WebApiBase.FigureOutOptions(this._options);
    if (typeof resourceParsing == "number")
      options.resourceParsing = resourceParsing;
    return new PersonAgent(options);
  }
  /** Sale data services */
  getSaleAgent(resourceParsing) {
    const options = WebApiBase.FigureOutOptions(this._options);
    if (typeof resourceParsing == "number")
      options.resourceParsing = resourceParsing;
    return new SaleAgent(options);
  }
  /** Collection of all services for searching for person or contact (company) phone numbers. */
  getPhoneListAgent(resourceParsing) {
    const options = WebApiBase.FigureOutOptions(this._options);
    if (typeof resourceParsing == "number")
      options.resourceParsing = resourceParsing;
    return new PhoneListAgent(options);
  }
  /** Collection of all services that works with Project data. */
  getProjectAgent(resourceParsing) {
    const options = WebApiBase.FigureOutOptions(this._options);
    if (typeof resourceParsing == "number")
      options.resourceParsing = resourceParsing;
    return new ProjectAgent(options);
  }
  /** Collection of all services that works with Appointment data. */
  getAppointmentAgent(resourceParsing) {
    const options = WebApiBase.FigureOutOptions(this._options);
    if (typeof resourceParsing == "number")
      options.resourceParsing = resourceParsing;
    return new AppointmentAgent(options);
  }
  /** Collection of all services that works with Foreign key data (Key/Value pairs) */
  getForeignSystemAgent(resourceParsing) {
    const options = WebApiBase.FigureOutOptions(this._options);
    if (typeof resourceParsing == "number")
      options.resourceParsing = resourceParsing;
    return new ForeignSystemAgent(options);
  }
  /** Collection of all services that works with Document data. This is services for the document information, not the physical document themselves. These are handled by the BLOB service methods. */
  getDocumentAgent(resourceParsing) {
    const options = WebApiBase.FigureOutOptions(this._options);
    if (typeof resourceParsing == "number")
      options.resourceParsing = resourceParsing;
    return new DocumentAgent(options);
  }
  /** Collection of all services that works with Lists. These are typical lists of data shown in dropdown list, checkbox lists, etc. */
  getListAgent(resourceParsing) {
    const options = WebApiBase.FigureOutOptions(this._options);
    if (typeof resourceParsing == "number")
      options.resourceParsing = resourceParsing;
    return new ListAgent(options);
  }
  /** Collection of all services that works with binary objects (BLOBS), e.g. Images and documents. */
  getBLOBAgent(resourceParsing) {
    const options = WebApiBase.FigureOutOptions(this._options);
    if (typeof resourceParsing == "number")
      options.resourceParsing = resourceParsing;
    return new BLOBAgent(options);
  }
  /** Navigator stuff. */
  getNavigatorAgent(resourceParsing) {
    const options = WebApiBase.FigureOutOptions(this._options);
    if (typeof resourceParsing == "number")
      options.resourceParsing = resourceParsing;
    return new NavigatorAgent(options);
  }
  /** MDO Lists, reading, searching, and item lookup. */
  getMDOAgent(resourceParsing) {
    const options = WebApiBase.FigureOutOptions(this._options);
    if (typeof resourceParsing == "number")
      options.resourceParsing = resourceParsing;
    return new MDOAgent(options);
  }
  /** User interface configuration - XMLs and other elements such as inter-client URLs */
  getConfigurationAgent(resourceParsing) {
    const options = WebApiBase.FigureOutOptions(this._options);
    if (typeof resourceParsing == "number")
      options.resourceParsing = resourceParsing;
    return new ConfigurationAgent(options);
  }
  /** User interface view state, history, currentXXX values */
  getViewStateAgent(resourceParsing) {
    const options = WebApiBase.FigureOutOptions(this._options);
    if (typeof resourceParsing == "number")
      options.resourceParsing = resourceParsing;
    return new ViewStateAgent(options);
  }
  /** Associate utilities, notes, not user admininstration */
  getAssociateAgent(resourceParsing) {
    const options = WebApiBase.FigureOutOptions(this._options);
    if (typeof resourceParsing == "number")
      options.resourceParsing = resourceParsing;
    return new AssociateAgent(options);
  }
  /** Diagnostics, usage data collection, caches and flushing */
  getDiagnosticsAgent(resourceParsing) {
    const options = WebApiBase.FigureOutOptions(this._options);
    if (typeof resourceParsing == "number")
      options.resourceParsing = resourceParsing;
    return new DiagnosticsAgent(options);
  }
  /** Tooltip system, hint to text transformation */
  getTooltipsAgent(resourceParsing) {
    const options = WebApiBase.FigureOutOptions(this._options);
    if (typeof resourceParsing == "number")
      options.resourceParsing = resourceParsing;
    return new TooltipsAgent(options);
  }
  /** Get preview strings from a hint */
  getPreviewsAgent(resourceParsing) {
    const options = WebApiBase.FigureOutOptions(this._options);
    if (typeof resourceParsing == "number")
      options.resourceParsing = resourceParsing;
    return new PreviewsAgent(options);
  }
  /** Selections, entities, members and tasks */
  getSelectionAgent(resourceParsing) {
    const options = WebApiBase.FigureOutOptions(this._options);
    if (typeof resourceParsing == "number")
      options.resourceParsing = resourceParsing;
    return new SelectionAgent(options);
  }
  /** Email connection, reading, sending */
  getEMailAgent(resourceParsing) {
    const options = WebApiBase.FigureOutOptions(this._options);
    if (typeof resourceParsing == "number")
      options.resourceParsing = resourceParsing;
    return new EMailAgent(options);
  }
  /** Find functions */
  getFindAgent(resourceParsing) {
    const options = WebApiBase.FigureOutOptions(this._options);
    if (typeof resourceParsing == "number")
      options.resourceParsing = resourceParsing;
    return new FindAgent(options);
  }
  /** Webhook definitions - webhooks signal other systems about events inside NetServer */
  getWebhookAgent(resourceParsing) {
    const options = WebApiBase.FigureOutOptions(this._options);
    if (typeof resourceParsing == "number")
      options.resourceParsing = resourceParsing;
    return new WebhookAgent(options);
  }
  /** Data and function right queries */
  getSentryAgent(resourceParsing) {
    const options = WebApiBase.FigureOutOptions(this._options);
    if (typeof resourceParsing == "number")
      options.resourceParsing = resourceParsing;
    return new SentryAgent(options);
  }
  /** Returns information about user-defined fields, like field type, field size, field label text, default value. Does not return the actual values in the user-defined fields. The values are returned on the entity objects. */
  getUserDefinedFieldInfoAgent(resourceParsing) {
    const options = WebApiBase.FigureOutOptions(this._options);
    if (typeof resourceParsing == "number")
      options.resourceParsing = resourceParsing;
    return new UserDefinedFieldInfoAgent(options);
  }
  /** Run reports, set favourites, labels */
  getReportAgent(resourceParsing) {
    const options = WebApiBase.FigureOutOptions(this._options);
    if (typeof resourceParsing == "number")
      options.resourceParsing = resourceParsing;
    return new ReportAgent(options);
  }
  /** Administration and maintenance of SAINT counters and statuses */
  getSaintAgent(resourceParsing) {
    const options = WebApiBase.FigureOutOptions(this._options);
    if (typeof resourceParsing == "number")
      options.resourceParsing = resourceParsing;
    return new SaintAgent(options);
  }
  /** Start, stop and monitor predefined batch tasks */
  getBatchAgent(resourceParsing) {
    const options = WebApiBase.FigureOutOptions(this._options);
    if (typeof resourceParsing == "number")
      options.resourceParsing = resourceParsing;
    return new BatchAgent(options);
  }
  /** Contact/Person relations */
  getRelationAgent(resourceParsing) {
    const options = WebApiBase.FigureOutOptions(this._options);
    if (typeof resourceParsing == "number")
      options.resourceParsing = resourceParsing;
    return new RelationAgent(options);
  }
  /** ArchiveList functions of all kinds */
  getArchiveAgent(resourceParsing) {
    const options = WebApiBase.FigureOutOptions(this._options);
    if (typeof resourceParsing == "number")
      options.resourceParsing = resourceParsing;
    return new ArchiveAgent(options);
  }
  /** Services specific to the Audience client */
  getAudienceAgent(resourceParsing) {
    const options = WebApiBase.FigureOutOptions(this._options);
    if (typeof resourceParsing == "number")
      options.resourceParsing = resourceParsing;
    return new AudienceAgent(options);
  }
  /** Preferences, user interface tab configuration */
  getPreferenceAgent(resourceParsing) {
    const options = WebApiBase.FigureOutOptions(this._options);
    if (typeof resourceParsing == "number")
      options.resourceParsing = resourceParsing;
    return new PreferenceAgent(options);
  }
  /** License query, download, activation */
  getLicenseAgent(resourceParsing) {
    const options = WebApiBase.FigureOutOptions(this._options);
    if (typeof resourceParsing == "number")
      options.resourceParsing = resourceParsing;
    return new LicenseAgent(options);
  }
  /** User administration */
  getUserAgent(resourceParsing) {
    const options = WebApiBase.FigureOutOptions(this._options);
    if (typeof resourceParsing == "number")
      options.resourceParsing = resourceParsing;
    return new UserAgent(options);
  }
  /** Replication/Travel administration */
  getReplicationAgent(resourceParsing) {
    const options = WebApiBase.FigureOutOptions(this._options);
    if (typeof resourceParsing == "number")
      options.resourceParsing = resourceParsing;
    return new ReplicationAgent(options);
  }
  /** TimeZone maintenance */
  getTimeZoneAgent(resourceParsing) {
    const options = WebApiBase.FigureOutOptions(this._options);
    if (typeof resourceParsing == "number")
      options.resourceParsing = resourceParsing;
    return new TimeZoneAgent(options);
  }
  /** SMS and other external messaging systems */
  getMessagingAgent(resourceParsing) {
    const options = WebApiBase.FigureOutOptions(this._options);
    if (typeof resourceParsing == "number")
      options.resourceParsing = resourceParsing;
    return new MessagingAgent(options);
  }
  /** This agent can be used to import data into the system */
  getImportAgent(resourceParsing) {
    const options = WebApiBase.FigureOutOptions(this._options);
    if (typeof resourceParsing == "number")
      options.resourceParsing = resourceParsing;
    return new ImportAgent(options);
  }
  /** This agent can be used to manage the free text system */
  getFreeTextAgent(resourceParsing) {
    const options = WebApiBase.FigureOutOptions(this._options);
    if (typeof resourceParsing == "number")
      options.resourceParsing = resourceParsing;
    return new FreeTextAgent(options);
  }
  /** This agent can be used to manage number allocation */
  getNumberAllocationAgent(resourceParsing) {
    const options = WebApiBase.FigureOutOptions(this._options);
    if (typeof resourceParsing == "number")
      options.resourceParsing = resourceParsing;
    return new NumberAllocationAgent(options);
  }
  /** Agent used for Customer Service methods */
  getCustomerServiceAgent(resourceParsing) {
    const options = WebApiBase.FigureOutOptions(this._options);
    if (typeof resourceParsing == "number")
      options.resourceParsing = resourceParsing;
    return new CustomerServiceAgent(options);
  }
  /** Agent with Pocket specific functionality */
  getPocketAgent(resourceParsing) {
    const options = WebApiBase.FigureOutOptions(this._options);
    if (typeof resourceParsing == "number")
      options.resourceParsing = resourceParsing;
    return new PocketAgent(options);
  }
  /** Agent lets you configure dashboard tiles and retrieve dashboard data */
  getDashboardAgent(resourceParsing) {
    const options = WebApiBase.FigureOutOptions(this._options);
    if (typeof resourceParsing == "number")
      options.resourceParsing = resourceParsing;
    return new DashboardAgent(options);
  }
  /** Agent that lets you configure dashboard tiles and retrieve dashboard data */
  getDashAgent(resourceParsing) {
    const options = WebApiBase.FigureOutOptions(this._options);
    if (typeof resourceParsing == "number")
      options.resourceParsing = resourceParsing;
    return new DashAgent(options);
  }
  /** Agent lets you configure targets, and retrieve targets */
  getTargetsAgent(resourceParsing) {
    const options = WebApiBase.FigureOutOptions(this._options);
    if (typeof resourceParsing == "number")
      options.resourceParsing = resourceParsing;
    return new TargetsAgent(options);
  }
  /** Agent used for retrieveing and setting favourites */
  getFavouriteAgent(resourceParsing) {
    const options = WebApiBase.FigureOutOptions(this._options);
    if (typeof resourceParsing == "number")
      options.resourceParsing = resourceParsing;
    return new FavouriteAgent(options);
  }
  /** Database schema queries and changes */
  getDatabaseAgent(resourceParsing) {
    const options = WebApiBase.FigureOutOptions(this._options);
    if (typeof resourceParsing == "number")
      options.resourceParsing = resourceParsing;
    return new DatabaseAgent(options);
  }
  /** Agent used for bulk update methods */
  getBulkUpdateAgent(resourceParsing) {
    const options = WebApiBase.FigureOutOptions(this._options);
    if (typeof resourceParsing == "number")
      options.resourceParsing = resourceParsing;
    return new BulkUpdateAgent(options);
  }
  /** Agent used for Marketing functions, such as Forms */
  getMarketingAgent(resourceParsing) {
    const options = WebApiBase.FigureOutOptions(this._options);
    if (typeof resourceParsing == "number")
      options.resourceParsing = resourceParsing;
    return new MarketingAgent(options);
  }
  /** Manage and execute CRMScript functions. */
  getCRMScriptAgent(resourceParsing) {
    const options = WebApiBase.FigureOutOptions(this._options);
    if (typeof resourceParsing == "number")
      options.resourceParsing = resourceParsing;
    return new CRMScriptAgent(options);
  }
  /** Agent used for Ticket functions */
  getTicketAgent(resourceParsing) {
    const options = WebApiBase.FigureOutOptions(this._options);
    if (typeof resourceParsing == "number")
      options.resourceParsing = resourceParsing;
    return new TicketAgent(options);
  }
  /** Agent used for CRUD operations on database tables. Read, add, update, delete rows in tables. */
  getDatabaseTableAgent(resourceParsing) {
    const options = WebApiBase.FigureOutOptions(this._options);
    if (typeof resourceParsing == "number")
      options.resourceParsing = resourceParsing;
    return new DatabaseTableAgent(options);
  }
  /** Chat functions. Manage chat channels, sessions and messages. */
  getChatAgent(resourceParsing) {
    const options = WebApiBase.FigureOutOptions(this._options);
    if (typeof resourceParsing == "number")
      options.resourceParsing = resourceParsing;
    return new ChatAgent(options);
  }
  /** AI services, such as Translation, Statistics, Sentiment analysis, backed by calls to Public Cloud providers */
  getAIAgent(resourceParsing) {
    const options = WebApiBase.FigureOutOptions(this._options);
    if (typeof resourceParsing == "number")
      options.resourceParsing = resourceParsing;
    return new AIAgent(options);
  }
  /** Agent used to support migrating documents between different document-plugins, as single documents or batches. */
  getDocumentMigrationAgent(resourceParsing) {
    const options = WebApiBase.FigureOutOptions(this._options);
    if (typeof resourceParsing == "number")
      options.resourceParsing = resourceParsing;
    return new DocumentMigrationAgent(options);
  }
  /** Agent lets you configure workflow automation */
  getWorkflowAgent(resourceParsing) {
    const options = WebApiBase.FigureOutOptions(this._options);
    if (typeof resourceParsing == "number")
      options.resourceParsing = resourceParsing;
    return new WorkflowAgent(options);
  }
};

// server/src/providers/completionProvider.ts
function completionHandler() {
  const completionItems = [];
  const RTL = new WebApi("");
  const methods = Object.getOwnPropertyNames(WebApi.prototype);
  const descriptions = Object.getOwnPropertyDescriptors(WebApi.prototype);
  methods.forEach((methodName) => {
    completionItems.push(
      {
        label: methodName,
        kind: 3,
        data: methodName,
        detail: methodName,
        documentation: "SuperOffice WebApi method"
      }
    );
  });
  return completionItems;
}

// server/src/browserServerMain.ts
console.log("running jsfso-server");
var messageReader = new import_browser.BrowserMessageReader(self);
var messageWriter = new import_browser.BrowserMessageWriter(self);
var connection = (0, import_browser.createConnection)(messageReader, messageWriter);
connection.onInitialize((params) => {
  const capabilities = {
    colorProvider: {},
    // provide a color provider
    textDocumentSync: import_browser.TextDocumentSyncKind.Incremental,
    // Tell the client that this server supports code completion.
    completionProvider: {
      resolveProvider: true
    }
  };
  return { capabilities };
});
var documents = new import_vscode_languageserver.TextDocuments(TextDocument2);
documents.listen(connection);
connection.onDocumentColor((params) => getColorInformation(params.textDocument));
connection.onColorPresentation((params) => getColorPresentation(params.color, params.range));
connection.listen();
connection.onCompletion(
  (_textDocumentPosition) => {
    let completionItems = [];
    completionItems = completionHandler();
    return completionItems;
  }
);
connection.onCompletionResolve(
  (item) => {
    if (item.data === 1) {
      item.detail = "TypeScript details";
      item.documentation = "TypeScript documentation";
    } else if (item.data === 2) {
      item.detail = "JavaScript details";
      item.documentation = "JavaScript documentation";
    }
    return item;
  }
);
var colorRegExp = /#([0-9A-Fa-f]{6})/g;
function getColorInformation(textDocument) {
  const colorInfos = [];
  const document2 = documents.get(textDocument.uri);
  if (document2) {
    const text = document2.getText();
    colorRegExp.lastIndex = 0;
    let match;
    while ((match = colorRegExp.exec(text)) != null) {
      const offset = match.index;
      const length = match[0].length;
      const range = import_vscode_languageserver.Range.create(document2.positionAt(offset), document2.positionAt(offset + length));
      const color = parseColor(text, offset);
      colorInfos.push({ color, range });
    }
  }
  return colorInfos;
}
function getColorPresentation(color, range) {
  const result = [];
  const red256 = Math.round(color.red * 255), green256 = Math.round(color.green * 255), blue256 = Math.round(color.blue * 255);
  function toTwoDigitHex(n) {
    const r = n.toString(16);
    return r.length !== 2 ? "0" + r : r;
  }
  const label = `#${toTwoDigitHex(red256)}${toTwoDigitHex(green256)}${toTwoDigitHex(blue256)}`;
  result.push({ label, textEdit: import_vscode_languageserver.TextEdit.replace(range, label) });
  return result;
}
function parseHexDigit(charCode) {
  if (charCode >= 48 /* Digit0 */ && charCode <= 57 /* Digit9 */) {
    return charCode - 48 /* Digit0 */;
  }
  if (charCode >= 65 /* A */ && charCode <= 70 /* F */) {
    return charCode - 65 /* A */ + 10;
  }
  if (charCode >= 97 /* a */ && charCode <= 102 /* f */) {
    return charCode - 97 /* a */ + 10;
  }
  return 0;
}
function parseColor(content, offset) {
  const r = (16 * parseHexDigit(content.charCodeAt(offset + 1)) + parseHexDigit(content.charCodeAt(offset + 2))) / 255;
  const g = (16 * parseHexDigit(content.charCodeAt(offset + 3)) + parseHexDigit(content.charCodeAt(offset + 4))) / 255;
  const b = (16 * parseHexDigit(content.charCodeAt(offset + 5)) + parseHexDigit(content.charCodeAt(offset + 6))) / 255;
  return import_vscode_languageserver.Color.create(r, g, b, 1);
}
//# sourceMappingURL=browser.js.map
